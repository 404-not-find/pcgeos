# *****************************************************************************
#
# 	Copyright (c) Berkeley Softworks 1989 -- All Rights Reserved
# 
# PROJECT:	PC GEOS
# MODULE:	
# FILE:		ref.80x8x - online 80x8x instruction reference file
# 
# AUTHOR:	Matt Loveless, Adam de Boor
# 
# REVISION HISTORY:
# 	Name	Date		Description
# 	----	-------		-----------
# 	Matt	4/17/89		Initial version
#	Matt	5/5/89		No longer in alpha order
#	Matt	5/8/89		*** First complete version ***
# 
# 
# DESCRIPTION:
#
# This file documents all the instructions in the 8088/8086/80286 series of
# processors. 80386 instructions are not documented in this file.
#
# The instructions are organized semi-alphabetically, which might facilitate
# access, although I suspect SWAT will build some sort of hash/index table
# instead of scanning the entire file for the desired instruction.
#
# The entry for each instruction begins with three equal signs on an otherwise
# empty line. The next line contains the instruction mnemonic, followed by 
# whitespace (usually one tab), followed by a short description of the
# instruction:
#
#      ===
#      MNM	Mnemonic with No Meaning
#
# All text from the initial === to the next === (or EOF) is considered part
# of the instruction description and, at this time, undergoes no
# interpretation.
# SWAT just spews it to the terminal as requested. There are certain
# conventions that are followed, however.
#
# Each instruction has three basic fields: Flags, Description, and Notes.
#
# The Flags field represents the effect the instruction has on the processor's
# condition flags. The nine flags are abbreviated by a single letter.
#
#	Abbrv.	Flag
#	======	=========================
#	O	Overflow
#	D	Direction
#	I	Interrupt
#	T	Trap
#	S	Sign
#	Z	Zero
#	A	Auxiliary Carry
#	P	Parity
#	C	Carry
#
# The flags are displayed horizontally with a code below each.
#
#	Flags:	O D I T S Z A P C
#		? - - - ? ? x ? x
#
# The code represents how the instruction affects the flag; the various
# code meanings are summarized in the table below. 
#
#	      Code	Meaning
#	      ======	======================================================
#		?	undefined or unpredictably altered by instruction
#		-	unchanged by instruction
#		x	changed predictably by instruction
#		1	forced to 1 by instruction
#		0	forced to 0 by instruction	
#
# The Description field, which describes the instruction, follows the Flags
# field. The final field is the Notes field, which is optional and provides
# additional information, such as caveats and see-also references.
#
# Note: see the file ~matt/instBugs for problems with this file.
#
#	$Id: ref.80x8x,v 1.31.11.1 97/03/29 11:27:26 canavese Exp $
#
# *****************************************************************************

xxx START xxx

===
HELP	Help for inst command

INST takes a single argument, usually an Intel 80x8x mnemonic, and prints out
reference information associated with the instruction. For example:

	inst stos

displays reference information for the stos (store string) instruction.

Each instruction reference has three basic fields: Flags, Description, Notes,
and Timing.

The Flags field illustrates how the instruction affects processor's
condition flags. Each of the nine flags is abbreviated by a single letter.

	Abbrv.	Flag
	------	------------------------
	O	Overflow
	D	Direction
	I	Interrupt
	T	Trap
	S	Sign
	Z	Zero
	A	Auxiliary Carry
	P	Parity
	C	Carry

The flags are displayed horizontally with a code below each.

	Flags:	O D I T S Z A P C
		1 - - ? ? x ? x 0

The flag codes have the following meanings:

	Code	Meaning
	------	-----------------------------------------------------
	-	unchanged by instruction
	x	changed predictably by instruction
	1	forced to 1 by instruction
	0	forced to 0 by instruction	
 	?	undefined or unpredictably altered by instruction

The Description field follows the Flags field and describes the purpose and
useage of the instruction. Sometimes optional fields, such as Notes and See
also, provide additional information and cross references.

The last field is the Timing field. It provides processor clock cycle data
for the instruction. The timings assume a full prefetch queue.

In addition to the normal mnemonics, the following arguments are also
available:

	inst help	displays this text

	inst ea		displays effective address (EA) timings for 8086/88

	inst ref	displays tabular reference of all mnemonics
	inst table

	inst j		displays table of conditional jump instructions
	inst jcc
	inst jump	
	inst jcond
	inst cond

===
EA	Effective address timings for 8086/88

Type of effective address			Cycles	 Examples
--------------------------------------------	------	 ---------------------
Displacement only				+6	 myVar, array+24
Base or index only (BX,BP,SI,DI)		+5	 [bx], [si]
Displacement plus base or index			+9	 [bx+4], table[di]
   (BX+disp, BP+disp, SI+disp, DI+disp)
Base plus "like" index				+7	[bp+di], [bx+si]
   (BP+DI or BX+SI)
Base plus "unlike" index			+8	[bp+si], [bx+di]
   (BP+SI or BX+DI)
Displacement plus base plus "like" index	+11	tag[bx+si], [bp+di+4]
   (BP+DI+disp, BX+SI+disp)
Displacement plus base plus "unlike" index	+12	tag[bx+di], [bp+si+8]
   (BP+SI+disp, BX+DI+disp)
Segment override				+EA+2	es:table, ds:[bp+8]

===
AAA	ASCII adjust AL (after addition)

Flags:	O D I T S Z A P C
	? - - - ? ? x ? x

Description:	AAA 						86/88/286+

		Adjusts the value in AL to normalize the result of an unpacked
		BCD addition.  The AAA instruction is necessary because the
		result of adding two unpacked BCD digits is not itself a BCD
		number. The AAA instruction converts this result (which must
		be in AL) into an unpacked BCD representation. After
		conversion, the least-significant BCD digit is in AL and the
		most-significant digit is in AH. If the adjustment causes a
		carry from AL to AH, then both the C and A flags are set.

		Pseudo-code for AAA
		===================
		if ( ((AL & 0Fh) > 9) || (AF=1) )
		{	AL += 6;
			AH++;
			AF = 1;
		}
		CF = AF
		AL &= 0Fh

Notes:		To convert the two-digit BCD result to ASCII, logically-OR AX
		with 3030h.

See also:	DAA for adjusting packed BCD numbers.

===
AAD	ASCII adjust AX (before division)

Flags:	O D I T S Z A P C
	? - - - x x ? x ?

Description:	AAD 						86/88/286+

		Converts the unpacked BCD digits in AH and AL (MSB and LSB,
		respectively) to a binary number in AX. AH is multiplied by 
		ten and added to AL; AH is then cleared. AAD is often used
		to prepare a two-digit BCD number for division, hence its
		mnemonic. (The effect of AAD is the opposite of AAM.)

		Pseudo-code
		================
		AL += (AH * 10);
		AH = 0;

Notes:		AAD is extremely inefficient on the 8086 and 8088, though no
		more so than the normal multiply instruction. Since 10 is the
		constant multiplier, it may be faster to shift and add.

===
AAM	ASCII adjust AX (after multiply)

Flags:	O D I T S Z A P C
	? - - - x x ? x ?

Description:	AAM 						86/88/286+

		Converts the binary number in AL to unpacked BCD digits in AH
		and AL (MSB and LSB, respectively). AL is divided by ten, the
		quotient is placed in AH and the remainder in AL. AAM is often
		used to adjust the result of multiplying two unpacked BCD
		digits together, hence its mnemonic. AAM is the reverse of AAD.

		Pseudo-code
		================
		AH = AL/10;
		AL = AL%10; 

Notes:		AAM will not work properly if the number in AL is greater than
		99. AAM is extremely inefficient on the 8086 and 8088, though
		no more so than the regular DIV instruction.

===
AAS	ASCII adjust AL (after subtraction)

Flags:	O D I T S Z A P C
	? - - - ? ? x ? x

Description:	AAS 						86/88/286+

		Corrects the value in AL after subtracting two unpacked BCD
		digits. In other words: after subtracting two unpacked BCD
		digits (using AL as the destination), the result is a pseudo-
		binary number, which is useless in BCD math. The AAS
		instruction converts this result into an unpacked BCD
		representation. After conversion, the least-significant BCD
		digit is in AL and the most-significant digit is in AH. If the
		adjustment causes a borrow from AH to AL, then both the C and
		A flags are set. 

		Pseudo-code
		================
		if ( ((AL & 0Fh) > 9) || (AF=1) )
		{	AL -= 6;
			AH--;
			AF = 1;
		}
		CF = AF
		AL &= 0Fh

Notes:		Logically-OR'ing the result with 3030h converts both digits to
		ASCII. Use the DAS instruction to adjust packed BCD numbers.

===
ADC	Add with carry

Flags:	O D I T S Z A P C
	x - - - x x x x x

Description:	ADC {reg},{reg|mem|immed} 			86/88/286+
		ADC {mem},{reg|immed}

		Adds OPERAND2 to OPERAND1 and stores the result in OPERAND1.
		The C flag is also added to OPERAND1, effectively propagating
		any carry from a previous addition. If OPERAND1 is a word and
		OPERAND2 is immed8, then OPERAND2 is sign-extended before the
		addition. The assembler will use the immed8 form whenever
		possible.

Notes:		See ADD for a mathematical interpretation of the condition
		codes.

===
ADD	Add without carry

Flags:	O D I T S Z A P C
	x - - - x x x x x

Description:	ADD {reg},{reg|mem|immed}			86/88/286+
		ADD {mem},{reg|immed}

		Adds OPERAND2 to OPERAND1 and stores the result in OPERAND1.
		If OPERAND1 is a word and OPERAND2 is immed8, then OPERAND2 is
		sign-extended before the addition. The assembler will use the
		immed8 form whenever possible.

		The O (overflow) flag indicates a carry into the sign bit. When
		doing signed arithmetic, a carry into the sign bit means an
		arithmetic overflow occurred--the result is incorrect because
		it could not fit in the destination operand. (When doing mult-
		precision arithmetic, the overall result is incorrect only
		if the highest-order addition produces an overflow; overflows
		produced by lower-order operations are irrelevant.)

		The Z (zero) flag is set if the result is zero.

		The C (carry) flag is set if the addition caused a carry out
		of the high-order bit. When doing multi-precision arithmetic,
		the carry can be propagated with the ADC instruction.

		The S (sign) flag is set if the result is negative.

===
AND	Logical AND

Flags:	O D I T S Z A P C
	0 - - - x x ? x 0

Description:	AND {reg},{reg|mem|immed} 			86/88/286+
		AND {mem},{reg|immed}

		Logically and's OPERAND1 with OPERAND2 and stores the result
		in OPERAND1. The S, Z, and P flags are set based on the result
		of the operation. If OPERAND1 is a word and OPERAND2 is
		immed8, OPERAND2 is sign-extended before the addition. The
		assembler will use the immed8 form whenever possible.

===
ANDNF	Logical AND w/undefined flags

Flags:	O D I T S Z A P C
	0 - - - ? ? ? ? 0

Description:	ANDNF {reg},{reg|mem|immed} 			86/88/286+
		ANDNF {mem},{reg|immed}

		This is a pseudo-instruction provided by Esp to allow the
		programmer to indicate to it that the AND is being
		performed exclusively for the effect it has on the destination,
		not for the effect the instruction has on the flags register.
		
		Armed with this knowledge, Esp can sometimes optimize a
		word-sized AND instruction with immediate source into a
		byte-sized form, speeding the operation and reducing code size.

See also:	AND

===
ARPL	Adjust requested privilege level

Flags:	O D I T S Z A P C
	- - - - - x - - -

Description:	ARPL {reg16|mem16},{reg16}			286+

		Protected mode instruction that takes two selector values and
		compares the RPL (requested privilege level) fields (bits 0 and
		1).

		If the RPL of OPERAND1 is numerically less than the RPL of
		OPERAND2, then the Z flag is set and the RPL field of OPERAND1
		is increased to match that of OPERAND2. Otherwise, the Z flag
		is cleared and the RPL field of OPERAND1 is left unchanged.
		
		Operating systems use ARPL in parameter validation procedures
		to ensure that the caller of a service routine has sufficient
		privilege to access a particular data structure. By using the
		ARPL instruction to check every pointer parameter, an
		operating system can avoid accessing a segment to which the
		caller does not have access.

		The privilege level of the calling procedure is stored in the
		RPL field of the return pointer on the stack. The standard
		procedure in using ARPL is to get the return selector off of
		the stack, then use ARPL to compare it with the selector of the
		pointer parameter. For example,

		   mov	   ax,Stack.ReturnSel	;get caller's selector
		   arpl	   ptrParam,ax		;check requested selector

		Because the ARPL instruction in the above example adjusts the
		paramter's RPL to match the caller's privilege level, an
		exception will occur if the pointer is used to access memory
		for which the caller does not have sufficient privilege.

See also:	VERR, VERW

===
BOUND	Check array bounds

	
Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	BOUND {reg16},{mem32}				286+

		Ensures that the signed value of OPERAND1, usually an index
		into an array, lies within the numerical bounds established by
		the range pointed to by OPERAND2 (the bounds of the array).
		OPERAND2 points to two 16-bit signed values in memory. If
		OPERAND1 is less than the the first 16-bit value (the low
		bound) or greater than the second 16-bit value (the high
		bound), an INT 5 is generated.

===
CALL	Call procedure

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	CALL {label|reg|mem}				86/88/286+

		Passes program control to another procedure. The procedure
		executes and then returns control to the caller with an RET
		instruction.

		A procedure call may be a near call (same segment) or a far
		call (different segment). A near call pushes IP (the offset
		portion of the return address) and adds the 16-bit signed
		OPERAND to IP (which points to the instruction following the
		CALL). A far call pushes both the CS (sement) and IP
		(IP) of the return address and loads the 32-bit OPERAND into
		CS (high word) and IP (low word). A call to a near procedure
		must terminate with a near return and a call to a far procedure
		must terminate with a far return (otherwise, the wrong
		information will be popped off the stack).

		A call may be direct or indirect. A direct call expects a label
		as its OPERAND and transfers control directly to the address
		specified by the label. The following are examples of direct
		calls:

			CALL	label			; implied NEAR
			CALL	NEAR PTR label		; NEAR call
			CALL	FAR PTR	label		; FAR call

		An indirect call expects a register or memory pointer as its
		operand and transfers control to the address specified by the
		contents of the register or memory location. The following are
		examples of indirect calls:

			CALL	CX			; implied NEAR
			CALL	WORD PTR [BX][SI]	; NEAR call
			CALL	DWORD PTR [BX]		; FAR call
		
		(Note: there is no indirect FAR call with a register OPERAND)

See also:	RET, J, JMP

===
CBW	Convert byte to word

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	CBW 						86/88/286+

		Sign extends the byte in AL into AH, effectively converting
		AX from an 8-bit signed byte into a 16-bit signed word.

See also:	CWD

===
CLC	Clear carry flag

Flags:	O D I T S Z A P C
	- - - - - - - - 0

Description:	CLC 						86/88/286+

		Clears the carry flag.

See also:	STC, CMC

===
CLD	Clear direction flag

Flags:	O D I T S Z A P C
	- 0 - - - - - - -

Description:	CLD 						86/88/286+

		Clears the direction flag. When the direction flag is cleared,
		string operations work upward (toward higher addresses),
		incrementing the appropriate index register. Otherwise, they
		work downward, decrementing the proper index register.

See also:	STD

===
CLI	Clear interrupt flag

Flags:	O D I T S Z A P C
	- - 0 - - - - - -

Description:	CLI 						86/88/286+

		Clears the interrupt flag, which disables maskable interrupts.
		This is a privileged instruction when the 286 is operating in
		protected mode.

See also:	STI

===
CLTS	Clear task-switched flag

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	CLTS 						286+ (priv)

		Privileged instruction that clears the task-switched flag
		in the MSW (machine status word) of the 286. The CPU sets the
		TS flag each time it performs a task switch; the CLTS
		instruction clears it.

===
CMC	Complement carry flag

Flags:	O D I T S Z A P C
	- - - - - - - - x

Description:	CMC 						86/88/286+

		Toggles the carry flag. Usually used after a NEG instruction
		when performing a multi-precision negation. NEG sets the
		C flag to the opposite of that desired for the negation.

See also:	STC, CLC

===
CMP	Compare

Flags:	O D I T S Z A P C
	x - - - x x x x x

Description:	CMP	{reg},{reg|mem|immed}			86/88/286+
			{mem},{reg|immed}

		Compares OPERAND1 with OPERAND2 and sets the condition codes
		appropriately. The condition codes (O, S, Z, and C flags)
		are set as if OPERAND2 were subtracted from OPERAND1. If
		OPERAND1 is a word and OPERAND2 is immed8, then OPERAND2 is
		sign-extended before the comparison. The assembler will use
		this immed8 form whenever possible.

		If the Z flag is set, then the two OPERANDs are equal. This
		applies to both signed and unsigned comparisons.

		When comparing unsigned values, the C flag is relevant:

			C flag		Result of comparison
			------		----------------------
			0		OPERAND1 >= OPERAND2
			1		OPERAND1 < OPERAND2

		When comparing signed values, the S and O flags are relevant:

			S and O		Result of comparison
			-------		----------------------
			same		OPERAND1 >= OPERAND2
			different	OPERAND1 < OPERAND2

See also:	SUB for a mathematical interpretation of the condition codes.

===
CMPS	Compare strings
CMPSB
CMPSW

Flags:	O D I T S Z A P C
	x - - - x x x x x

Description:	CMPS	{seg:[SI]},{ES:[DI]}			86/88/286+
		CMPSB
		CMPSW
		CMPSB	{segreg:}
		CMPSW	{segreg:}

		Compares the string addressed by OPERAND2 to the string
		addressed by OPERAND1, setting the condition flags as if
		OPERAND2 were subtracted from OPERAND1, then adjusts SI and DI
		to point to the next element of the string. The size of the
		comparison (byte or word) is determined by the size of the
		operands. 

		Unless overriding the source segment (DS), the CMPSB and CMPSW
		abbreviations may be used. Neither has operands.

			CMPSB		Compares bytes DS:[SI],ES:[DI]
			CMPSW		Compares words DS:[SI],ES:[DI]

		CMPS is typically used with the following repeat prefixes:

		  Prefix	Function
		  -----------	--------------------------------------------
		  REPNE/REPNZ	Find first match in strings of length CX
				If Z=0, then no match found
		  REPE/REPZ	Find first mismatch in strings of length CX.
				If Z=1, then no mismatch found

		When a repeating CMPS instruction finishes, SI and DI point one
		element beyond the match/mismatch (or one element past the end
		of the string if no match/mismatch found).

		After comparing an element, CMPS adjusts SI and DI to point to
		the next element in the strings depending on the state of the
		D flag: if D is set, then SI and DI are decremented, otherwise,
		incremented. The size of the operands determines the amount of
		adjustment.

Notes:		CMPS reverses the "normal" dest-to-source comparison order.
		CMPS subtracts the dest (DI) from the source (SI) when setting
		the condition codes. (This is the reverse of what happens with
		the CMP instruction, which subtracts the source from the dest.)

See also:	CMP for information on interpreting the condition codes; REP
		for more information on repeat prefixes.

===
CWD	Convert word to double word

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	CWD 						86/88/286+

		Sign extends the word in AX into DX, effectively converting
		the register pair DX:AX from a 16-bit signed word into a 32-bit
		signed dword.

===
DAA	Decimal adjust AL (after addition)

Flags:	O D I T S Z A P C
	? - - - x x x x x

Description:	DAA 						86/88/286+

		Adjusts the result of adding two packed BCD digits in AL.
		The pseudo-binary result is converted into a packed BCD	numeral
		with the least-significant digit in the lower-nibble. If the
		adjusted value exceeds 99h, then the C and A flags are both
		set.

		Pseudo-code
		================
		if ( ((AL & 0Fh) > 9) || (AF=1) )
		{	AL += 06h;
			AF = 1;
		}
		if ( (AL & 0Fh > 9Fh) || (CF=1) )
		{	AL += 60h;
			CF = 1;
		}

Notes:		See AAA also

===
DAS	Decimal adjust AL (after subtraction)

Flags:	O D I T S Z A P C
	? - - - x x x x x

Description:	DAS 						86/88/286+

		Adjusts the result of subtracting two packed BCD digits in AL.
		The pseudo-binary result is converted into a packed BCD	numeral
		with the least-significant digit in the lower-nibble.

		Pseudo-code
		================
		if ( ((AL & 0Fh) > 9) || (AF=1) )
		{	AL -= 06h;
			AF = 1;
		}
		if ( (AL & 0Fh > 9Fh) || (CF=1) )
		{	AL -= 60h;
			CF = 1;
		}

Notes:		See AAS also.

===
DEC	Decrement

Flags:	O D I T S Z A P C
	x - - - x x x x -

Description:	DEC {reg8|reg16|mem}				86/88/286+

		Subtracts 1 from the OPERAND.

Notes:		Use SUB if you require signed or unsigned borrow detection.

===
DIV	Unsigned divide

Flags:	O D I T S Z A P C
	? - - - ? ? ? ? ?

Description:	DIV {reg|mem}					86/88/286+

		If OPERAND is 8-bits, then divides the 16-bit AX by the
		unsigned OPERAND, stores the quotient in AL, and stores the
		remainder in AH.
		
		If OPERAND is 16-bits, then divides the 32-bit register pair 
		DX:AX (high word in DX) by the unsigned OPERAND, stores the
		quotient in AX, and the remainder in DX.

Notes:		A type 0 interrupt is generated in the following cases:

			1. divide by zero
			2. 8-bit quotient > 255
			3. 16-bit quotient > 65535

===
ENTER	Make stack frame entry to procedure

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	ENTER {immed16},{immed5}			286+

		Creates a local stack frame for the current procedure. A local
		stack frame is used store variables local to the current
		procedure. Using the stack to store local variables maintains
		a routine's reentrancy and recursive properties.

		OPERAND1 specifies the size of the stack frame (in bytes) and
		OPERAND2 specifies the lexical nesting level (0-31) of the
		procedure. OPERAND2 specifies the number of frame pointers
		copied into the new stack frame from the previous one and is
		usually zero (unless supporting nested procedures as those in
		high-level language such as Pascal).

		Local variables are accessed as negative offsets from BP. At
		the end of the procedure, the stack and the original value of
		BP are restored with the LEAVE instruction.

Notes:		The Esp assembler implements an ENTER pseudo-op for creating
		stack frames in place of the ENTER instruction. The ENTER
		pseudo-op generates the following instruction sequence, which
		runs most efficiently, even on those processors that support
		the ENTER opcode:

			push	bp		; save current base pointer
			mov	bp,sp		; establish new base pointer
			sub	sp,frameSize	; adjust stack ptr with size
						; of the stack frame
		
		The frameSize constant in the above example is calculated
		automatically from the local variables defined by the LOCAL
		pseudo-op.

See also:	LEAVE for information on the LEAVE pseudo-op

===
ESC	Escape to coprocessor

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	ESC {immed6}					86/88/286+
		ESC {immed6},{mem|reg}
		
		Invokes the coprocessor if available, or emulation routines if
		a coprocessor is not available. OPERAND1 is a 6-bit coprocessor
		opcode and the optional OPERAND2 is a memory or register
		operand for the coprocessor instruction.

===
HLT	Halt processor

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	HLT 						86/88/286+

		Halts the processor until an interrupt or reset signal is
		encountered.

Notes:		This is a privileged instruction on the 286 and above
		processors when operating in protected mode.

===
IDIV	Signed integer divide

Flags:	O D I T S Z A P C
	? - - - ? ? ? ? ?

Description:	IDIV {reg|mem}					86/88/286+

		If OPERAND is 8-bits, then divides the 16-bit AX by the signed
		8-bit OPERAND, stores the quotient in AL, and stores the
		remainder in AX.
		
		If OPERAND is 16-bits, then divides the 32-bit register pair 
		DX:AX (high word in DX) by the signed 16-bit OPERAND,
		stores the quotient in AX, and stores the remainder in DX.

		The remainder has the same sign as the dividend (destination).
		Quotients (both positive and negative) are truncated toward
		zero.

Notes:		A type 0 interrupt is generated in the following cases:

			1. if OPERAND is 0
			2. 8-bit quotient not in the range -127 <= x <= 127
			   for 8088/86 or -128 <= x <= 127 for 80286+
			3. 16-bit quotient not in the range
				  -32767 <= x <= 32767
			   for 8088/86 or
				  -32768 <= x <= 32767 for 80286+

===
IMUL	Signed multiply

Flags:	O D I T S Z A P C
	x - - - ? ? ? ? x

Description:	IMUL {reg8|mem8}				86/88/286+

		Multiplies the signed 8-bit value in AL by the signed 8-bit
		OPERAND and stores the 16-bit result in AX. If the C and O
		flags are cleared, then AH is merely a sign-extension of AL
		and contains no significant bits of the result.

		IMUL {reg16|mem16}				86/88/286+

		Multiplies the signed 16-bit value in AX by the signed 16-bit
		OPERAND and stores the 32-bit result in the register pair
		DX:AX (high word in DX). If the C and O flags are
		cleared, then DX is merely a sign-extension of AX and
		contains no significant bits of the result.

		IMUL {reg16},{reg16|mem16},{immed8|immed16}	286+

		Multiplies the signed 16-bit value in OPERAND2 by OPERAND3
		(OPERAND3 sign-extended to 16-bits if necessary) and stores
		the low 16-bits of the result in OPERAND1. If the C and O flags
		are set, then the result was larger than 16-bits.

Notes:		When checking for sign-extension, it is not necessary to
		test both the C and O flags, as they are always identical.

		Most assemblers implement a two-operand immediate version of
		IMUL for use on the 286 and higher processors:

			IMUL {reg16},{immed8|immed16}

		The assembler translates this into three operands by using the
		first operand twice in succession. IMUL AX,25h becomes
		IMUL AX,AX,25h, which is how Swat displays it.

===
IN	Input from port

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	IN {AL|AX},{immed8|DX}				86/88/286+

		Transfers a byte or word from the I/O port specified by
		OPERAND2 into the accumulator (AL or AX) specified by OPERAND1.
		The size of OPERAND1 determines the size of the transfer.

		Port addresses range from 0 to 65535. Ports 0 through 255 can
		be specified by an 8-bit immediate value or by a value in DX.
		Port addresses greater than 255 can only be specified by a
		value in DX.

Notes:		Port addresses 00F8h through 00FFH are reserved by Intel and
		should not be used. This is a priveleged instruction on
		the 286+ when it is operating in protected mode.

===
INC	Increment

Flags:	O D I T S Z A P C
	x - - - x x x x -

Description:	INC {reg8|reg16|mem}				86/88/286+

		Adds 1 to the OPERAND.

Notes:		Use ADD if you require signed carry detection. Unsigned carry
		detection can be made by checking the Z flag.

===
INS	Input string from port
INSB
INSW

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	INS	{ES:[DI]},{DX}				286+
		INSB
		INSW

		Transfers a string of bytes or words from the I/O port
		specified in DX to the destination address ES:[DI]. DI is
		incremented or decremented according to the direction flag so
		that it points to the next byte or word in the string.  Adding
		a REP prefix allows multi-byte and multi-word reads from the
		port, though some devices will be unable to sustain the
		transfer rate.

		The size of the data is determined by the size of OPERAND1.
		You can also use the INSB and INSW aliases to specify byte or
		word reads. Both INSB and INSW have implied operands.

			INSB		same as INS BYTE PTR ES:[DI],DX
			INSW		same as INS WORD PTR ES:[DI],DX


		INS is typically used with the REP prefix, which will execute
		the number of reads specified by the value in CX.

		When the REP INS instruction finishes executing, DI points
		one element beyond the end of the string.

		INS adjusts DI to point to the next byte or word in the string.
		DI is decremented if the direction flag (D) is 1 and
		incremented if the direction flag is 0. The amount of
		increment or decrement depends on size of the input
		(byte or word). DI is always adjusted AFTER the read,
		regardless of the direction.

Notes:		Port addresses 00F8h through 00FFH are reserved by Intel and
		should not be used. This is a privileged instruction on the
		286+ when it is operating in protected mode.

===
INT	Interrupt
INT3	Interrupt #3 (software breakpoint)

Flags:	O D I T S Z A P C
	- - 0 0 - - - - -

Description:	INT {immed8}					86/88/286+

		Generates a software interrupt by calling the handler specified
		in the interrupt descriptor table. Interrupts range from 0 to
		255. A software interrupt handler returns using the IRET
		instruction.

		On the 8088, 8086 and the 80286+ operating in real mode, the
		interrupt descriptor table resides at absolute 0 and consists
		of FAR pointers, one per interrupt.
		
		STACK USAGE
		===========
		The processor flags, CS, and IP are all pushed onto the stack
		prior to the interrupt as if the following instructions were
		executed in this order:

			PUSHF
			PUSH CS
			PUSH IP

Notes:		The first 32 interrupts are reserved for Intel's use. INT 3
		uses a special one byte opcode (0CCh), which specifies a
		software breakpoint. The error-checking version of the
		kernel fills unused memory with this value to catch
		out-of-bounds branches.

		The I and T flags are only cleared for the interrupt handler;
		they are unchanged in the flags image pushed on the stack,
		which is restored when the interrupt completes.

===
INTO	Interrupt on overflow

Flags:	O D I T S Z A P C
	- - 0 0 - - - - -

Description:	INTO 						86/88/286+

		Tests the O (overflow) flag and generates an INT 4 if it is
		set. INTO otherwise behaves like the INT instruction.

Notes:		The I and T flags are only cleared for the interrupt handler;
		they are unchanged in the flags image pushed on the stack,
		which is restored when the interrupt completes.

===
IRET	Interrupt return

Flags:	O D I T S Z A P C
	x x x x x x x x x 

Description:	IRET 						86/88/286+

		Returns from an interrupt by performing a far return,
		then popping the processor flags.

Notes:		This can be used to pop the processor flags in a critical
		section of code, when running on a 286. Since the 286 will
		allow a pending interrupt in should interrupts be off when
		a POPF of a flags word in which the interrupts are also off,
		it is sometimes necessary to perform a far CALL to an IRET
		to ensure that no unexpected interrupts arrive.

===
J	Conditional jump table
JCC
JUMP	
JCOND
COND

	The conditional jump comes in many incarnations. Consult the following
	table, then refer to the specific mnemonic if necessary.

	Unsigned Compare	Mnemonic		True if
	==================	====================	=================
	dest =  source		JE	JZ		Z
	dest != source		JNE	JNZ		!Z
	dest >  source		JA	JNBE		!(C|Z)
	dest <  source		JB	JNAE	(JC)	C
	dest >= source		JAE	JNB	(JNC)	!C
	dest <= source		JBE	JNA		C|Z

	Signed Compare		Mnemonic		True if
	==================	====================	=================
	dest =  source		JE	JZ		Z
	dest != source		JNE	JNZ		!Z
	dest >  source		JG	JNLE		!((S^O)|Z)
	dest <  source		JL	JNGE		S^O
	dest >= source		JGE	JNL		!(S^O)
	dest <= source		JLE	JNG		(S^O)|Z

	Flag 			Set Mnemonic		Clear Mnemonic
	==================	====================	=================
	O (overflow)		JO			JNO
	S (sign)		JS			JNS
	Z (zero)		JZ   (JE)		JNZ  (JNE)
	P (parity)		JP   (JPE)		JNP  (JPO)
	C (carry)		JC   (JB, JNAE)		JNC  (JAE, JNB)

	Other			Mnemonic
	==================	=========================================
	CX = 0000h		JCXZ

===
JA	Jump on above (unsigned)
JNBE	Jump on not below or equal (unsigned)

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	JA {shortlabel}					86/88/286+
		JNBE {shortlabel}

		Jump succeeds if...			Which means...
		===========================		==================
		unsigned dest > source			!(C|Z)

Notes:		The destination of the jump must be SHORT (between -128 and
		127 bytes from the next instruction).

===
JNC	Jump on no carry
JAE	Jump on above or equal (unsigned)
JNB	Jump on not below (unsigned)

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	JAE {shortlabel}				86/88/286+
		JNB {shortlabel}
		JNC {shortlabel}

		Jump succeeds if...			Which means...
		===========================		==================
		unsigned dest >= source			!C

Notes:		The destination of the jump must be SHORT (between -128 and
		127 bytes from the next instruction).

===
JC	Jump on carry
JB	Jump on below (unsigned)
JNAE	Jump on not above or equal (unsigned)

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	JB {shortlabel}					86/88/286+
		JNAE {shortlabel}
		JC {shortlabel}

		Jump succeeds if...			Which means...
		===========================		==================
		unsigned dest < source			C

Notes:		The destination of the jump must be SHORT (between -128 and
		127 bytes from the next instruction).

===
JBE	Jump on below or equal (unsigned)
JNA	Jump on not above (unsigned)

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	JBE {shortlabel}				86/88/286+
		JNA {shortlabel}

		Jump succeeds if...			Which means...
		===========================		==================
		unsigned dest <= source			C|Z

Notes:		The destination of the jump must be SHORT (between -128 and
		127 bytes from the next instruction).

===
JCXZ	Jump if CX is zero

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	JCXZ {shortlabel}				86/88/286+

		Tests the CX register for 0000h and jumps to the specified
		label if true.

Notes:		The destination of the jump must be SHORT (between -128 and
		127 bytes from the next instruction).

===
JZ	Jump on zero (Z flag is set)
JE	Jump on equal (signed and unsigned)

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	JE {shortlabel}					86/88/286+
		JZ {shortlabel}

		Jump succeeds if...			Which means...
		===========================		==================
		dest = source				Z

Notes:		The destination of the jump must be SHORT (between -128 and
		127 bytes from the next instruction).

===
JNZ	Jump on not zero (Z flag is cleared)
JNE	Jump on not equal (signed and unsigned)

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	JNE {shortlabel}				86/88/286+
		JNZ {shortlabel}

		Jump succeeds if...			Which means...
		===========================		==================
		dest != source				!Z

Notes:		The destination of the jump must be SHORT (between -128 and
		127 bytes from the next instruction).

===
JG	Jump on greater (signed)
JNLE	Jump on not less or equal (signed)

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	JG {shortlabel}					86/88/286+
		JNLE {shortlabel}

		Jump succeeds if...			Which means...
		===========================		==================
		signed dest > source			!((S^O)|Z)

Notes:		The destination of the jump must be SHORT (between -128 and
		127 bytes from the next instruction).

===
JGE	Jump on greater or equal (signed)
JNL	Jump on not less (signed)

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	JGE {shortlabel}				86/88/286+
		JNL {shortlabel}

		Jump succeeds if...			Which means...
		===========================		==================
		signed dest >= source			!(S^O))

Notes:		The destination of the jump must be SHORT (between -128 and
		127 bytes from the next instruction).

===
JL	Jump on less (signed)
JNGE	Jump on not greater or equal (signed)

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	JL {shortlabel}					86/88/286+
		JNGE {shortlabel}

		Jump succeeds if...			Which means...
		===========================		==================
		signed dest < source			S^O

Notes:		The destination of the jump must be SHORT (between -128 and
		127 bytes from the next instruction).

===
JLE	Jump on less or equal (signed)
JNG	Jump on not greater (signed)

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	JLE {shortlabel}				86/88/286+
		JNG {shortlabel}

		Jump succeeds if...			Which means...
		===========================		==================
		signed dest <= source			(S^O)|Z

Notes:		The destination of the jump must be SHORT (between -128 and
		127 bytes from the next instruction).

===
JP	Jump on Parity flag is one
JPE	Jump on Parity even

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	JP {shortlabel}					86/88/286+
		JPE {shortlabel}

		Jump succeeds if...			Which means...
		===========================		==================
		The Parity bit is one			P

Notes:		The destination of the jump must be SHORT (between -128 and
		127 bytes from the next instruction).

		The parity is only taken from the low BYTE!!!
===
JNP	Jump on Parity flag is zero
JPO	Jump on Parity odd

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	JNP {shortlabel}				86/88/286+
		JPO {shortlabel}

		Jump succeeds if...			Which means...
		===========================		==================
		The Parity bit is zero			!P

Notes:		The destination of the jump must be SHORT (between -128 and
		127 bytes from the next instruction).

		The parity is only taken from the low BYTE!!!

===
JMP	Jump always

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	JMP {shortlabel|nearlabel|farlabel}		86/88/286+
		JMP {regptr16|regptr32|memptr16|memptr32}

		Transfers control to OPERAND1. Nothing is pushed on the stack
		to record from whence control came.

		A jump may be direct or indirect. A direct jump expects a label
		as its OPERAND and transfers control directly to the address
		specified by the label. The following are examples of direct
		jumps:

			JMP	SHORT label		; 8-bit offset
			JMP	label			; implied NEAR
			JMP	NEAR PTR label		; NEAR jump
			JMP	FAR PTR	label		; FAR jump

		An indirect jump expects a register or memory pointer as its
		operand and transfers control to the address specified by the
		contents of the register or memory location. The following are
		examples of indirect jumps:

			JMP	CX			; implied NEAR
			JMP	WORD PTR [BX][SI]	; NEAR jump
			JMP	DWORD PTR [BX]		; FAR jump
		
		(Note: there is no indirect FAR jump with a register OPERAND)

===
JS	Jump short if sign (result was negative)

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	JS {shortlabel}

		Jump succeeds if...			Which means...
		==========================		=================
		'signed' bit is set			SF

Notes:		The destination of the jump must be SHORT (between -128 and
		127 bytes from the next instruction).

===
JNS	Jump short if not sign (result was non-negative)

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	JNS {shortlabel}

		Jump succeeds if...			Which means...
		==========================		=================
		'signed' bit is clear			!SF

Notes:		The destination of the jump must be SHORT (between -128 and
		127 bytes from the next instruction).

===
JO	Jump short if overflow

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	JO {shortlabel}

		Jump succeeds if...			Which means...
		==========================		=================
		'overflow' bit is set			OF

Notes:		The destination of the jump must be SHORT (between -128 and
		127 bytes from the next instruction).

===
JNO	Jump short if no overflow

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	JNO {shortlabel}

		Jump succeeds if...			Which means...
		==========================		=================
		'overflow' bit is clear			!OF

Notes:		The destination of the jump must be SHORT (between -128 and
		127 bytes from the next instruction).

===
LAHF	Load AH with flags register

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	LAHF						86/88/286+

		Transfers the low eight bits of the flags register into AH.
		The bits have the following significance:

			7 6 5 4 3 2 1 0
			S Z - A - P - C
			    |   |   |
			    |---|---|------ undefined

Notes:		To get the high byte of the flags register (which holds the T,
		I, D, and O flags) in addition to the low byte, use the
		following:
			
			pushf		; push flags on stack
			pop	ax	; transfer flags to ax

See also:	SAHF

===
LAR	Load access rights byte

Flags:	O D I T S Z A P C
	- - - - - x - - - 

Description:	LAR {reg16},{reg16|mem16}			286+

		Protected mode instruction for loading the access rights of a
		descriptor into a register. Using the selector provided in
		OPERAND2, the LAR instruction moves the access rights byte of
		the associated descriptor into the high byte of OPERAND1
		(assuming the descriptor is visible at the current privilege
		level and selector RPL); the low byte of OPERAND1 is set to
		zero.

		If the selector specified by OPERAND2 is not visible at the
		current privilege level or selector RPL, the register specified
		by OPERAND1 is left unchanged and the Z flag is cleared (no
		protection exception is generated). Otherwise, the Z flag is
		set, indicating the loading was performed.

===
LDS	Load far pointer into DS:xx
LES	Load far pointer into ES:xx

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	LDS {reg},{mem}					86/88/286+
		LES {reg},{mem}					86/88/286+

		Loads a far pointer (32-bits of segment and offset) from memory
		into a segment+offset register combination. OPERAND2 specifies
		the location in memory where the far pointer is stored. The
		LDS and LES instructions move the high word from the memory
		location (the segment) into either DS or ES as determined by
		the instruction mnemonic. The low word from the memory
		location (the offset) is moved into the register specified by
		OPERAND1.

		Examples:

			lds	si,ptrTable2	   ; load far ptr into ds:si
			les	di,ds:[si].MI_class; load far ptr into es:di

===
LEA	Load effective address

Flags:	O D I T S Z A P C
	- - - - - - - - - 

Description:	LEA {reg},{mem}					86/88/286+

		Calculates the effective address offset of OPERAND2 and stores
		it in the register specified by OPERAND1. The LEA instruction
		is useful for calculating the address of indirect memory
		operands, as in

			lea	dx,table[si]	; place address of table+index
						; into dx

Notes:		On the 8086 and 8088, it is faster to compute the effective
		address manually than to use the LEA instruction when dealing
		with base or index addressing (e.g. table[si]). On all
		processors, it is faster to use the MOV instruction when
		loading a register with the address of a direct memory operand
		because it is a constant at assembly time. In other words, use

			mov	dx,OFFSET table

		instead of
			
			lea	dx,table

===
LEAVE	Clean up stack frame at exit of procedure

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	LEAVE 						286+

		Removes a local stack frame created by the ENTER instruction.
		LEAVE copies BP to SP, thereby releasing the stack space used
		by the procedure. The previous frame pointer is then popped
		into BP. The LEAVE instruction is typically executed just
		prior to a RET instruction.

Notes:		The Esp assembler implements a LEAVE pseudo-op for removing
		stack frames in place of the LEAVE instruction. The LEAVE
		pseudo-op generates the following instruction sequence, to
		make sure the code will run on all processors:

			mov	sp,bp		; move stack back
			pop	bp		; get previous base pointer

===
LGDT	Load global descriptor table register

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	LGDT {mem64} 					286+

		Protected mode instruction for loading values into the global
		descriptor table register. The single OPERAND points to six
		bytes in memory that are loaded into the global descriptor
		table register as follows:

			bytes 0,1    ->  LIMIT field
			bytes 2,3,4  ->  BASE field
			byte 5       ->  ignored

Notes:		This instruction is not used by application programs. LGDT and
		LIDT are the only instructions that directly load physical
		memory addresses in protected mode. The instruction must be
		executed at privilege level 0.

See also:	SGDT, LIDT

===
LIDT	Load interrupt descriptor table register

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	LIDT {mem64} 					286+

		Protected mode instruction for loading values into the
		interrupt descriptor table register. The single
		OPERAND points to six bytes in memory that are loaded
		into the interrupt descriptor table register as follows:

			bytes 0,1    ->  LIMIT field
			bytes 2,3,4  ->  BASE field
			byte 5       ->  ignored

Notes:		This instruction is not used by application programs. LGDT and
		LIDT are the only instructions that directly load physical
		memory addresses in protected mode. The instruction must be
		executed at privilege level 0.

See also:	LGDT, SIDT

===
LLDT	Load local descriptor table register

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	LLDT {reg16|mem16}				286+

		Protected mode instruction for loading values into the local
		descriptor table register. The single OPERAND supplies a
		selector from the global descriptor table. The global
		descriptor table entry at that position should be a local
		descriptor table from which the local descriptor register will
		be loaded. The LDT field in the TSS and the DS, ES, SS, and CS
		cache entries are unchanged.

		If the OPERAND is zero, then the local descriptor table
		register is marked invalid.

Notes:		This instruction is not used by application programs. The
		instruction must be executed at privilege level 0.

===
LODS	Load String
LODSB
LODSW

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	LODS	{segreg:[SI]}				86/88/286+
		LODSB
		LODSW
		LODSB	{segreg:}
		LODSW	{segreg:}

		Loads the value pointed to by the source OPERAND into AX
		(word) or AL (byte).  After loading the value, LODS adjusts SI
		to point to the next element in the string depending on the
		state of the D flag: if D is set, then SI is decremented,
		otherwise, incremented. The size of the operand determines the
		amount of adjustment.

		The LODSB and LODSW abbreviations can also be used to specify
		byte or word values. Neither has operands.

			LODSB		Load byte pointed by DS:[SI]
			LODSW		Load word pointed by DS:[SI]


		LODS is not normally used with the REP prefix, which would
		continually overwrite the accumulator with the successive
		elements, effectively loading only the last element.

===
LMSW	Load machine status word

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	LMSW {reg16|mem16}				286+

		Loads the 16-bit value specified by the single OPERAND into
		the machine status word (MSW). The MSW is a 16-bit register of
		which only the lower four bits are currently defined: 

			bit	name	function
			====	=====	============================
			0	PE	protected mode enable
			1	MP	monitor processor extension
			2	EM	emulate processor extension
			3	TS	task switched
			4-15	??	reserved for future use
		
		The upper twelve bits of the MSW are reserved for future
		extensions and must not be modifed. The following code fragment
		demonstrates a safe method of changing the lower four bits.

			smsw	ax		; get machine status word
			and	al,0f0h		; nuke lower four bits
			or	al,newbits	; set new bits (0-3 only)
			lmsw	ax		; establish new status

Notes:		This instruction is not normally used by application programs.
		It must be executed in real address mode or at privilege
		level 0 in protected mode. When in real mode, this instruction
		can be used to switch into protected mode; be sure to
		immediately execute a near jump (intra-segment jump) after
		the LMSW in order to flush the instruction queue. LMSW cannot
		be used to switch from protected mode to real mode, however.

===
LOCK	Lock the bus

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	LOCK {instruction}				86/88/286+

		Instruction prefix that locks the bus through the duration of
		the prefixed instruction. The lock instruction asserts the BUS
		LOCK signal which grants the processor exclusive use of the
		bus, allowing atomic operations upon shared memory. By locking
		the XCHG instruction, for example, a complete read-modify-write
		sequence can be performed.

Notes:		LOCK should only be used with the XCHG, MOVS, INC, DEC, NOT,
		NEG, ADD, ADC, SUB, SBB, AND, OR and XOR instructions when
		they modify memory, as the 386 will raise an illegal
		instruction exception should the LOCK prefix be applied to any
		other instruction. The 286 and later processors always assert
		a lock signal during an XCHG instruction with memory. The LOCK
		signal on the 286 and later processors does not go active
		during an instruction prefetch.

===
LOOP	Loop while CX is nonzero

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	LOOP {label}					88/86/286+

		Decrements CX (without altering any flags) and does one of the
		following:

		1. If, after the decrement, CX is nonzero, then control passes
		   to the label specified by the OPERAND.

		2. If CX became zero as a result of the decrement, control
		   passes to the instruction following the LOOP instruction.

Notes:		See also LOOPE and LOOPNE.

===
LOOPE	Loop while CX is nonzero and Z flag is set.
LOOPZ

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	LOOPE {label}					88/86/286+
		LOOPZ {label}

		Decrements CX (without altering any flags) and does one of the
		following:

		1. If, after the decrement, CX is nonzero *AND* the Z (zero)
		   flag is set, control passes to the label specified by the
		   OPERAND.

		2. If CX became zero as a result of the decrement *OR* the Z
		   (zero) flag is not set, control passes to the instruction
		   following the LOOP instruction.

Notes:		See also LOOP and LOOPNE. 

===
LOOPNE	Loop while CX is nonzero and Z flag is not set.
LOOPNZ

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	LOOPNE {label}					88/86/286+
		LOOPNZ {label}

		Decrements CX (without altering any flags) and does one of the
		following:

		1. If, after the decrement, CX is nonzero *AND* the Z (zero)
		   flag is not set, control passes to the label specified
		   by the OPERAND.

		2. If CX became zero as a result of the decrement *OR* the Z
		   (zero) flag is set, control passes to the instruction
		   following the LOOP instruction.

Notes:		See also LOOP and LOOPE. 

===
LSL	Load segment limit

Flags:	O D I T S Z A P C
	- - - - - x - - -

Description:	LSL {reg},{reg16|mem16}				286+

		Unprivileged protected mode instruction for loading the
		limit field of a selector. If the selector denoted by
		OPERAND2 is visible at the current privilege level, then
		OPERAND1 is loaded with the word limit field of the
		selector. This loading can only be performed on segments,
		task state segments, and local descriptor tables.
		
		The Z flag is set if the descriptor is actually loaded into
		OPERAND1. Otherwise, the Z flag is cleared.

Notes:		This is a protected mode instruction and is not recognized in
		real mode.

===
LTR	Load task register

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	LTR {reg16|mem16}				286+

		Places the value in the register or memory location specified
		by the OPERAND into the current task register. The loaded
		task state segment (TSS) is marked as busy, though a task
		switch does not occur.
		
Notes:		This is a privileged protected mode instruction and is not
		used by application programs.

See also:	STR

===
MOV	Move data

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	MOV {segreg|reg},{reg|mem|immed}		86/88/286+
		MOV {mem},{reg|immed}

		Copies OPERAND2 to OPERAND1. The size of the  operands
		determines the size of the data moved (byte or word).

===
MOVS	Move string
MOVSB
MOVSW

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	MOVS	{ES:[DI]},{seg:[SI]}			86/88/286+
		MOVSB
		MOVSW
		MOVSB	{segreg:}
		MOVSW	{segreg:}

		Moves the string pointed to by SI (source) to the ES:DI
		destination. the MOVS instruction moves a byte or word and
		adjusts SI and DI to point to the next element of the string.
		The size of the operands determines the size of the string
		elements (byte or word). Multi-byte and multi-word strings can
		be moved by using the various repeat prefixes.

		Unless overriding the source segment (DS), the abbreviated
		MOVSB and MOVSW mnemonics may be used. Neither has operands.

			MOVSB		Moves byte from DS:[SI] to ES:[DI]
			MOVSW		Moves word from DS:[SI] to ES:[DI]

		MOVS is typically used with the REP prefix to move a string of
		of the length specifed in CX.

		When the REP MOVS instruction finishes executing, SI and DI
		point one element beyond the the last element moved.

		MOVS adjusts SI and DI up or down to point to the next
		elements in the strings depending on the state of the D flag:
		if it is set, then SI and DI are decremented, otherwise,
		incremented. The size of the operands determines the amount of
		adjustment.

Notes:		See REP for more information on the repeat prefix.

===
MUL	Mutiply unsigned

Flags:	O D I T S Z A P C
	x - - - ? ? ? ? x

Description:	MUL {reg|mem}					86/88/286+

		If OPERAND is 8-bits, then multiplies AL by the unsigned
		OPERAND and stores the result in AX. If the C and O flags are
		clear, then AH is not significant (contains 00h).
		
		If OPERAND is 16-bits, then multiplies AX by the unsigned
		16-bit OPERAND and stores the result in the register pair
		DX:AX. If the C and O flags are clear, then DX is not
		significant (contains 0000h).

Notes:		The C and O flags are always set identically, so you need only
		check one of them.

===
NEG	Negate two's complement number

Flags:	O D I T S Z A P C
	x - - - x x x x x

Description:	NEG {reg|mem}					86/88/286+

		Negates a two's complement number by subtracting it from zero
		(which is equivalent to exclusive-or'ing it with -1 and 
		adding 1).

		If the original OPERAND is zero, the C flag is clear.
		Otherwise, the C flag is set. This is the opposite of what
		is needed for multi-precision arithmetic, hence CMC...

Notes:		Trying to negate the smallest two's comp. number (-128 byte,
		-32768 word) sets the O flag and leaves the OPERAND
		unchanged.

See also:	CMC

===
NOT	Negate one's complement number

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	NOT {reg|mem}					86/88/286+

		Negates a one's complement number by exclusive-or'ing it
		with -1. All one bits become zero and all zero bits become
		one.

===
NOP	No-operation

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	NOP 						86/88/286+

		Space-holder instruction that theoretically performs
		no-operation (except take up clock cycles and
		increment the program counter). Contrary to what you'd
		expect, this is not one of the fastest operations, as
		it actually exchanges AX with itself. If you need to fill
		a lot of space something like "MOV AX, AX" takes up
		two bytes and takes one fewer cycle to execute.

===
OR	Logical OR

Flags:	O D I T S Z A P C
	0 - - - x x ? x 0

Description:	OR {reg},{reg|mem|immed} 			86/88/286+
		OR {mem},{reg|immed}

		Logically or's OPERAND1 with OPERAND2 and stores the result
		in OPERAND1. 

===
ORNF	Logical OR with undefined flags

Flags:	O D I T S Z A P C
	0 - - - ? ? ? ? 0

Description:	ORNF {reg},{reg|mem|immed} 			86/88/286+
		ORNF {mem},{reg|immed}

		This is a pseudo-instruction provided by Esp to allow the
		programmer to indicate to it that the OR is being
		performed exclusively for the effect it has on the destination,
		not for the effect the instruction has on the flags register.
		
		Armed with this knowledge, Esp can sometimes optimize a
		word-sized OR instruction with immediate source into a
		byte-sized form, speeding the operation and reducing code size.

See also:	OR

===
OUT	Output byte or word to port

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	OUT	{immed8|DX},{AL|AX}			88/86/286+

		Transfers a single byte or word from AL or AX (OPERAND2) to
		to the I/O port specified by OPERAND1. If OPERAND1 is an
		immediate value, only the first 256 ports may be specified.

		The size of the data is determined by the size of OPERAND2.
		You can also use the OUTSB and OUTSB aliases to specify byte
		or word writes. Both OUTSB and OUTSW have implied operands.

Notes:		Port addresses 00F8h through 00FFH are reserved by Intel and
		should not be used. This is a priveleged instruction on the
		286+ when it is operating in protected mode.

See also:	OUTS

===
OUTS	Output string to port
OUTSB
OUTSW

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	OUTS	{DX},{seg:[SI]}				286+

		Transfers a string of bytes or words from the source address
		specified by OPERAND2 to the I/O port specified in DX. SI is
		incremented or decremented according to the direction flag so
		that it points to the next byte or word in the string. Adding
		a REP prefix allows multi-byte and multi-word reads from the
		port.

		The size of the data is determined by the size of OPERAND2.
		You can also use the OUTSB and OUTSB aliases to specify byte
		or word writes. Both OUTSB and OUTSW have implied operands.

			OUTSB		same as OUTS DX,BYTE PTR DS:[SI]
			OUTSW		same as OUTS DX,WORD PTR DS:[SI]


		OUTS is typically used with the REP prefix, which will 
		execute the number of writes specified by the value in CX.

		When the REP OUTS instruction finishes executing, SI points
		one element beyond the end of the string. Note that some
		I/O devices will be unable to maintain the rate of transfer
		required of a repeated OUTS.

		OUTS adjusts SI to point to the next byte or word in the
		string. SI is decremented if the direction flag (D) is 1 and
		incremented if the direction flag is 0. The amount of
		increment or decrement depends on size of the output (byte or
		word). SI is always adjusted AFTER the write, regardless of
		the direction.

Notes:		Port addresses 00F8h through 00FFH are reserved by Intel and
		should not be used. This is a priveleged instruction on the
		286+ when it is operating in protected mode. Also refer to the
		OUT instruction.

===
POP	Pop word from stack

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	POP {reg16|segreg|mem16} 			86/88/286+

		Pops the top word off of the stack into the register or memory
		location specified by the OPERAND. Effectively, the word at
		SS:SP is copied into the OPERAND and SP is incremented by
		two.

Notes:		The CS segment register is not a valid operand. Use the RET
		instruction to pop CS.

See also:	POPA, POPF, and PUSH.

===
POPA	Pop all registers

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	POPA 						286+

		Pops the top eight words off of the stack into registers
		in the following order: DI, SI, BP, (SP discarded), BX, DX,
		CX, AX.

===
POPF	Pop flags

Flags:	O D I T S Z A P C
	x x x x x x x x x

Description:	POPF 						86/88/286+

		Pops the top word off the stack into the flags register.

Notes:		On the 286, this can allow interrupts in when they're not
		expected. If the I flag is clear in both the current flags
		register and the popped register, a pending interrupt will
		still be recognized by the processor. Use a far call to
		an IRET instruction if the flags must be popped while making
		sure interrupts are excluded.

See also:	IRET

===
PUSH	Push word onto stack

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	POP {reg16|segreg|mem16} 			86/88/286+

		Pushes the word value in the register or memory location
		specified by the OPERAND. Effectively, SP is decremented by
		two and the operand is copied to SS:SP.

Notes:		On the 86/88 processors, PUSH SP pushes the value of SP after
		the push (after it has been decremented by two); 286 and above
		processors push the value of SP before the push.

See also:	PUSHA, PUSHF, and POP.

===
PUSHA	Push all registers

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	PUSHA 						286+

		Pushes AX, CX, DX, BX, SP, BP, SI, DI (in that order) onto the
		stack.

Notes:		PUSHA pushes the value of SP before the push.

See also:	PUSH, PUSHF, and POP.

===
PUSHF	Push flags

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	PUSHF 						86/88/286+

		Pushes the flags register (word) onto the stack.

===
RCL	Rotate through carry left

Flags:	O D I T S Z A P C
	x - - - - - - - x

Description:	RCL {reg|mem},{1|CL}				86/88/286+
		RCL {reg|mem},{immed8}				286+

		Rotates the bits in OPERAND1 leftward the number of bits
		indicated by OPERAND2. The bits rotate through the C flag as
		if it were a one-bit extension of OPERAND1. That is, the C
		flag rotates into the low-order bit and the high-order bit
		rotates into the C flag. The O flag is set if the sign bit
		changes.

Notes:		(1) Do not rely on the processor to detect redundant rotations
		(i.e. counts larger than the size of the operand). Instead,
		apply a modulus operation to large count values.
		(2) The O flag is only defined when the rotation count is 1.

See also:	ROL, SAL, SHL

===
RCR	Rotate through carry right

Flags:	O D I T S Z A P C
	x - - - - - - - x

Description:	RCR {reg|mem},{1|CL}				86/88/286+
		RCR {reg|mem},{immed8}				286+

		Rotates the bits in OPERAND1 rightward the number of bits
		indicated by OPERAND2. The bits rotate through the C flag as
		if it were a one-bit extension of OPERAND1. That is, the C
		flag rotates into the high-order bit and the low-order bit
		rotates into the C flag. The O flag is set if the sign bit
		changes.

Notes:		(1) Do not rely on the processor to detect redundant rotations
		(i.e. counts larger than the size of the operand). Instead,
		apply a modulus operation to large count values.
		(2) The O flag is only defined when the rotation count is 1.

See also:	ROR, SAR, SHR

===
REP	Repeat string operation CX times (prefix)

Description:	REP {string instruction}			86/88/286+

		Repeat the specified string operation the number of times
		specified by the value in CX.
		
		On the 8088/8086, combining a repeat prefix and a segment 
		override while interrupts are enabled is a distinctly
		dangerous practice, as the processor will push the address
		of the last prefix (either the repeat or the override,
		depending on the assembler), rather than the first prefix,
		and it will be to the last prefix that the interrupt handler
		will return, thus either scribbling on random memory or
		breaking out of the repeat prematurely.

		The exact operation is as follows:
		    while (CX != 0) {
		    	deal with interrupts
			perform string operation
			CX := CX - 1
    	    	    }

See also:	REPE, REPNE, CMPS, STOS, SCAS, MOVS, OUTS

===
REPE	Repeat string operation CX times while the Z flag is set (prefix)
REPZ

Description:	REPE {string instruction}			86/88/286+
		REPZ {string instruction}

		Repeat the specified string operation the number of times
		specified by the value in CX or until the Z flag is cleared
		by the operation.

		On the 8088/8086, combining a repeat prefix and a segment 
		override while interrupts are enabled is a distinctly
		dangerous practice, as the processor will push the address
		of the last prefix (either the repeat or the override,
		depending on the assembler), rather than the first prefix,
		and it will be to the last prefix that the interrupt handler
		will return, thus either scribbling on random memory or
		breaking out of the repeat prematurely.

		The exact operation is as follows:
		    while (CX != 0) {
		    	deal with interrupts
			perform string operation
			CX := CX - 1
			if Z flag is 0 then break
    	    	    }

See also:	REP, REPNE, CMPS, STOS, SCAS, MOVS, OUTS

===
REPNE	Repeat string operation CX times while the Z flag is cleared (prefix)
REPNZ

Description:	REPNE {string instruction}			86/88/286+
		REPNZ {string instruction}

		Repeat the specified string operation the number of times
		specified by the value in CX or until the Z flag is set by
		the operation.

		On the 8088/8086, combining a repeat prefix and a segment 
		override while interrupts are enabled is a distinctly
		dangerous practice, as the processor will push the address
		of the last prefix (either the repeat or the override,
		depending on the assembler), rather than the first prefix,
		and it will be to the last prefix that the interrupt handler
		will return, thus either scribbling on random memory or
		breaking out of the repeat prematurely.

		The exact operation is as follows:
		    while (CX != 0) {
		    	deal with interrupts
			perform string operation
			CX := CX - 1
			if Z flag is 1 then break
    	    	    }

See also:	REP, REPE, CMPS, STOS, SCAS, MOVS, OUTS

===
RET	Return from procedure
RETN
RETF

Description:	RET 						86/88/286+
		RETN
		RETF
		RET	{#bytes}
		RETN	{#bytes}
		RETF	{#bytes}

		Returns control from a procedure. The procedure is expected to
		have been called by a CALL instruction. Depending on whether a
		procedure is defined as a near or far call, the RET mnemonic
		will generate a near or far return (the difference being that
		a near return only expects a value for IP on the stack and far
		return expects a CS:IP register pair on the stack).

		The RETN and RETF mnemonics can be used to force a near or far
		return.
		
		In all forms, if the #bytes operand is given, the processor
		will add it to SP after the return address has been popped into
		the appropriate registers. You can use this to remove any
		arguments that were passed on the stack to your procedure.

See also:	CALL, IRET

===
ROL	Rotate left

Flags:	O D I T S Z A P C
	x - - - - - - - x

Description:	ROL {reg|mem},{1|CL}				86/88/286+
		ROL {reg|mem},{immed8}				286+

		Rotates the bits in OPERAND1 leftward the number of bits
		indicated by OPERAND2. The high-order bit rotates into the
		low-order bit as well as into the C flag. The O flag is set if
		the sign bit changes.

Notes:		(1) Do not rely on the processor to detect redundant rotations
    	    	(i.e. counts larger than the size of the operand). Instead,
		apply a modulus operation to large count values.
		(2) The O flag is only defined when the rotation count is 1.

See also:	RCL, SAL, SHL

===
ROR	Rotate right

Flags:	O D I T S Z A P C
	x - - - - - - - x

Description:	ROR {reg|mem},{1|CL}				86/88/286+
		ROR {reg|mem},{immed8}				286+

		Rotates the bits in OPERAND1 rightward the number of bits
		indicated by OPERAND2. The low-order bit rotates into the
		high-order bit as well as into the C flag. The O flag is set
		if the sign bit changes.

Notes:		(1) Do not rely on the processor to detect redundant rotations
		(i.e. counts larger than the size of the operand). Instead,
		apply a modulus operation to large count values.
		(2) The O flag is only defined when the rotation count is 1.

See also:	RCR, SAR, SHR

===
SAHF	Store AH into flags register

Flags:	O D I T S Z A P C
	- - - - x x x x x 

Description:	SAHF						86/88/286+

		Transfers AH into the low eight bits of the flags register.
		The bits have the following significance:

			7 6 5 4 3 2 1 0
			S Z - A - P - C
			    |   |   |
			    |---|---|------ undefined

Notes:		To store the high byte of the flags register (which holds the
		T, I, D, and O flags) in addition to the low byte, use the
		following:
			
			push	ax	; push flags on stack
			popf		; transfer flags to register

See also:	LAHF

===
SAL	Shift arithmetically left
SHL	Shift logically left

Flags:	O D I T S Z A P C
	x - - - x x ? x x

Description:	SAL {reg|mem},{1|CL}				86/88/286+
		SAL {reg|mem},{immed8}				286+
		SHL {reg|mem},{1|CL}				86/88/286+
		SHL {reg|mem},{immed8}				286+

		Shifts the bits in OPERAND1 leftward the number of bits
		indicated by OPERAND2. The high-order bit is shifted into the
		C flag and a zero is shifted into the low-order bit. If the
		sign bit changes, the O flag is set.

		The SAL and SHL mnemonics generate the same opcode because
		arithmetic and logical left shift operations are identical.

Notes:		(1) Do not rely on the processor to detect redundant shifts
		(i.e. counts larger than the size of the operand). Instead,
		apply a modulus operation to large count values.
		(2) The O flag is only defined when the shift count is 1.

See also:	RCL, ROL

===
SAR	Shift arithmetically right

Flags:	O D I T S Z A P C
	0 - - - x x ? x x

Description:	SAR {reg|mem},{1|CL}				86/88/286+
		SAR {reg|mem},{immed8}				286+

		Shifts the bits in OPERAND1 rightward the number of bits
		indicated by OPERAND2. The low-order bit is shifted into the
		C flag and the high-order bit is left unchanged (thereby
		preserving the sign). 

Notes:		(1) Do not rely on the processor to detect redundant shifts
		(i.e. counts larger than the size of the operand). Instead,
		apply a modulus operation to large count values.
		(2) The O flag is only defined when the shift count is 1.

See also:	SHR, RCR, ROR

===
SHR	Shift logically right

Flags:	O D I T S Z A P C
	x - - - x x ? x x

Description:	SHR {reg|mem},{1|CL}				86/88/286+
		SHR {reg|mem},{immed8}				286+

		Shifts the bits in OPERAND1 rightward the number of bits
		indicated by OPERAND2. The low-order bit is shifted into the
		C flag and the high-order bit is set to zero.

Notes:		(1) Do not rely on the processor to detect redundant shifts
		(i.e. counts larger than the size of the operand). Instead,
		apply a modulus operation to large count values.
		(2) The O flag is only defined when the shift count is 1.

See also:	SAR, RCR, ROR

===
SBB	Subtract with borrow

Flags:	O D I T S Z A P C
	x - - - x x x x x

Description:	SBB {reg},{reg|mem|immed} 			86/88/286+
		SBB {mem},{reg|immed}

		Subtracts OPERAND2 from OPERAND1 and stores the result in
		OPERAND1. The C flag is also subtracted from OPERAND1,
		effectively propagating any borrow from a previous subtraction.
		If OPERAND1 is a word and OPERAND2 is immed8, then OPERAND2 is
		sign-extended before the subtraction.

See Also:	SUB for subtract without borrow and a mathematical
		interpretation of the condition codes.

===
SCAS	Scan string
SCASB
SCASW

Flags:	O D I T S Z A P C
	x - - - x x x x x

Description:	SCAS	{ES:[DI]}				86/88/286+
		SCASB
		SCASW

		Scans the string specified by ES:[DI], comparing it against
		the value in AX (word) or AL (byte).

		The SCASB and SCASW abbreviations can also be used. Neither
		has operands.

			SCASB		Scans bytes at ES:[DI]
			SCASW		Scans words at ES:[DI]

		SCAS is typically used with the following repeat prefixes:

		  Prefix	Function
		  -----------	-------------------------------------------
		  REPNE/REPNZ	Find first match in string of length CX
				If Z=0, then no match found
		  REPE/REPZ	Find first mismatch in string of length CX.
				If Z=1, then no mismatch found


		When a repeating SCAS instruction finishes, DI points one
		element beyond the match/mismatch (or one element past the end
		of the string if no match/mismatch found).

		After comparing an element, SCAS adjusts DI to point to
		the next element in the string depending on the state of the
		D flag: if D is set, then DI is decremented, otherwise,
		incremented. The size of the operand determines the amount of
		adjustment.


See also:	REP for more information on repeat prefixes.

===
SGDT	Store global descriptor table register

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	SGDT {mem64} 					286+

		Protected mode instruction for transferring values from the
		global descriptor table register to memory. The single OPERAND
		points to six bytes in memory that receive the contents of the
		global descriptor table register as follows:

			bytes 0,1    <-  LIMIT field
			bytes 2,3,4  <-  BASE field
			byte 5       <-  undefined

Notes:		This instruction is not used by application programs. 

See also:	SIDT, LGDT

===
SIDT	Save interrupt descriptor table register

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	SIDT {mem64} 					286+

		Protected mode instruction for transferring values from the
		interrupt descriptor table register to memory. The single
		OPERAND points to six bytes in memory that receive the
		contents of the interrupt descriptor table register as
		follows:

			bytes 0,1    <-  LIMIT field
			bytes 2,3,4  <-  BASE field
			byte 5       <-  undefined

Notes:		This instruction is not used by application programs. 

See also:	SGDT, LIDT

===
SLDT	Store local descriptor table register

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	SLDT {reg16|mem16}				286+

		Protected mode instruction for accessing values in the local
		descriptor table register. The single OPERAND supplies a
		a register or memory location into which the local descriptor
		table register is stored.

Notes:		This instruction is not used by application programs.

See also:	LLDT

===
SMSW	Store machine status word

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	SMSW {reg16|mem16}				286+

		Stores the machine status word (MSW) into the register or
		memory location specified by the OPERAND. The SMSW instruction
		is the complement of the LMSW instruction. See LMSW for more
		information.

===
STD	Set direction flag

Flags:	O D I T S Z A P C
	- 1 - - - - - - -

Description:	STD 						86/88/286+

		Sets the direction flag. When the direction flag is set,
		string operations work downward (toward lower addresses),
		decrementing the appropriate index register.

See also:	CLD

===
STC	Set carry flag

Flags:	O D I T S Z A P C
	- - - - - - - - 1

Description:	STC 						86/88/286+

		Sets the carry flag.

See also:	CMC, CLC

===
STI	Set interrupt flag

Flags:	O D I T S Z A P C
	- - 1 - - - - - -

Description:	STI 						86/88/286+

		Sets the interrupt flag, which enables maskable interrupts.

See also:	CLI

===
STOS	Store string
STOSB
STOSW

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	STOS	{ES:[DI]}				86/88/286+
		STOSB
		STOSW

		Stores the value in AX (word) or AL (byte) into the string
		specified by ES:[DI].

		The STOSB and STOSW abbreviations can also be used. Neither
		has operands.

			STOSB		Stores bytes to ES:[DI]
			STOSW		Stores words to ES:[DI]

		STOS is typically used with the REP prefix, which stores the
		value in AL or AX the number of times specified by the value
		in CX.

		When a repeating STOS instruction finishes, DI points one
		element beyond the one element past the end of the string.

		After storing an element, STOS adjusts DI to point to
		the next element in the string depending on the state of the
		D flag: if D is set, then DI is decremented, otherwise,
		incremented. The size of the operand determines the amount of
		adjustment.

See also:	REP for more information on repeat prefixes.

===
STR	Store task register

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	STR {reg16|mem16}				286+ (priv)

		Places the value in the current task register into the
		register or memory location specified by the OPERAND.

See also:	LTR
		
===
SUB	Subtract without borrow

Flags:	O D I T S Z A P C
	x - - - x x x x x

Description:	SUB	{reg},{reg|mem|immed}		    	86/88/286+
		SUB	{mem},{reg|immed}

		Subtracts OPERAND2 from OPERAND1 and stores the result in
		OPERAND1. If OPERAND1 is a word and OPERAND2 is immed8, then 
		OPERAND2 is sign-extended before the subtraction. The
		assembler will use the immed8 form whenever possible.

		The O (overflow) flag indicates a borrow from the sign bit.
		When doing signed arithmetic, a borrow from the sign bit means
		an arithmetic overflow occurred--the result is incorrect
		because it could not fit in the destination operand. When doing
		multi-precision arithmetic, the overall result is incorrect
		only if the high-order subtraction produces an overflow;
		overflow produced by lower-order operations is irrelevant.

		The Z (zero) flag is set if the result is zero.

		The C (carry) flag is set if the subtraction caused a borrow,
		which means that the unsigned value of OPERAND2 was greater
		than to the unsigned value of OPERAND1. When doing multi-
		precision arithmetic, the borrow can be propagated with the
		SBB instruction.

		The S (sign) flag is set if the result is negative.

See Also:	CMP for a relational interpretation of condition codes; SBB
		for subtract with borrow.

===
TEST	Test operand

Flags:	O D I T S Z A P C
	0 - - - x x ? x 0

Description:	TEST {reg},{reg|mem|immed} 			86/88/286+
		TEST {mem},{reg|immed}

		Logically and's OPERAND1 with OPERAND2, setting the
		appropriate condition flags but without disturbing
		either OPERAND. The S, Z, and P flags are set based on the
		result of the operation.

Notes:		Most assemblers encode TEST {mem},{reg} as TEST {reg},{mem},
		which is an equivalent operation. OS/90 uses a TST macro that
		is optimized for special test cases on the 8088 and 8086.

===
VERR	Verify segment for read access

Flags:	O D I T S Z A P C
	- - - - - x - - -

Description:	VERR {reg16|mem16}				286+

		Checks the segment specified by OPERAND for reading. The
		OPERAND is expected to be a valid selector. The instruction
		determines whether the segment is accessible and readable at
		the current privilege level. VERR is used to check the
		accessibility of a segment without generating a protection
		fault.

		If the segment cannot be read, then the Z flag is 0,
		otherwise, the Z flag is 1.

See also:	VERW

===
VERW	Verify segment for write access

Flags:	O D I T S Z A P C
	- - - - - x - - -

Description:	VERW {reg16|mem16}				286+

		Checks the segment specified by OPERAND for writing. The
		OPERAND is expected to be a valid selector. The instruction
		determines whether the segment is accessible and writable at
		the current privilege level. VERW is used to check the
		accessibility of a segment without generating a protection
		fault.

		If the segment cannot be written, then the Z flag is 0,
		otherwise, the Z flag is 1.

See also:	VERR

===
WAIT	Wait for coprocessor

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	WAIT 						86/88/286+

		Pauses the CPU until the BUSY pin goes high, indicating the
		coprocessor has finished its calculation.

===
XCHG	Exchange data

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	XCHG {reg},{reg|mem}				86/88/286+
		XCHG {mem},{reg}

		Exchanges OPERAND1 with OPERAND2. The size of the  operands
		determines the size of the data exchanged (byte or word).

===
XLAT	Translate value through lookup table
XLATB

Flags:	O D I T S Z A P C
	- - - - - - - - -

Description:	XLAT 					    	86/88/286+
		XLAT {mem}
		XLATB
		XLATB {segreg:}

		Translates the byte in AL by using AL as an unsigned index
		into the table pointed to by BX. If no segment override is
		specified, then DS is assumed.

		XLAT and XLATB are synonymns. Unless a segment override is
		needed, no operand is required.
		
===
XOR	Logical exclusive-or

Flags:	O D I T S Z A P C
	0 - - - x x ? x 0

Description:	XOR {reg},{immed|reg|mem} 			86/88/286+
		XOR {mem},{immed|reg}

		Logically exclusive-or's OPERAND1 with OPERAND2 and stores the
		result in OPERAND1. 

===
XORNF	Logical exclusive-or with undefined flags

Flags:	O D I T S Z A P C
	0 - - - ? ? ? ? 0

Description:	XORNF {reg},{reg|mem|immed} 			86/88/286+
		XORNF {mem},{reg|immed}

		This is a pseudo-instruction provided by Esp to allow the
		programmer to indicate to it that the XOR is being
		performed exclusively for the effect it has on the destination,
		not for the effect the instruction has on the flags register.
		
		Armed with this knowledge, Esp can sometimes optimize a
		word-sized XOR instruction with immediate source into a
		byte-sized form, speeding the operation and reducing code size.

See also:	XOR

===
MOVS	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
MOVZX	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
CWDE	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
CDQ	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SHLD	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SHRD	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
BSF	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
BSR	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
BT	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
BTC	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
BTR	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
BTS	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETB	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETNAE	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETA	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETNB	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETBE	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETNA	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETA	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETNBE	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETE	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETZ	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETNE	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETNZ	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETL	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETNGE	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETGE	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETNL	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETLE	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETNG	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETG	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETNLE	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETS	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETNS	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETC	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETNC	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETO	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETNO	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETP	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETPE	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETNP	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
SETPO	***** 80386 INSTRUCTION. NOT DOCUMENTED HERE. *****

===
REF	Reference table of all instructions and tables available with inst 
TABLE

Instr.  Description
-------------------------------------------
AAA	ASCII adjust AL (after addition)
AAD	ASCII adjust AX (before division)
AAM	ASCII adjust AX (after multiply)
AAS	ASCII adjust AL (after subtraction)
ADC	Add with carry
ADD	Add without carry
AND	Logical and
ARPL	Adjust requested privilege level
BOUND	Check array bounds
CALL	Call procedure
CBW	Convert byte to word
CLC	Clear carry flag
CLD	Clear direction flag
CLI	Clear interrupt flag
CLTS	Clear task-switched flag
CMC	Complement carry flag
CMP	Compare
CMPS	Compare strings
CMPSB	Compare strings (byte-size elements)
CMPSW	Compare strings (word-size elements)
CWD	Convert word to double word
DAA	Decimal adjust AL (after addition)
DAS	Decimal adjust AL (after subtraction)
DEC	Decrement
DIV	Unsigned divide
ENTER	Make stack frame entry to procedure
ESC	Escape to coprocessor
HLT	Halt processor
IDIV	Signed integer divide
IMUL	Signed multiply
IN	Input from port
INC	Increment
INS	Input string from port
INSB	Input string from port (byte-size elements)
INSW	Input string from port (word-size elements)
INT	Interrupt
INT3	Interrupt #3 (software breakpoint)
INTO	Interrupt on overflow
IRET	Interrupt return
JA	Jump on above (unsigned)
JAE	Jump on above or equal (unsigned)
JB	Jump on below (unsigned)
JBE	Jump on below or equal (unsigned)
JC	Jump on carry
JCXZ	Jump if CX is zero
JE	Jump on equal (signed and unsigned)
JG	Jump on greater (signed)
JGE	Jump on greater or equal (signed)
JL	Jump on less (signed)
JLE	Jump on less or equal (signed)
JMP	Jump always
JNA	Jump on not above (unsigned)
JNAE	Jump on not above or equal (unsigned)
JNB	Jump on not below (unsigned)
JNBE	Jump on not below or equal (unsigned)
JNC	Jump on no carry
JNE	Jump on not equal (signed and unsigned)
JNG	Jump on not greater (signed)
JNGE	Jump on not greater or equal (signed)
JNL	Jump on not less (signed)
JNLE	Jump on not less or equal (signed)
JNO	Jump on no overflow
JNP	Jump on not Parity (parity bit is zero)
JNS	Jump on non-negative
JNZ	Jump on not zero (Z flag is cleared)
JO	Jump on overflow
JP	Jump on Parity (parity bit is one)
JS	Jump on negative
JZ	Jump on zero (Z flag is set)
LAHF	Load AH with flags register
LAR	Load access rights byte
LDS	Load far pointer into DS:xx
LEA	Load effective address
LEAVE	Clean up stack frame at exit of procedure
LES	Load far pointer into ES:xx
LGDT	Load global descriptor table register
LIDT	Load interrupt descriptor table register
LLDT	Load local descriptor table register
LMSW	Load machine status word
LOCK	Lock the bus
LODS	Load string
LODSB	Load string (byte-size elements)
LODSW	Load string (word-size elements)
LOOP	Loop while CX is nonzero
LOOPE	Loop while CX is nonzero and Z flag is set
LOOPNE	Loop while CX is nonzero and Z flag is not set
LOOPNZ	Loop while CX is nonzero and Z flag is not set
LOOPZ	Loop while CX is nonzero and Z flag is set
LSL	Load segment limit
LTR	Load task register
MOV	Move data
MOVS	Move string
MOVSB	Move string (byte-sized elements)
MOVSW	Move string (word-sized elements)
MUL	Mutiply unsigned
NEG	Negate two's complement number
NOP	No-operation
NOT	Negate one's complement number
OR	Logical or
OUT	Output byte or word to port
OUTS	Output string to port
OUTSB	Output string to port (byte-size elements)
OUTSW	Output string to port (word-size elements)
POP	Pop word from stack
POPA	Pop all registers
POPF	Pop flags
PUSH	Push word onto stack
PUSHA	Push all registers
PUSHF	Push flags
RCL	Rotate through carry left
RCR	Rotate through carry right
REP	Repeat string operation CX times (prefix)
REPE	Repeat string operation CX times while the Z flag is set (prefix)
REPNE	Repeat string operation CX times while the Z flag is cleared (prefix)
REPNZ	Repeat string operation CX times while the Z flag is cleared (prefix)
REPZ	Repeat string operation CX times while the Z flag is set (prefix)
RET	Return from procedure
RETF	Return from far procedure
RETN	Return from near procedure
ROL	Rotate left
ROR	Rotate right
SAHF	Store AH into flags register
SAL	Shift arithmetically left
SAR	Shift arithmetically right
SBB	Subtract with borrow
SCAS	Scan string
SCASB	Scan string (byte-size elements)
SCASW	Scan string (word-size elements)
SGDT	Store global descriptor table register
SHL	Shift logically left
SHR	Shift logically right
SIDT	Save interrupt descriptor table register
SLDT	Store local descriptor table register
SMSW	Store machine status word
STC	Set carry flag
STD	Set direction flag
STI	Set interrupt flag
STOS	Store string
STOSB	Store string (byte-size elements)
STOSW	Store string (word-size elements)
STR	Store task register
SUB	Subtract without borrow
TEST	Test operand
VERR	Verify segment for read access
VERW	Verify segment for write access
WAIT	Wait for coprocessor
XCHG	Exchange data
XLAT	Translate value through lookup table
XLATB	Synonymn for XLAT
XOR	Logical exclusive-or
