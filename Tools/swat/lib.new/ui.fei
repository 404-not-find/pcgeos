table enter $fatalerr_info_table ui::UI_MSG_DETACH_ABORT_SENT_TO_INVALID_CLASS { MSG_META_DETACH_ABORT can only be sent to a GenSystemClass object or a
 GenFieldClass object.}
table enter $fatalerr_info_table ui::BAD_FLAGS_PASSED_TO_GEN_COPY_CHUNK { GenCopyChunk utility routine can only be passed the CCF_MARK_DIRTY flag.
 None of the other CompChildFlags should be set.}
table enter $fatalerr_info_table ui::GEN_GET_DISPLAY_SCHEME_REQUIRES_GEN_OBJECT { GenGetDisplayScheme utility routine must be passed a generic object as it
 might need to get the generic parent to find the display scheme.}
table enter $fatalerr_info_table ui::UI_VUM_MANUAL_NOT_ALLOWED_FOR_GEN_SET_NOT_USABLE { VUM_MANUAL has been outlawed with a FATAL_ERROR for the same reason that there
 is a warning in MSG_GEN_UPDATE_VISUAL about needing to send a
 MSG_GEN_UPDATE_VISUAL to EVERY generic object you've marked as needing
 visual updating via VUM_MANUAL.  The problem is this:
 An application should make no assumption
 about the visual construction of a generic tree; in other words, if you
 mark two triggers as IMAGE_INVALID, you shouldn't assume that you can
 just update the display that they are on, since the buttons may visually
 be placed on some window other than the display.  This problem is solved
 by having the MSG_GEN_UPDATE_VISUAL, since the specific UI can implement
 this method by invalidating all visual aspects of the object wherever
 (as in whatever window they're in) they may be.  Whew!

 So, how does this relate to VUM_MANUAL & MSG_GEN_SET_NOT_USABLE?  Well,
 when an object is marked not usable, it is visually torn down, & may actually
 have the visible instance data discarded.  In this state,
 MSG_GEN_UPDATE_VISUAL does nothing, since the object isn't specifically built.

 How to get around this?  I'd recommend using one of the
 VUM_DELAYED_VIA_??_QUEUE modes for these calls, if you're trying to avoid
 flickering of your display in bringing down UI components.  Note that
 calling multiple MSG_GEN_SET_NOT_USABLE's w/ a DELAYED update mode only
 generates one method which goes through the queue to perform the udpate later.}
table enter $fatalerr_info_table ui::UI_GEN_USED_BEFORE_GROWN { Generic part of object must be grown before this operation can occur.  Make
 sure that the object is a generic object.}
table enter $fatalerr_info_table ui::NO_SPECIFIC_UI { Unable to find specific UI to use when trying to resolve specific UI class
 for a generic object.}
table enter $fatalerr_info_table ui::UI_ERROR_CAN_NOT_SET_USABLE_IF_NOT_IN_GEN_COMPOSITE { Occurs when MSG_GEN_SET_USABLE is sent to object that is not attached to a
 generic object tree.  Make sure that you've added the object to the
 appropriate place in you application's object tree.}
table enter $fatalerr_info_table ui::UI_ERROR_CAN_NOT_ADD_OR_REMOVE_OBJECT_WHILE_USABLE { An object must be set not usable before it can be added with MSG_GEN_ADD_CHILD
 or removed with MSG_GEN_REMOVE_CHILD.  Make sure that either the object is
 marked not usable in your .ui/.goc file or that you set it not usable with
 MSG_GEN_SET_NOT_USABLE.}
table enter $fatalerr_info_table ui::OBJECT_NOT_GENERIC { NOT CURRENTLY USED}
table enter $fatalerr_info_table ui::UI_ERROR_CAN_NOT_DO_OPERATION_WHEN_USABLE { An object must be not usable before this operation can occur.  Make sure that
 either the object is marked not usable in your .ui/.goc file or that you set
 it not usable with MSG_GEN_SET_NOT_USABLE.}
table enter $fatalerr_info_table ui::UI_GEN_COPY_TREE_SOURCE_AND_DEST_CANNOT_BE_SAME_BLOCK { MSG_GEN_COPY_TREE cannot be used to copy a generic object tree to the same
 object block as the source object tree.  Usually, you can define a seperate
 "template" object block as the source block and attach the copied tree to
 your working destination block.}
table enter $fatalerr_info_table ui::UI_FUNCTION_REQUIRES_THAT_GENERIC_OBJECT_BE_IN_TREE { An object must be attached to a generic parent before this operation can
 occur.  Make sure that either the object is a child of some object in your
 .ui/.goc file or that you add it to some generic parent with
 MSG_GEN_ADD_CHILD.}
table enter $fatalerr_info_table ui::UI_GEN_OBJECT_REQUIRED_FOR_THIS_OPERATION { This operation can only operation on generic objects.  Make sure that the
 object is of one of the predefined generic class or is a subclass thereof.}
table enter $fatalerr_info_table ui::UI_GEN_GET_APPLICATION_OD_FOUND_IN_GUP { (Internal)  The owner of the object block passed to GenGetApplicationOD
 does not have an application object associated with it, though an
 application object was found up in the generic tree.}
table enter $fatalerr_info_table ui::UI_GEN_FIND_CHILD_BAD_OD { MSG_GEN_FIND_CHILD was passed a bad child optr to find.  Make sure the
 handle and chunk are valid.}
table enter $fatalerr_info_table ui::UI_GEN_CANT_SET_GEN_ATTRIBUTES_WHEN_USABLE { MSG_GEN_SET_ATTRS cannot be used on a generic object that is already
 usable as the attributes are used to specifically resolve the object.  Set
 GenAttributes when object is not usable then set object usable with
 MSG_GEN_SET_USABLE.}
table enter $fatalerr_info_table ui::UI_ERROR_NO_OWNING_PROCESS { MSG_GEN_SEND_TO_PROCESS can't do it's job, because the block that the
 current object is in has no owner.}
table enter $fatalerr_info_table ui::BAD_ASSUMPTION_IN_GenCheckIfFullyUsable { Internal error within GenCheckIfFullyUsable}
table enter $fatalerr_info_table ui::BAD_ASSUMPTION_IN_GenCheckIfFullyEnabled { Internal error within GenCheckIfFullyEnabled}
table enter $fatalerr_info_table ui::UI_ILLEGAL_REQUEST_OF_GEN_APPLICATION_OBJECT { Generally the result of attempting to set an GenApplication object USABLE or
 not USABLE, which is an illegal operation.  Application objects are made
 USABLE via MSG_META_ATTACH, & made NOT_USABLE via MSG_META_DETACH, both
 messages which should originate only from with the default behavior of
 GenProcessClass for handling the startup & shutdown of apps.}
table enter $fatalerr_info_table ui::UI_GEN_CLASS_ILLEGALLY_USED { This occurs if GenClass receives a MSG_META_RESOLVE_VARIANT_SUPERCLASS,
 which should never happen, as the only legal generic classes are those
 subclassed off of GenClass, not GenClass itself, which exists only to 
 provide common behavior.}
table enter $fatalerr_info_table ui::UI_APP_OBJ_HAS_NO_GENERIC_PARENT { The app object needs to be grown out in order for some message to reach
 the specific instance data, but the app isn't yet hooked into the generic
 tree, & so the field can't be asked which specific UI library should be used.
 Generally caused by sending messages to the app very early or very late in
 its life (i.e. while it is illegal to do so)}
table enter $fatalerr_info_table ui::UI_ERROR_CREATE_VIS_MONIKER_SOURCE_TOO_LARGE { Size field passed to MSG_VIS_CREATE_VIS_MONIKER and MSG_GEN_CREATE_VIS_MONIKER
 must be less than 8192.  Larger monikers are not supported by these messages.}
table enter $fatalerr_info_table ui::UI_ERROR_CREATE_VIS_MONIKER_BAD_SOURCE_TYPE { sourceType passed to MSG_VIS_CREATE_VIS_MONIKER and MSG_GEN_CREATE_VIS_MONIKER
 must be a valid VisMonikerSourceType.}
table enter $fatalerr_info_table ui::UI_ERROR_CREATE_VIS_MONIKER_BAD_DATA_TYPE { dataType passed to MSG_VIS_CREATE_VIS_MONIKER and MSG_GEN_CREATE_VIS_MONIKER
 must be a valid VisMonikerDataType.}
table enter $fatalerr_info_table ui::UI_ERROR_CREATE_VIS_MONIKER_CANNOT_USE_VMDT_NULL { VMDT_NULL cannot be used with MSG_VIS_CREATE_VIS_MONIKER and
 MSG_GEN_CREATE_VIS_MONIKER.}
table enter $fatalerr_info_table ui::UI_ERROR_CREATE_VIS_MONIKER_CANNOT_USE_VMDT_TOKEN { VMDT_TOKEN cannot be used with MSG_VIS_CREATE_VIS_MONIKER and
 MSG_GEN_CREATE_VIS_MONIKER as VMDT_TOKEN must have an associated object
 which the specific UI can use to determine which moniker in the Token
 Database's moniker list for the passed token is to be used.  So, only
 MSG_GEN_REPLACE_VIS_MONIKER, MSG_GEN_PRIMARY_REPLACE_LONG_TERM_MONIKER, and
 MSG_GEN_DYNAMIC_LIST_COPY_ITEM_MONIKER can use VMDT_TOKEN.}
table enter $fatalerr_info_table ui::UI_ERROR_CREATE_VIS_MONIKER_GSTRING_SIZE_0_NOT_ALLOWED { When using VMDT_GSTRING, the size field must be passed.  It cannot be 0.}
table enter $fatalerr_info_table ui::UI_BAD_COORDINATE { Some value passed to this routine (usually a mouse position or an object's
 bounds) is illegal coordinate under the PC graphics system.}
table enter $fatalerr_info_table ui::UI_EXPOSURE_OF_NON_WINDOW_OBJECT { Only visual objects that have VTF_IS_WINDOW should receive MSG_META_EXPOSED events.
 Perhaps you are not using VisContent type object as the output of a view
 somewhere.}
table enter $fatalerr_info_table ui::UI_VIS_USED_BEFORE_GROWN { Some routine assumes that an object's visual master class has been grown,
 and it isn't.  This could be the specific UI's fault for trying to muck with
 visual or specific instance data for an object that is not yet built,
 or possibly something trashed Vis_offset for the object.}
table enter $fatalerr_info_table ui::UI_BAD_FLAGS_RETURNED_FROM_MOUSE_MESSAGE { Visual objects are required to return MouseReturnFlags (most often MRF_-
 PROCESSED) from certain mouse messages (MSG_META_START_SELECT, MSG_META_PTR, etc.)}
table enter $fatalerr_info_table ui::UI_VIS_OBJECT_ALREADY_OPENED { A MSG_VIS_OPEN was passed to an object that already has VA_REALIZED already
 set, indicating that the object has been previously opened.}
table enter $fatalerr_info_table ui::UI_CAN_NOT_WIN_RESIZE_NON_WINDOW { A MSG_VIS_MOVE_RESIZE_WIN was somehow passed to an object with VTF_IS_WINDOW
 cleared (i.e. a non-window object).  This shouldn't happen.}
table enter $fatalerr_info_table ui::UI_NESTED_VISUAL_UPDATE { Somehow a MSG_VIS_UPDATE_WIN_GROUP was sent to a win group where one is
 already in progress.  Most commonly the result of an object handling a visual
 update message such as MSG_VIS_OPEN passing VUM_NOW in some message to
 an object in the same window.  VUM_NOW may not be used while performing
 a visual update.  VUM_MANUAL, or one oof the delayed VUM modes, must be used
 instead.}
table enter $fatalerr_info_table ui::UI_NULL_GWIN_RETURNED_FROM_MSG_VIS_OPEN_WIN { A MSG_VIS_OPEN_WIN should return the handle of the window that has been
 opened, so that it can passed to the appropriate children.}
table enter $fatalerr_info_table ui::UI_VIS_COMP_OBJECT_MARKED_REALIZED_WITHOUT_GWIN { An object already has VA_REALIZED bit set (i.e. has received a MSG_VIS_OPEN)
 but doesn't have a gWin set for it, as it is supposed to after a MSG_VIS_
 OPEN.}
table enter $fatalerr_info_table ui::UI_VIS_COMP_OBJECT_NOT_REALIZED_YET_HAS_GWIN { An object that has not yet received a MSG_VIS_OPEN (as indicated by the
 VA_REALIZED bit) already has a gWin set for it.  This should only get set
 in a MSG_VIS_OPEN, and always cleared during a MSG_VIS_CLOSE.}
table enter $fatalerr_info_table ui::UI_BAD_SET_VIS_ATTR_FLAGS { Only VA_VISIBLE, VA_MANAGED, VA_DRAWABLE, VA_DETECTABLE, or VA_FULLY_ENABLED
 are allowed to be set or cleared via VisSetVisAttrs.}
table enter $fatalerr_info_table ui::UI_UPDATE_OF_NON_WIN_GROUP_OBJECT { A MSG_VIS_UPDATE_WIN_GROUP was sent to a non-win-group object.  Use MSG_VIS_-
 VUP_UPDATE_WIN_GROUP instead, which finds the win group object from the object
 you send the message to.  Better yet, make sure what you are doing isn't
 better (or more correctly) served VisMarkInvalid.}
table enter $fatalerr_info_table ui::UI_BAD_VIS_UPDATE_MODE { Caller to the routine that fatal errored didn't pass a legal VisUpdateMode,
 either VUM_NOW, VUM_MANUAL, VUM_DELAYED_VIA_APP_QUEUE, VUM_DELAYED_VIA_UI_-
 QUEUE.}
table enter $fatalerr_info_table ui::UI_BAD_UPDATE_WINDOW_FLAGS { Bad UpdateWindowFlags passed to MSG_META_UPDATE_WINDOW or
 MSG_GEN_GUP_ENSURE_UPDATE_WINDOW.}
table enter $fatalerr_info_table ui::UI_VIS_NON_COMPOSITE_OBJECT_MARKED_AS_IS_WINDOW { Any object marked as VTF_IS_WINDOW must also have VTF_IS_COMPOSITE set.
 Either subclass your windowed object off of VisCompClass or figure out where
 the VI_typeFlags for the object got screwed up.}
table enter $fatalerr_info_table ui::UI_VIS_WIN_GROUP_OBJECT_MUST_BE_MARKED_AS_IS_WINDOW { Win group objects must have VTF_IS_WINDOW set.  Most likely you are trashing
 the VisTypeFlags that were set by your object's superclass, or not executing
 your superclass' MSG_SPEC_BUILD or MSG_META_INITIALIZE.}
table enter $fatalerr_info_table ui::UI_VIS_WIN_GROUP_OBJECT_MARKED_AS_IS_PORTAL { A win group object cannot be a portal.  Re-think what type flags to give your
 object, or figure out how you're trashing the VI_typeFlags instance data.}
table enter $fatalerr_info_table ui::UI_VIS_SPEC_CANT_GET_A_FIELD_SIZE { VisConvertSpecVisSize (called by the HINT_FIXED_SIZE, etc. handlers) couldn't
 find a GenField object up the generic tree from this object.  Do a "vup"
 to try to see what's going on.  NOTE: one possibility is that you are using
 HINT_FIXED_SIZE, etc. on a windowed object -- this is a bad thing.  You
 should be using something like HINT_SIZE_WINDOW_AS_RATIO_OF_PARENT, not
 HINT_FIXED_SIZE for windowed objects.}
table enter $fatalerr_info_table ui::UI_VIS_BAD_SPEC_SIZE_ARGUMENT { An illegal SpecSizeSpec argument was passed to VisConvertSpecVisSize (and 
 typically was an argument to HINT_FIXED_SIZE or a related hint.)  Make
 sure your hint is of the correct format.}
table enter $fatalerr_info_table ui::UI_VIS_SPEC_SIZE_CANT_USE_COUNT_HERE { A count is being passed to VisConvertSpecVisSize.  The caller should have
 dealt with this on its own.  SST_COUNT is not a legal argument to the
 width or height arguments of HINT_FIXED_SIZE, HINT_MINIMUM_SIZE, HINT_MAXIMUM
 _SIZE or HINT_INITIAL_SIZE.}
table enter $fatalerr_info_table ui::UI_SIZE_HINT_MUST_HAVE_ARGUMENTS { Any of the size hints (HINT_FIXED_SIZE, HINT_MINIMUM_SIZE, HINT_MAXIMUM_SIZE,
 HINT_INITIAL_SIZE) require at least a SpecWidth argument, and optionally
 a SpecHeightArgument and a count (for composites).}
table enter $fatalerr_info_table ui::UI_SIZE_HINT_TOO_MANY_ARGUMENTS { None of the size hints (HINT_FIXED_SIZE, HINT_MINIMUM_SIZE, HINT_MAXIMUM_SIZE,
 HINT_INITIAL_SIZE) should be larger than CompSizeHintArgs.}
table enter $fatalerr_info_table ui::UI_SIZE_HINT_ILLEGAL_TYPE_FOR_HEIGHT_ARGUMENT { Only certain SpecSizeSpec arguments (SST_LINES_OF_TEXT, SST_PIXELS,
 SST_PCT_OF_FIELD_HEIGHT) are allowable as a height argument to
 HINT_FIXED_SIZE, HINT_MINIMUM_SIZE, HINT_MAXIMUM_SIZE or HINT_INITIAL_SIZE.}
table enter $fatalerr_info_table ui::UI_SIZE_HINT_ILLEGAL_TYPE_FOR_WIDTH_ARGUMENT { Only certain SpecSizeSpec arguments (SST_AVG_CHAR_WIDTHS, 
 SST_WIDE_CHAR_WIDTHS, SST_PIXELS, SST_PCT_OF_FIELD_WIDTH) 
 are allowable as a height argument to HINT_FIXED_SIZE, HINT_MINIMUM_SIZE, 
 HINT_MAXIMUM_SIZE or HINT_INITIAL_SIZE.}
table enter $fatalerr_info_table ui::UI_SIZE_HINT_COUNT_ARGUMENT_MUST_BE_A_PLAIN_NUMBER { A simple number, not a SpecSizeSpec value, should be passed as the count
 argument to HINT_FIXED_SIZE, HINT_MINIMUM_SIZE, HINT_MAXIMUM_SIZE, or HINT_
 INITIAL_SIZE.}
table enter $fatalerr_info_table ui::UI_SIZE_HINT_CHILD_COUNT_TOO_LARGE { A rather large child count is being passed as the count argument to
 HINT_FIXED_SIZE, HINT_MINIMUM_SIZE, HINT_MAXIMUM_SIZE or HINT_INITIAL_SIZE.
 Currently this routine fatal errors for more than 255 children -- hopefully
 this maximum is not a problem.}
table enter $fatalerr_info_table ui::UI_BAD_GEO_UPDATE_PATH { Somewhere a VOF_GEO_UPDATE_PATH path bit is set in an object whose children
 all have valid geometry, or a VOF_GEOMETRY_INVALID bit is set in a child,
 but the corresponding path bit is not set in the parent.  Do a "vup *ds:si
 VI_optFlags to view all the flags leading up from the object, or a 
 "vistree {addr} VI_optFlags" from the win group object to try to see where
 the offending bit is located.   This often occurs from a composite that
 doesn't have a well behaved MSG_VIS_RECALC_SIZE handler (doesn't clear
 the path or invalid bits correctly, typically done by VisRecalcSizeAndInvalIfNeeded).}
table enter $fatalerr_info_table ui::UI_BAD_WINDOW_UPDATE_PATH { Somewhere a VOF_WINDOW_UPDATE_PATH path bit is set in an object whose children
 all have valid windows, or a VOF_WINDOW_INVALID bit is set in a child,
 but the corresponding path bit is not set in the parent.  Do a "vup *ds:si
 VI_optFlags to view all the flags leading up from the object, or a 
 "vistree {addr} VI_optFlags" from the win group object to try to see where
 the offending bit is located.}
table enter $fatalerr_info_table ui::UI_BAD_IMAGE_UPDATE_PATH { Somewhere a VOF_GEO_IMAGE_PATH path bit is set in an object whose children
 all have valid images, or a VOF_IMAGE_INVALID bit is set in a child,
 but the corresponding path bit is not set in the parent.  Do a "vup *ds:si
 VI_optFlags to view all the flags leading up from the object, or a 
 "vistree {addr} VI_optFlags" from the win group object to try to see where
 the offending bit is located.}
table enter $fatalerr_info_table ui::VIS_ADD_OR_REMOVE_CHILD_BAD_FLAGS { Bad InsertChildFlags are being passed to VisInsertChild (probably via MSG_
 VIS_ADD_CHILD or MSG_VIS_REMOVE_CHILD).  Check what you're passing in bp.
 Also for GenInsertChild.}
table enter $fatalerr_info_table ui::UI_REQUIRES_VISUAL_COMPOSITE { Certain VisClass utilities require that the object in *ds:si be a composite.
 Check to make sure you have made your object is VisComp and set VTF_IS_COMP-
 OSITE, or look for where you might have trashed VI_typeFlags.}
table enter $fatalerr_info_table ui::UI_REALIZED_VIS_OBJECT_CAN_NOT_BE_FREED { A MSG_VIS_DESTROY was sent to a visual object that has not yet been closed.
 An object must receive a MSG_VIS_CLOSE first (or prehaps a MSG_GEN_SET_NOT-
 _USABLE for generic objects).}
table enter $fatalerr_info_table ui::UI_VIS_OBJECT_IN_TREE_CAN_NOT_BE_FREED { This object has received a MSG_VIS_DESTROY without being removed from the
 visual tree first.  Call MSG_VIS_REMOVE_CHILD on the parent, or for generic
 objects, do a MSG_GEN_SET_NOT_USABLE on the object first.}
table enter $fatalerr_info_table ui::UI_VIS_OBJECT_WITH_CHILDREN_CAN_NOT_BE_FREED { This object has received a MSG_VIS_DESTROY while it still has visual children.
 They must be removed (and probably destroyed) first via a MSG_VIS_REMOVE_-
 CHILD.}
table enter $fatalerr_info_table ui::UI_BAD_VIS_TYPE_FLAGS { Error checking code discovered an illegal combination of VI_typeFlags.
 Objects with VTF_IS_CONTENT or VTF_IS_ROOT must also be VTF_IS_WIN_GROUP;
 Objects with VTF_IS_WIN_GROUP must also be VTF_IS_WINDOW and VTF_IS_COMPOSITE
 and can't be VTF_IS_PORTAL.}
table enter $fatalerr_info_table ui::UI_BAD_VIS_ATTRIBUTES { A bad combination of VI_attrs was found.  Non win-group objects cannot ever
 have VA__VISIBLE set.}
table enter $fatalerr_info_table ui::UI_BAD_VIS_SPEC_ATTRIBUTES { A bad combination of VI_attrs was found.  Non win-group objects cannot have
 SA_USES_DUAL_BUILD or SA_TREE_BUILT_BUT_NOT_REALIZED or SA_REALIZABLE set.}
table enter $fatalerr_info_table ui::UI_VIS_UPDATE_SPEC_BUILD_BUT_VIS_NOT_GROWN { A MSG_SPEC_BUILD_BRANCH has been delivered to an object that doesn't have
 a vis part.  An assumption has been made that this can't happen.}
table enter $fatalerr_info_table ui::UI_STILL_VISIBLE_AFTER_VIS_UNBUILD { An object has been unbuilt, but is still marked as VA_VISIBLE.  This should
 have been cleared as part of MSG_VIS_CLOSE.}
table enter $fatalerr_info_table ui::UI_WIN_GROUP_HAS_NO_VIS_PARENT { The default MSG_VIS_UPDATE_WIN_GROUP assumes that when it's setting a win-
 group object not visible, that it has a visual parent (i.e. is in the visible
 tree).  If it doesn't, something is really wrong.  Likely its a trashed 
 link pointer of some kind.}
table enter $fatalerr_info_table ui::UI_RELEASE_GADGET_EXCL_NO_OBJECT_PASSED { MSG_VIS_RELEASE_GADGET_EXCL requires that an object be passed in ^lcx:dx.}
table enter $fatalerr_info_table ui::UI_VIS_CONTENT_OPEN_WIN_WITH_NO_WIN { When a MSG_VIS_OPEN_WIN is passed to VisContent object, it is assumed that
 the content has already received a window from the view via a MSG_VIS_CONTENT_
 VIEW_WIN_CREATED.  Perhaps something is wrong with the view; more likely,
 an object subclassed the latter message without calling the superclass, which
 is a no-no.}
table enter $fatalerr_info_table ui::UI_VIS_GET_PARENT_GEOMETRY_NO_PARENT { VisGetParentGeometry requires that the object in *ds:si has a visual parent.}
table enter $fatalerr_info_table ui::UI_VIS_GET_PARENT_GEOMETRY_PARENT_NOT_GROWN { VisGetParentGeometry requires that the object's parent have its Vis master 
 class grown.}
table enter $fatalerr_info_table ui::UI_VIS_GET_PARENT_GEOMETRY_PARENT_NOT_COMPOSITE { VisGetParentGeometry requires that the object's parent have VTF_IS_COMPOSITE 
 set. If you get this, then something is really fishy (VI_typeFlags trashed on
 the parent?)}
table enter $fatalerr_info_table ui::UI_NO_WINDOW_TO_CLOSE { A MSG_VIS_WIN_ABOUT_TO_BE_CLOSED was passed to a non-window object (VTF_
 IS_WINDOW was clear.)  Either the update mechanism is screwed up, or some
 instance data was trashed.}
table enter $fatalerr_info_table ui::UI_RATIO_OF_FIELD_WITH_FIELD_SIZE_ZERO { We were trying to get the ratio of the field, but we think the size of the
 field is zero, which is probably quite wrong.   Check for a trashed field
 object or some other object along the way that might have masqueraded as a 
 field object.}
table enter $fatalerr_info_table ui::UI_VIS_ADD_CHILD_REL_NO_GEN_PARENT { The specific UI was trying to add a child to the visible tree based on its
 position in the generic tree.   Alas, for some reason it's not in the generic
 tree (has no gen parent).   The MSG_GEN_SET_USABLE mechanism should have
 caught this flaw earlier, so perhaps its not as obvious as not being in the
 generic tree.}
table enter $fatalerr_info_table ui::UI_VIS_REMOVE_NO_VIS_PARENT { Somehow during in VisRemove utility, the object being removed from the visual
 tree prematurely lost its visible parent.}
table enter $fatalerr_info_table ui::UI_VIS_TEST_MONIKER_BAD_VALUE { VisTestMoniker has internally broken some of its assumptions.  Perhaps there's
 a badly set up VisMoniker involved.}
table enter $fatalerr_info_table ui::VIS_MSG_VIS_VUP_CREATE_GSTATE_NOT_ANSWERED { The above-mentioned method was sent & not responded to.  This should be
 impossible, since there is a VisClass default method handler which always
 returns a response.  Perhaps the method has been subclassed, & the handler
 for the subclass is not setting carry before returning, to indicate a
 response.}
table enter $fatalerr_info_table ui::VIS_CANT_SET_TYPE_FLAGS_WHEN_REALIZED { You must close your visual object before changing its type flags.}
table enter $fatalerr_info_table ui::UI_BAD_GEO_FLAGS { VisGeoAttrs or VisGeoDimensionAttrs flags are passed which are not available.}
table enter $fatalerr_info_table ui::UI_BAD_CHOOSE_OWN_SIZE { If this occurred in the generic world, then you`ve likely set up some
 combination of object attributes that the system can't handle.  Make
 sure sizes and hints of all the objects seem within reasonable limits.  Try
 doing a vistree on the primary or other main windowed object to see what
 object might be getting too large.   For those working with visual objects 
 and  RSA_CHOOSE_OWN_SIZE bit was passed to a composite's MSG_VIS_RECALC_SIZE
 handler, but some kind of suggested size was passed as well, which is illegal.
 This can also occur from a ridiculous size being set for an object.}
table enter $fatalerr_info_table ui::UI_CANT_WRAP_AND_DO_ONE_PASS { This is just a bad idea.  The GA_ONE_PASS_OPTIMIZATION flag should not be
 set in a wrapping composite, or things won't work properly.}
table enter $fatalerr_info_table ui::UI_RESIZE_BAD_CHILD_HANDLE { Shouldn't happen.  A bad handle was passed to the resize routine.}
table enter $fatalerr_info_table ui::UI_GEOMETRY_SUGGESTED_WIDTH_TOO_LARGE { If this occurred in the generic world, then you`ve likely set up some
 combination of object attributes that the system can't handle.  Make
 sure sizes and hints of all the objects seem within reasonable limits.  Try
 doing a vistree on the primary or other main windowed object to see what
 object might be getting too large.   For those working with visual objects:
 a very large suggested value has been calculated for an object's size or
 center.  This is usually from objects growing a little bit on each pass,
 and never stopping.  Historically, this has happened from a HINT_CENTER_
 CHILDREN_ON_MONIKERS.  Try setting VGA_ALWAYS_SEND_CALC_NEW_SIZE on the
 child and all its siblings.  More likely, you've created some recalc size
 handler that keeps returning a larger size than what was passed no matter
 what.}
table enter $fatalerr_info_table ui::UI_GEOMETRY_SUGGESTED_HEIGHT_TOO_LARGE { If this occurred in the generic world, then you`ve likely set up some
 combination of object attributes that the system can't handle.  Make
 sure sizes and hints of all the objects seem within reasonable limits.  Try
 doing a vistree on the primary or other main windowed object to see what
 object might be getting too large.   For those working with visual objects:
 a very large suggested value has been calculated for an object's size or
 center.  This is usually from objects growing a little bit on each pass,
 and never stopping.  Historically, this has happened from a HINT_CENTER_
 CHILDREN_ON_MONIKERS.  Try setting VGA_ALWAYS_SEND_CALC_NEW_SIZE on the
 child and all its siblings.  More likely, you've created some recalc size
 handler that keeps returning a larger size than what was passed no matter
 what.}
table enter $fatalerr_info_table ui::UI_GEOMETRY_WIDTH_TOO_LARGE { If this occurred in the generic world, then you`ve likely set up some
 combination of object attributes that the system can't handle.  Make
 sure sizes and hints of all the objects seem within reasonable limits.  Try
 doing a vistree on the primary or other main windowed object to see what
 object might be getting too large.   For those working with visual objects:
 a very large suggested value has been calculated for an object's size or
 center.  This is usually from objects growing a little bit on each pass,
 and never stopping.  Historically, this has happened from a HINT_CENTER_
 CHILDREN_ON_MONIKERS.  Try setting VGA_ALWAYS_SEND_CALC_NEW_SIZE on the
 child and all its siblings.  More likely, you've created some recalc size
 handler that keeps returning a larger size than what was passed no matter
 what.}
table enter $fatalerr_info_table ui::UI_GEOMETRY_HEIGHT_TOO_LARGE { If this occurred in the generic world, then you`ve likely set up some
 combination of object attributes that the system can't handle.  Make
 sure sizes and hints of all the objects seem within reasonable limits.  Try
 doing a vistree on the primary or other main windowed object to see what
 object might be getting too large.   For those working with visual objects:
 a very large suggested value has been calculated for an object's size or
 center.  This is usually from objects growing a little bit on each pass,
 and never stopping.  Historically, this has happened from a HINT_CENTER_
 CHILDREN_ON_MONIKERS.  Try setting VGA_ALWAYS_SEND_CALC_NEW_SIZE on the
 child and all its siblings.  More likely, you've created some recalc size
 handler that keeps returning a larger size than what was passed no matter
 what.}
table enter $fatalerr_info_table ui::UI_GEOMETRY_SIZE_LEFT_OF_CENTER_TOO_LARGE { If this occurred in the generic world, then you`ve likely set up some
 combination of object attributes that the system can't handle.  Make
 sure sizes and hints of all the objects seem within reasonable limits.  Try
 doing a vistree on the primary or other main windowed object to see what
 object might be getting too large.   For those working with visual objects:
 a very large suggested value has been calculated for an object's size or
 center.  This is usually from objects growing a little bit on each pass,
 and never stopping.  Historically, this has happened from a HINT_CENTER_
 CHILDREN_ON_MONIKERS.  Try setting VGA_ALWAYS_SEND_CALC_NEW_SIZE on the
 child and all its siblings.  More likely, you've created some recalc size
 handler that keeps returning a larger size than what was passed no matter
 what.}
table enter $fatalerr_info_table ui::UI_GEOMETRY_SIZE_RIGHT_OF_CENTER_TOO_LARGE { If this occurred in the generic world, then you`ve likely set up some
 combination of object attributes that the system can't handle.  Make
 sure sizes and hints of all the objects seem within reasonable limits.  Try
 doing a vistree on the primary or other main windowed object to see what
 object might be getting too large.   For those working with visual objects:
 a very large suggested value has been calculated for an object's size or
 center.  This is usually from objects growing a little bit on each pass,
 and never stopping.  Historically, this has happened from a HINT_CENTER_
 CHILDREN_ON_MONIKERS.  Try setting VGA_ALWAYS_SEND_CALC_NEW_SIZE on the
 child and all its siblings.  More likely, you've created some recalc size
 handler that keeps returning a larger size than what was passed no matter
 what.}
table enter $fatalerr_info_table ui::UI_GEOMETRY_SIZE_ABOVE_CENTER_TOO_LARGE { If this occurred in the generic world, then you`ve likely set up some
 combination of object attributes that the system can't handle.  Make
 sure sizes and hints of all the objects seem within reasonable limits.  Try
 doing a vistree on the primary or other main windowed object to see what
 object might be getting too large.   For those working with visual objects:
 a very large suggested value has been calculated for an object's size or
 center.  This is usually from objects growing a little bit on each pass,
 and never stopping.  Historically, this has happened from a HINT_CENTER_
 CHILDREN_ON_MONIKERS.  Try setting VGA_ALWAYS_SEND_CALC_NEW_SIZE on the
 child and all its siblings.  More likely, you've created some recalc size
 handler that keeps returning a larger size than what was passed no matter
 what.}
table enter $fatalerr_info_table ui::UI_GEOMETRY_SIZE_BELOW_CENTER_TOO_LARGE { If this occurred in the generic world, then you`ve likely set up some
 combination of object attributes that the system can't handle.  Make
 sure sizes and hints of all the objects seem within reasonable limits.  Try
 doing a vistree on the primary or other main windowed object to see what
 object might be getting too large.   For those working with visual objects:
 a very large suggested value has been calculated for an object's size or
 center.  This is usually from objects growing a little bit on each pass,
 and never stopping.  Historically, this has happened from a HINT_CENTER_
 CHILDREN_ON_MONIKERS.  Try setting VGA_ALWAYS_SEND_CALC_NEW_SIZE on the
 child and all its siblings.  More likely, you've created some recalc size
 handler that keeps returning a larger size than what was passed no matter
 what.}
table enter $fatalerr_info_table ui::UI_CAN_ONLY_FULL_JUSTIFY_IN_DIRECTION_OF_CHILDREN { Fix the full-justify hint or attribute.  A horizontal full-justify should
 only be set for a horizontal composite; a vertical full-justify only
 for a vertical composite.}
table enter $fatalerr_info_table ui::UI_MUST_BE_VIS_COMP_TO_HAVE_MARGINS { You should only call VisGetBoundsInsideMargins on a composite object.}
table enter $fatalerr_info_table ui::UI_CANT_DO_CUSTOM_RECALC_SIZE_AND_DO_SPECIAL_JUSTIFICATION { The VisComp's default MSG_VIS_POSITION_BRANCH handler (part of the geometry 
 manager) was is being used to try an center, right, or bottom justify 
 children in a composite, without information that is usually generated from 
 the VisComp's default MSG_VIS_RECALC_SIZE handler.   If you are going to
 subclass an object's MSG_VIS_RECALC_SIZE handler to provide custom geometry
 management, you must either subclass the MSG_VIS_POSITION_BRANCH handler
 as well, or stop trying to use center, right or bottom justification.  (If
 none of this applies to you, there must be some memory trashing of the 
 internal ATTR_VIS_GEOMETRY_DATA going on.}
table enter $fatalerr_info_table ui::UI_LARGE_DOCUMENT_FLAG_NOT_SET { MSG_VIS_CONTENT_SET_DOC_BOUNDS was called on a VisContent
 that didn't have its VCNA_LARGE_DOCUMENT_MODEL flag set.  Make sure
 this flag is set before calling this method.}
table enter $fatalerr_info_table ui::UI_POSITION_HINT_FORCES_OBJECT_OUTSIDE_VIS_PARENT_BOUNDS {
 A positioning hint (ATTR_GEN_POSITION, ATTR_GEN_POSITION_X, ATTR_GEN_POSITION_Y,
 HINT_ALIGN_TOP_EDGE_WITH_OBJECT, HINT_ALIGN_BOTTOM_EDGE_WITH_OBJECT,
 HINT_ALIGN_RIGHT_EDGE_WITH_OBJECT, HINT_ALIGN_LEFT_EDGE_WITH_OBJECT)
 has caused the object's bounds to be at least partially outside that of its
 visual parent.  You may need to allocate a fixed size (via HINT_FIXED_SIZE)
 for the parent to make it large enough to hold the object, or it could be
 that the object is being placed by the specific UI under some other composite,
 in which case you probably can't apply a positioning hint to it.}
table enter $fatalerr_info_table ui::UI_VIS_UPDATE_GEOMETRY_FAILED { Error reported if within the MSG_VIS_UPDATE_WIN_GROUP handler, 
 MSG_VIS_UPDATE_GEOMETRY is called, & yet on return, the 
 VOF_GEOMETRY_INVALID bit is still set in the object.}
table enter $fatalerr_info_table ui::UI_BAD_WIN_SIZE_TYPE { The WinSizeType passed to MSG_GEN_SET_WIN_SIZE is not a legal value.}
table enter $fatalerr_info_table ui::UI_BAD_WIN_POSITION_TYPE { The WinPositionType passed to MSG_GEN_SET_WIN_POSITION is not a legal value.}
table enter $fatalerr_info_table ui::UI_BAD_WIN_CONSTRAIN_TYPE { The WinConstrainType passed to MSG_GEN_SET_WIN_CONSTRAIN is not a legal value.}
table enter $fatalerr_info_table ui::VIS_ERROR_PASSIVE_GRAB_CHUNK_MISSING { VisContent's instance data holds references to assorted passive grab 
 chunks.  These chunks are created in MSG_VIS_INITIALIZE_WORKING_VARS,
 which is called from MSG_META_INITIALIZE.  This error results if somehow the
 chunk do not exist when input data is attempted to be sent through them.}
table enter $fatalerr_info_table ui::UI_BAD_MSG_PASSED_TO_TRANSLATE_BUTTON { The utility TranslateButton only handles MSG_META_BUTTON, MSG_META_PRE_PASSIVE_BUTTON,
 and MSG_META_POST_PASSIVE_BUTTON.  There must be some internal problem if this
 is not the case (or ax is trashed).}
table enter $fatalerr_info_table ui::UI_MISSING_HANDLER_FOR_SPEC_GET_SPECIFIC_VIS_OBJECT { SA_SIMPLE_GEN_OBJ cannot be set for an object uses a dual build (SA_USES_
 DUAL_BUILD).}
table enter $fatalerr_info_table ui::UI_SPEC_BUILD_NO_VIS_PARENT { A visible parent cannot be found for this object, for some reason (MSG_SPEC_
 GET_VIS_PARENT didn't return anything).}
table enter $fatalerr_info_table ui::UI_NO_PARENT_WIN_FOUND { In the default MSG_VIS_OPEN handler for an object, a window was not found
 for the object.}
table enter $fatalerr_info_table ui::UI_VIS_PARENT_NOT_BUILT { An object has received a MSG_SPEC_BUILD, but its visual parent has not yet 
 been visually built.  If you have a custom MSG_SPEC_BUILD routine for the
 visual parent, make sure it's doing the right wrong.}
table enter $fatalerr_info_table ui::UI_SPEC_BUILD_NOT_IN_GENERIC_TREE { A MSG_SPEC_BUILD has been sent to an object that is not in the generic tree.}
table enter $fatalerr_info_table ui::UI_BAD_SET_SPEC_ATTR_FLAGS { The arguments passed to MSG_SPEC_SET_ATTRS had some illegal bits set.}
table enter $fatalerr_info_table ui::UI_SPEC_BUILD_BRANCH_DEFAULT_MSG_CANNOT_HANDLE_DUAL_BUILD { You have to specially subclass these messages if your object uses a 
 dual build (has SA_USES_DUAL_BUILD set).}
table enter $fatalerr_info_table ui::UI_VIS_MONIKER_IS_STILL_VIS_MONIKER_LIST { The moniker draw and size routines assume that any moniker lists have been
 converted to a particular moniker by now.  Perhaps a moniker list was passed
 to MSG_GEN_USE_VIS_MONIKER, which is not allowed.}
table enter $fatalerr_info_table ui::UI_BAD_SEARCH_SPEC_IN_VIS_FIND_MONIKER { Bad VisMonikerSearchFlags were passed to VisFindMoniker.}
table enter $fatalerr_info_table ui::UI_BAD_DISPLAY_TYPE_IN_VIS_FIND_MONIKER { A bad DisplayType was passed to VisFindMoniker.}
table enter $fatalerr_info_table ui::UI_EXPECTED_VIS_TYPE_VTF_IS_GEN { A number of specific UI utility routines expect the Vis object passed to
 be generic (VTF_IS_GEN must be set).  These can't be used for non-generic
 objects.  If you expected your object to be generic, check to make sure you're
 not trashing VI_typeFlags.}
table enter $fatalerr_info_table ui::UI_VIS_MASTER_NOT_READY_FOR_UNBUILD { Generic objects are trying to be visually unbuilt (as a result of MSG_GEN_
 SET_NOT_USABLE), but there is something already wrong with the object's
 visual data.  Either its visual master class is not visually grown, 
 it doesn't have a parent link, or it's not a visual composite.}
table enter $fatalerr_info_table ui::UI_GENERIC_WIN_GROUP_MUST_BE_NOT_VISIBLE_BEFORE_REMOVING { A generic object that is being set not realized is still open and visible.
 MSG_VIS_UPDATE_GEN_WIN_GROUP was supposed to have taken care of this.}
table enter $fatalerr_info_table ui::UI_BAD_NAVIGATE_COMMON_FLAGS { Bad NavigateCommonFlags were passed to VisNavigateCommon.}
table enter $fatalerr_info_table ui::UI_NAVIGATION_CIRCUIT_BROKEN { Some object probably didn't handle MSG_SPEC_NAVIGATION_QUERY, or if it did,
 didn't return the carry set.}
table enter $fatalerr_info_table ui::UI_NAVIGATION_QUERY_REACHED_ROOT_NODE_TWICE { It appears that the navigation stuff didn't find anything to navigate to.
 Make sure your vis objects are handling navigation correctly.}
table enter $fatalerr_info_table ui::UI_NAVIGATION_QUERY_ROOT_NODE_MUST_BE_COMPOSITE { Navigation always starts from a composite.  Make sure you're doing the right
 thing or passing the correct flags to VisNavigateCommon.}
table enter $fatalerr_info_table ui::UI_NAVIGATION_QUERY_MUST_TRAVEL_CIRCUIT_TO_BACKTRACK { If NF_BACKTRACK_AFTER_TRAVELING is passed to VisNavigateCommon, it must 
 also have NF_TRAVEL_CIRCUIT set as well.  See the navigation documentation.}
table enter $fatalerr_info_table ui::UI_BAD_NAVIGATION_QUERY_FLAGS { NF_COMPLETED_CIRCUIT cannot be passed to VisNavigateCommon.  See the
 navigation documentation.}
table enter $fatalerr_info_table ui::UI_NAVIGATION_QUERY_REACHED_WIN_GROUP { This shouldn't happen.  Navigation queries are always passed between 
 children of a win group.}
table enter $fatalerr_info_table ui::UI_NAVIGATION_BROADCAST_FOR_ID_FAILED { At the start of VisNavigateCommon, a MSG_SPEC_START_BROADCASE_FOR_NAV_ID was 
 passed to the object's visual parent, to get an ID to find, and parent didn't
 return the carry set.}
table enter $fatalerr_info_table ui::UI_NAVIGATION_NOT_SPEC_NAV_QUERY { VisNavigateCommon was called without ax being set to MSG_SPEC_NAVIGATION_
 QUERY, even though this is certainly being called in response to that 
 message.  Make sure you haven't biffed ax.}
table enter $fatalerr_info_table ui::UI_BAD_FLAGS_IN_HIERARCHICAL_GRAB { An object passed to either FlowGainedExcl or FlowLostExcl had bad 
 HierarchicalGrabFlags.}
table enter $fatalerr_info_table ui::UI_GENERIC_BRANCH_MUST_BE_NOT_USABLE_BEFORE_VISIBLY_UNGROWN { A MSG_SPEC_UNBUILD_BRANCH was sent to a generic object that wasn't already
 fully usable.  Something fishy is going on.}
table enter $fatalerr_info_table ui::UI_BAD_DRAW_MONIKER_FLAGS { Bad DrawMonikerFlags were passed to VisDrawMoniker.}
table enter $fatalerr_info_table ui::UI_NON_MOUSE_EVENT { Error in ConvertToLargeMouseEvent which occurs if the method in AX is
 not a mouse event which can be turned into a LARGE mouse event.}
table enter $fatalerr_info_table ui::UI_MOUSE_GRAB_WINDOW_BEING_DESTROYED { If object has grabbed but not yet release the mouse on a window which
 is being destroyed, this will result.}
table enter $fatalerr_info_table ui::UI_GUP_QUERY_CALLED_ON_NON_GEN_OBJECT { For some reason, a MSG_SPEC_GUP_QUERY_VIS_PARENT was sent to a non-generic
 vis object.  Either the caller doesn't know what it's doing, or instance
 data got trashed.}
table enter $fatalerr_info_table ui::BAD_TRANSFER_FLAGS { Bad ClipboardItemFlags passed to ClipboardRegisterItem, ClipboardQueryItem,
 or ClipboardRequestItemFormat.  Or bad ClipboardItemFlags stored in
 ClipboardItemHeader.  Make sure correct flags are passed.}
table enter $fatalerr_info_table ui::BAD_TRANSFER_FORMAT_COUNT { CIH_formatCount field in ClipboardItemHeader is out of range.  Must be
 between 1 and CLIPBOARD_MAX_FORMATS.}
table enter $fatalerr_info_table ui::NON_UI_TRANSFER_ITEM_EXISTS { A transfer item from a VM file other than the UI's transfer VM file has
 been registered.  This is not supported.}
table enter $fatalerr_info_table ui::UI_CANNOT_CREATE_TRANSFER_FILE { Unable to open or create the UI's transfer VM file (clipboard file).  This
 may indicated a disk problem.}
table enter $fatalerr_info_table ui::TRANSFER_ITEM_IS_ALREADY_ACTIVE { Attempt to register a transfer item (normal or quick) that is already the
 current transfer item.  This is illegal.  If you are registering a new item,
 make sure your create a new item.}
table enter $fatalerr_info_table ui::TRANSFER_ITEM_DONE_NOT_FOUND { Internal error}
table enter $fatalerr_info_table ui::TRANSFER_FREE_LIST_NOT_EMPTY { Attempt to exit the system when ClipboardQueryItems are still active
 (corresponding ClipboardDoneWithItem haven't been called).}
table enter $fatalerr_info_table ui::WRONG_QUICK_NOTIFY_FLAGS_FOR_TRANSFER_DONE { Bad ClipboardQuickNotifyFlags passed to ClipboardEndQuickTransfer.  Only one of CQNF_MOVE,
 CQNF_COPY, and CQNF_NO_OPERATION is allowed.  Pass the correct one, depending
 on the operation that occured.}
table enter $fatalerr_info_table ui::BAD_QUICK_TRANSFER_XOR_REGION { The region to use for quick-tranfser cursor must be in a block that is in
 memory already.  You can ensure this by locking the block before calling
 ClipboardStartQuickTransfer or specifying the block has 'fixed'.}
table enter $fatalerr_info_table ui::BAD_TRANSFER_FILE_CLOSE_NO_MAP { UI's transfer VM file (clipboard file) has been damaged during the current
 session.  It could not be closed successfully.}
table enter $fatalerr_info_table ui::BAD_FLOW_QUICK_TRANSFER_FLAGS { Bad ClipboardQuickTransferFlags passed to ClipboardStartQuickTransfer.  Make sure
 only valid flags are passed.}
table enter $fatalerr_info_table ui::BAD_QUICK_TRANSFER_CURSOR { Bad ClipboardQuickTransferFeedback enum passed to QuickTransferSetCursor.  Make sure
 a valid value is passed.}
table enter $fatalerr_info_table ui::BAD_TRANSFER_HEADER_SIZE { The ClipboardItemHeader of a transfer item is too small.  Make sure the
 correct VM block handle is passed to ClipboardRegisterItem.}
table enter $fatalerr_info_table ui::SHARED_TOKEN_DATABASE_FILE_HAS_BAD_PROTOCOL_NUMBER { The shared token database file on the path specified in the .INI
 file is out of date and must be replaced.
}
table enter $fatalerr_info_table ui::COULD_NOT_OPEN_SHARED_TOKEN_DATABASE_FILE { Either the path for the shared token database is wrongly specified
 in the .INI file (note that the file name should *not* be included
 in the path specification) or VMOpen returned an error, in which
 case the file may be invalid.
}
table enter $fatalerr_info_table ui::COULD_NOT_OPEN_LOCAL_TOKEN_DATABASE_FILE { No local token database file could be opened and no shared token
 database file path appears in the .INI file. If you're running on a
 read-only file-system then you *must* have a shared token database.
}
table enter $fatalerr_info_table ui::NO_TOKEN_DATABASE_FILE_HANDLE { The stored file handle for either the local or the shared token
 database file (whichever one an attempt was made to use) appears
 to be null. Is ds equal to dgroup?
}
table enter $fatalerr_info_table ui::TOKEN_DB_ITEM_IS_NOT_MONIKER_LIST { The database item which has just been locked should contain the
 moniker list for the token presently being defined, but it doesn't.
 Make sure the correct group and item are being passed from
 TokenDefineToken to AddMonikers.
}
table enter $fatalerr_info_table ui::ALLOCATE_TOKEN_DB_ITEM_PASSED_BAD_CHUNK_HANDLE { AllocateTokenDBItem has been passed an invalid chunk handle from
 TokenDefineToken or AddMonikers.
}
table enter $fatalerr_info_table ui::UI_FLOW_RECEIVED_TWO_INK_REPLIES {	The flow object received a MSG_FLOW_INK_REPLY when it was not expecting
	it.}
table enter $fatalerr_info_table ui::UI_INVALID_INK_RETURN_VALUE { 	Some object returned an invalid value to the MSG_META_QUERY_IF_PRESS_IS_INK
	message.
}
table enter $fatalerr_info_table ui::UI_BAD_INK_RETURN_VALUE_PASSED_TO_GEN_APP_INK_QUERY_REPLY {	An object passed a bad InkReturnValue in CX with 
	MSG_GEN_APPLICATION_INK_QUERY_REPLY.
}
table enter $fatalerr_info_table ui::GASP_CHOKE_WHEEZE { This is generated by some of the IACP support code in GenApplication when
 something unexpected happens. Either vardata has been corrupted, or I
 messed up -- ardeb
 }
table enter $fatalerr_info_table ui::INVALID_ADDITIONAL_TOKENS_ATTRIBUTE { The ATTR_GEN_APPLICATION_ADDITIONAL_TOKENS attribute for a GenApplication
 object ends with an incomplete GeodeToken structure.}
table enter $fatalerr_info_table ui::FLOW_MOUSE_GRAB_NOT_RELEASED_BY_DYING_OBJECT { Most common cause:   Destruction of a generic object which is still
 GS_USABLE & attached to the generic tree, or a visible object which
 is still in the visible tree.  This can happen if LMemFree, MSG_META_OBJ_FREE,
 MSG_META_BLOCK_FREE are called on the chunk/object/block
 that the object resides in, while it is still active.  These primitives may
 only be used AFTER the object/block has been properly shutdown, i.e. set
 NOT_USABLE & removed from the generic tree for generic objects, &
 MSG_VIS_REMOVE'd from the visual tree for vis objects.   Note that if the 
 intent is to destroy only individual objects or branches, & not an entire
 block, MSG_GEN_DESTROY & MSG_VIS_DESTROY do the job quite nicely, performing
 the pre-requisite shutdown procedures, and then nuking the objects.}
table enter $fatalerr_info_table ui::FLOW_KBD_GRAB_NOT_RELEASED_BY_DYING_OBJECT { Most common cause:   Destruction of a generic object which is still
 GS_USABLE & attached to the generic tree, or a visible object which
 is still in the visible tree.  This can happen if LMemFree, MSG_META_OBJ_FREE,
 MSG_META_BLOCK_FREE are called on the chunk/object/block
 that the object resides in, while it is still active.  These primitives may
 only be used AFTER the object/block has been properly shutdown, i.e. set
 NOT_USABLE & removed from the generic tree for generic objects, &
 MSG_VIS_REMOVE'd from the visual tree for vis objects.   Note that if the 
 intent is to destroy only individual objects or branches, & not an entire
 block, MSG_GEN_DESTROY & MSG_VIS_DESTROY do the job quite nicely, performing
 the pre-requisite shutdown procedures, and then nuking the objects.}
table enter $fatalerr_info_table ui::UI_FLOW_INK_HOLD_UP_INPUT_FAILED { The flow object tried to hold up input while waiting to see if the button 
 press should be ink or not, but it couldn't for some reason.}
table enter $fatalerr_info_table ui::UI_FLOW_RECEIVED_UNEXPECTED_INK { The flow object received ink when it wasn't expecting one (had not
 told the IM that it wanted Ink)}
table enter $fatalerr_info_table ui::UI_FLOW_GRAB_WITHIN_LEVEL_ILLEGAL_FLAGS { FlowGrabWithinLevel has received bad flags in bp.}
table enter $fatalerr_info_table ui::FLOW_HIERARCHICAL_GRAB_ERROR_CAN_NOT_GRAB_FROM_SELF { This happens when FlowGrabWithinLevel, or MSG_VUP_GRAB_* is handled by the
 same object as the optr which is passed requesting the grab.  This isn't 
 allowed, for infinite loops would result on MSG_META_GAINED_* coming into a node
 which has grabbed itself.}
table enter $fatalerr_info_table ui::FLOW_ERROR_HIERARCHICAL_NODE_ALREADY_HAS_APP_EXCL { This happens if FlowGainedAppExcl is called on a hierarchical grab node that
 already has the app exclusive, i.e. HGF_APP_EXCL is true.   Check to make
 sure that you haven't intercepted the LOST_APP_XXX_EXCL and forgotten to
 pass it onto the superclass (at the end of the method handler).}
table enter $fatalerr_info_table ui::FLOW_ERROR_HIERARCHICAL_NODE_DOES_NOT_HAVE_APP_EXCL { This happens if FlowLostAppExcl or FlowGainedSysExcl is called on a
 hierarchical grab node that does not have the app exclusive, i.e.
 HGF_APP_EXCL is false.  Check to see make sure you haven't intercepted the
 GAINED_APP_XXX_EXCL message & not called the superclass with it (at the
 start of the method handler).}
table enter $fatalerr_info_table ui::FLOW_ERROR_HIERARCHICAL_NODE_ALREADY_HAS_SYS_EXCL { Happens if FlowGainedSysExcl called on hierarchical grab node that already
 has the system-wide exclusive, i.e. the HGF_SYS_EXCL bit is set.  Check
 to make sure you haven't intercepted the LOST_SYS_XXX_EXCL and forgotten to
 call the superclass (at the end of the method handler).}
table enter $fatalerr_info_table ui::FLOW_ERROR_HIERARCHICAL_NODE_DOES_NOT_HAVE_SYS_EXCL { Happens if FlowLostSysExcl called on hierarchical grab node that does not
 have the system-wide exclusive, i.e. the HGF_SYS_EXCL bit is clear.  Check
 to make sure you haven't intercepted the GAINED_SYS_XXX_EXCL and forgotten
 to call the superclass (at the start of the method handler).}
table enter $fatalerr_info_table ui::FLOW_ERROR_BAD_MASTER_OFFSET { This happens if a master offset is passed which is to large to be valid.}
table enter $fatalerr_info_table ui::FLOW_ERROR_BAD_INSTANCE_OFFSET { This happens if an offset within a master instance level is passed which
 is too large to be valid (the comparison is made against MAX_INSTANCE_OFFSET)}
table enter $fatalerr_info_table ui::UI_ILLEGAL_MOUSE_RETURN_FLAGS { All handlers of mouse events are responsible for returning valid
 MouseReturnFlags in AX.  Failure to do so will result in this death,
 immediately upon return to the VisContentClass object which has called the
 active/implied mouse grab to process the current mouse event.  ^lbx:si will
 either be pointing to the active mouse grab, or if there is no active
 grab, then to the VisContent above the implied mouse grab.
 NOTE:  If you have no particular directives for the input system after
 having processed a mouse event, just return AX = 0.
}
table enter $fatalerr_info_table ui::FLOW_BAD_MESSAGE_COMBO_PASSED_TO_FlowUpdateHierarchicalGrab { Just what it says -- either the base message, or the operation message, or
 both, are bad, based on the simple test of operation message - base message
 not falling into a valid range.}
table enter $fatalerr_info_table ui::FLOW_BAD_FLAGS_PASSED_TO_FlowAlterHierarchicalGrab { This is the result of passing HGF_SYSTEM to FlowAlterHierarchicalGrab, which
 isn't allowed.}
table enter $fatalerr_info_table ui::UI_BAD_GEN_VIEW_INK_TYPE { The GVI_inkType field had an invalid value}
table enter $fatalerr_info_table ui::UI_VIEW_NEG_HEIGHT_PASSED_TO_SET_SIMPLE_BOUNDS { You can't use the simpler GenViewSetSimpleBounds if you're going to have
 negative bounds.}
table enter $fatalerr_info_table ui::UI_VIEW_BAD_MESSAGE_FLAGS_PASSED_TO_SET_SIMPLE_BOUNDS { The only flags that can be passed to GenViewSetSimpleBounds in di are
 MF_FIXUP_DS and MF_FIXUP_ES.  If you're hoping to record the message, or
 use the message flags some other way, use the full-featured MSG_GEN_VIEW_-
 SET_DOC_BOUNDS.}
table enter $fatalerr_info_table ui::UI_VIEW_BAD_DOC_BOUNDS { Something`s wrong with the bounds you passed to MSG_GEN_VIEW_SET_DOC_BOUNDS.
 Likely the width or height of the content is negative, which is bad.}
table enter $fatalerr_info_table ui::UI_VIEW_BAD_INCREMENT { The increment is negative, which is not allowed.}
table enter $fatalerr_info_table ui::UI_VIEW_LINKAGE_MUST_BE_CIRCULAR { Either the horizontal or the vertical linkage is not continuous.  The
 vertical or horizontal linkage, if there is any, must be continuous and
 pass through each view exactly once, and be circular (i.e. last node
 is linked to the first).}
table enter $fatalerr_info_table ui::UI_CX_DX_MUST_BE_VALID_VIEW_OBJECT { A view object hasn't been passed to MSG_META_CONTENT_VIEW_OPENING.  Something
 internal is probably wrong.}
table enter $fatalerr_info_table ui::UI_VIS_CONTENT_NEEDS_TO_HANDLE_TRACK_SCROLLING_BETTER { The content didn't have a target object or even a visible child to send the
 MSG_META_CONTENT_TRACK_SCROLLING to.  This message must be answered.  Either
 add a child who can respond to the message, subclass the VisContent handler
 to do it yourself, or turn off track scrolling in the view.}
table enter $fatalerr_info_table ui::UI_VIS_CONTENT_MUST_BE_OWNED_BY_AN_APPLICATION { When a MSG_META_QUERY_IF_PRESS_IS_INK is received by a VisContent, it needs to
 be able to send a reply to an associated GenApplication object, which it
 can only do if it is owned by an application (not the UI).}
table enter $fatalerr_info_table ui::UI_VIS_CONTENT_CAN_NOT_GRAB_OR_RELEASE_THIS_EXCL { Occurs if MSG_VIS_VUP_ALTER_INPUT_FLOW is called on VisContent w/
 VIFGF_NOT_HERE flag set, which can happen if the VisContent attempts
 to grab the active mouse or keyboard exclusive.  Since the VisContent 
 & GenView are effectively one single node in the input flow hierarchy, it
 is illegal for the VisContent to attempt to grab exclusives from the
 GenView, for they do not exists.}
table enter $fatalerr_info_table ui::UI_REALIZED_VIS_OBJECT_HAD_NO_WINDOW { Occurs if VisCallChildrenInBounds tried to get the gwin of a realized
 windowed VisComp object, and VisQueryWindow returned 0.
}
table enter $fatalerr_info_table ui::UI_WINDOWED_VIS_OBJECT_HAD_SAME_WINDOW_AS_PARENT { Occurs if an object with VTF_IS_WINDOW/PORTAL had the same VCI_gwin as its
 parent.	}
table enter $fatalerr_info_table ui::GEN_FILE_SELECTOR_BAD_ATTRS { Occurs if bad FileSelectorAttrs are passed to MSG_GEN_FILE_SELECTOR_SET_ATTRS.
 Make sure only valid flags are set.}
table enter $fatalerr_info_table ui::GEN_FILE_SELECTOR_BAD_FILE_TYPES { Occurs if bad FileSelectorFileTypes are passed to
 MSG_GEN_FILE_SELECTOR_SET_FILE_TYPES.  Make sure only valid flags are set.}
table enter $fatalerr_info_table ui::GEN_FILE_SELECTOR_BAD_FILE_CRITERIA { Occurs if bad FileSelectorFileCriteria are passed to
 MSG_GEN_FILE_SELECTOR_SET_FILE_CRITERIA.  Make sure only valid flags are set.}
table enter $fatalerr_info_table ui::GEN_FILE_SELECTOR_BAD_DOS_ATTRS { Occurs if bad FileAttrs are passed to MSG_GEN_FILE_SELECTOR_SET_DOS_ATTRS.
 Make sure only valid flags are set.}
table enter $fatalerr_info_table ui::GEN_FILE_SELECTOR_BAD_GEODE_ATTRS { Occurs if bad GeodeAttrs are passed to MSG_GEN_FILE_SELECTOR_SET_GEODE_ATTRS
 for either the match attrs or the mismatch attrs.  Make sure only valid flags
 are set.}
table enter $fatalerr_info_table ui::GEN_FILE_SELECTOR_TEMP_DATA_NOT_FOUND { Occurs whenever the GFSTempDataEntry variable data for a GenFileSelector
 is not found when it is expected to exists.  Most likely, the memory space
 for the object has been trashed.}
table enter $fatalerr_info_table ui::GEN_CONTROL_INTERNAL_ERROR { Error within GenControl logic, presumably caused by the UI not behaving
 as advertised.}
table enter $fatalerr_info_table ui::GEN_APP_GCN_INTERNAL_ERROR { Error within GenApplication GCN optimization mechanism -- something happened
 to the GCN lists which isn't supposed to be able to happen.}
table enter $fatalerr_info_table ui::ROUTINE_REQUIRES_GEN_CONTROL_OBJECT_AS_INPUT { GenControlOutputActionRegs/Stack or GenControlSendToOutputRegs/Stack was
 not passed a valid GenControlObject as the input	}
table enter $fatalerr_info_table ui::GEN_CONTROL_MUST_BE_ON_ACTIVE_LIST { The GenControl object must be placed on the active list.  You can do this in
 your .ui/.goc file with gcnList(MANUFACTURER_ID_GEOWORKS,MGCNLT_ACTIVE_LIST)
 or dynamically with MSG_META_GCN_LIST_ADD sent to the appropriate
 GenApplication object.}
table enter $fatalerr_info_table ui::GEN_CONTROL_CANNOT_SET_ALWAYS_INTERACTABLE_IF_NOT_ON_ACTIVE_LIST { This GenControl class has GCBF_ALWAYS_INTERACTABLE set but not
 GCBF_IS_ON_ACTIVE_LIST}
table enter $fatalerr_info_table ui::GEN_CONTROL_CANNOT_SET_ALWAYS_ON_GCN_LIST_IF_NOT_ON_ACTIVE_LIST { This GenControl class has GCBF_ALWAYS_ON_GCN_LIST set but not
 GCBF_IS_ON_ACTIVE_LIST}
table enter $fatalerr_info_table ui::GEN_CONTROL_MUST_BE_ON_SELF_LOAD_OPTIONS_LIST { The GenControl object must be placed on the self-load options list.  You can
 do this in your .ui/.goc file with
 gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_SELF_LOAD_OPTIONS) or dynamically
 with MSG_META_GCN_LIST_ADD sent to the appropriate GenApplication object.}
table enter $fatalerr_info_table ui::GEN_CONTROL_MUST_BE_ON_STARTUP_LOAD_OPTIONS_LIST { The GenControl object must be placed on the startup options list.  You can
 do this in your .ui/.goc file with
 gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_STARTUP_LOAD_OPTIONS) or dynamically
 with MSG_META_GCN_LIST_ADD sent to the appropriate GenApplication object.}
table enter $fatalerr_info_table ui::GEN_CONTROL_NO_DUP_BLOCKS { A GenControl object had neither normal UI nor toolbox UI to duplicate.
 The help mechanism uses these to get the library a controller is defined in,
 and both are NULL, something is probably wrong.}
table enter $fatalerr_info_table ui::TEMP_INSTANCE_IS_MARKED_SAVE_TO_STATE { A GenControl object has some TEMP vardata marked SAVE_TO_STATE, which is
 bad.
}
table enter $fatalerr_info_table ui::GEN_CONTROL_HELP_CONTEXT_TOO_LONG { The help context for the controller is too long.  This probably means that
 the string is not null-terminated.  The maximum length is 30}
table enter $fatalerr_info_table ui::GEN_CONTROL_DIDNT_BUILD_TO_VIS_COMP { A GenControl object is being detached and wishes to quickly sever the
 visible link between itself and its presumed children, but cannot do so
 as it finds it is not a subclass of VisComp. This is a Bad Thing, as it means
 the controller can't actually have any visual children. Since I can't think
 where the controller's children might actually go otherwise, I hereby declare
 it illegal.}
table enter $fatalerr_info_table ui::GEN_PATH_DISK_HANDLE_NOT_SAVED { Need to restore a disk handle saved by the GenPath code, but the vardata entry
 that holds the information doesn't exist. Either the application, the kernel
 or fate has nuked it, as it's supposed to be there...}
table enter $fatalerr_info_table ui::GEN_PATH_PATH_TO_SET_MAY_NOT_BE_IN_SAME_BLOCK_AS_OBJECT { Because the act of setting the path bound to an object may cause the chunks
 in the object's block (owing to the creation of a new vardata entry for
 the object), the path being set may not be in the same block as the object
 (because it would also likely move and GenPathSetObjectPath has no way of
 tracking it).}
table enter $fatalerr_info_table ui::GEN_PATH_CANT_UNRELOCATE_DISK_HANDLE { For an object with GenPath info, if the path has never been set with
 MSG_GEN_PATH_SET, the disk handle can only be relocated if there is
 accompanying disk handle vardata or if the disk handle is a standard path.}
table enter $fatalerr_info_table ui::GEN_PATH_UNHANDLED_DISK_RESTORE_ERROR { DiskRestore (or the callback for it) returned an error code for which we
 have no message to display.
 }
table enter $fatalerr_info_table ui::UI_GEN_DISPLAY_GROUP_BAD_ATTRS { Bad GenDisplayGroupAttrs passed to MSG_GEN_DISPLAY_GROUP_SET_ATTRS.}
table enter $fatalerr_info_table ui::UI_GEN_DISPLAY_BAD_ATTRS { Bad GenDisplayAttrs passed to MSG_GEN_DISPLAY_SET_ATTRS.}
table enter $fatalerr_info_table ui::GEN_ITEM_GROUP_SELECTION_MARKED_INCORRECTLY_FOR_ZERO_SELECTIONS { If GIGI_numSelections is zero, GIGI_selection must be set to GIGS_NONE_-
 SELECTED.  Likely this error was caused by incorrect setup of these variables
 in the .ui or .goc definition of the object.  Less likely, but possible,  is 
 there is an internal error in the GenItemGroup code that is causing this to
 happen.}
table enter $fatalerr_info_table ui::GEN_ITEM_GROUP_INCORRECT_SIZE_FOR_SELECTION_CHUNK { Apparently GIGI_numSelections is set to some value greater than one, which
 implies that GIGI_selections should be a chunk handle of a chunk of words
 describing the selections.  The size of this chunk does not correspond to
 the value in GIGI_numSelections.  Most likely, an error was made in setting
 up the .ui or .goc definition for a GenItemGroup.  Less likely, but possible,
 is there is an internal error in the GenItemGroup code that is causing this to
 happen.
}
table enter $fatalerr_info_table ui::GEN_DYNAMIC_LIST_SAME_ITEM_TWICE_IN_REMOVAL_LIST { When calling MSG_GEN_DYNAMIC_LIST_REMOVE_ITEM_LIST, the same item should not 
 be passed twice in the list of items to remove.
}
table enter $fatalerr_info_table ui::UNDO_START_COUNT_OVERFLOW { MSG_GEN_PROCESS_START_UNDO_CHAIN was sent to the process 65536 times.
}
table enter $fatalerr_info_table ui::UNDO_START_COUNT_UNDERFLOW { MSG_GEN_PROCESS_END_UNDO_CHAIN was sent to the process more times than
 MSG_GEN_PROCESS_START_UNDO_CHAIN
}
table enter $fatalerr_info_table ui::MUST_SET_CONTEXT_BEFORE_SENDING_UNDO_MESSAGES { No undo context was set when an UNDO message was sent.
}
table enter $fatalerr_info_table ui::BAD_START_OF_CHAIN_TOKEN { The start of the undo chain was invalid
}
table enter $fatalerr_info_table ui::ADD_ACTION_SENT_BEFORE_START_UNDO { A MSG_GEN_PROCESS_ADD_UNDO_ACTION was received when there was no active
 undo chain.}
table enter $fatalerr_info_table ui::BAD_UNDO_ACTION_DATA_TYPE { An invalid UndoActionDataType was passed to GenProcessAddUndoAction.
}
table enter $fatalerr_info_table ui::FLUSH_SENT_BEFORE_END_OF_UNDO_CHAIN { A MSG_GEN_PROCESS_FLUSH_UNDO_ACTIONS was sent before the current Undo
 chain was terminated.	
}
table enter $fatalerr_info_table ui::UNDO_CONTEXT_SWITCHED_BEFORE_END_OF_UNDO_CHAIN { A MSG_GEN_PROCESS_SET_UNDO_CONTEXT was sent before the current undo chain
 was terminated.
}
table enter $fatalerr_info_table ui::UNDO_CHAIN_PLAYED_BACK_BEFORE_ENDED { A MSG_GEN_PROCESS_PLAYBACK_UNDO_CHAIN was sent before the current undo chain
 was terminated.
}
table enter $fatalerr_info_table ui::UNDO_START_COUNT_NON_ZERO_WHEN_PROCESS_EXITED { The process exited with more calls to MSG_GEN_PROCESS_START_UNDO_CHAIN
 than END_UNDO_CHAIN.	
}
table enter $fatalerr_info_table ui::UNDO_IGNORE_COUNT_NON_ZERO_WHEN_PROCESS_EXITED { The process exited with more calls to MSG_GEN_PROCESS_IGNORE_ACTIONS
 than ACCEPT_ACTIONS
}
table enter $fatalerr_info_table ui::NO_UNDO_CHAIN { A MSG_GEN_PROCESS_PLAYBACK_UNDO_CHAIN was sent when there was no current
 undo chain.
}
table enter $fatalerr_info_table ui::BAD_ADD_UNDO_ACTION_FLAGS { A bad AddUndoActionFlags was passed with MSG_GEN_PROCESS_ADD_UNDO_CHAIN
}
table enter $fatalerr_info_table ui::CANNOT_PLAYBACK_WHILE_IGNORING { Received a MSG_GEN_PROCESS_UNDO_PLAYBACK_CHAIN while ignore was active.}
table enter $fatalerr_info_table ui::IGNORE_COUNT_UNDERFLOW { Received more MSG_GEN_PROCESS_UNDO_ACCEPT_ACTIONS messages than
 IGNORE_ACTIONS.}
table enter $fatalerr_info_table ui::IGNORE_COUNT_OVERFLOW { Received too many MSG_GEN_PROCESS_UNDO_IGNORE_ACTIONS messages.}
table enter $fatalerr_info_table ui::UI_TRIED_TO_GET_WINDOW_SIZE_WITHOUT_VIS_PARENT { A windowed object apparently was trying to calculate a size or position
 for itself that was some ratio of its parent window or the field, but the
 window didn't have a visible parent, which causes problems in the routine.
 See Chris or Doug and whine.}
table enter $fatalerr_info_table ui::UNDO_OBJECT_MUST_BE_RUN_BY_PROCESS_THREAD { An object associated with an undo action/chain must be run by the process
 thread to ensure synchronicity.	}
table enter $fatalerr_info_table ui::VIS_CHAR_TABLE_LINE_OPTR_IS_NULL { The instance data of the VisCharTableObj is null}
table enter $fatalerr_info_table ui::TOO_MANY_UNDO_ACTIONS { Too many undo actions were added to the undo chain.}
table enter $fatalerr_info_table ui::NON_ZERO_TITLE_PASSED_WITH_UD_NOT_UNDOABLE { This error occurs if UD_NOT_UNDOABLE is sent to the edit controller with
 GWNT_UNDO_STATE_CHANGE, and a non-zero title is passed}
table enter $fatalerr_info_table ui::BAD_SELECTION_TYPE { An invalid SelectionType enumerated type was passed with a
 NotifySelectionStateChange structure.}
table enter $fatalerr_info_table ui::KBD_INDEX_TO_KBDLAYOUT_TBL_OUT_OF_BOUNDS { An index to the KeyboardLayout table was out of bounds.}
table enter $fatalerr_info_table ui::ILLEGAL_KBD_CHARACTER_VALUE { An illegal keyboard character value was found.}
table enter $fatalerr_info_table ui::ILLEGAL_CHAR_TABLE_COORDINATE { An illegal coordinate in the Character Table is found}
table enter $fatalerr_info_table ui::TOO_MANY_REGISTERED_OBJECTS { 65536 objects called VisTextRegisterForContext without unregistering (let's
 face it, what this really means is that somebody trashed the count).}
table enter $fatalerr_info_table ui::OBJECT_NEVER_REGISTERED { An object called VisTextUnregisterForContext without calling
 VisTextRegisterForContext.}
table enter $fatalerr_info_table ui::IACP_INVALID_SERVER_NUMBER { Caller passed a number to IACPSendMessageToServer that is greater than
 the number of servers returned by IACPConnect.}
table enter $fatalerr_info_table ui::HELP_FILE_HAS_NO_MAP_BLOCK { The help file specified has no map block (which is where all the cool
 and very necessary stuff like the names are kept).}
table enter $fatalerr_info_table ui::HELP_HISTORY_BUFFER_NOT_EMPTY { The buffer the history information is stored in was not empty on startup.}
table enter $fatalerr_info_table ui::HELP_HISTORY_ILLEGAL_NUMBER { An invalid history number was passed to a history routine.}
table enter $fatalerr_info_table ui::HELP_NAME_TOO_LONG { A name larger than MAX_CONTEXT_NAME_SIZE or FILE_LONGNAME_LENGTH was passed.}
table enter $fatalerr_info_table ui::HELP_NO_HISTORY { No history was saved for the help object, but it was a point where it needed
 at least one item of saved history.  Basically, whenever there is help
 text displayed there should be at least one item of history -- the current.}
table enter $fatalerr_info_table ui::HELP_NO_FILENAME_FOUND { No filename was found by calling up the generic tree from a help trigger.
 Either a ATTR_GEN_HELP_FILE must be specified in the tree, or the help
 trigger must be part of a controller (in which case the name of the geode
 defining the controller class is used).}
table enter $fatalerr_info_table ui::HELP_NO_HELP_TYPE_FOUND { No type for help was defined in the generic tree.  Depending on which type
 of help you want a trigger to bring up, somewhere above it in the generic
 tree should be a ATTR_GEN_HELP_TYPE specifying a HelpType.}
table enter $fatalerr_info_table ui::HELP_FOCUS_HELP_NOT_SUPPORTED { Focus help is not yet supported.  It was once, and shall rise from the
 ashes into a new, more streamlined and glorious beast.  Sigh...}
table enter $fatalerr_info_table ui::HELP_RECORDED_HELP_MISSING { The user attempted to go to an item in the history list (meaning they
 had already been there so we know it existed at some point), but the
 text/context/file is now missing.}
table enter $fatalerr_info_table ui::HELP_CANNOT_HAVE_HISTORY_FOR_FIRST_AID_HELP { You cannot have a history list (HPCF_HISTORY) for First Aid help.}
table enter $fatalerr_info_table ui::HELP_FIRST_AID_MODE_NOT_FOUND { The help object was unable to figure out what mode First Aid help was in.}
table enter $fatalerr_info_table ui::HELP_CONTROL_MUST_HAVE_TEXT { If you set custom features on a HelpControl object, you must include HPCF_TEXT}
table enter $fatalerr_info_table ui::HELP_FILE_IS_NOT_A_HELP_FILE { A file that was to be opened in the help directory was not a valid help file.}
table enter $fatalerr_info_table ui::HELP_LINK_TO_NO_WHERE { The user clicked on a link in help that didn't go anywhere.  The cause for
 this is a name is missing -- it was most likely deleted.}
table enter $fatalerr_info_table ui::BAD_GEODE_LOAD_ERROR {
	A bad GeodeLoadError was passed
}
table enter $fatalerr_info_table ui::EXPRESS_MENU_CONTROL_BAD_ASSUMPTION { Bad assumption made in Express Menu Control code.  Notify the authorities.}
table enter $fatalerr_info_table ui::EXPRESS_MENU_CONTROL_ILLEGAL_CREATE_ITEM_FEATURE { An illegal feature was requested for MSG_EXPRESS_MENU_CONTROL_CREATE_ITEM.
 Use one of the CreateExpressMenuControlItemFeatures.}
table enter $fatalerr_info_table ui::INVALID_MONIKER { GrDrawGStringAtCP died trying to draw the moniker for an object.}
table enter $fatalerr_info_table ui::BAD_TOOL_GROUP_BOUNDS { A ToolGroup had invalid bounds, even though it had Gen children.}
table enter $fatalerr_info_table ui::BAD_HIGHLIGHT_TYPE { An invalid ToolGroupHighlightType was encountered}
table enter $fatalerr_info_table ui::TOOL_NOT_FOUND { The tool was not a child of the toolbar that the tool control thought it was.}
table enter $fatalerr_info_table ui::TOOL_FOUND_TWICE { Someone trashed a register while trying to move a tool around within a
 toolbar}
table enter $fatalerr_info_table ui::DOING_PLAYBACK_BUT_NOT_IN_MIDDLE_OF_CHAIN {
 A MSG_GEN_PROCESS_UNDO_ABORT_CHAIN was sent with ds:[ULMBH_currentChain] set
 to non-zero (indicating that we are playing back an undo chain), but
 ds:[ULMBH_startCount] (indicating that we are creating a redo chain) is not
 set.
}
table enter $fatalerr_info_table ui::UNDO_CHAIN_LEFT_OPEN {
 The current Undo chain was not ended - it is illegal for any messages to get
 through to the process before the undo chain has ended, and
 MSG_GEN_PROCESS_DO_UNDO_EC got through.	
}
table enter $fatalerr_info_table ui::IGNORE_COUNT_IS_NON_ZERO_AT_END_OF_PLAYBACK {
 The ignore count was non-zero at the end of playing back an undo chain. This
 just isn't allowed (someone turn on ignore in the middle of the playback,
 and didn't turn it off).
}
table enter $fatalerr_info_table ui::UI_LOADER_PASSED_BAD_DEFAULT_SIMPLE_GRAPHICS_MODE { The loader, in its attempt to determine which one of the simple graphics
 modes is a good fallback, passed an illegal SysSimpleGraphicsMode to
 the kernel.}
table enter $fatalerr_info_table ui::GVA_GENERIC_CONTENTS_MUST_BE_RUN_BY_SAME_THREAD {
 When using GVA_GENERIC_CONTENTS with a GenView, the GVI_contents object
 must be run by the same thread as the GenView.
}
table enter $fatalerr_info_table ui::NET_ROUTINE_TRASHED_BPDI {
 One of the routines in the net library trashed BP or DI.
}
table enter $fatalerr_info_table ui::CANNOT_BRING_UP_KEYBOARD_WITHOUT_FLOATING_KEYBOARD_INFO {
 BringUpKeyboard was called when the floating keyboard information had not
 been setup.
}
table enter $fatalerr_info_table ui::FLOATING_KEYBOARD_MUST_BE_SUBCLASS_OF_GEN_INTERACTION {
 The object specified in ATTR_GEN_APPLICATION_KBD_OBJ must be a subclass
 of GenInteraction.
}
table enter $fatalerr_info_table ui::CANNOT_CLOSE_PORT {
 Error given when we cannot close the socket/port that we just opened in
 ClipboardRemoteSend/Receive
}
table enter $fatalerr_info_table ui::UI_MALFORMED_PATH {
 Bad path passed to MSG_GEN_PATH_SET.}
table enter $fatalerr_info_table ui::CLIPBOARD_SEND_SOCKET_RECEIVED_DATA {
 We were doing a clipboard send, and we received data over the
 socket...	
}
table enter $fatalerr_info_table ui::UI_ERROR_SECOND_REAL_DETACH { This error occurs if the UI is about to send a second
 MSG_GEN_PROCESS_REAL_DETACH to the process in any one detach cycle}
table enter $fatalerr_info_table ui::UI_MESSAGE_ARRIVING_AFTER_SAVED_TO_STATE { "Build" handlers spits out this warning if the application has no generic
 parent & the object tree has been shrunk down to not include specific
 versions of the objects.  This is usually the result of a message arriving
 at the application in the final states of detaching, after it is legal
 to message objects in the application.}
table enter $fatalerr_info_table ui::NOT_A_DISCARDABLE_OBJECT { MSG_GEN_INTERACTION_DISABLE_DISCARDING was sent to an object that did
 not have HINT_INTERACTION_DISCARD_WHEN_CLOSED on it.}
table enter $fatalerr_info_table ui::ALL_CHILDREN_OF_DISCARDABLE_DIALOG_MUST_BE_IN_THE_SAME_RESOURCE { If a dialog is marked discardable (has HINT_INTERACTION_DISCARD_WHEN_CLOSED)
 all of its generic children must be in the block in which it resides
}
table enter $fatalerr_info_table ui::UI_VALUE_REMOVING_MORE_ITEMS_THAN_EXIST { The number of items to remove passed to MSG_GEN_DYNAMIC_LIST_REMOVE_ITEMS
 exceeded the number of items in the list (GDLI_numItems).
}
table enter $fatalerr_info_table ui::EMOM_COULD_NOT_FIND_MATCHING_CLASS { could not find the entry in the EMOMI_classes array that had a
 responseData field which matched the response data of the object created.}
table enter $fatalerr_info_table ui::EMOM_SLOT_ALREADY_FILLED { in the array of objects kept for each express menu, there were two
 objects that mapped to the same array entry.  This is probably
 caused because the EMOMI_classes did not contain unique
 CEMCIP_responseData for each object.}
table enter $fatalerr_info_table ui::NOT_DGROUP { A segment register was not passed as dgroup to a routine that expected it}
table enter $fatalerr_info_table ui::INVALID_TOKEN_DB_FLAG { An invalid local/shared token DB flag was passed to TokenLockTokenMoniker}
table enter $fatalerr_info_table ui::INTERACTION_CANNOT_BE_MODAL_AND_SYS_MODAL { You cannot have both the GIA_MODAL and GIA_SYS_MODAL attributes set on
 an interaction.}
table enter $fatalerr_info_table ui::GEN_DYNAMIC_LIST_NUM_VISIBLE_ITEMS_CHANGED_BAD_ARGUMENT { Items were being added to the dynamic list in
 GenDynamicListNumVisibleItemsChanged and there was not a valid value
 in dx to indicate whether or not to validate those new items}
table enter $fatalerr_info_table ui::IACP_FILENAME_AND_PATHNAME_MUST_RESIDE_IN_SAME_SEGMENT { Two of the arguments passed to this routine, the filename and the pathname,
 are presumed to reside in the same segment; The filename and pathname
 passed in this time were from different segments, which would lead to 
 confusion a short while down the road.}
table enter $fatalerr_info_table ui::INVALID_FOAM_HELP_CONTROL_CLASS { Some hoser rearranged the entry points in the foam library, so you need
 to do a "pmake lib" on the foam library, and remake and redownload the UI.
 If *you* are the hoser, then go back into foam.gp, and un-rearrange the
 entry points (you should always add new classes at the end).}
table enter $fatalerr_info_table ui::VP_NOT_LOADED { How can that be?}
