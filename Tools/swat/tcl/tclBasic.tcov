           /* 
            * tclBasic.c --
            *
            *	Contains the basic facilities for TCL command interpretation,
            *	including interpreter creation and deletion, command creation
            *	and deletion, and command parsing and execution.
            *
            * Copyright 1987 Regents of the University of California
            * Permission to use, copy, modify, and distribute this
            * software and its documentation for any purpose and without
            * fee is hereby granted, provided that the above copyright
            * notice appear in all copies.  The University of California
            * makes no representations about the suitability of this
            * software for any purpose.  It is provided "as is" without
            * express or implied warranty.
            */
           
           #ifndef lint
           static char *rcsid = "$Id: tclBasic.c,v 1.60 92/07/09 21:55:26 adam Exp $ SPRITE (Berkeley)";
           #endif not lint
           
           #include <stdio.h>
           #include <ctype.h>
           #include <malloc.h>
           #include <string.h>
           #include "tclInt.h"
           
           /*
            * Flags for stack frames
            */
           #define TCL_FRAME_FREE_ARGS 	1
           #define TCL_FRAME_FREE_ARGV 	2
           #define TCL_FRAME_FREE_SEPARGS	4
           
           /*
            * Built-in commands, and the procedures associated with them:
            */
           
           static const Tcl_CommandRec *const builtInCmds[] = {
               &Tcl_BreakCmdRec,
               &Tcl_CaseCmdRec,
               &Tcl_CatchCmdRec,
               &Tcl_ConcatCmdRec,
               &Tcl_ContinueCmdRec,
               &Tcl_DefsubrCmdRec,
               &Tcl_ErrorCmdRec,
               &Tcl_EvalCmdRec,
               &Tcl_ExecCmdRec,
               &Tcl_ExprCmdRec,
               &Tcl_FileCmdRec,
               &Tcl_ForCmdRec,
               &Tcl_ForeachCmdRec,
               &Tcl_FormatCmdRec,
               &Tcl_GlobalCmdRec,
               &Tcl_IfCmdRec,
               &Tcl_IndexCmdRec,
               &Tcl_InfoCmdRec,
               &Tcl_LengthCmdRec,
               &Tcl_ListCmdRec,
               &Tcl_ProcCmdRec,
               &Tcl_ProtectCmdRec,
               &Tcl_RangeCmdRec,
               &Tcl_ReturnCmdRec,
               &Tcl_ScanCmdRec,
               &Tcl_SourceCmdRec,
               &Tcl_StringCmdRec,
               &Tcl_TimeCmdRec,
               &Tcl_UplevelCmdRec,
               &Tcl_VarCmdRec
           };
           
           
           /*
            *----------------------------------------------------------------------
            *
            * Tcl_CreateInterp --
            *
            *	Create a new TCL command interpreter.
            *
            * Results:
            *	The return value is a token for the interpreter, which may be
            *	used in calls to procedures like Tcl_CreateCmd, Tcl_Eval, or
            *	Tcl_DeleteInterp.
            *
            * Side effects:
            *	The command interpreter is initialized with an empty variable
            *	table and the built-in commands.
            *
            *----------------------------------------------------------------------
            */
           
           Tcl_Interp *
           Tcl_CreateInterp()
           {
               register Interp *iPtr;
               register const Tcl_CommandRec * const *cmdRecPtr;
               register int i;
           
      2 ->     iPtr = (Interp *) malloc(sizeof(Interp));
               iPtr->result = iPtr->resultSpace;
               iPtr->dynamic = 0;
               iPtr->helpFetch = 0;	/* No help hook, by default */
               iPtr->commandPtr = NULL;
               iPtr->globalFrame.vars = NULL;
               iPtr->globalFrame.next = NULL;
               iPtr->numLevels = 0;
               iPtr->curProc = NULL;
               iPtr->cmdCount = 0;
               iPtr->flags = 0;
               iPtr->tracePtr = NULL;
               iPtr->top = NULL;
               iPtr->resultSpace[0] = 0;
           
               /*
                * Create the built-in commands.  Do it here, rather than calling
                * Tcl_CreateCommand, because it's faster (there's no need to check
                * for a pre-existing command by the same name).
                */
           
               for (cmdRecPtr = builtInCmds,
           	 i = sizeof(builtInCmds)/sizeof(builtInCmds[0]);
           	 i > 0;
           	 cmdRecPtr++, i--)
               {
     60 -> 	Tcl_CreateCommandByRec((Tcl_Interp *)iPtr, *cmdRecPtr);
               }
           
      2 ->     return (Tcl_Interp *) iPtr;
           }
           
           
           
           /*
            *----------------------------------------------------------------------
            *
            * Tcl_TopLevel --
            *
            *	Return an interpreter to its top-level state. This assumes the
            *	caller will unwind the various levels of C procedure calls...
            *
            * Results:
            *	None.
            *
            * Side effects:
            *	Any local variables are destroyed. numLevels is reset to 0.
            *	protect strings for frames are evaluated.
            *
            *----------------------------------------------------------------------
            */
           void
           Tcl_TopLevel(Tcl_Interp	*interp)
      2 -> {
               register Interp	*iPtr;
               register Frame  	*frame, *nextFrame;
               void    	    	**fp;
               
           
               iPtr = (Interp *)interp;
           
               for (frame = iPtr->top; frame != NULL; frame = nextFrame) {
     71 -> 	nextFrame = (Frame *)frame->ext.next;
           
           	/*
           	 * Evaluate any protected command in its context.
           	 */
           	if (frame->protect) {
  ##### -> 	    (void)Tcl_Eval(interp, frame->protect, 0, 0);
           	}
           
           	/*
           	 * Free any separately-allocated arguments
           	 */
     71,      80 -> 	for (fp = frame->sepArgs; *fp != (void *)NULL; fp++) {
      9 -> 	    free(*fp);
           	}
     71 -> 	if (frame->ext.flags & TCL_FRAME_FREE_SEPARGS) {
  ##### -> 	    free((malloc_t)frame->sepArgs);
           	}
           	
           	/*
           	 * Free args and argv if requested by Tcl_Eval
           	 */
     71 -> 	if (frame->ext.flags & TCL_FRAME_FREE_ARGS) {
     40 -> 	    free((malloc_t)frame->copyStart);
           	}
     71 -> 	if (frame->ext.flags & TCL_FRAME_FREE_ARGV) {
  ##### -> 	    free((malloc_t)frame->ext.argv);
           	}
           	
           	/*
           	 * If the frame is for a command procedure (and the scope has
           	 * actually been set up), we need to free up its local variables.
           	 */
           	if ((frame->ext.cmdFlags & TCL_PROC) &&
           	    (!frame->ext.next ||
     20,      20,      71 -> 	     frame->localPtr != ((Frame *)frame->ext.next)->localPtr))
           	{
     20 -> 	    TclDeleteVars(frame->localPtr->vars);
           
           	    frame->localPtr->vars = (Var *)NULL;
           	}
           
           	/*
           	 * Switch to the next frame up.
           	 */
     71 -> 	iPtr->top = nextFrame;
               }
           
      2 ->     iPtr->numLevels = 0;
               iPtr->curProc = NULL;
           }
           	     
           
           
           /*
            *----------------------------------------------------------------------
            *
            * Tcl_CurrentFrame --
            *
            *	Return the top-most frame in the current call stack.
            *
            * Results:
            *	See above.
            *
            * Side effects:
            *	None.
            *
            *----------------------------------------------------------------------
            */
           Tcl_Frame *
           Tcl_CurrentFrame(Tcl_Interp *interp)
           {
               Interp  *iPtr = (Interp *)interp;
           
    230 ->     return ((Tcl_Frame *)iPtr->top);
           }
           
           
           /*
            *----------------------------------------------------------------------
            *
            * Tcl_DeleteInterp --
            *
            *	Delete an interpreter and free up all of the resources associated
            *	with it.
            *
            * Results:
            *	None.
            *
            * Side effects:
            *	The interpreter is destroyed.  The caller should never again
            *	use the interp token.
            *
            *----------------------------------------------------------------------
            */
           
           void
           Tcl_DeleteInterp(Tcl_Interp *interp)	/* Token for command interpreter
           					 * (returned by a previous call to
           					 * Tcl_CreateInterp). */
  ##### -> {
               Interp *iPtr = (Interp *) interp;
               register Command *cmdPtr;
               register Trace *tracePtr;
           
               /*
                * If the interpreter is in use, delay the deletion until later.
                */
           
               iPtr->flags |= DELETED;
               if (iPtr->numLevels != 0) {
           	return;
               }
  ##### ->     for (cmdPtr = iPtr->commandPtr; cmdPtr != NULL; cmdPtr = cmdPtr->nextPtr) {
  ##### -> 	if (cmdPtr->deleteProc != 0) { 
  ##### -> 	    (*cmdPtr->deleteProc)(cmdPtr->clientData);
           	}
  ##### -> 	free((char *) cmdPtr);
               }
  ##### ->     iPtr->commandPtr = NULL;
               TclDeleteVars(iPtr->globalFrame.vars);
               for (tracePtr=iPtr->tracePtr; tracePtr!=NULL; tracePtr=tracePtr->nextPtr) {
  ##### -> 	free((char *) tracePtr);
               }
  ##### ->     free((char *) iPtr);
           }
           
           /*
            *----------------------------------------------------------------------
            *
            * Tcl_CreateCommand --
            *
            *	Define a new command in a command table.
            *
            * Results:
            *	None.
            *
            * Side effects:
            *	If a command named cmdName already exists for interp, it is
            *	deleted.  In the future, when cmdName is seen as the name of
            *	a command by Tcl_Eval, proc will be called with the following
            *	syntax:
            *
            *	int
            *	proc(clientData, interp, argc, argv)
            *	    ClientData clientData;
            *	    Tcl_Interp *interp;
            *	    int argc;
            *	    char **argv;
            *	{
            *	}
            *
            *	The clientData and interp arguments are the same as the corresponding
            *	arguments passed to this procedure.  Argc and argv describe the
            *	arguments to the command, in the usual UNIX fashion (argv[argv] will
            *	be NULL).  Proc must return a code like TCL_OK or TCL_ERROR.  It
            *	can also set interp->result ("" is the default value if proc doesn't
            *	set it) and interp->dynamic (0 is the default).  See tcl.h for more
            *	information on these variables.
            *
            *	When the command is deleted from the table, deleteProc will be called
            *	in the following way:
            *
            *	void
            *	deleteProc(clientData)
            *	    ClientData clientData;
            *	{
            *	}
            *
            *	DeleteProc allows command implementors to perform their own cleanup
            *	when commands (or interpreters) are deleted.
            *
            *----------------------------------------------------------------------
            */
           
           void
           Tcl_CreateCommand(Tcl_Interp	*interp,	/* Token for command
           						 * interpreter (returned by
           						 * a previous call to
           						 * Tcl_CreateInterp). */
           		  const char	*cmdName,	/* Name of command. */
           		  Tcl_CmdProc	*proc,	    	/* Command procedure to
           						 * associate with cmdName. */
           		  int	    	flags,	    	/* Flags for the command
           						 * (TCL_EXACT, eg.) */
           		  ClientData	clientData,	/* Arbitrary one-word value
           						 * to pass to proc. */
           		  Tcl_DelProc	*deleteProc)	/* If not NULL, gives a
           						 * procedure to call when
           						 * this command is deleted. */
           {
               Interp *iPtr = (Interp *) interp;
               register Command *cmdPtr;
   1245 ->     int	nameLength = strlen(cmdName);
           
               Tcl_DeleteCommand(interp, cmdName);
               cmdPtr = (Command *) malloc(CMD_SIZE(nameLength));
               cmdPtr->proc = proc;
               cmdPtr->flags = flags;
               cmdPtr->clientData = clientData;
               cmdPtr->deleteProc = deleteProc;
               cmdPtr->nextPtr = iPtr->commandPtr;
               iPtr->commandPtr = cmdPtr;
               bcopy(cmdName, cmdPtr->name, nameLength+1);
           }
           
           
           /***********************************************************************
            *				Tcl_CreateCommandByRec
            ***********************************************************************
            * SYNOPSIS:	    Define a new command using a command record.
            * CALLED BY:	    GLOBAL
            * RETURN:	    Nothing
            * SIDE EFFECTS:    See Tcl_CreateCommand.
            *
            * STRATEGY:
            *	    Delete the command if it already exists.
            *	    If the command record has a non-null 'data' pointer, use
            *	    	TclCmdCheckUsage as the handler instead of that stored
            *	    	in the record.
            *
            * REVISION HISTORY:
            *	Name	Date		Description
            *	----	----		-----------
            *	ardeb	4/23/91		Initial Revision
            *
            ***********************************************************************/
           void
           Tcl_CreateCommandByRec(Tcl_Interp   	    *interp,
           		       const Tcl_CommandRec *cmdRec)
    244 -> {
               Tcl_CmdProc	    *proc;
               ClientData	    data;
           
               if (cmdRec->data != 0) {
     90 -> 	proc = TclCmdCheckUsage;
           	data = (ClientData)cmdRec;
               } else {
    154 -> 	proc = cmdRec->proc;
           	data = (ClientData)NULL;
               }
           
               Tcl_CreateCommand(interp, cmdRec->name, proc, cmdRec->flags, data,
    244 -> 		      cmdRec->delProc);
           }
           
           /*
            *----------------------------------------------------------------------
            *
            * Tcl_OverrideCommand --
            *
            *	Override the values for a command in an interpreter, returning
            *	the old values so they may be replaced later. This function
            *	is intended to allow functions to catch procedure calls, e.g.
            *	for debugging.
            *
            * Results:
            *	If the command doesn't exist in the table then 0 is returned.
            *	Otherwise 1 is returned and cmdProcPtr, cmdClientDataPtr and
            *	deleteProcPtr are filled in.
            *
            * Side effects:
            *	The command will be brought to the front of the list by
            *	TclFindCmd if it is found, and its values will be changed.
            *
            *----------------------------------------------------------------------
            */
           int
           Tcl_OverrideCommand(Tcl_Interp	*interp,
           		    const char	*cmdName,   	    /* Name of command to
           						     * change */
           		    Tcl_CmdProc	*cmdProc,	    /* Command procedure to
           						     * associate with cmdName.*/
           		    int	    	flags,	    	    /* New flags */
           		    ClientData	clientData,	    /* Arbitrary one-word value
           						     * to pass to proc. */
           		    Tcl_DelProc	*deleteProc,        /* If not NULL, gives a
           						     * procedure to call when
           						     * this command is deleted*/
           		    Tcl_CmdProc	**cmdProcPtr,	    /* Place to store old
           						     * handler */
           		    int	    	*flagsPtr,  	    /* Storage for old flags */
           		    ClientData	*clientDataPtr,	    /* Storage for old CD */
           		    Tcl_DelProc	**deleteProcPtr)    /* Storage for old delProc*/
  ##### -> {
               register Command 	*cmdPtr;
           
               cmdPtr = TclFindCmd((Interp *)interp, cmdName, 1);
           
               if (cmdPtr == (Command *)NULL) {
  ##### -> 	return(0);
               } else {
  #####,   ##### -> 	if (cmdProcPtr) *cmdProcPtr = cmdPtr->proc;
  #####,   ##### -> 	if (flagsPtr) *flagsPtr = cmdPtr->flags;
  #####,   ##### -> 	if (clientDataPtr) *clientDataPtr = cmdPtr->clientData;
  #####,   ##### -> 	if (deleteProcPtr) *deleteProcPtr = cmdPtr->deleteProc;
  ##### -> 	cmdPtr->proc = cmdProc;
           	cmdPtr->flags = flags;
           	cmdPtr->clientData = clientData;
           	cmdPtr->deleteProc = deleteProc;
           	return(1);
               }
           }	
           
           /*
            *----------------------------------------------------------------------
            *
            * Tcl_FetchCommand --
            *
            *	Return the cmdProc, clientData and deleteProc values for a
            *	function, if it exists.
            *
            * Results:
            *	If the command doesn't exist in the table then 0 is returned.
            *	Otherwise 1 is returned and cmdProcPtr, cmdClientDataPtr and
            *	deleteProcPtr are filled in.
            *
            * Side effects:
            *	The command will be brought to the front of the list by
            *	TclFindCmd if it is found.
            *
            *----------------------------------------------------------------------
            */
           int
           Tcl_FetchCommand(Tcl_Interp 	*interp,
           		 const char    	*cmdName,
           		 Tcl_CmdProc 	**cmdProcPtr,
           		 int	    	*flagsPtr,
           		 ClientData 	*clientDataPtr,
           		 Tcl_DelProc    **deleteProcPtr)
    745 -> {
               register Command 	*cmdPtr;
           
               cmdPtr = TclFindCmd((Interp *)interp, cmdName, 1);
           
               if (cmdPtr == (Command *)NULL) {
    491 -> 	return(0);
               } else {
    254 -> 	*cmdProcPtr = cmdPtr->proc;
           	*flagsPtr = cmdPtr->flags;
           	*clientDataPtr = cmdPtr->clientData;
           	*deleteProcPtr = cmdPtr->deleteProc;
           	return(1);
               }
           }	
           
           /*
            *----------------------------------------------------------------------
            *
            * Tcl_DeleteCommand --
            *
            *	Remove the given command from the given interpreter.
            *
            * Results:
            *	None.
            *
            * Side effects:
            *	CmdName will no longer be recognized as a valid command for
            *	interp.
            *
            *----------------------------------------------------------------------
            */
           
           void
           Tcl_DeleteCommand(Tcl_Interp	*interp,    /* Token for command interpreter
           					     * (returned by a previous call to
           					     * Tcl_CreateInterp). */
           		  const char	*cmdName)   /* Name of command to remove. */
           {
   1348 ->     Interp *iPtr = (Interp *) interp;
               Command *cmdPtr;
           
               cmdPtr = TclFindCmd(iPtr, cmdName, 1);
               if (cmdPtr != NULL) {
    178 -> 	if (cmdPtr->deleteProc != 0) {
     71 -> 	    (*cmdPtr->deleteProc)(cmdPtr->clientData);
           	}
    178 -> 	iPtr->commandPtr = cmdPtr->nextPtr;
           	free((char *) cmdPtr);
               }
           }
           
           /*
            *-----------------------------------------------------------------
            *
            * Tcl_Eval --
            *
            *	Parse and execute a command in the Tcl language.
            *
            * Results:
            *	The return value is one of the return codes defined in
            *	tcl.h (such as TCL_OK), and interp->result contains a string
            *	value to supplement the return code.  The value of interp->result
            *	will persist only until the next call to Tcl_Eval:  copy it
            *	or lose it!
            *
            * Side effects:
            *	Almost certainly;  depends on the command.
            *
            *-----------------------------------------------------------------
            */
           int
           Tcl_Eval(Tcl_Interp *interp,	/* Token for command interpreter (returned by a
           				 * previous call to Tcl_CreateInterp). */
           	 const char *cmd,	/* Pointer to TCL command to interpret. */
           	 char	    termChar,	/* Return when this character is found in the
           				 * command stream.  This is either 0, ']'.   If
           				 * termChar is 0, then individual commands are
           				 * terminated by newlines, although this
           				 * procedure doesn't return until it sees the
           				 * end of the string. */
           	 const char **termPtr)	/* If non-NULL, fill in the address it points
           				 * to with the address of the char. that
           				 * terminated cmd.  This character will be
           				 * either termChar or the null at the end of
           				 * cmd. */
 107040 -> {
               /*
                * While processing the command, make a local copy of
                * the command characters.  This is needed in order to
                * terminate each argument with a null character, replace
                * backslashed-characters, etc.  The copy starts out in
                * a static string (for speed) but gets expanded into
                * dynamically-allocated strings if necessary.  The constant
                * BUFFER indicates how much space there must be in the copy
                * in order to pass through the main loop below (e.g., must
                * have space to copy both a backslash and its following
                * characters).
                */
           
           #   define NUM_CHARS 200
           #   define BUFFER 5
               char    	    copyStorage[NUM_CHARS];
               char    	    *copy=copyStorage;	    /* Pointer to current copy. */
               unsigned   	    copySize = NUM_CHARS;   /* Size of current copy. */
               register char   *dst;		    /* Points to next place to copy
           					     * a character. */
               char    	    *limit;		    /* When dst gets here, must make
           					     * the copy larger. */
           
               /*
                * This procedure generates an (argv, argc) array for the command,
                * It starts out with stack-allocated space but uses dynamically-
                * allocated storage to increase it if needed.
                */
           
           #   define NUM_ARGS 32
               char    	    *argStorage[NUM_ARGS];
               char    	    **argv = argStorage;
               int     	    argc;
               int     	    argSize = NUM_ARGS;
           
               /*
                * Things to track any separately-allocated args that we usurp.
                */
               void    	    *sepArgStorage[NUM_ARGS];
               int	    	    sepArgc=0;
               int	       	    sepArgSize = NUM_ARGS;
           
               int     	    openBraces=0;   	/* Count of how many nested open braces
           					 * there are at the current point in
           					 * the current argument */
           
               register const char   *src;		/* Points to current character
           					 * in cmd. */
               const char 	    *argStart;		/* Location in cmd of first character
           					 * in current argument;  it's used to
           					 * detect that nothing has been read
           					 * from the current argument. */
               int     	    result=TCL_OK;	/* Return value. */
               int     	    i;
               register Interp *iPtr = (Interp *) interp;
               char 	    *errRes;
               Command 	    *cmdPtr;
               const char 	    *tmp;
               const char 	    *syntaxMsg;
               register Trace  *tracePtr;
               Frame   	    frame;  	    	/* Frame for this command */
           
               /*
                * Set up the result so that if there's no command at all in
                * the string then this procedure will return TCL_OK.
                */
               if (iPtr->dynamic) {
     28 -> 	free((char *) iPtr->result);
           	iPtr->dynamic = 0;
               }
               
 107040 ->     iPtr->result = iPtr->resultSpace;
               iPtr->resultSpace[0] = 0;
               
           
               iPtr->numLevels++;
               iPtr->cmdCount++;
               src = cmd;
               result = TCL_OK;
           
               /*
                * Initialize Frame for this level
                */
               frame.ext.level = iPtr->numLevels;
               frame.ext.next = (Tcl_Frame *)iPtr->top;
               frame.ext.flags = 0;
               frame.sepArgs = sepArgStorage;
               if (iPtr->top) {
 107010 -> 	frame.localPtr = iPtr->top->localPtr;
               } else {
     30 -> 	frame.localPtr = &iPtr->globalFrame;
               }
 107040 ->     cmdPtr = (Command *)NULL;
               iPtr->top = &frame;
               
               /*
                * There can be many sub-commands (bracketed or separated by
                * newlines) in one command string.  This outer loop iterates over
                * the inner commands.
                */
           
 181687 ->     while ((*src != termChar) && (result == TCL_OK)) {
           
           	/*
           	 * Skim off leading white space, skip comments, and handle brackets
           	 * at the beginning of the command by recursing.
           	 */
               
 173189 -> 	while (isspace(*src)) {
 446160,  619349 -> 	    src += 1;
           	}
 173189 -> 	if (*src == '#') {
  17000,  476213,  493213 -> 	    for (src++; *src != 0; src++) {
 493213 -> 		if (*src == '\n') {
  17000 -> 		    src++;
           		    break;
           		}
           	    }
  ##### -> 	    continue;
           	}
           	/*
           	 * If the first character of the command is a [, the command within
           	 * is executed and its output discarded (unless it's the only command
           	 * in the string). This allows multi-line commands by placing it
           	 * in brackets -- if this weren't done, the result would be executed,
           	 * which would be bad.
           	 *
           	 * Switches back to calling frame before recursing so there's not a
           	 * bogus frame in the middle (we don't have anything to assign to our
           	 * frame yet).
           	 *
           	 * XXX: If Tcl_TopLevel is called while in the nested Tcl_Eval,
           	 * anything we've allocated dynamically will be left dangling.
           	 */
 156189 -> 	if (*src == '[') {
   4501 -> 	    iPtr->top = (Frame *)frame.ext.next;
           	    result = Tcl_Eval(interp, src+1, ']', &tmp);
           	    iPtr->top = &frame;
           	    src = tmp+1;
           	    continue;
           	}
           
           	/*
           	 * Set up the first argument (the command name).  Note that
           	 * the arg pointer gets set up BEFORE the first real character
           	 * of the argument has been found.
           	 */
               
 151688 -> 	dst = copy;
           	argc = 0;
           	frame.protect = (char *)NULL;
           	frame.ext.cmdProc = 0;
           	frame.ext.cmdFlags = 0;
           	frame.copyStart = copy;
           	frame.copyEnd = limit = copy + copySize - BUFFER;
           	frame.ext.command = src;
           
           	argv[0] = dst;
           	argStart = src;
           
           	/*
           	 * Skim off the command name and arguments by looping over
           	 * characters and processing each one according to its type.
           	 */
               
           	while (1) {
  #####, 1032018, 1198388,  125505,  126408, 1266751, 1650689,  166370, 1714702,      28,  286185,  286185,   30235,  316420,  383938,     502,  954590,  954590 -> 	    switch (*src) {
               
           		/*
           		 * All braces are treated as normal characters
           		 * unless the first character of the argument is an
           		 * open brace.  In that case, braces nest and
           		 * the argument terminates when all braces are matched.
           		 * Internal braces are also copied like normal chars.
           		 */
               
           		case '{': {
  77428,   77428 -> 		    if ((openBraces == 0) && (src == argStart)) {
           			int len;
           
           			/*
           			 * Skip forward to the closing brace. Much better to
           			 * enlarge the dst all at once, if necessary, than
           			 * to do so by increments, seems to me...
           			 */
  77428 -> 			openBraces = 1;
11593409, 11670568, 11670837 -> 			for (src++; *src && openBraces; src++) {
11593409 -> 			    if (*src == '{') {
 142873 -> 				openBraces++;
11450536 -> 			    } else if (*src == '}') {
 220301 -> 				openBraces--;
11230235,   14902 -> 			    } else if (*src == '\\' && src[1] != '\0') {
  14902 -> 				src++;
           			    }
           			}
           
           			/*
           			 * If any braces left open (i.e. we hit the end of
           			 * the string), complain
           			 */
  77428 -> 			if (openBraces) {
           			    syntaxMsg = "unmatched brace";
           			    goto syntaxError;
           			}
           
           			/*
           			 * Figure length w/o braces (src points after close)
           			 */
  77428 -> 			len = (src-1)-(argStart+1);
           			
           			if ((limit - dst) < len) {
           			    /*
           			     * Not enough room in dst for whole thing --
           			     * enlarge copy to fit.
           			     */
           			    char    *newCopy;
           			    int     delta;
           			    char    **av;
           				
  11263 -> 			    copySize = len + NUM_CHARS + (dst - copy);
           
           			    newCopy = (char *) malloc((unsigned) copySize);
           			    bcopy(copy, newCopy, (dst-copy));
           
           			    delta = newCopy - copy;
           			    dst += delta;
  75071 -> 			    for (av = &argv[argc]; av >= argv; av--) {
  71893,   75071 -> 				if (*av >= copy && *av <= limit) {
  70590 -> 				    *av += delta;
           				}
           			    }
           
  11263 -> 			    if (copy != copyStorage) {
   5175 -> 				free((char *) copy);
           			    }
           
  11263 -> 			    frame.copyStart = copy = newCopy;
           			    frame.copyEnd = limit =
           				newCopy + copySize - BUFFER;
           			    frame.ext.flags |= TCL_FRAME_FREE_ARGS;
           			}
           			/*
           			 * Copy the thing into the destination
           			 */
  77428 -> 			bcopy(argStart+1, dst, len);
           			dst += len;
           
           			/*
           			 * Make sure the beast is terminated correctly
           			 */
           			src--;
           			goto checkbrace;
           		    } else {
  ##### -> 			*dst++ = '{';
           		    }
           		    break;
           		}
           
           		case '}': {
  ##### -> 		    if (openBraces == 1) {
           			const char *p;
           
  ##### -> 			openBraces = 0;
           
           			checkbrace:
           
           			if (isspace(src[1]) || (src[1] == termChar) ||
  #####,    5865,   77428 -> 			    (src[1] == 0))
           			{
           			    break;
           			}
  #####,   #####,   #####,   ##### -> 			for (p = src+1;
           			     (*p != 0) && (!isspace(*p)) &&
  ##### -> 			     (*p != termChar) && (p < src+20);
  ##### -> 			     p++)
           			{
           			    /* null body */
           			}
           			Tcl_RetPrintf(interp,
           				      "argument in braces followed by \"%.*s\" instead of space",
  ##### -> 				      p-(src+1), src+1);
           			result = TCL_ERROR;
           			goto done;
           		    } else {
  ##### -> 			*dst++ = '}';
           			if (openBraces != 0) {
  ##### -> 			    openBraces--;
           			}
           		    }
           		    break;
           		}
               
           		case '[': {
               
           		    /*
           		     * Open bracket: if not in middle of braces, then execute
           		     * following command and substitute result into argument.
           		     */
           
  39962 -> 		    if (openBraces != 0) {
  ##### -> 			*dst++ = '[';
           		    } else {
           			int length;
               
           			/*
           			 * Set up partial frame. cmdProc is NULL to indicate
           			 * we're still working on it...
           			 */
  39962 -> 			frame.ext.argc = argc;
           			frame.ext.argv = argv;
           			frame.sepArgs[sepArgc] = (void *)NULL;
           			
           			result = Tcl_Eval(interp, src+1, ']', &tmp);
           			src = tmp;
           			if (result != TCL_OK) {
           			    goto done;
           			}
               
           			/*
           			 * Copy the return value into the current argument.
           			 * May have to enlarge the argument storage.  When
           			 * enlarging, get more than enough to reduce the
           			 * likelihood of having to enlarge again.  This code
           			 * is used for $-processing also.
           			 */
           			copyResult:
           
           			if ((iPtr->dynamic ||
           			     (iPtr->result !=
           			      (const char *)iPtr->resultSpace)) &&
           			    (dst == argv[argc]) &&
           			    ((i = src[1]) == '\n' || i == '\r' ||
           			     i == ' ' || i == '\t' || i == '\0' ||
 103963,   16023,   16891,   16891,   63148,   63148,   68597,   71719,   98965 -> 			     i == termChar))
           			{
           			    /*
           			     * If result is the only thing in this
           			     * argument and it's dynamic or static and
           			     * not in resultSpace, don't bother
           			     * copying the thing to our local storage,
           			     * just use it directly.
           			     */
  66506 -> 			    argv[argc] = (char *)iPtr->result;
           			    if (iPtr->dynamic) {
           				/*
           				 * If arg is dynamic, record that it needs
           				 * to be freed, storing its address in
           				 * the sepArgs array, rather than relying
           				 * on argv remaining the same during the
           				 * call.
           				 */
   4935 -> 				frame.sepArgs[sepArgc++] = (char *)iPtr->result;
           				if (sepArgc == sepArgSize) {
  ##### -> 				    if (frame.sepArgs == sepArgStorage) {
           					frame.sepArgs =
           					    (void **)malloc((sepArgc*2)*
  ##### -> 							    sizeof(void *));
           					bcopy(sepArgStorage,
           					      frame.sepArgs,
           					      sepArgc*sizeof(void *));
           				    } else {
           					frame.sepArgs =
           					    (void **)realloc((malloc_t)frame.sepArgs,
           							     (sepArgc*2)*
  ##### -> 							     sizeof(void *));
           				    }
  ##### -> 				    frame.ext.flags |= TCL_FRAME_FREE_SEPARGS;
           				}
   4935 -> 				iPtr->dynamic = 0;
           			    }
           			} else {
  37457 -> 			    length = strlen(iPtr->result);
           			    if ((limit - dst) < length) {
           				char *newCopy;
           				int delta;
           				char **av;
           				
     96 -> 				copySize = length + NUM_CHARS + (dst - copy);
           				newCopy = (char *) malloc((unsigned) copySize);
           				bcopy(copy, newCopy, (dst-copy));
           				delta = newCopy - copy;
           				dst += delta;
    436 -> 				for (av = &argv[argc]; av >= argv; av--) {
    436,     436 -> 				    if (*av >= copy && *av <= limit) {
    436 -> 					*av += delta;
           				    }
           				}
     96 -> 				if (copy != copyStorage) {
     16 -> 				    free((char *) copy);
           				}
     96 -> 				frame.copyStart = copy = newCopy;
           				frame.copyEnd = limit =
           				    newCopy + copySize - BUFFER;
           				frame.ext.flags |= TCL_FRAME_FREE_ARGS;
           			    }
           
  37457 -> 			    bcopy(iPtr->result, dst, length);
           			    dst += length;
           			}
           		    }
           		    break;
           		}
           
           		case '$': {
  64013 -> 		    if (openBraces != 0) {
  ##### -> 			*dst++ = '$';
           		    } else {
           
           			/*
           			 * Parse off a variable name and copy its value.
           			 */
  64013 ->     	    	    	if (iPtr->dynamic) {
     12 -> 			    free((malloc_t)iPtr->result);
           			    iPtr->dynamic = 0;
           			}
  64013 -> 			iPtr->result = Tcl_ParseVar(interp, src, &tmp);
           			src = tmp-1;
           			goto copyResult;
           		    }
           		    break;
           		}
           
           		case ']': {
  68363,   68363 -> 		    if ((openBraces == 0) && (termChar == ']')) {
           			goto cmdComplete;
           		    }
  ##### -> 		    *dst++ = ']';
           		    break;
           		}
               
           		case '\n': {
           
           		    /*
           		     * A newline can be either a command terminator
           		     * or a space character.  If it's a space character,
           		     * just fall through to the space code below.
           		     */
               
  67518,   67518 -> 		    if ((openBraces == 0) && (termChar == 0)) {
           			goto cmdComplete;
           		    }
           		}
           		    /*FALLTHRU*/
           		case '\r':
           		case ' ':
           		case '\t': {
 300597 -> 		    if (openBraces > 0) {
               
           			/*
           			 * Quoted space.  Copy it into the argument.
           			 */
               
           			*dst++ = *src;
           		    } else {
           
           			/*
           			 * Argument separator.  Find the start of the next
           			 * argument;  if none, then exit the loop.  Otherwise,
           			 * null-terminate the current argument and set up for
           			 * the next one.  Expand the argv array if it's about
           			 * to overflow (watch out!  leave space both for next
           			 * arg and for NULL pointer that gets added to the
           			 * end of argv when the command is complete).
           			 */
               
 300597 -> 			*dst++ = 0;
           
           			argc++;
           			if (argc >= argSize-1) {
     23 -> 			    argSize *= 2;
           			    if (argv == argStorage) {
           				char **newArgs;
           				
           				newArgs = (char **)
     23 -> 				    malloc((unsigned) argSize*sizeof(char *));
           				bcopy(argv, newArgs, argc * sizeof(char *));
           				argv = newArgs;
           				frame.ext.flags |= TCL_FRAME_FREE_ARGV;
           			    } else {
           				argv =
           				    (char **)realloc((malloc_t)argv,
           						     (unsigned)argSize*
  ##### -> 						     sizeof(char *));
           			    }
           			}
           			
 300597 -> 			argv[argc] = dst;
           
           			while (((i = src[1]) == ' ') || (i == '\t') ||
           			       ((i == '\n') && (termChar != 0)) ||
 300597,  300928,  313094,  366503,     372 -> 			       (i == '\r'))
           			{
  65906 -> 			    src++;
           			}
 300597 -> 			argStart = src+1;
           
           			/*
           			 * If this is the first arg, look up the associated
           			 * command so we can deal with the TCL_NOEVAL flag.
           			 * We don't handle a non-existent command at this
           			 * level, though, as we need to get to the end
           			 * of the command string.
           			 */
           			if (argc == 1) {
 125647 -> 			    cmdPtr = TclFindCmd(iPtr, (const char *)argv[0], 0);
           			    if (cmdPtr == NULL) {
  ##### -> 				errRes = (char *)malloc(strlen(iPtr->result)+1);
           				strcpy(errRes, iPtr->result);
 125647 -> 			    } else if (cmdPtr->flags & TCL_NOEVAL) {
  ##### -> 				int openBrackets=0; /* Count of nested open
           						     * square brackets. */
           				int len;
           
  ##### -> 				for (src++; *src != '\0'; src++) {
  ##### -> 				    if (*src == '{') {
  ##### -> 					openBraces++;
  #####,   ##### -> 				    } else if (openBraces && *src == '}') {
  ##### -> 					openBraces--;
  ##### -> 				    } else if (!openBraces) {
  ##### -> 					if (*src == '[') {
  ##### -> 					    openBrackets++;
  ##### -> 					} else if (*src == ']') {
           					    if ((openBrackets-- == 0) &&
  #####,   ##### -> 						(termChar == ']'))
           					    {
  ##### -> 						openBrackets = 0;
           						break;
           					    }
           					} else if (!openBrackets &&
           						   termChar == 0 &&
  #####,   #####,   ##### -> 						   *src == '\n')
           					{
           					    break;
           					}
           				    }
           				}
  ##### -> 				if (openBraces) {
           				    syntaxMsg = "unmatched brace";
           				    goto syntaxError;
  ##### -> 				} else if (openBrackets) {
           				    syntaxMsg = "unmatched bracket";
           				    goto syntaxError;
  #####,   ##### -> 				} else if (termChar && (*src != termChar)) {
  ##### -> 				    if (termChar == ']') {
           					syntaxMsg = "unmatched bracket";
           				    } 
  ##### -> 				    goto syntaxError;
           				}
           				
  ##### -> 				len = src-argStart;
           
           				if ((limit - dst) < len) {
           				    /*
           				     * Not enough room in dst for whole thing --
           				     * enlarge copy to fit.
           				     */
           				    char    *newCopy;
           				    int     delta;
           				    char    **av;
           				    
  ##### -> 				    copySize = len + NUM_CHARS + (dst - copy);
           				    
           				    newCopy = (char *) malloc(copySize);
           				    bcopy(copy, newCopy, (dst-copy));
           				    
           				    delta = newCopy - copy;
           				    dst += delta;
  ##### -> 				    for (av = &argv[argc]; av >= argv; av--) {
  #####,   ##### -> 					if (*av >= copy && *av <= limit) {
  ##### -> 					    *av += delta;
           					}
           				    }
           				    
  ##### -> 				    if (copy != copyStorage) {
  ##### -> 					free((char *) copy);
           				    }
           				    
  ##### -> 				    frame.copyStart = copy = newCopy;
           				    frame.copyEnd = limit =
           					newCopy + copySize - BUFFER;
           				    frame.ext.flags |= TCL_FRAME_FREE_ARGS;
           				}
           				
           				/*
           				 * Copy the thing into the destination
           				 */
  ##### -> 				bcopy(argStart, dst, len);
           				dst += len;
           				
           				/* This'll null-terminate the arg for us... */
           				goto cmdComplete;
           			    }
           
           			}
           		    }
           		    break;
           		}
               
           		case '\\': {
           		    int numRead;
           
           		    /*
           		     * If we're in an argument in braces then the
           		     * backslash doesn't get collapsed.  However whether
           		     * we're in braces or not the characters inside the
           		     * backslash sequence must not receive any additional
           		     * processing:  make src point to the last character
           		     * of the sequence.
           		     */
           
    903 -> 		    *dst = Tcl_Backslash(src, &numRead);
           		    if (openBraces > 0) {
  ##### -> 			while (numRead-- > 0) {
  #####,   ##### -> 			    *dst++ = *src++;
           			}
  ##### -> 			src--;
           		    } else {
    903 -> 			src += numRead-1;
           			dst++;
           		    }
           		    break;
           		}
               
           		case 0: {
               
           		    /*
           		     * End of string.  Make sure that braces were
           		     * properly matched.  Also, it's only legal to
           		     * terminate a command by a null character if termChar
           		     * is zero.
           		     */
           
  29733 -> 		    if (openBraces != 0) {
  ##### -> 			syntaxMsg = "unmatched brace";
           			goto syntaxError;
  29733 -> 		    } else if (termChar != 0) {
  ##### -> 			if (termChar == ']') {
  ##### -> 			    syntaxMsg = "unmatched bracket";
           			} else {
  ##### -> 			    syntaxMsg = "termination character not found";
           			}
           			goto syntaxError;
           		    }
           		    goto cmdComplete;
           		}
               
           		default: {
1080123, 1080123, 1081026 -> 		    *dst++ = *src;
           		    break;
           		}
           	    }
1563014 -> 	    src += 1;
               
           	    /*
           	     * Make sure that we're not running out of space in the
           	     * string copy area.  If we are, allocate a larger area
           	     * and copy the string.  Be sure to update all of the
           	     * relevant pointers too.
           	     */
               
           	    if (dst >= limit) {
           		char *newCopy;
           		int delta;
               
    811 -> 		copySize *= 2;
           		newCopy = (char *) malloc((unsigned) copySize);
           		bcopy(copy, newCopy, (dst-copy));
           		delta = newCopy - copy;
           		dst += delta;
   3341 -> 		for (i = 0; i <= argc; i++) {
   3333,    3341 -> 		    if (argv[i] >= copy && argv[i] <= limit)
           		    {
   3333 -> 			argv[i] += delta;
           		    }
           		}
    811 -> 		if (copy != copyStorage) {
    200 -> 		    free((char *) copy);
           		}
    811 -> 		frame.copyStart = copy = newCopy;
           		frame.copyEnd = limit = newCopy + copySize - BUFFER;
           
           		frame.ext.flags |= TCL_FRAME_FREE_ARGS;
           	    }
           	}
               
           	/*
           	 * Terminate the last argument.  If the interpreter has been
           	 * deleted then return;  if there's no command, then go on to
           	 * the next iteration.
           	 */
           
           	cmdComplete:
           
 151676 -> 	if (iPtr->flags & DELETED) {
           	    goto done;
           	}
 151676 -> 	if (src != argStart) {
 127397 -> 	    *dst = 0;
           	    argc++;
  24279 -> 	} else if (argc == 0) {
           	    continue;
           	}
 127754 -> 	argv[argc] = NULL;
           	frame.sepArgs[sepArgc] = (void *)NULL;
           
           	/*
           	 * Clear out the result area.  This has already been done once,
           	 * but a result may have been regenerated by a bracketed command.
           	 */
           
           	if (iPtr->dynamic) {
     25 -> 	    free((char *) iPtr->result);
           	    iPtr->dynamic = 0;
           	}
 127754 -> 	iPtr->result = iPtr->resultSpace;
           	iPtr->resultSpace[0] = 0;
           
           	/*
           	 * If only the command for an argument, need to locate the cmdPtr here,
           	 * else it's done when the first arg is terminated.
           	 */
           	if (argc == 1) {
   2121 -> 	    cmdPtr = TclFindCmd(iPtr, (const char *)argv[0], 0);
           	    if (cmdPtr == NULL) {
  ##### -> 		errRes = (char *)malloc(strlen(iPtr->result)+1);
           		strcpy(errRes, iPtr->result);
           	    }
           	}
           
 127754 -> 	if (cmdPtr == NULL) {
  ##### -> 	    result = TCL_ERROR;
           	    iPtr->result = errRes;
           	    iPtr->dynamic = 1;
           	    goto done;
           	}
           
           	/*
           	 * Now we're committed, set up the rest of the frame.
           	 */
 127754 -> 	frame.ext.cmdProc = cmdPtr->proc;
           	frame.ext.cmdFlags = cmdPtr->flags;
           	frame.ext.cmdData = cmdPtr->clientData;
           	frame.ext.argc = argc;
           	frame.ext.argv = argv;
           	
           	/*
           	 * Call trace procedures, if any, then invoke the command.
           	 */
           
 122710 -> 	for (tracePtr = iPtr->tracePtr; tracePtr != NULL;
 122710 -> 	     tracePtr = tracePtr->nextPtr)
           	{
 122710,  122710 -> 	    if ((tracePtr->level < iPtr->numLevels) && tracePtr->level) {
           		continue;
           	    }
           	    (*tracePtr->callProc)(tracePtr->clientData, interp,
 122710 -> 				  (Tcl_Frame *)&frame);
           	}
           
           	/*
           	 * Invoke the command
           	 */
 127754 -> 	result = (*cmdPtr->proc)(cmdPtr->clientData, interp, argc, argv);
           
           	/*
           	 * Call the returnProcs for the traces
           	 */
 122643 -> 	for (tracePtr = iPtr->tracePtr; tracePtr != NULL;
 122641 -> 	     tracePtr = tracePtr->nextPtr)
           	{
 122643,  122643 -> 	    if ((tracePtr->level < iPtr->numLevels) && tracePtr->level) {
           		continue;
           	    }
           	    (*tracePtr->returnProc)(tracePtr->clientData, interp,
 122643 -> 				    (Tcl_Frame *)&frame, result);
           	}
           
 127685 -> 	for (i = sepArgc-1; i >= 0; i--) {
   4926 -> 	    free(frame.sepArgs[i]);
           	}
 127685,  280132 -> 	sepArgc = 0;
               }
           
               done:
 106949 ->     if (termPtr != NULL) {
  68341 -> 	*termPtr = src;
               }
           
               /*
                * Free up any extra resources that were allocated.
                */
           
 106949 ->     for (i = sepArgc-1; i >= 0; i--) {
  ##### -> 	free(frame.sepArgs[i]);
               }
           
 106949 ->     if (frame.ext.flags & TCL_FRAME_FREE_SEPARGS) {
  ##### -> 	free((char *)frame.sepArgs);
               }
 106949 ->     if (frame.ext.flags & TCL_FRAME_FREE_ARGS) {
   6739 -> 	free((char *) copy);
               }
 106949 ->     if (frame.ext.flags & TCL_FRAME_FREE_ARGV) {
     23 -> 	free((char *) argv);
               }
               
 106949 ->     iPtr->numLevels--;
               if (iPtr->numLevels == 0) {
  #####,      14 -> 	if ((result != TCL_OK) && (result != TCL_ERROR)) {
  ##### -> 	    if (result == TCL_BREAK) {
           		Tcl_Return(interp, "invoked \"break\" outside of a loop",
  ##### -> 			   TCL_STATIC);
  ##### -> 	    } else if (result == TCL_CONTINUE) {
           		 Tcl_Return(interp, "invoked \"continue\" outside of a loop",
  ##### -> 			    TCL_STATIC);
  ##### -> 	    } else if (result == TCL_RETURN) {
           		Tcl_Return(interp, "invoked \"return\" outside of a procedure",
  #####,   ##### -> 			   TCL_STATIC);
           	    } else {
           		Tcl_RetPrintf(interp, "command returned bad code: %d",
  ##### -> 			      result);
           	    }
  ##### -> 	    result = TCL_ERROR;
           	}
     14 -> 	if (iPtr->flags & DELETED) {
  ##### -> 	    Tcl_DeleteInterp(interp);
           	}
               }
 106949 ->     iPtr->top = (Frame *)frame.ext.next;
           
               return result;
           
               /*
                * Syntax error:  generate a two-line message to pinpoint the error.
                * The first line contains a swatch of the command (without any
                * embedded newlines) and the second line contains a caret.
                */
           
               syntaxError: {
           	const char *first, *last;
           
  #####,   #####,   #####,   ##### -> 	for (first = src; ((first != cmd) && (first[-1] != '\n')); first--) {
           	    /* Null loop body. */
           	}
  #####,   #####,   #####,   ##### -> 	for (last = src; ((*last != 0) && (*last!= '\n')); last++) {
           	    /* Null loop body. */
           	}
  ##### -> 	if ((src - first) > 60) {
  ##### -> 	    first = src - 60;
           	}
  ##### -> 	if ((last - first) > 70) {
  ##### -> 	    last = first + 70;
           	}
  ##### -> 	if (last == first) {
  ##### -> 	    Tcl_RetPrintf(interp, "%s", syntaxMsg);
           	} else {
           	    /*
           	     * We need to make sure the caret lines up with the place of
           	     * error by using tab characters wherever the source string
           	     * uses them, and spaces everywhere else.
           	     */
           	    char	*cp;
           	    char	*cp2;
           
  ##### -> 	    Tcl_Return(interp, NULL, TCL_STATIC);
           
           	    strcpy(iPtr->resultSpace, syntaxMsg);
           	    cp = iPtr->resultSpace + strlen(syntaxMsg);
           
           	    *cp++ = '\n';
           	    cp2 = cp + (last-first);
           	    *cp2++ = '\n';
           
  ##### -> 	    while (first != last) {
  ##### -> 		if (first <= src) {
  ##### -> 		    if (*first != '\t') {
  ##### -> 			*cp2++ = ' ';
           		    } else {
  #####,   ##### -> 			*cp2++ = '\t';
           		    }
           		    if (first == src) {
  ##### -> 			*cp2++ = '^';
           			*cp2++ = '\0';
           		    }
           		}
  ##### -> 		*cp++ = *first++;
           	    }
  ##### -> 	    if (first == src) {
  ##### -> 		*cp2++ = '^';
           		*cp2++ = '\0';
           	    }
           	}
  ##### -> 	result = TCL_ERROR;
               }
           
               goto done;
           }
           
           /*
            *----------------------------------------------------------------------
            *
            * Tcl_CreateTrace --
            *
            *	Arrange for a procedure to be called to trace command execution.
            *
            * Results:
            *	The return value is a token for the trace, which may be passed
            *	to Tcl_DeleteTrace to eliminate the trace.
            *
            * Side effects:
            *	From now on, proc will be called just before a command procedure
            *	is called to execute a Tcl command.  Calls to callProc will have the
            *	following form:
            *
            *	void
            *	callProc(clientData, interp, frame)
            *	    ClientData clientData;
            *	    Tcl_Interp *interp;
            *	    Tcl_Frame *frame;
            *	{
            *	}
            *
            *	while those to returnProc will be:
            *
            *	void
            *	returnProc(clientData, interp, frame, result)
            *	    ClientData clientData;
            *	    Tcl_Interp interp;
            *	    Tcl_Frame *frame;
            *	    int result;
            *
            *	The clientData and interp arguments to both procs will be the same
            *	as the corresponding arguments to this procedure. frame is a pointer
            *	to a Tcl_Frame structure describing the current state of things.
            *	For returnProc, result is the integer returned by the command. Neither
            *	proc returns a value.
            *
            *----------------------------------------------------------------------
            */
           
           Tcl_Trace
           Tcl_CreateTrace(Tcl_Interp  *interp,		/* Interpreter in which to
           						 * create the trace. */
           		int	    level,		/* Only call proc for commands
           						 * at nesting level <= level (1
           						 * => top level, 0 => all
           						 * levels) */
           		Tcl_TraceCallProc   *callProc,	/* Procedure to call before
           						 * executing each command */
           	    	Tcl_TraceRetProc    *returnProc,/* Procedure to call after
           						 * executing each command */
           		ClientData  clientData)		/* Arbitrary one-word value to
           						 * pass to proc. */
           {
               register Trace *tracePtr;
               register Interp *iPtr = (Interp *) interp;
           
      2 ->     tracePtr = (Trace *) malloc(sizeof(Trace));
               tracePtr->level = level;
               tracePtr->callProc = callProc;
               tracePtr->returnProc = returnProc;
               tracePtr->clientData = clientData;
               tracePtr->nextPtr = iPtr->tracePtr;
               iPtr->tracePtr = tracePtr;
           
               return (Tcl_Trace) tracePtr;
           }
           
           /*
            *----------------------------------------------------------------------
            *
            * Tcl_DeleteTrace --
            *
            *	Remove a trace.
            *
            * Results:
            *	None.
            *
            * Side effects:
            *	From now on there will be no more calls to the procedure given
            *	in trace.
            *
            *----------------------------------------------------------------------
            */
           
           void
           Tcl_DeleteTrace(Tcl_Interp  *interp,	/* Interpreter that contains trace. */
           		Tcl_Trace   trace)	/* Token for trace (returned previously
           					 * by Tcl_CreateTrace). */
           {
  ##### ->     register Interp *iPtr = (Interp *) interp;
               register Trace *tracePtr = (Trace *) trace;
               register Trace *tracePtr2;
           
               if (iPtr->tracePtr == tracePtr) {
  ##### -> 	iPtr->tracePtr = tracePtr->nextPtr;
           	free((char *) tracePtr);
               } else {
  ##### -> 	for (tracePtr2 = iPtr->tracePtr;
           	     tracePtr2 != NULL;
  ##### -> 	     tracePtr2 = tracePtr2->nextPtr)
           	{
  ##### -> 	    if (tracePtr2->nextPtr == tracePtr) {
  ##### -> 		tracePtr2->nextPtr = tracePtr->nextPtr;
  ##### -> 		free((char *) tracePtr);
           		return;
           	    }
           	}
               }
           }
           
           /*
            *----------------------------------------------------------------------
            *
            * TclFindCmd --
            *
            *	Find a particular command in an interpreter.
            *
            * Results:
            *	If the command doesn't exist in the table then NULL is returned.
            *	Otherwise the return value is a pointer to the command.
            *
            * Side effects:
            *	If the command is found, it is relinked at the front of iPtr's
            *	command list so it will be found more quickly in the future.
            *
            *----------------------------------------------------------------------
            */
           
           Command *
           TclFindCmd(Interp   *iPtr,	/* Interpreter in which to search. */
           	   const char *cmdName,	/* Desired command. */
           	   int      exact)  	/* Non-zero if an exact match is required */
 129861 -> {
               register Command *prev;
               register Command *cur;
               register Command *match, *matchPrev;
               register int cmdLen;
               register char c;
               int	err;
           
           
               c = *cmdName;
               cmdLen = strlen(cmdName);
               match = (Command *)NULL;
               err = 0;
           
               /*
                * (re-)initialize the result
                */
               if (iPtr->dynamic) {
    117 -> 	free((char *) iPtr->result);
           	iPtr->dynamic = 0;
               }
               
 129861 ->     iPtr->result = iPtr->resultSpace;
               iPtr->resultSpace[0] = 0;
               
 129859 ->     for (prev = NULL, cur = iPtr->commandPtr; cur != NULL;
2015952 -> 	 prev = cur, cur = cur->nextPtr)
               {
           	/*
           	 * Check the first character here before wasting time calling
           	 * strcmp.
           	 */
           
           	if ((cur->name[0] == c) &&
2143301,  298966 -> 	    (strncmp(cur->name, cmdName, cmdLen) == 0))
           	{
 130481 -> 	    if (strlen(cur->name) == cmdLen) {
           		/*
           		 * Prefer an exact match if we can get it.
           		 */
 127349 -> 		match = cur;
           		matchPrev = prev;
           		if (err) {
           		    /*
           		     * Make sure we don't return an error
           		     */
  ##### -> 		    iPtr->resultSpace[0] = '\0';
           		    err = 0;
           		}
           		break;
   2557,    3132 -> 	    } else if (!exact && !(cur->flags & TCL_EXACT)) {
    856 -> 		if (match == (Command *)NULL) {
    856 -> 		    match = cur;
           		    matchPrev = prev;
           		} else {
  ##### -> 		    if (*iPtr->result == '\0') {
           			sprintf(iPtr->resultSpace,
           				"%.50s ambiguous. Matches: %s, %s",
  ##### -> 				cmdName, match->name, cur->name);
           			err = 1;
           		    } else {
           			/*
           			 * XXX: CATCH OVERRUN HERE
           			 */
  ##### -> 			strcat(iPtr->resultSpace, ", ");
           			strcat(iPtr->resultSpace, cur->name);
           		    }
           		}
           	    }
           	}
               }
           
 129861 ->     if (match == (Command *)NULL) {
           	sprintf(iPtr->resultSpace,
           		"invoked \"%.50s\", which isn't a valid command name",
   1661 -> 		cmdName);
           	return NULL;
 128200 ->     } else if (err) {
  ##### -> 	return NULL;
               }
           
               /*
                * Shift the command to the front of the list.
                */
 128200 ->     if (matchPrev != NULL) {
 122651 -> 	matchPrev->nextPtr = match->nextPtr;
           	match->nextPtr = iPtr->commandPtr;
           	iPtr->commandPtr = match;
               }
 128200 ->     return match;
           }


		 Top 10 Blocks

		 Line	   Count

		  764	11670837
		  764	11670568
		  764	11593409
		  765	11593409
		  767	11450536
		  769	11230235
		 1645	 2143301
		 1637	 2015952
		  744	 1714702
		  744	 1650689


	  352	Basic blocks in this file
	  212	Basic blocks executed
	60.23	Percent of the file executed

     103149850	Total basic block executions
     293039.34	Average executions per basic block
