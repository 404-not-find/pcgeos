*** /tmp/,RCSt1a26966	Sun Apr 14 19:28:51 1991
--- Makefile	Fri Apr  5 12:16:32 1991
***************
*** 1,56 ****
  #
! # This Makefile is for use when distributing Tcl to the outside world.
! # It is simplified so that it doesn't include any Sprite-specific stuff.
  #
  
- OBJS 		= tclBasic.o tclCmdAH.o tclCmdIZ.o tclExpr.o tclProc.o \
-                   tclUtil.o
  
! CSRCS 		= tclBasic.c tclCmdAH.c tclCmdIZ.c tclExpr.c tclProc.c \
!                   tclUtil.c
  
! CC		= gcc -fstrength-reduce -fcombine-regs -finline-functions
! CFLAGS		= -g -O
  
! #include	<makelib.mk>
  
! libtcl.a	: libtcl.a(${OBJS}) .EXPORTSAME			MAKELIB
! 	
! tags		: $(CSRCS)
! 	ctags -wt $(CSRCS)
  
! TAGS		: $(CSRCS)
! 	etags -wt $(CSRCS) *.h
  
! tclTest		: tcl.o libtcl.a .EXPORTSAME
! 	$(CC) $(CFLAGS) $(.ALLSRC) -o $(.TARGET)
! #ifdef is68k
! tclTest		: ../sys/libsys.a
  #endif
  
! tsh		: tsh.o libtcl.a .EXPORTSAME
! 	$(CC) $(CFLAGS) $(.ALLSRC) -o $(.TARGET)
  
! # DO NOT DELETE THIS LINE -- make depend depends on it.
  
! tcl.o: /usr/include/stdio.h /usr/include/sys/time.h tcl.h
! tclBasic.o: /usr/include/stdio.h /usr/include/ctype.h tclInt.h tcl.h
! tclCmd.o: /usr/include/ctype.h /usr/include/signal.h /usr/include/stdio.h
! tclCmd.o: /usr/include/sys/types.h /usr/include/sys/errno.h
! tclCmd.o: /usr/include/sys/file.h /usr/include/sys/fcntl.h
! tclCmd.o: /usr/include/sys/stat.h /usr/include/sys/wait.h
! tclCmd.o: /usr/include/sys/time.h /usr/include/sys/resource.h tclInt.h tcl.h
! tclCmdAH.o: /usr/include/ctype.h /usr/include/signal.h /usr/include/stdio.h
! tclCmdAH.o: /usr/include/sys/types.h /usr/include/sys/errno.h
! tclCmdAH.o: /usr/include/sys/file.h /usr/include/sys/fcntl.h
! tclCmdAH.o: /usr/include/sys/stat.h /usr/include/sys/time.h
! tclCmdAH.o: /usr/include/sys/resource.h /usr/include/sys/wait.h tclInt.h
! tclCmdAH.o: tcl.h
! tclCmdIZ.o: /usr/include/ctype.h /usr/include/stdio.h
! tclCmdIZ.o: /usr/include/sys/types.h /usr/include/sys/file.h
! tclCmdIZ.o: /usr/include/sys/fcntl.h /usr/include/sys/stat.h
! tclCmdIZ.o: /usr/include/sys/time.h tclInt.h tcl.h
! tclExpr.o: /usr/include/stdio.h /usr/include/ctype.h tcl.h
! tclProc.o: /usr/include/stdio.h /usr/include/ctype.h tclInt.h tcl.h
! tclUtil.o: /usr/include/ctype.h tcl.h tclInt.h /usr/include/stdio.h
! tclUtil.o: /usr/include/varargs.h
--- 1,97 ----
+ ##############################################################################
  #
! # 	Copyright (c) Berkeley Softworks 1989 -- All Rights Reserved
  #
+ # PROJECT:	PC GEOS
+ # MODULE:	tcl -- Makefile
+ # FILE: 	Makefile
+ # AUTHOR: 	Adam de Boor, Fri Apr  5 12:16:27 PST 1991
+ #
+ # TARGETS:
+ # 	Name			Description
+ #	----			-----------
+ #	all			create the tool for all possible architectures
+ #	install			create and install for all architectures
+ #	depend			generate dependencies for all architectures
+ #	isi                     create tool for isi 
+ #	installisi              create and install tool for isi 
+ #	dependisi               generate dependencies for isi 
+ #	sparc                   create tool for sparc 
+ #	installsparc            create and install tool for sparc 
+ #	dependsparc             generate dependencies for sparc 
+ #	sun3                    create tool for sun3 
+ #	installsun3             create and install tool for sun3 
+ #	dependsun3              generate dependencies for sun3 
+ #
+ # DESCRIPTION:
+ #	This makefile was automatically generated from:
+ #	    /staff/pcgeos/Tools/mkmf/Makefile.tool
+ #
+ #	DO NOT EDIT IT, AS YOU MAY LOSE YOUR CHANGES WHEN IT IS REGENERATED
+ #
+ #	$Id: Makefile.tool,v 1.2 89/07/20 15:48:08 adam Exp $
+ #
+ ###############################################################################
  
  
! #include	<geos.mk>
! #include	<gpath.mk>
  
! MACHINES	=  isi sparc sun3
! MAKEFILE	= Makefile
! NAME		= tcl
! SYSMAKEFILE	= tool.mk
! TYPE		= tool
  
! #if	defined(sun) && defined(sparc)
! DEFTARGET	= sparc
! #elif	defined(sun)
! DEFTARGET	= sun3
! #else
! DEFTARGET	= isi
! #endif
  
! MISRCS          = tcl.c tcl.h tclBasic.c tclCmdAH.c tclCmdIZ.c tclExpr.c\
!                   tclInt.h tclProc.c tclUtil.c tsh.c
  
! isiSRCS         = $(MISRCS) isi.md/
! isiOBJS         = isi.md/tcl.o isi.md/tclBasic.o isi.md/tclCmdAH.o\
!                   isi.md/tclCmdIZ.o isi.md/tclExpr.o isi.md/tclProc.o\
!                   isi.md/tclUtil.o isi.md/tsh.o
! isiLIBS         =
  
! sparcSRCS       = $(MISRCS) sparc.md/
! sparcOBJS       = sparc.md/tcl.o sparc.md/tclBasic.o sparc.md/tclCmdAH.o\
!                   sparc.md/tclCmdIZ.o sparc.md/tclExpr.o sparc.md/tclProc.o\
!                   sparc.md/tclUtil.o sparc.md/tsh.o
! sparcLIBS       =
! 
! sun3SRCS        = $(MISRCS) sun3.md/
! sun3OBJS        = sun3.md/tcl.o sun3.md/tclBasic.o sun3.md/tclCmdAH.o\
!                   sun3.md/tclCmdIZ.o sun3.md/tclExpr.o sun3.md/tclProc.o\
!                   sun3.md/tclUtil.o sun3.md/tsh.o
! sun3LIBS        =
! 
! 
! SUBDIRS         = New
! 
! #if exists(local.mk)
! #include	"local.mk"
! #else
! #include	<$(SYSMAKEFILE)>
  #endif
  
! #if	exists(isi.md/dependencies.mk)
! #include	"isi.md/dependencies.mk"
! #endif
  
! #if	exists(sparc.md/dependencies.mk)
! #include	"sparc.md/dependencies.mk"
! #endif
  
! #if	exists(sun3.md/dependencies.mk)
! #include	"sun3.md/dependencies.mk"
! #endif
! 
! 
! # Allow mkmf
No differences encountered
*** /tmp/,RCSt1a26966	Sun Apr 14 19:28:52 1991
--- local.mk	Mon Nov 26 20:19:43 1990
***************
*** 19,25 ****
  # DESCRIPTION:
  #	
  #
! #	$Id: local.mk,v 1.2.4.1 91/01/25 22:47:40 adam Exp $
  #
  ###############################################################################
  
--- 19,25 ----
  # DESCRIPTION:
  #	
  #
! #	$Id: local.mk,v 1.2 89/09/13 13:34:06 adam Exp Locker: adam $
  #
  ###############################################################################
  
*** /tmp/,RCSt1a26966	Sun Apr 14 19:28:53 1991
--- tcl.c	Mon Nov 26 20:19:36 1990
***************
*** 15,21 ****
   */
  
  #ifndef lint
! static char rcsid[] = "$Id: tcl.c,v 1.6.4.1 91/01/25 22:47:32 adam Exp $ SPRITE (Berkeley)";
  #endif not lint
  
  #include <stdio.h>
--- 15,21 ----
   */
  
  #ifndef lint
! static char rcsid[] = "$Id: tcl.c,v 1.6 89/03/14 11:49:34 adam Exp $ SPRITE (Berkeley)";
  #endif not lint
  
  #include <stdio.h>
*** /tmp/,RCSt1a26966	Sun Apr 14 19:28:54 1991
--- tcl.h	Fri Apr  5 11:18:30 1991
***************
*** 13,19 ****
   * software for any purpose.  It is provided "as is" without
   * express or implied warranty.
   *
!  * $Id: tcl.h,v 1.29.4.1 91/01/25 22:47:13 adam Exp $ SPRITE (Berkeley)
   */
  
  #ifndef _TCL
--- 13,19 ----
   * software for any purpose.  It is provided "as is" without
   * express or implied warranty.
   *
!  * $Id: tcl.h,v 1.30 91/04/05 11:18:24 adam Exp $ SPRITE (Berkeley)
   */
  
  #ifndef _TCL
***************
*** 41,47 ****
   */
  
  typedef struct {
!     char *result;		/* Points to result string returned by last
  				 * command. */
      int dynamic;		/* Non-zero means result is dynamically-
  				 * allocated and must be freed by Tcl_Eval
--- 41,47 ----
   */
  
  typedef struct {
!     const char *result;		/* Points to result string returned by last
  				 * command. */
      int dynamic;		/* Non-zero means result is dynamically-
  				 * allocated and must be freed by Tcl_Eval
***************
*** 57,63 ****
  
  typedef struct _TclFrame {
      int	    	    	level;      /* Frame's level */
!     char    	    	*command;   /* Command being executed */
      Tcl_CmdProc	    	*cmdProc;   /* Handling function */
      int	    	    	cmdFlags;   /* Flags for the command */
      ClientData	    	cmdData;    /* Data for same */
--- 57,63 ----
  
  typedef struct _TclFrame {
      int	    	    	level;      /* Frame's level */
!     const char 	    	*command;   /* Command being executed */
      Tcl_CmdProc	    	*cmdProc;   /* Handling function */
      int	    	    	cmdFlags;   /* Flags for the command */
      ClientData	    	cmdData;    /* Data for same */
***************
*** 120,138 ****
  				 * invoked */
  #define TCL_PROC    	2   	/* If command is user-defined (i.e. a "proc")*/
  #define TCL_DEBUG   	4   	/* Procedure being debugged */
  
  /*
!  * Exported Tcl procedures:
!  */
! extern char		Tcl_Backslash(char *src, int *readPtr);
  extern void		Tcl_CreateCommand(Tcl_Interp *interp,
! 					  char *cmdName,
  					  Tcl_CmdProc *proc,
  					  int flags,
  					  ClientData clientData,
  					  Tcl_DelProc *deleteProc);
  extern int		Tcl_OverrideCommand(Tcl_Interp *interp,
! 					    char *cmdName,
  					    Tcl_CmdProc *cmdProc,
  					    int flags,
  					    ClientData clientData,
--- 120,141 ----
  				 * invoked */
  #define TCL_PROC    	2   	/* If command is user-defined (i.e. a "proc")*/
  #define TCL_DEBUG   	4   	/* Procedure being debugged */
+ #define TCL_NOEVAL  	8   	/* Do not evaluate arguments, variable or
+ 				 * nested command or otherwise. Equivalent to
+ 				 * lisp "lexpr" */
  
  /*
!  * Exported Tcl procedures: 
! */
! extern char		Tcl_Backslash(const char *src, int *readPtr);
  extern void		Tcl_CreateCommand(Tcl_Interp *interp,
! 					  const char *cmdName,
  					  Tcl_CmdProc *proc,
  					  int flags,
  					  ClientData clientData,
  					  Tcl_DelProc *deleteProc);
  extern int		Tcl_OverrideCommand(Tcl_Interp *interp,
! 					    const char *cmdName,
  					    Tcl_CmdProc *cmdProc,
  					    int flags,
  					    ClientData clientData,
***************
*** 142,152 ****
  					    ClientData *clientDataPtr,
  					    Tcl_DelProc **deleteProcPtr);
  extern int		Tcl_FetchCommand(Tcl_Interp *interp,
! 					 char *cmdName,
  					 Tcl_CmdProc **cmdProcPtr,
  					 int *flagsPtr,
  					 ClientData *clientDataPtr,
! 					 void (**deleteProcPtr)());
  extern Tcl_Interp *	Tcl_CreateInterp();
  extern void		Tcl_TopLevel(Tcl_Interp *interp);
  extern Tcl_Trace	Tcl_CreateTrace(Tcl_Interp *interp,
--- 145,155 ----
  					    ClientData *clientDataPtr,
  					    Tcl_DelProc **deleteProcPtr);
  extern int		Tcl_FetchCommand(Tcl_Interp *interp,
! 					 const char *cmdName,
  					 Tcl_CmdProc **cmdProcPtr,
  					 int *flagsPtr,
  					 ClientData *clientDataPtr,
! 					 Tcl_DelProc **deleteProcPtr);
  extern Tcl_Interp *	Tcl_CreateInterp();
  extern void		Tcl_TopLevel(Tcl_Interp *interp);
  extern Tcl_Trace	Tcl_CreateTrace(Tcl_Interp *interp,
***************
*** 155,193 ****
  					Tcl_TraceRetProc *returnProc,
  					ClientData clientData);
  extern void		Tcl_DeleteCommand(Tcl_Interp *interp,
! 					  char *cmdName);
  extern void		Tcl_DeleteInterp(Tcl_Interp *interp);
  extern void		Tcl_DeleteTrace(Tcl_Interp *interp,
  					Tcl_Trace trace);
  extern int		Tcl_Eval(Tcl_Interp *interp,
! 				 char *cmd,
  				 char termChar,
! 				 char **termPtr);
  extern int		Tcl_Expr(Tcl_Interp *interp,
! 				 char *string,
  				 int *valuePtr);
! extern char *		Tcl_GetVar(Tcl_Interp *interp,
! 				   char *varName,
  				   int global);
! extern char *		Tcl_Merge(int argc, char **argv);
! extern char *		Tcl_ParseVar(Tcl_Interp *,
! 				     char *string,
! 				     char **termPtr);
  extern void		Tcl_Return(Tcl_Interp *interp,
! 				   char *string,
  				   int status);
  extern void 	    	Tcl_RetPrintf(Tcl_Interp *interp,
! 				      char *format,
  				      ...);
  extern void		Tcl_SetVar(Tcl_Interp *interp,
! 				   char *varName,
! 				   char *newValue,
  				   int global);
  extern int		Tcl_SplitList(Tcl_Interp *interp,
! 				      char *list,
  				      int *argcPtr,
  				      char ***argvPtr);
! extern int  	    	Tcl_StringMatch(char *string, char *pattern);
  extern Tcl_Frame    	*Tcl_CurrentFrame(Tcl_Interp *interp);
  
  /*
--- 158,200 ----
  					Tcl_TraceRetProc *returnProc,
  					ClientData clientData);
  extern void		Tcl_DeleteCommand(Tcl_Interp *interp,
! 					  const char *cmdName);
  extern void		Tcl_DeleteInterp(Tcl_Interp *interp);
  extern void		Tcl_DeleteTrace(Tcl_Interp *interp,
  					Tcl_Trace trace);
  extern int		Tcl_Eval(Tcl_Interp *interp,
! 				 const char *cmd,
  				 char termChar,
! 				 const char **termPtr);
  extern int		Tcl_Expr(Tcl_Interp *interp,
! 				 const char *string,
  				 int *valuePtr);
! extern int		Tcl_FExpr(Tcl_Interp *interp,
! 				 const char *string,
! 				 double *valuePtr);
! extern const char *	Tcl_GetVar(Tcl_Interp *interp,
! 				   const char *varName,
  				   int global);
! extern char *		Tcl_Merge(int argc, const char * const *argv);
! extern const char *	Tcl_ParseVar(Tcl_Interp *,
! 				     const char *string,
! 				     const char **termPtr);
  extern void		Tcl_Return(Tcl_Interp *interp,
! 				   const char *string,
  				   int status);
  extern void 	    	Tcl_RetPrintf(Tcl_Interp *interp,
! 				      const char *format,
  				      ...);
  extern void		Tcl_SetVar(Tcl_Interp *interp,
! 				   const char *varName,
! 				   const char *newValue,
  				   int global);
  extern int		Tcl_SplitList(Tcl_Interp *interp,
! 				      const char *list,
  				      int *argcPtr,
  				      char ***argvPtr);
! extern int  	    	Tcl_StringMatch(const char *string,
! 					const char *pattern);
  extern Tcl_Frame    	*Tcl_CurrentFrame(Tcl_Interp *interp);
  
  /*
*** /tmp/,RCSt1a26966	Sun Apr 14 19:28:55 1991
--- tclBasic.c	Sat Apr  6 14:31:57 1991
***************
*** 16,22 ****
   */
  
  #ifndef lint
! static char *rcsid = "$Id: tclBasic.c,v 1.54.4.1 91/01/25 22:47:44 adam Exp $ SPRITE (Berkeley)";
  #endif not lint
  
  #include <stdio.h>
--- 16,22 ----
   */
  
  #ifndef lint
! static char *rcsid = "$Id: tclBasic.c,v 1.56 91/04/06 14:31:42 adam Exp $ SPRITE (Berkeley)";
  #endif not lint
  
  #include <stdio.h>
***************
*** 386,392 ****
  						 * interpreter (returned by
  						 * a previous call to
  						 * Tcl_CreateInterp). */
! 		  char		*cmdName,	/* Name of command. */
  		  Tcl_CmdProc	*proc,	    	/* Command procedure to
  						 * associate with cmdName. */
  		  int	    	flags,	    	/* Flags for the command
--- 386,392 ----
  						 * interpreter (returned by
  						 * a previous call to
  						 * Tcl_CreateInterp). */
! 		  const char	*cmdName,	/* Name of command. */
  		  Tcl_CmdProc	*proc,	    	/* Command procedure to
  						 * associate with cmdName. */
  		  int	    	flags,	    	/* Flags for the command
***************
*** 436,457 ****
   */
  int
  Tcl_OverrideCommand(Tcl_Interp	*interp,
! 		    char	*cmdName,
! 		    Tcl_CmdProc	*cmdProc,		/* Command procedure to
! 							 * associate with
! 							 * cmdName. */
! 		    int	    	flags,	    	    	/* New flags */
! 		    ClientData	clientData,		/* Arbitrary one-word
! 							 * value to pass to
! 							 * proc. */
! 		    Tcl_DelProc	*deleteProc,    	/* If not NULL, gives a
! 							 * procedure to call
! 							 * when this command
! 							 * is deleted.*/
! 		    Tcl_CmdProc	**cmdProcPtr,
! 		    int	    	*flagsPtr,
! 		    ClientData	*clientDataPtr,
! 		    Tcl_DelProc	**deleteProcPtr)
  {
      register Command 	*cmdPtr;
  
--- 436,456 ----
   */
  int
  Tcl_OverrideCommand(Tcl_Interp	*interp,
! 		    const char	*cmdName,   	    /* Name of command to
! 						     * change */
! 		    Tcl_CmdProc	*cmdProc,	    /* Command procedure to
! 						     * associate with cmdName.*/
! 		    int	    	flags,	    	    /* New flags */
! 		    ClientData	clientData,	    /* Arbitrary one-word value
! 						     * to pass to proc. */
! 		    Tcl_DelProc	*deleteProc,        /* If not NULL, gives a
! 						     * procedure to call when
! 						     * this command is deleted*/
! 		    Tcl_CmdProc	**cmdProcPtr,	    /* Place to store old
! 						     * handler */
! 		    int	    	*flagsPtr,  	    /* Storage for old flags */
! 		    ClientData	*clientDataPtr,	    /* Storage for old CD */
! 		    Tcl_DelProc	**deleteProcPtr)    /* Storage for old delProc*/
  {
      register Command 	*cmdPtr;
  
***************
*** 493,499 ****
   */
  int
  Tcl_FetchCommand(Tcl_Interp 	*interp,
! 		 char	    	*cmdName,
  		 Tcl_CmdProc 	**cmdProcPtr,
  		 int	    	*flagsPtr,
  		 ClientData 	*clientDataPtr,
--- 492,498 ----
   */
  int
  Tcl_FetchCommand(Tcl_Interp 	*interp,
! 		 const char    	*cmdName,
  		 Tcl_CmdProc 	**cmdProcPtr,
  		 int	    	*flagsPtr,
  		 ClientData 	*clientDataPtr,
***************
*** 535,541 ****
  Tcl_DeleteCommand(Tcl_Interp	*interp,    /* Token for command interpreter
  					     * (returned by a previous call to
  					     * Tcl_CreateInterp). */
! 		  char		*cmdName)   /* Name of command to remove. */
  {
      Interp *iPtr = (Interp *) interp;
      Command *cmdPtr;
--- 534,540 ----
  Tcl_DeleteCommand(Tcl_Interp	*interp,    /* Token for command interpreter
  					     * (returned by a previous call to
  					     * Tcl_CreateInterp). */
! 		  const char	*cmdName)   /* Name of command to remove. */
  {
      Interp *iPtr = (Interp *) interp;
      Command *cmdPtr;
***************
*** 573,579 ****
  int
  Tcl_Eval(Tcl_Interp *interp,	/* Token for command interpreter (returned by a
  				 * previous call to Tcl_CreateInterp). */
! 	 char	    *cmd,	/* Pointer to TCL command to interpret. */
  	 char	    termChar,	/* Return when this character is found in the
  				 * command stream.  This is either 0, ']'.   If
  				 * termChar is 0, then individual commands are
--- 572,578 ----
  int
  Tcl_Eval(Tcl_Interp *interp,	/* Token for command interpreter (returned by a
  				 * previous call to Tcl_CreateInterp). */
! 	 const char *cmd,	/* Pointer to TCL command to interpret. */
  	 char	    termChar,	/* Return when this character is found in the
  				 * command stream.  This is either 0, ']'.   If
  				 * termChar is 0, then individual commands are
***************
*** 580,586 ****
  				 * terminated by newlines, although this
  				 * procedure doesn't return until it sees the
  				 * end of the string. */
! 	 char	    **termPtr)	/* If non-NULL, fill in the address it points
  				 * to with the address of the char. that
  				 * terminated cmd.  This character will be
  				 * either termChar or the null at the end of
--- 579,585 ----
  				 * terminated by newlines, although this
  				 * procedure doesn't return until it sees the
  				 * end of the string. */
! 	 const char **termPtr)	/* If non-NULL, fill in the address it points
  				 * to with the address of the char. that
  				 * terminated cmd.  This character will be
  				 * either termChar or the null at the end of
***************
*** 603,609 ****
  #   define BUFFER 5
      char    	    copyStorage[NUM_CHARS];
      char    	    *copy=copyStorage;	    /* Pointer to current copy. */
!     int     	    copySize = NUM_CHARS;   /* Size of current copy. */
      register char   *dst;		    /* Points to next place to copy
  					     * a character. */
      char    	    *limit;		    /* When dst gets here, must make
--- 602,608 ----
  #   define BUFFER 5
      char    	    copyStorage[NUM_CHARS];
      char    	    *copy=copyStorage;	    /* Pointer to current copy. */
!     unsigned   	    copySize = NUM_CHARS;   /* Size of current copy. */
      register char   *dst;		    /* Points to next place to copy
  					     * a character. */
      char    	    *limit;		    /* When dst gets here, must make
***************
*** 632,640 ****
  					 * there are at the current point in
  					 * the current argument */
  
!     register char   *src;		/* Points to current character
  					 * in cmd. */
!     char    	    *argStart;		/* Location in cmd of first character
  					 * in current argument;  it's used to
  					 * detect that nothing has been read
  					 * from the current argument. */
--- 631,639 ----
  					 * there are at the current point in
  					 * the current argument */
  
!     register const char   *src;		/* Points to current character
  					 * in cmd. */
!     const char 	    *argStart;		/* Location in cmd of first character
  					 * in current argument;  it's used to
  					 * detect that nothing has been read
  					 * from the current argument. */
***************
*** 641,649 ****
      int     	    result=TCL_OK;	/* Return value. */
      int     	    i;
      register Interp *iPtr = (Interp *) interp;
      Command 	    *cmdPtr;
!     char    	    *tmp;
!     char    	    *syntaxMsg;
      register Trace  *tracePtr;
      Frame   	    frame;  	    	/* Frame for this command */
  
--- 640,649 ----
      int     	    result=TCL_OK;	/* Return value. */
      int     	    i;
      register Interp *iPtr = (Interp *) interp;
+     const char 	    *errRes;
      Command 	    *cmdPtr;
!     const char 	    *tmp;
!     const char 	    *syntaxMsg;
      register Trace  *tracePtr;
      Frame   	    frame;  	    	/* Frame for this command */
  
***************
*** 677,682 ****
--- 677,683 ----
      } else {
  	frame.localPtr = &iPtr->globalFrame;
      }
+     cmdPtr = (Command *)NULL;
      iPtr->top = &frame;
      
      /*
***************
*** 841,847 ****
  
  		case '}': {
  		    if (openBraces == 1) {
! 			char *p;
  
  			openBraces = 0;
  
--- 842,848 ----
  
  		case '}': {
  		    if (openBraces == 1) {
! 			const char *p;
  
  			openBraces = 0;
  
***************
*** 908,914 ****
  			 */
  			copyResult:
  
! 			xxx = iPtr->result[0];/*XXX*/
  
  			if ((iPtr->dynamic ||
  			     (iPtr->result != iPtr->resultSpace)) &&
--- 909,915 ----
  			 */
  			copyResult:
  
! /*			xxx = iPtr->result[0];/*XXX*/
  
  			if ((iPtr->dynamic ||
  			     (iPtr->result != iPtr->resultSpace)) &&
***************
*** 924,930 ****
  			     * copying the thing to our local storage,
  			     * just use it directly.
  			     */
! 			    argv[argc] = iPtr->result;
  			    if (iPtr->dynamic) {
  				/*
  				 * If arg is dynamic, record that it needs
--- 925,931 ----
  			     * copying the thing to our local storage,
  			     * just use it directly.
  			     */
! 			    argv[argc] = (char *)iPtr->result;
  			    if (iPtr->dynamic) {
  				/*
  				 * If arg is dynamic, record that it needs
***************
*** 933,939 ****
  				 * on argv remaining the same during the
  				 * call.
  				 */
! 				frame.sepArgs[sepArgc++] = iPtr->result;
  				if (sepArgc == sepArgSize) {
  				    if (frame.sepArgs == sepArgStorage) {
  					frame.sepArgs =
--- 934,940 ----
  				 * on argv remaining the same during the
  				 * call.
  				 */
! 				frame.sepArgs[sepArgc++] = (char *)iPtr->result;
  				if (sepArgc == sepArgSize) {
  				    if (frame.sepArgs == sepArgStorage) {
  					frame.sepArgs =
***************
*** 1048,1053 ****
--- 1049,1055 ----
  			 */
      
  			*dst++ = 0;
+ 
  			argc++;
  			if (argc >= argSize-1) {
  			    argSize *= 2;
***************
*** 1076,1082 ****
  			    src++;
  			}
  			argStart = src+1;
! 			break;
  		    }
  		    break;
  		}
--- 1078,1182 ----
  			    src++;
  			}
  			argStart = src+1;
! 
! 			/*
! 			 * If this is the first arg, look up the associated
! 			 * command so we can deal with the TCL_NOEVAL flag.
! 			 * We don't handle a non-existent command at this
! 			 * level, though, as we need to get to the end
! 			 * of the command string.
! 			 */
! 			if (argc == 1) {
! 			    cmdPtr = TclFindCmd(iPtr, (const char *)argv[0], 0);
! 			    if (cmdPtr == NULL) {
! 				errRes = (char *)malloc(strlen(iPtr->result)+1);
! 				strcpy(errRes, iPtr->result);
! 			    } else if (cmdPtr->flags & TCL_NOEVAL) {
! 				int openBrackets=0; /* Count of nested open
! 						     * square brackets. */
! 				int len;
! 
! 				for (src++; *src != '\0'; src++) {
! 				    if (*src == '{') {
! 					openBraces++;
! 				    } else if (openBraces && *src == '}') {
! 					openBraces--;
! 				    } else if (!openBraces) {
! 					if (*src == '[') {
! 					    openBrackets++;
! 					} else if (*src == ']') {
! 					    if ((openBrackets-- == 0) &&
! 						(termChar == ']'))
! 					    {
! 						openBrackets = 0;
! 						break;
! 					    }
! 					} else if (!openBrackets &&
! 						   termChar == 0 &&
! 						   *src == '\n')
! 					{
! 					    break;
! 					}
! 				    }
! 				}
! 				if (openBraces) {
! 				    syntaxMsg = "unmatched brace";
! 				    goto syntaxError;
! 				} else if (openBrackets) {
! 				    syntaxMsg = "unmatched bracket";
! 				    goto syntaxError;
! 				} else if (termChar && (*src != termChar)) {
! 				    if (termChar == ']') {
! 					syntaxMsg = "unmatched bracket";
! 				    } 
! 				    goto syntaxError;
! 				}
! 				
! 				len = src-argStart;
! 
! 				if ((limit - dst) < len) {
! 				    /*
! 				     * Not enough room in dst for whole thing --
! 				     * enlarge copy to fit.
! 				     */
! 				    char    *newCopy;
! 				    int     delta;
! 				    char    **av;
! 				    
! 				    copySize = len + NUM_CHARS + (dst - copy);
! 				    
! 				    newCopy = (char *) malloc(copySize);
! 				    bcopy(copy, newCopy, (dst-copy));
! 				    
! 				    delta = newCopy - copy;
! 				    dst += delta;
! 				    for (av = &argv[argc]; av >= argv; av--) {
! 					if (*av >= copy && *av <= limit) {
! 					    *av += delta;
! 					}
! 				    }
! 				    
! 				    if (copy != copyStorage) {
! 					free((char *) copy);
! 				    }
! 				    
! 				    frame.copyStart = copy = newCopy;
! 				    frame.copyEnd = limit =
! 					newCopy + copySize - BUFFER;
! 				    frame.ext.flags |= TCL_FRAME_FREE_ARGS;
! 				}
! 				
! 				/*
! 				 * Copy the thing into the destination
! 				 */
! 				bcopy(argStart, dst, len);
! 				dst += len;
! 				
! 				/* This'll null-terminate the arg for us... */
! 				goto cmdComplete;
! 			    }
! 
! 			}
  		    }
  		    break;
  		}
***************
*** 1200,1208 ****
  	iPtr->result = iPtr->resultSpace;
  	iPtr->resultSpace[0] = 0;
  
! 	cmdPtr = TclFindCmd(iPtr, argv[0], 0);
  	if (cmdPtr == NULL) {
  	    result = TCL_ERROR;
  	    goto done;
  	}
  
--- 1300,1317 ----
  	iPtr->result = iPtr->resultSpace;
  	iPtr->resultSpace[0] = 0;
  
! 	/*
! 	 * If only the command for an argument, need to locate the cmdPtr here,
! 	 * else it's done when the first arg is terminated.
! 	 */
! 	if (argc == 1) {
! 	    cmdPtr = TclFindCmd(iPtr, (const char *)argv[0], 0);
! 	}
! 
  	if (cmdPtr == NULL) {
  	    result = TCL_ERROR;
+ 	    iPtr->result = errRes;
+ 	    iPtr->dynamic = 1;
  	    goto done;
  	}
  
***************
*** 1309,1315 ****
       */
  
      syntaxError: {
! 	char *first, *last;
  
  	for (first = src; ((first != cmd) && (first[-1] != '\n')); first--) {
  	    /* Null loop body. */
--- 1418,1424 ----
       */
  
      syntaxError: {
! 	const char *first, *last;
  
  	for (first = src; ((first != cmd) && (first[-1] != '\n')); first--) {
  	    /* Null loop body. */
***************
*** 1326,1333 ****
  	if (last == first) {
  	    Tcl_RetPrintf(interp, "%s", syntaxMsg);
  	} else {
! 	    Tcl_RetPrintf(interp, "%s:\n%.*s\n%*s", syntaxMsg,
! 			  last-first, first, src+1-first, "^");
  	}
  	result = TCL_ERROR;
      }
--- 1435,1475 ----
  	if (last == first) {
  	    Tcl_RetPrintf(interp, "%s", syntaxMsg);
  	} else {
! 	    /*
! 	     * We need to make sure the caret lines up with the place of
! 	     * error by using tab characters wherever the source string
! 	     * uses them, and spaces everywhere else.
! 	     */
! 	    char	*cp;
! 	    char	*cp2;
! 
! 	    Tcl_Return(interp, NULL, TCL_STATIC);
! 
! 	    strcpy(iPtr->resultSpace, syntaxMsg);
! 	    cp = iPtr->resultSpace + strlen(syntaxMsg);
! 
! 	    *cp++ = '\n';
! 	    cp2 = cp + (last-first);
! 	    *cp2++ = '\n';
! 
! 	    while (first != last) {
! 		if (first <= src) {
! 		    if (*first != '\t') {
! 			*cp2++ = ' ';
! 		    } else {
! 			*cp2++ = '\t';
! 		    }
! 		    if (first == src) {
! 			*cp2++ = '^';
! 			*cp2++ = '\0';
! 		    }
! 		}
! 		*cp++ = *first++;
! 	    }
! 	    if (first == src) {
! 		*cp2++ = '^';
! 		*cp2++ = '\0';
! 	    }
  	}
  	result = TCL_ERROR;
      }
***************
*** 1468,1474 ****
  
  Command *
  TclFindCmd(Interp   *iPtr,	/* Interpreter in which to search. */
! 	   char	    *cmdName,	/* Desired command. */
  	   int      exact)  	/* Non-zero if an exact match is required */
  {
      register Command *prev;
--- 1610,1616 ----
  
  Command *
  TclFindCmd(Interp   *iPtr,	/* Interpreter in which to search. */
! 	   const char *cmdName,	/* Desired command. */
  	   int      exact)  	/* Non-zero if an exact match is required */
  {
      register Command *prev;
***************
*** 1516,1522 ****
  		    /*
  		     * Make sure we don't return an error
  		     */
! 		    *iPtr->result = '\0';
  		    err = 0;
  		}
  		break;
--- 1658,1664 ----
  		    /*
  		     * Make sure we don't return an error
  		     */
! 		    iPtr->resultSpace[0] = '\0';
  		    err = 0;
  		}
  		break;
*** /tmp/,RCSt1a26966	Sun Apr 14 19:28:58 1991
--- tclCmdAH.c	Fri Apr  5 11:17:32 1991
***************
*** 16,22 ****
   */
  
  #ifndef lint
! static char *rcsid = "$Id: tclCmdAH.c,v 1.35.4.1 91/01/25 22:47:22 adam Exp $ SPRITE (Berkeley)";
  #endif not lint
  
  #include <ctype.h>
--- 16,22 ----
   */
  
  #ifndef lint
! static char *rcsid = "$Id: tclCmdAH.c,v 1.36 91/04/05 11:17:25 adam Exp $ SPRITE (Berkeley)";
  #endif not lint
  
  #include <ctype.h>
***************
*** 244,250 ****
  		      argv[0]);
  	return TCL_ERROR;
      }
!     result = Tcl_Eval(interp, argv[1], 0, (char **) NULL);
      if (argc == 3) {
  	Tcl_SetVar(interp, argv[2], interp->result, 0);
      }
--- 244,250 ----
  		      argv[0]);
  	return TCL_ERROR;
      }
!     result = Tcl_Eval(interp, argv[1], 0, (const char **) NULL);
      if (argc == 3) {
  	Tcl_SetVar(interp, argv[2], interp->result, 0);
      }
***************
*** 286,293 ****
      for (totalSize = 1, i = 1; i < argc; i++) {
  	totalSize += strlen(argv[i]) + 1;
      }
!     Tcl_Return(interp, malloc((unsigned) totalSize), TCL_DYNAMIC);
!     for (p = interp->result, i = 1; i < argc; i++) {
  	int len;
  	
  	if (*argv[i] == 0) {
--- 286,294 ----
      for (totalSize = 1, i = 1; i < argc; i++) {
  	totalSize += strlen(argv[i]) + 1;
      }
!     p = malloc((unsigned) totalSize);
!     Tcl_Return(interp, p, TCL_DYNAMIC);
!     for (i = 1; i < argc; i++) {
  	int len;
  	
  	if (*argv[i] == 0) {
***************
*** 398,404 ****
  		      argv[0]);
  	return TCL_ERROR;
      }
!     result = Tcl_Eval(interp, argv[1], 0, (char **) NULL);
      return result;
  }
  
--- 399,405 ----
  		      argv[0]);
  	return TCL_ERROR;
      }
!     result = Tcl_Eval(interp, argv[1], 0, (const char **) NULL);
      return result;
  }
  
***************
*** 1163,1169 ****
  	return TCL_ERROR;
      }
  
!     result = Tcl_Eval(interp, argv[1], 0, (char **) NULL);
      if (result != TCL_OK) {
  	return result;
      }
--- 1164,1170 ----
  	return TCL_ERROR;
      }
  
!     result = Tcl_Eval(interp, argv[1], 0, (const char **) NULL);
      if (result != TCL_OK) {
  	return result;
      }
***************
*** 1175,1187 ****
  	if (!value) {
  	    break;
  	}
! 	result = Tcl_Eval(interp, argv[4], 0, (char **) NULL);
  	if (result == TCL_CONTINUE) {
  	    result = TCL_OK;
  	} else if (result != TCL_OK) {
  	    break;
  	}
! 	result = Tcl_Eval(interp, argv[3], 0, (char **) NULL);
  	if (result == TCL_BREAK) {
  	    break;
  	} else if (result != TCL_OK) {
--- 1176,1188 ----
  	if (!value) {
  	    break;
  	}
! 	result = Tcl_Eval(interp, argv[4], 0, (const char **) NULL);
  	if (result == TCL_CONTINUE) {
  	    result = TCL_OK;
  	} else if (result != TCL_OK) {
  	    break;
  	}
! 	result = Tcl_Eval(interp, argv[3], 0, (const char **) NULL);
  	if (result == TCL_BREAK) {
  	    break;
  	} else if (result != TCL_OK) {
***************
*** 1243,1249 ****
      for (i = 0; i < listArgc; i++) {
  	Tcl_SetVar(interp, argv[1], listArgv[i], 0);
  
! 	result = Tcl_Eval(interp, argv[3], 0, (char **) NULL);
  	if (result != TCL_OK) {
  	    if (result == TCL_CONTINUE) {
  		result = TCL_OK;
--- 1244,1250 ----
      for (i = 0; i < listArgc; i++) {
  	Tcl_SetVar(interp, argv[1], listArgv[i], 0);
  
! 	result = Tcl_Eval(interp, argv[3], 0, (const char **) NULL);
  	if (result != TCL_OK) {
  	    if (result == TCL_CONTINUE) {
  		result = TCL_OK;
***************
*** 1302,1308 ****
  				 * it's a two-word value. */
      int useTwoWords;		/* 0 means use oneWordValue, 1 means use
  				 * twoWordValue. */
!     char *dst;			 /* Where result is stored.  Starts off at
  				 * interp->resultSpace, but may get dynamically
  				 * re-allocated if this isn't enough. */
      int dstSize = 0;		/* Number of non-null characters currently
--- 1303,1309 ----
  				 * it's a two-word value. */
      int useTwoWords;		/* 0 means use oneWordValue, 1 means use
  				 * twoWordValue. */
!     char *dst;			/* Where result is stored.  Starts off at
  				 * interp->resultSpace, but may get dynamically
  				 * re-allocated if this isn't enough. */
      int dstSize = 0;		/* Number of non-null characters currently
***************
*** 1318,1324 ****
       * Make sure pointing at resultSpace
       */
      Tcl_Return(interp, NULL, TCL_STATIC);
!     dst = interp->result;
  
      /*
       * This procedure is a bit nasty.  The goal is to use sprintf to
--- 1319,1325 ----
       * Make sure pointing at resultSpace
       */
      Tcl_Return(interp, NULL, TCL_STATIC);
!     dst = (char *)interp->result;
  
      /*
       * This procedure is a bit nasty.  The goal is to use sprintf to
*** /tmp/,RCSt1a26966	Sun Apr 14 19:29:00 1991
--- tclCmdIZ.c	Fri Apr  5 11:17:44 1991
***************
*** 16,22 ****
   */
  
  #ifndef lint
! static char *rcsid = "$Id: tclCmdIZ.c,v 1.24.4.1 91/01/25 22:47:19 adam Exp $ SPRITE (Berkeley)";
  #endif not lint
  
  #include <ctype.h>
--- 16,22 ----
   */
  
  #ifndef lint
! static char *rcsid = "$Id: tclCmdIZ.c,v 1.25 91/04/05 11:17:36 adam Exp $ SPRITE (Berkeley)";
  #endif not lint
  
  #include <ctype.h>
***************
*** 62,68 ****
  	  int		argc,	    /* Number of arguments. */
  	  char		**argv)	    /* Argument strings. */
  {
!     char *condition, *elsePart, *cmd, *name;
      int result, value;
  
      name = argv[0];
--- 62,68 ----
  	  int		argc,	    /* Number of arguments. */
  	  char		**argv)	    /* Argument strings. */
  {
!     const char *condition, *elsePart, *cmd, *name;
      int result, value;
  
      name = argv[0];
***************
*** 176,182 ****
  	Tcl_RetPrintf(interp, "%d", value);
  	return(TCL_OK);
      } else {
! 	return(Tcl_Eval(interp, cmd, 0, (char **) NULL));
      }
  }
  
--- 176,182 ----
  	Tcl_RetPrintf(interp, "%d", value);
  	return(TCL_OK);
      } else {
! 	return(Tcl_Eval(interp, cmd, 0, (const char **) NULL));
      }
  }
  
***************
*** 204,210 ****
  	     int	argc,	    /* Number of arguments. */
  	     char	**argv)	    /* Argument strings. */
  {
!     char *p, *element;
      int index, size, parenthesized, result;
  
      if (argc < 3) {
--- 204,210 ----
  	     int	argc,	    /* Number of arguments. */
  	     char	**argv)	    /* Argument strings. */
  {
!     const char *p, *element;
      int index, size, parenthesized, result;
  
      if (argc < 3) {
***************
*** 236,244 ****
  	}
  	if (parenthesized) {
  	    bcopy(element, interp->result, size);
! 	    interp->result[size] = 0;
  	} else {
! 	    TclCopyAndCollapse(size, element, interp->result);
  	}
      } else if ((argc == 4) &&
  	       (strncmp(argv[3], "chars", strlen(argv[3])) == 0))
--- 236,244 ----
  	}
  	if (parenthesized) {
  	    bcopy(element, interp->result, size);
! 	    ((char *)interp->result)[size] = 0;
  	} else {
! 	    TclCopyAndCollapse(size, element, (char *)interp->result);
  	}
      } else if ((argc == 4) &&
  	       (strncmp(argv[3], "chars", strlen(argv[3])) == 0))
***************
*** 248,255 ****
  	    goto badIndex;
  	}
  	Tcl_Return(interp, NULL, TCL_STATIC);
! 	interp->result[0] = p[index];
! 	interp->result[1] = '\0';
      } else {
  	goto indexSyntax;
      }
--- 248,255 ----
  	    goto badIndex;
  	}
  	Tcl_Return(interp, NULL, TCL_STATIC);
! 	((char *)interp->result)[0] = p[index];
! 	((char *)interp->result)[1] = '\0';
      } else {
  	goto indexSyntax;
      }
***************
*** 476,482 ****
  	 * Increase the size of the argument array if necessary to
  	 * accommodate another string.
  	 */
! 	char	*name;
  
  	if (argc == argSize) {
  	    argSize *= 2;
--- 476,482 ----
  	 * Increase the size of the argument array if necessary to
  	 * accommodate another string.
  	 */
! 	const char	*name;
  
  	if (argc == argSize) {
  	    argSize *= 2;
***************
*** 501,507 ****
  		/*
  		 * Has default -- form list of variable's name and value.
  		 */
! 		char    *vargv[2];
  		
  		vargv[0] = varPtr->name;
  		vargv[1] = varPtr->value;
--- 501,507 ----
  		/*
  		 * Has default -- form list of variable's name and value.
  		 */
! 		const char *vargv[2];
  		
  		vargv[0] = varPtr->name;
  		vargv[1] = varPtr->value;
***************
*** 547,553 ****
  	    varPtr = varPtr->nextPtr;
  	}
  	if (!pattern || Tcl_StringMatch(name, pattern)) {
! 	    argv[argc] = name;
  	    argc++;
  	}
      }
--- 547,553 ----
  	    varPtr = varPtr->nextPtr;
  	}
  	if (!pattern || Tcl_StringMatch(name, pattern)) {
! 	    argv[argc] = (char *)name;
  	    argc++;
  	}
      }
***************
*** 592,598 ****
  	      char	    **argv)	/* Argument strings. */
  {
      int count;
!     char *p;
  
      if (argc < 2) {
  	lengthSyntax:
--- 592,598 ----
  	      char	    **argv)	/* Argument strings. */
  {
      int count;
!     const char *p;
  
      if (argc < 2) {
  	lengthSyntax:
***************
*** 603,609 ****
      }
      p = argv[1];
      if (argc == 2) {
! 	char *element;
  	int result;
  
  	for (count = 0; *p != 0 ; count++) {
--- 603,609 ----
      }
      p = argv[1];
      if (argc == 2) {
! 	const char *element;
  	int result;
  
  	for (count = 0; *p != 0 ; count++) {
***************
*** 680,686 ****
      Frame   *frame; 	    	    	/* Current frame */
      Interp  *iPtr = (Interp *)interp;	/* Internal version of interpreter */
      int	    result; 	    	    	/* Result code */
!     char    *value; 	    	    	/* Result value */
      int	    dynamic;	    	    	/* Non-zero if our return value is
  					 * dynamically-allocated */
  
--- 680,686 ----
      Frame   *frame; 	    	    	/* Current frame */
      Interp  *iPtr = (Interp *)interp;	/* Internal version of interpreter */
      int	    result; 	    	    	/* Result code */
!     const char *value; 	    	    	/* Result value */
      int	    dynamic;	    	    	/* Non-zero if our return value is
  					 * dynamically-allocated */
  
***************
*** 760,766 ****
  	     char	**argv)	    /* Argument strings. */
  {
      int first, last, result;
!     char *begin, *end, c, *dummy;
      int count;
  
      if (argc < 4) {
--- 760,768 ----
  	     char	**argv)	    /* Argument strings. */
  {
      int first, last, result;
!     const char *begin, *end;
!     char c;
!     const char *dummy;
      int count;
  
      if (argc < 4) {
***************
*** 852,860 ****
  	end++;
      }
      c = *end;
!     *end = 0;
      Tcl_Return(interp, begin, TCL_VOLATILE);
!     *end = c;
      return TCL_OK;
  }
  
--- 854,862 ----
  	end++;
      }
      c = *end;
!     *(char *)end = 0;
      Tcl_Return(interp, begin, TCL_VOLATILE);
!     *(char *)end = c;
      return TCL_OK;
  }
  
***************
*** 1166,1172 ****
      }
      close(fileId);
      cmdBuffer[statBuf.st_size] = 0;
!     result = Tcl_Eval(interp, cmdBuffer, 0, (char **) NULL);
      free(cmdBuffer);
      return result;
  }
--- 1168,1174 ----
      }
      close(fileId);
      cmdBuffer[statBuf.st_size] = 0;
!     result = Tcl_Eval(interp, cmdBuffer, 0, (const char **) NULL);
      free(cmdBuffer);
      return result;
  }
***************
*** 1294,1300 ****
      }
      gettimeofday(&start, &tz);
      for (i = count ; i > 0; i--) {
! 	result = Tcl_Eval(interp, argv[1], 0, (char **) NULL);
  	if (result != TCL_OK) {
  	    return result;
  	}
--- 1296,1302 ----
      }
      gettimeofday(&start, &tz);
      for (i = count ; i > 0; i--) {
! 	result = Tcl_Eval(interp, argv[1], 0, (const char **) NULL);
  	if (result != TCL_OK) {
  	    return result;
  	}
*** /tmp/,RCSt1a26966	Sun Apr 14 19:29:01 1991
--- tclExpr.c	Fri Apr  5 11:17:58 1991
***************
*** 15,21 ****
   */
  
  #ifndef lint
! static char *rcsid = "$Id: tclExpr.c,v 1.10.4.1 91/01/25 22:47:26 adam Exp $ SPRITE (Berkeley)";
  #endif not lint
  
  
--- 15,21 ----
   */
  
  #ifndef lint
! static char *rcsid = "$Id: tclExpr.c,v 1.11 91/04/05 11:17:52 adam Exp $ SPRITE (Berkeley)";
  #endif not lint
  
  
***************
*** 88,95 ****
   */
  
  double
! strtod(string, endPtr)
!     char *string;		/* A decimal ASCII floating-point number,
  				 * optionally preceded by white space.
  				 * Must have form "-I.FE-X", where I is the
  				 * integer part of the mantissa, F is the
--- 88,94 ----
   */
  
  double
! strtod(const char *string,	/* A decimal ASCII floating-point number,
  				 * optionally preceded by white space.
  				 * Must have form "-I.FE-X", where I is the
  				 * integer part of the mantissa, F is the
***************
*** 101,112 ****
  				 * The "E" may actually be an "e".  E and X
  				 * may both be omitted (but not just one).
  				 */
!     char **endPtr;		/* If non-NULL, store terminating character's
  				 * address here. */
  {
      int sign, expSign = FALSE;
      double fraction, dblExp, *d;
!     register char *p, c;
      int exp = 0;		/* Exponent read from "EX" field. */
      int fracExp = 0;		/* Exponent that derives from the fractional
  				 * part.  Under normal circumstatnces, it is
--- 100,112 ----
  				 * The "E" may actually be an "e".  E and X
  				 * may both be omitted (but not just one).
  				 */
!        const char **endPtr)	/* If non-NULL, store terminating character's
  				 * address here. */
  {
      int sign, expSign = FALSE;
      double fraction, dblExp, *d;
!     register const char *p;
!     register char c;
      int exp = 0;		/* Exponent read from "EX" field. */
      int fracExp = 0;		/* Exponent that derives from the fractional
  				 * part.  Under normal circumstatnces, it is
***************
*** 122,128 ****
      int decPt;			/* Number of mantissa digits BEFORE decimal
  				 * point.
  				 */
!     char *pExp;			/* Temporarily holds location of exponent
  				 * in string.
  				 */
  
--- 122,128 ----
      int decPt;			/* Number of mantissa digits BEFORE decimal
  				 * point.
  				 */
!     const char *pExp;		/* Temporarily holds location of exponent
  				 * in string.
  				 */
  
***************
*** 286,294 ****
  typedef struct {
      Tcl_Interp *interp;		/* Intepreter to use for command execution
  				 * and variable lookup. */
!     char *originalExpr;		/* The entire expression, as originally
  				 * passed to Tcl_Expr. */
!     char *expr;			/* Position to the next character to be
  				 * scanned from the expression string. */
      int token;			/* Type of the last token to be parsed from
  				 * expr.  See below for definitions.
--- 286,294 ----
  typedef struct {
      Tcl_Interp *interp;		/* Intepreter to use for command execution
  				 * and variable lookup. */
!     const char *originalExpr;	/* The entire expression, as originally
  				 * passed to Tcl_Expr. */
!     const char *expr;		/* Position to the next character to be
  				 * scanned from the expression string. */
      int token;			/* Type of the last token to be parsed from
  				 * expr.  See below for definitions.
***************
*** 389,399 ****
   */
  
  int
! ExprGetNum(register char    *string,	/* ASCII representation of number. If
  					 * leading digit is "0" then read in
  					 * base 8,  if "0x", then read in base
  					 * 16. */
! 	   register char    **termPtr)	/* If non-NULL, fill in with address of
  					 * terminating character. */
  {
      int result, sign;
--- 389,399 ----
   */
  
  int
! ExprGetNum(register const char *string,	/* ASCII representation of number. If
  					 * leading digit is "0" then read in
  					 * base 8,  if "0x", then read in base
  					 * 16. */
! 	   register const char **termPtr)/* If non-NULL, fill in with address of
  					 * terminating character. */
  {
      int result, sign;
***************
*** 409,415 ****
      }
      if (c == '0') {
  	string++; c = *string;
! 	if (c == 'x') {
  	    while (1) {
  		string++; c = *string;
  		if ((c >= '0') && (c <= '9')) {
--- 409,415 ----
      }
      if (c == '0') {
  	string++; c = *string;
! 	if (c == 'x' || c == 'X') {
  	    while (1) {
  		string++; c = *string;
  		if ((c >= '0') && (c <= '9')) {
***************
*** 458,469 ****
   *----------------------------------------------------------------------
   */
  static
! ExprGetNumber(register char *string,
  	      ExprInfo	    *infoPtr,
! 	      register char **termPtr)
  {
!     if (!infoPtr->doFloat) {
  	infoPtr->number = ExprGetNum(string, termPtr);
      } else {
  	extern double strtod();
  	
--- 458,475 ----
   *----------------------------------------------------------------------
   */
  static
! ExprGetNumber(register const char *string,
  	      ExprInfo	    *infoPtr,
! 	      register const char **termPtr)
  {
!     if (!infoPtr->doFloat ||
! 	(*string == '0' && (string[1] ==  'x' || string[1] == 'X')))
!     {
  	infoPtr->number = ExprGetNum(string, termPtr);
+ 
+ 	if (infoPtr->doFloat) {
+ 	    infoPtr->fnumber = (double)infoPtr->number;
+ 	}
      } else {
  	extern double strtod();
  	
***************
*** 471,479 ****
      }
  }
  	
- 	    
- 	    
-     
  
  /*
   *----------------------------------------------------------------------
--- 477,482 ----
***************
*** 505,512 ****
  					 * etc. b/c we're in a part of a
  					 * boolean expression we don't need */
  {
!     register char *p, c;
!     char *var, *term;
      int result;
  
      /*
--- 508,516 ----
  					 * etc. b/c we're in a part of a
  					 * boolean expression we don't need */
  {
!     register const char *p;
!     register char c;
!     const char *var, *term;
      int result;
  
      /*
***************
*** 563,575 ****
  	    if (!noEval) {
  		ExprGetNumber(var, infoPtr, &term);
  		if ((term == var) || (*term != 0)) {
- 		    c = *infoPtr->expr;
- 		    *infoPtr->expr = 0;
  		    Tcl_Return(interp, (char *) NULL, TCL_STATIC);
  		    sprintf(interp->result,
! 			    "variable \"%.50s\" contained non-numeric value \"%.50s\"",
! 			    p, var);
! 		    *infoPtr->expr = c;
  		    return TCL_ERROR;
  		}
  	    }
--- 567,576 ----
  	    if (!noEval) {
  		ExprGetNumber(var, infoPtr, &term);
  		if ((term == var) || (*term != 0)) {
  		    Tcl_Return(interp, (char *) NULL, TCL_STATIC);
  		    sprintf(interp->result,
! 			    "variable \"%.*s\" contained non-numeric value \"%.50s\"",
! 			    infoPtr->expr - p, p, var);
  		    return TCL_ERROR;
  		}
  	    }
***************
*** 585,595 ****
  		ExprGetNumber(interp->result, infoPtr, &term);
  		if ((term == interp->result) || (*term != 0)) {
  		    char string[200];
! 		    c = *infoPtr->expr;
! 		    *infoPtr->expr = 0;
! 		    sprintf(string, "command \"%.50s\" returned non-numeric result \"%.50s\"",
! 			    p+1, interp->result);
! 		    *infoPtr->expr = c;
  		    Tcl_Return(interp, string, TCL_VOLATILE);
  		    return TCL_ERROR;
  		}
--- 586,593 ----
  		ExprGetNumber(interp->result, infoPtr, &term);
  		if ((term == interp->result) || (*term != 0)) {
  		    char string[200];
! 		    sprintf(string, "command \"%.*s\" returned non-numeric result \"%.50s\"",
! 			    infoPtr->expr - (p+1), p+1, interp->result);
  		    Tcl_Return(interp, string, TCL_VOLATILE);
  		    return TCL_ERROR;
  		}
***************
*** 1096,1102 ****
  
  int
  Tcl_Expr(Tcl_Interp *interp,	/* Intepreter to use for variables etc. */
! 	 char	    *string,	/* Expression to evaluate. */
  	 int	    *valuePtr)	/* Where to store result of evaluation. */
  {
      ExprInfo info;
--- 1094,1100 ----
  
  int
  Tcl_Expr(Tcl_Interp *interp,	/* Intepreter to use for variables etc. */
! 	 const char *string,	/* Expression to evaluate. */
  	 int	    *valuePtr)	/* Where to store result of evaluation. */
  {
      ExprInfo info;
***************
*** 1141,1148 ****
  
  int
  Tcl_FExpr(Tcl_Interp *interp,	/* Intepreter to use for variables etc. */
! 	 char	    *string,	/* Expression to evaluate. */
! 	 double	    *valuePtr)	/* Where to store result of evaluation. */
  {
      ExprInfo info;
      int result;
--- 1139,1146 ----
  
  int
  Tcl_FExpr(Tcl_Interp *interp,	/* Intepreter to use for variables etc. */
! 	  const char *string,	/* Expression to evaluate. */
! 	  double *valuePtr)	/* Where to store result of evaluation. */
  {
      ExprInfo info;
      int result;
*** /tmp/,RCSt1a26966	Sun Apr 14 19:29:04 1991
--- tclInt.h	Fri Apr  5 11:18:39 1991
***************
*** 12,18 ****
   * software for any purpose.  It is provided "as is" without
   * express or implied warranty.
   *
!  * $Id: tclInt.h,v 1.19.4.1 91/01/25 22:47:10 adam Exp $ SPRITE (Berkeley)
   */
  
  #ifndef _TCLINT
--- 12,18 ----
   * software for any purpose.  It is provided "as is" without
   * express or implied warranty.
   *
!  * $Id: tclInt.h,v 1.20 91/04/05 11:18:33 adam Exp $ SPRITE (Berkeley)
   */
  
  #ifndef _TCLINT
***************
*** 173,179 ****
       * one, be sure to change the other.
       */
  
!     char *result;		/* Points to result returned by last
  				 * command. */
      int dynamic;		/* Non-zero means result is dynamically-
  				 * allocated and must be freed by Tcl_Eval
--- 173,179 ----
       * one, be sure to change the other.
       */
  
!     const char *result;		/* Points to result returned by last
  				 * command. */
      int dynamic;		/* Non-zero means result is dynamically-
  				 * allocated and must be freed by Tcl_Eval
***************
*** 213,228 ****
   * world:
   */
  
! extern void		TclCopyAndCollapse(int count, char *src, char *dst);
  extern void		TclDeleteVars(Var *varPtr);
! extern Command *	TclFindCmd(Interp *iPtr, char *cmdName, int exact);
  extern int		TclFindElement(Tcl_Interp *interp,
! 				       char *list,
! 				       char **elementPtr,
! 				       char **nextPtr,
  				       int *sizePtr,
  				       int *bracePtr);
! extern Proc *		TclFindProc(Interp *iPtr, char *procName);
  #define TclIsProc(cmdPtr) ((cmdPtr)->flags & TCL_PROC)
  
  #endif _TCLINT
--- 213,230 ----
   * world:
   */
  
! extern void		TclCopyAndCollapse(int count, const char *src,
! 					   char *dst);
  extern void		TclDeleteVars(Var *varPtr);
! extern Command *	TclFindCmd(Interp *iPtr, const char *cmdName,
! 				   int exact);
  extern int		TclFindElement(Tcl_Interp *interp,
! 				       const char *list,
! 				       const char **elementPtr,
! 				       const char **nextPtr,
  				       int *sizePtr,
  				       int *bracePtr);
! extern Proc *		TclFindProc(Interp *iPtr, const char *procName);
  #define TclIsProc(cmdPtr) ((cmdPtr)->flags & TCL_PROC)
  
  #endif _TCLINT
*** /tmp/,RCSt1a26966	Sun Apr 14 19:29:05 1991
--- tclProc.c	Fri Apr  5 11:18:08 1991
***************
*** 15,21 ****
   */
  
  #ifndef lint
! static char *rcsid = "$Id: tclProc.c,v 1.30.4.1 91/01/25 22:47:06 adam Exp $ SPRITE (Berkeley)";
  #endif not lint
  
  #include <stdio.h>
--- 15,21 ----
   */
  
  #ifndef lint
! static char *rcsid = "$Id: tclProc.c,v 1.31 91/04/05 11:18:01 adam Exp $ SPRITE (Berkeley)";
  #endif not lint
  
  #include <stdio.h>
***************
*** 22,27 ****
--- 22,31 ----
  #include <ctype.h>
  #include "tclInt.h"
  
+ #if	defined(sparc)
+ #include <alloca.h>
+ #endif
+ 
  /*
   * Library imports:
   */
***************
*** 68,73 ****
--- 72,78 ----
      char **argArray;
      int cmdLen;
      Var	**argNextPtr;
+     int cmdFlags = 0;
  
      if (argc != 4) {
  	sprintf(iPtr->result,
***************
*** 140,145 ****
--- 145,160 ----
  	argPtr->flags = 0;
  	argPtr->nextPtr = NULL;
  	free((char *) fieldValues);
+ 
+ 	/*
+ 	 * If only argument is "noeval", set the TCL_NOEVAL flag for the
+ 	 * command. No need to have a special case in InterpProc as there is
+ 	 * for "args" since Tcl_Eval will merge everything into a single
+ 	 * argument, whose name will be "noeval"...
+ 	 */
+ 	if ((argCount == 1) && (strcmp(argPtr->name, "noeval") == 0)) {
+ 	    cmdFlags |= TCL_NOEVAL;
+ 	}
      }
  
      free((char *) argArray);
***************
*** 150,157 ****
       * name matching for our command be exact.
       */
      procPtr->inuse = procPtr->delete = 0;
      Tcl_CreateCommand(interp, argv[1], InterpProc,
! 		      TCL_PROC | ((strcmp(argv[0], "defsubr")==0)?TCL_EXACT:0),
  		      (ClientData) procPtr, ProcDeleteProc);
  
      Tcl_Return(interp, NULL, TCL_STATIC);
--- 165,175 ----
       * name matching for our command be exact.
       */
      procPtr->inuse = procPtr->delete = 0;
+     if (strcmp(argv[0], "defsubr") == 0) {
+ 	cmdFlags |= TCL_EXACT;
+     }
      Tcl_CreateCommand(interp, argv[1], InterpProc,
! 		      TCL_PROC | cmdFlags,
  		      (ClientData) procPtr, ProcDeleteProc);
  
      Tcl_Return(interp, NULL, TCL_STATIC);
***************
*** 186,195 ****
   *----------------------------------------------------------------------
   */
  
! char *
  Tcl_GetVar(Tcl_Interp	*interp,    /* Command interpreter in which varName is
  				     * to be looked up. */
! 	   char		*varName,   /* Name of a variable in interp. */
  	   int		global)	    /* If non-zero, use only a global variable*/
  {
      Var *varPtr;
--- 204,213 ----
   *----------------------------------------------------------------------
   */
  
! const char *
  Tcl_GetVar(Tcl_Interp	*interp,    /* Command interpreter in which varName is
  				     * to be looked up. */
! 	   const char	*varName,   /* Name of a variable in interp. */
  	   int		global)	    /* If non-zero, use only a global variable*/
  {
      Var *varPtr;
***************
*** 230,237 ****
  void
  Tcl_SetVar(Tcl_Interp	*interp,    /* Command interpreter in which varName is
  				     * to be looked up. */
! 	   char		*varName,   /* Name of a variable in interp. */
! 	   char		*newValue,  /* New value for varName. */
  	   int		global)	    /* If non-zero, use only a global variable*/
  {
      register Var *varPtr;
--- 248,255 ----
  void
  Tcl_SetVar(Tcl_Interp	*interp,    /* Command interpreter in which varName is
  				     * to be looked up. */
! 	   const char	*varName,   /* Name of a variable in interp. */
! 	   const char	*newValue,  /* New value for varName. */
  	   int		global)	    /* If non-zero, use only a global variable*/
  {
      register Var *varPtr;
***************
*** 281,296 ****
   *----------------------------------------------------------------------
   */
  
! char *
  Tcl_ParseVar(Tcl_Interp	    *interp,	/* Context for looking up variable. */
! 	     register char  *string,	/* String containing variable name.
  					 * First character must be "$". */
! 	     char	    **termPtr)	/* If non-NULL, points to word to fill
  					 * in with character just after last
  					 * one in the variable specifier. */
      
  {
! 			    char	*name, c, *result;
  
      /*
       * There are two cases:
--- 299,316 ----
   *----------------------------------------------------------------------
   */
  
! const char *
  Tcl_ParseVar(Tcl_Interp	    *interp,	/* Context for looking up variable. */
! 	     register const char *string,/* String containing variable name.
  					 * First character must be "$". */
! 	     const char **termPtr)  	/* If non-NULL, points to word to fill
  					 * in with character just after last
  					 * one in the variable specifier. */
      
  {
!     const char	*name, *result;
!     char *varname;
!     int len;
  
      /*
       * There are two cases:
***************
*** 325,334 ****
  	}
      }
  
!     c = *string;
!     *string = 0;
!     result = Tcl_GetVar(interp, name, 0);
!     *string = c;
      return result;
  }
  
--- 345,355 ----
  	}
      }
  
!     len = string-name;
!     varname = (char *)alloca(len+1);
!     bcopy(name, varname, len);
!     varname[len] = '\0';
!     result = Tcl_GetVar(interp, (const char *)varname, 0);
      return result;
  }
  
***************
*** 445,451 ****
  
  Proc *
  TclFindProc(Interp  *iPtr,	/* Interpreter in which to look. */
! 	    char    *procName)	/* Name of desired procedure. */
  {
      Command *cmdPtr;
  
--- 466,472 ----
  
  Proc *
  TclFindProc(Interp  *iPtr,	/* Interpreter in which to look. */
! 	    const char *procName)	/* Name of desired procedure. */
  {
      Command *cmdPtr;
  
***************
*** 517,523 ****
  					 * procedure. */
  	   char		    **argv)	/* Argument values. */
  {
!     char **args;
      register Var *formalPtr, *argPtr;
      Var *nextArg;
      register Interp *iPtr = (Interp *) interp;
--- 538,544 ----
  					 * procedure. */
  	   char		    **argv)	/* Argument values. */
  {
!     char *const *args;
      register Var *formalPtr, *argPtr;
      Var *nextArg;
      register Interp *iPtr = (Interp *) interp;
***************
*** 591,597 ****
       * Invoke the commands in the procedure's body.
       */
  
!     result = Tcl_Eval(interp, procPtr->command, 0, (char **) NULL);
      if (result == TCL_RETURN) {
  	result = TCL_OK;
      } else if (result == TCL_OK) {
--- 612,618 ----
       * Invoke the commands in the procedure's body.
       */
  
!     result = Tcl_Eval(interp, procPtr->command, 0, (const char **) NULL);
      if (result == TCL_RETURN) {
  	result = TCL_OK;
      } else if (result == TCL_OK) {
***************
*** 677,683 ****
  
  Var *
  FindVar(VarFrame *vf,	    	/* Pointer to frame to search */
! 	char	*varName)	/* Desired variable. */
  {
      register Var *prev, *cur;
      register char c;
--- 698,704 ----
  
  Var *
  FindVar(VarFrame *vf,	    	/* Pointer to frame to search */
! 	const char *varName)	/* Desired variable. */
  {
      register Var *prev, *cur;
      register char c;
***************
*** 723,730 ****
   */
  
  Var *
! NewVar(char *name,  /* Name for variable. */
!        char *value) /* Value for variable. */
  {
      register Var *varPtr;
      int nameLength, valueLength, realValueLength;
--- 744,751 ----
   */
  
  Var *
! NewVar(const char *name,  /* Name for variable. */
!        const char *value) /* Value for variable. */
  {
      register Var *varPtr;
      int nameLength, valueLength, realValueLength;
***************
*** 763,770 ****
   *
   ***********************************************************************/
  Var *
! AddVar(char 	*name,
!        char 	*value,
         VarFrame	*vf)
  {
      Var     *result = NewVar(name, value);
--- 784,791 ----
   *
   ***********************************************************************/
  Var *
! AddVar(const char *name,
!        const char *value,
         VarFrame	*vf)
  {
      Var     *result = NewVar(name, value);
*** /tmp/,RCSt1a26966	Sun Apr 14 19:29:06 1991
--- tclUtil.c	Fri Apr  5 11:18:17 1991
***************
*** 16,22 ****
  
  #ifndef lint
  static char *rcsid =
! "$Id: tclUtil.c,v 1.29.4.1 91/01/25 22:47:15 adam Exp $ SPRITE (Berkeley)";
  #endif not lint
  
  #include <ctype.h>
--- 16,22 ----
  
  #ifndef lint
  static char *rcsid =
! "$Id: tclUtil.c,v 1.30 91/04/05 11:18:10 adam Exp $ SPRITE (Berkeley)";
  #endif not lint
  
  #include <ctype.h>
***************
*** 69,81 ****
  int
  TclFindElement(Tcl_Interp	*interp,	/* Interpreter to use for error
  						 * reporting. */
! 	       register char	*list,		/* String containing Tcl list
  						 * with zero or more elements
  						 * (possibly in braces). */
! 	       char		**elementPtr,	/* Fill in with location of
  						 * first significant character
  						 * in first element of list. */
! 	       char		**nextPtr,	/* Fill in with location of
  						 * character just after all
  						 * white space following end of
  						 * argument (i.e. next argument
--- 69,81 ----
  int
  TclFindElement(Tcl_Interp	*interp,	/* Interpreter to use for error
  						 * reporting. */
! 	       register const char *list,	/* String containing Tcl list
  						 * with zero or more elements
  						 * (possibly in braces). */
! 	       const char	**elementPtr,	/* Fill in with location of
  						 * first significant character
  						 * in first element of list. */
! 	       const char	**nextPtr,	/* Fill in with location of
  						 * character just after all
  						 * white space following end of
  						 * argument (i.e. next argument
***************
*** 87,93 ****
  						 * that arg was/wasn't in
  						 * braces. */
  {
!     register char *p;
      int openBraces = 0;
      int size;
  
--- 87,93 ----
  						 * that arg was/wasn't in
  						 * braces. */
  {
!     register const char *p;
      int openBraces = 0;
      int size;
  
***************
*** 133,139 ****
  
  	    case '}':
  		if (openBraces == 1) {
! 		    char *p2;
  
  		    size = p - list;
  		    p++;
--- 133,139 ----
  
  	    case '}':
  		if (openBraces == 1) {
! 		    const char *p2;
  
  		    size = p - list;
  		    p++;
***************
*** 232,238 ****
  
  void
  TclCopyAndCollapse(int 	    	    count,
! 		   register char    *src,   /* Copy from here... */
  		   register char    *dst)   /* ... to here. */
  {
      register char c;
--- 232,238 ----
  
  void
  TclCopyAndCollapse(int 	    	    count,
! 		   register const char *src,/* Copy from here... */
  		   register char    *dst)   /* ... to here. */
  {
      register char c;
***************
*** 273,279 ****
  
  char *
  Tcl_Merge(int	argc,	/* How many strings to merge. */
! 	  char	**argv)	/* Array of string values. */
  {
      /*
       * This procedure operates in two passes.  In the first pass it figures
--- 273,279 ----
  
  char *
  Tcl_Merge(int	argc,	/* How many strings to merge. */
! 	  const char *const *argv)	/* Array of string values. */
  {
      /*
       * This procedure operates in two passes.  In the first pass it figures
***************
*** 313,319 ****
      int *flagPtr;
      int numChars;
      char *result;
!     register char *src, *dst;
      register int curFlags;
      int i;
  
--- 313,320 ----
      int *flagPtr;
      int numChars;
      char *result;
!     register const char *src;
!     register char *dst;
      register int curFlags;
      int i;
  
***************
*** 486,492 ****
  void
  Tcl_Return(Tcl_Interp	*interp,    /* Interpreter with which to associate the
  				     * return value. */
! 	   char		*string,    /* Value to be returned.  If NULL, the
  				     * result is set to an empty string. */
  	   int		status)	    /* Gives information about the string:
  				     * TCL_STATIC, TCL_DYNAMIC, TCL_VOLATILE.
--- 487,493 ----
  void
  Tcl_Return(Tcl_Interp	*interp,    /* Interpreter with which to associate the
  				     * return value. */
! 	   const char	*string,    /* Value to be returned.  If NULL, the
  				     * result is set to an empty string. */
  	   int		status)	    /* Gives information about the string:
  				     * TCL_STATIC, TCL_DYNAMIC, TCL_VOLATILE.
***************
*** 495,501 ****
      register Interp *iPtr = (Interp *) interp;
      int length;
      int wasDynamic = iPtr->dynamic;
!     char *oldResult = iPtr->result;
  
      if (string == NULL) {
  	iPtr->resultSpace[0] = 0;
--- 496,502 ----
      register Interp *iPtr = (Interp *) interp;
      int length;
      int wasDynamic = iPtr->dynamic;
!     const char *oldResult = iPtr->result;
  
      if (string == NULL) {
  	iPtr->resultSpace[0] = 0;
***************
*** 550,562 ****
  void
  Tcl_RetPrintf(Tcl_Interp    *interp,	/* Interpreter with which to associate
  					 * the return value. */
! 	      char	    *format,	/* Format string */
  	      ...)
  {
      va_list 	  	args;
      register Interp 	*iPtr = (Interp *) interp;
      int     	  	wasDynamic = iPtr->dynamic;
!     char    	  	*oldResult = iPtr->result;
      FILE    	  	f;
  
      /*
--- 551,563 ----
  void
  Tcl_RetPrintf(Tcl_Interp    *interp,	/* Interpreter with which to associate
  					 * the return value. */
! 	      const char    *format,	/* Format string */
  	      ...)
  {
      va_list 	  	args;
      register Interp 	*iPtr = (Interp *) interp;
      int     	  	wasDynamic = iPtr->dynamic;
!     const char 	  	*oldResult = iPtr->result;
      FILE    	  	f;
  
      /*
***************
*** 583,589 ****
       * it will format it into the string (w/o overflow), but it won't null-
       * terminate the thing -- we do that using putc.
       */
!     f._base = f._ptr = iPtr->result;
      f._cnt = TCL_RESULT_SIZE - 1;
      f._bufsiz = TCL_RESULT_SIZE;
      f._flag = _IOWRT|_IOSTRG;
--- 584,590 ----
       * it will format it into the string (w/o overflow), but it won't null-
       * terminate the thing -- we do that using putc.
       */
!     f._base = f._ptr = (unsigned char *)iPtr->resultSpace;
      f._cnt = TCL_RESULT_SIZE - 1;
      f._bufsiz = TCL_RESULT_SIZE;
      f._flag = _IOWRT|_IOSTRG;
***************
*** 639,650 ****
   */
  
  char
! Tcl_Backslash(char  *src,	/* Points to the backslash character of a
  				 * backslash sequence. */
  	      int   *readPtr)	/* Fill in with number of characters read from
  				 * src, unless NULL. */
  {
!     register char *p = src+1;
      char result;
      int count;
  
--- 640,651 ----
   */
  
  char
! Tcl_Backslash(const char  *src,	/* Points to the backslash character of a
  				 * backslash sequence. */
  	      int   *readPtr)	/* Fill in with number of characters read from
  				 * src, unless NULL. */
  {
!     register const char *p = src+1;
      char result;
      int count;
  
***************
*** 770,776 ****
  int
  Tcl_SplitList(Tcl_Interp    *interp,	/* Interpreter to use for error
  					 * reporting. */
! 	      char	    *list,	/* Pointer to string with list
  					 * structure. */
  	      int	    *argcPtr,	/* Pointer to location to fill in with
  					 * the number of elements in the list.
--- 771,777 ----
  int
  Tcl_SplitList(Tcl_Interp    *interp,	/* Interpreter to use for error
  					 * reporting. */
! 	      const char    *list,	/* Pointer to string with list
  					 * structure. */
  	      int	    *argcPtr,	/* Pointer to location to fill in with
  					 * the number of elements in the list.
***************
*** 782,788 ****
      char **argv;
      register char *p;
      int size, i, result, elSize, brace;
!     char *element;
  
      /*
       * Figure out how much space to allocate.  There must be enough
--- 783,789 ----
      char **argv;
      register char *p;
      int size, i, result, elSize, brace;
!     const char *element;
  
      /*
       * Figure out how much space to allocate.  There must be enough
***************
*** 791,797 ****
       * the number of space characters in the list.
       */
  
!     for (size = 1, p = list; *p != 0; p++) {
  	if (isspace(*p)) {
  	    size++;
  	}
--- 792,798 ----
       * the number of space characters in the list.
       */
  
!     for (size = 1, p = (char *)list; *p != 0; p++) {
  	if (isspace(*p)) {
  	    size++;
  	}
***************
*** 799,805 ****
      argv = (char **) malloc((unsigned)
  	    ((size * sizeof(char *)) + (p - list) + 1));
      for (i = 0, p = ((char *) argv) + size*sizeof(char *);
! 	    *list != 0; i++) {
  	result = TclFindElement(interp, list, &element, &list, &elSize, &brace);
  	if (result != TCL_OK) {
  	    free((char *) argv);
--- 800,808 ----
      argv = (char **) malloc((unsigned)
  	    ((size * sizeof(char *)) + (p - list) + 1));
      for (i = 0, p = ((char *) argv) + size*sizeof(char *);
! 	 *list != 0;
! 	 i++)
!     {
  	result = TclFindElement(interp, list, &element, &list, &elSize, &brace);
  	if (result != TCL_OK) {
  	    free((char *) argv);
***************
*** 849,858 ****
   */
  
  int
! Tcl_StringMatch(register char *string,  /* String. */
! 		register char *pattern) /* Pattern, which may contain
!                                          * special characters.
!                                          */
  {
      char    	    c2;
      register char   pchar = *pattern;
--- 852,861 ----
   */
  
  int
! Tcl_StringMatch(register const char *string,  /* String. */
! 		register const char *pattern) /* Pattern, which may contain
! 					       * special characters.
! 					       */
  {
      char    	    c2;
      register char   pchar = *pattern;
*** /tmp/,RCSt1a26966	Sun Apr 14 19:29:07 1991
--- tsh.c	Mon Nov 26 20:19:41 1990
***************
*** 27,33 ****
   ***********************************************************************/
  #ifndef lint
  static char *rcsid =
! "$Id: tsh.c,v 1.3.4.1 91/01/25 22:47:36 adam Exp $";
  #endif lint
  
  #include <stdio.h>
--- 27,33 ----
   ***********************************************************************/
  #ifndef lint
  static char *rcsid =
! "$Id: tsh.c,v 1.3 89/05/04 18:54:44 adam Exp $";
  #endif lint
  
  #include <stdio.h>
