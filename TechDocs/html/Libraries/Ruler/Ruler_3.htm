<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: Ruler_3.htm,v 1.1 97/06/02 15:43:53 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE> VisRuler Instance Data</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">


<H1 CLASS="sectionTitle">
<A HREF="index.htm">Ruler Object Library</A>: 3 
VisRuler Instance Data</H1>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="Ruler_2.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">2 Ruler Setup</A> 
<!-- to next --> | <A HREF="Ruler_4.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">4 Managing Rulers</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
<P>
<A NAME="IX_VRI_&ldots;  (VisRulerClass instance data)">
 </A>
<A NAME="IX_VisRulerClass">
 </A>
The VisRuler's instance data fields are listed below. Depending on your setup, the management of most of these fields will probably be taken care of by the ruler itself or some of its associated controllers. However, many programs set values for the <CODE>
VRI_rulerAttrs</CODE>
, <CODE>
VRI_constrainStrategy</CODE>
, and <CODE>
VRI_slave</CODE>
 fields when defining their rulers.</P>
<P CLASS="figTitle">
Code Display 19-1 </P>
<PRE>@classVisRulerClass,VisClass;
@instance VisRulerAttributes VRI_rulerAttrs;</PRE>
<PRE>typedef ByteFlags VisRulerAttributes; 
#define VRA_IGNORE_ORIGIN 				0x80
#define VRA_SHOW_GUIDES 				0x40
#define VRA_SHOW_GRID 				0x20
#define VRA_SHOW_MOUSE 				0x10
#define VRA_HORIZONTAL 				0x08
#define VRA_MASTER 				0x04</PRE>
<PRE>@instance VisRulerType VRI_type;</PRE>
<PRE>typedef ByteEnum VisRulerType; 
<A NAME="IX_VisRulerType"> </A><A NAME="IX_VRT_&ldots;"> </A>#define VRT_INCHES 			0x0
#define VRT_CENTIMETERS 			0x1
#define VRT_POINTS 			0x2
#define VRT_PICAS 			0x3
#define VRT_CUSTOM 			CUSTOM_RULER_DEFINITION
#define VRT_NONE 			NO_RULERS
#define VRT_DEFAULT 			SYSTEM_DEFAULT</PRE>
<PRE>@instance VisRulerConstrainStrategy VRI_constrainStrategy;</PRE>
<PRE>typedef WordFlags VisRulerConstrainStrategy; 
#define VRCS_OVERRIDE 							0x8000
#define VRCS_SET_REFERENCE 							0x2000
#define VRCS_SNAP_TO_GRID_X_ABSOLUTE 							0x1000
#define VRCS_SNAP_TO_GRID_Y_ABSOLUTE 							0x0800
#define VRCS_SNAP_TO_GRID_X_RELATIVE 							0x0400
#define VRCS_SNAP_TO_GRID_Y_RELATIVE 							0x0200
#define VRCS_SNAP_TO_GUIDES_X 							0x0100
#define VRCS_SNAP_TO_GUIDES_Y 							0x0080
#define VRCS_CONSTRAIN_TO_HORIZONTAL_AXIS 							0x0040
#define VRCS_CONSTRAIN_TO_VERTICAL_AXIS 							0x0020
#define VRCS_CONSTRAIN_TO_UNITY_SLOPE_AXIS 							0x0010
#define VRCS_CONSTRAIN_TO_NEGATIVE_UNITY_SLOPE_AXIS 							0x0008
#define VRCS_CONSTRAIN_TO_VECTOR 							0x0004
#define VRCS_CONSTRAIN_TO_VECTOR_REFLECTION 							0x0002
#define VRCS_INTERNAL 							0x0001</PRE>
<PRE>@instance MinIncrementType 			VRI_minIncrement; /* minimum increment displayed */</PRE>
<PRE><A NAME="IX_MIT_&ldots;"> </A><A NAME="IX_MinIncrementType"> </A>typedef union {
	MinUSMeasure 			MIT_US;
	MinMetricMeasure 			MIT_METRIC;
	MinPointMeasure 			MIT_POINT;
	MinPicaMeasure 			MIT_PICA;
} MinIncrementType;</PRE>
<PRE>typedef ByteEnum <A NAME="IX_MUSM_&ldots;"> </A><A NAME="IX_MinUSMeasure"> </A>MinUSMeasure; 
#define MUSM_EIGHTH_INCH 				0x0
#define MUSM_QUARTER_INCH 				0x1
#define MUSM_HALF_INCH 				0x2
#define MUSM_ONE_INCH 				0x3 </PRE>
<PRE>typedef ByteEnum <A NAME="IX_MMM_&ldots;"> </A><A NAME="IX_MinMetricMeasure"> </A>MinMetricMeasure;
#define MMM_MILLIMETER 				0x0
#define MMM_HALF_CENTIMETER 				0x1
#define MMM_CENTIMETER 				0x2</PRE>
<PRE>typedef ByteEnum <A NAME="IX_MPM_&ldots;"> </A><A NAME="IX_MinPointMeasure"> </A>MinPointMeasure; 
#define MPM_25_POINT 				0x0
#define MPM_50_POINT 				0x1
#define MPM_100_POINT 				0x2 </PRE>
<PRE>typedef ByteEnum <A NAME="IX_MPM_&ldots;"> </A><A NAME="IX_MinPicaMeasure"> </A>MinPicaMeasure;
#define MPM_PICA 				0x0
#define MPM_INCH 				0x1</PRE>
<PRE>@instance WWFixed VRI_scale; /* scale factor */</PRE>
<PRE>@instance DWFixed VRI_origin; /* 0,0 of the ruler in document coordinates */</PRE>
<PRE>@instance PointDWFixed VRI_reference;</PRE>
<PRE>@instance sdword VRI_mouseMark;</PRE>
<PRE>@instance word VRI_window; /* actually a noreloc WindowHandle */</PRE>
<PRE>@instance optr VRI_slave;</PRE>
<PRE>@instance Grid VRI_grid;</PRE>
<PRE>@instance WWFixed VRI_vectorSlope; /* slope of vector */</PRE>
<PRE>@instance optr VRI_guideArray;</PRE>
<PRE>@instance word VRI_guideInfluence; /* influence of guides in pixels */</PRE>
<PRE>@instance word VRI_desiredSize;</PRE>
<PRE>@instance word VRI_reserved;</PRE>
<PRE>@instance dword VRI_invalOD; /* actually a noreloc optr */</PRE>
<PRE>@instance word VRI_transformGState; /* actually a noreloc GStateHandle */</PRE>
<P>
<A NAME="IX_VisRulerAttributes">
 </A>
<A NAME="IX_VRA_&ldots;">
 </A>
The <A NAME="IX_VRI_rulerAttrs">
 </A>
<CODE>
VRI_rulerAttrs</CODE>
 field contains flags which determine whether the ruler will support given features. This field tends to vary between applications; put some thought into which flags to turn on.</P>
<DL>
<DT>
VRA_IGNORE_ORIGIN </DT><DD>
Using the <CODE>
VRI_origin</CODE>
 field, it is possible to set an origin for the user to use based upon the coordinates of the graphic space within the main view. This can come in handy when the zero point for the ruler shouldn't correspond to the very left or top of the view; GeoWrite uses this when the user wants the ruler's origin to be based upon the right edge of a text object rather than the edge of the view. The VRA_IGNORE_ORIGIN flag effectively turns off this feature.</DD>
<DT>
VRA_SHOW_GUIDES</DT><DD>
This flag indicates that the user wants guidelines drawn over their main view.</DD>
<DT>
VRA_SHOW_GRID </DT><DD>
This flag indicates that the user wants gridlines drawn over the main view.</DD>
<DT>
VRA_SHOW_MOUSE</DT><DD>
This flag indicates that the ruler should draw a tick mark to show the mouse pointer's location.</DD>
<DT>
VRA_HORIZONTAL </DT><DD>
This flag indicates that the ruler is horizontal. Horizontal rulers should have this flag turned on; vertical rulers should not.</DD>
<DT>
VRA_MASTER </DT><DD>
If a given view has only one ruler associated with it, that ruler should have this flag set. If a given view has more than one ruler (perhaps having one horizontal and one vertical), one of these rulers should be set up as the master ruler. It should have the VRA_MASTER flag set and should have the second ruler's optr in its <CODE>
VRI_slave</CODE>
 field. If there is a third ruler, the second ruler should have its optr in its (the second ruler's) VRI_slave field, and so on. </DD>
</DL>
<P>
<A NAME="IX_VisRulerConstrainStrategy">
 </A>
<A NAME="IX_VRCS_&ldots;">
 </A>
The <A NAME="IX_VRI_constrainStrategy">
 </A>
<CODE>
VRI_constrainStrategy</CODE>
 field contains the default mouse constraint strategy the ruler should use when constraining mouse movement.</P>
<DL>
<DT>
VRCS_OVERRIDE </DT><DD>
This flag isn't really meant to be part of the default mouse constraint; it will be ignored if in the <CODE>
VRI_constrainStrategy</CODE>
 field. During some events other constrain strategies may be combined with the default mouse constrain strategy; if the other strategy's VRCS_OVERRIDE flag is set, then the default mouse constraint strategy field will be ignored.</DD>
<DT>
VRCS_SET_REFERENCE </DT><DD>
This flag signals that the next selection should signal that the user wishes the point clicked on to be the reference point, which is used with certain kinds of mouse constraint.</DD>
<DT>
VRCS_SNAP_TO_GRID_X_ABSOLUTE </DT><DD>
This flag signals that the mouse position should be snapped to the grid horizontally.</DD>
<DT>
VRCS_SNAP_TO_GRID_Y_ABSOLUTE </DT><DD>
This flag signals that the mouse position should be snapped to the grid vertically.</DD>
<DT>
VRCS_SNAP_TO_GRID_X_RELATIVE </DT><DD>
This flag signals that the mouse position should be horizontally snapped to a grid such as would be formed if the present grid spacing was used with the reference point as the grid's origin.</DD>
<DT>
VRCS_SNAP_TO_GRID_Y_RELATIVE </DT><DD>
This flag signals that the mouse position should be vertically snapped to a grid such as would be formed if the present grid spacing was used with the reference point as the grid's origin.</DD>
<DT>
VRCS_SNAP_TO_GUIDES_X </DT><DD>
This flag signals that the mouse positions should be horizontally snapped to guidelines. Note that guidelines are only effective within range of their &quot;influence&quot; in pixels.</DD>
<DT>
VRCS_SNAP_TO_GUIDES_Y </DT><DD>
This flag signals that the mouse positions should be vertically snapped to guidelines. Note that guidelines are only effective within range of their &quot;influence&quot; in pixels. </DD>
<DT>
VRCS_CONSTRAIN_TO_HORIZONTAL_AXIS </DT><DD>
This flag signals that the mouse position should be restrained to the horizontal line passing through the reference point.</DD>
<DT>
VRCS_CONSTRAIN_TO_VERTICAL_AXIS</DT><DD>
This flag signals that the mouse position should be restrained to the vertical line passing through the reference point.</DD>
<DT>
VRCS_CONSTRAIN_TO_UNITY_SLOPE_AXIS </DT><DD>
This flag signals that the mouse position should be restrained to the diagonal line with slope (<EM>
y </EM>
= <EM>
x</EM>
) passing through the reference point.</DD>
<DT>
VRCS_CONSTRAIN_TO_NEGATIVE_UNITY_SLOPE_AXIS </DT><DD>
This flag signals that the mouse position should be restrained to the diagonal line with slope (<EM>
y</EM>
 = <EM>
-x</EM>
) passing through the reference point.</DD>
<DT>
VRCS_CONSTRAIN_TO_VECTOR </DT><DD>
This flag signals that the mouse position should be constrained to the line passing through the reference and vector points.</DD>
<DT>
VRCS_CONSTRAIN_TO_VECTOR_REFLECTION </DT><DD>
This flag signals that the mouse position should be constrained to the reflection of the line passing through the reference and vector points.</DD>
</DL>
<P>
The <A NAME="IX_VRI_type">
 </A>
<CODE>
VRI_type</CODE>
 and <A NAME="IX_VRI_minIncrement">
 </A>
<CODE>
VRI_minIncrement</CODE>
 fields determine the measurement type and ruler increment of the ruler.Normally, the user will work with the ruler's type via a RulerTypeControl. <CODE>
RulerTypeControlClass</CODE>
<A NAME="IX_RulerTypeControlClass">
 </A>
's features structures are shown below.</P>
<P CLASS="figTitle">
Code Display 19-2 RulerTypeControl Features</P>
<PRE>typedef WordFlags <A NAME="IX_RTCFeatures"> </A>RTCFeatures;
#define <A NAME="IX_RTCF_&ldots;"> </A>RTCF_DEFAULT				(0x20)
#define RTCF_SPREADSHEET 				(0x10)
#define RTCF_INCHES 				(0x08)
#define RTCF_CENTIMETERS 				(0x04)
#define RTCF_POINTS 				(0x02)
#define RTCF_PICAS 				(0x01)
#define <A NAME="IX_RTC_DEFAULT_FEATURES"> </A>RTC_DEFAULT_FEATURES \
	(RTCF_INCHES | RTCF_CENTIMETERS | RTCF_POINTS | RTCF_PICAS | RTCF_DEFAULT)</PRE>
<PRE>typedef WordFlags <A NAME="IX_RTCToolboxFeatures"> </A>RTCToolboxFeatures;
#define <A NAME="IX_RTCTF_&ldots;"> </A>RTCTF_DEFAULT 				(0x20)
#define RTCTF_SPREADSHEET 				(0x10)
#define RTCTF_INCHES 				(0x08)
#define RTCTF_CENTIMETERS 				(0x04)
#define RTCTF_POINTS 				(0x02)
#define RTCTF_PICAS 				(0x01)
#define <A NAME="IX_RTC_DEFAULT_TOOLBOX_FEATURES"> </A>RTC_DEFAULT_TOOLBOX_FEATURES (RTCF_INCHES | RTCF_CENTIMETERS)</PRE>
<P>
The RulerTypeControl uses a notification block with the following structure:</P>
<PRE>typedef struct RulerTypeNotificationBlock {
	VisRulerType <A NAME="IX_RTNB_type"> </A>RTNB_type;
} <A NAME="IX_RulerTypeNotificationBlock"> </A>RulerTypeNotificationBlock;</PRE>
<P>
The ruler must keep track of the main view's scale; if the main view has doubled in scale, the ruler should put its tick marks twice as far apart. This scale is stored in the <CODE>
VRI_scale</CODE>
 field. The ruler automatically receives a MSG_VIS_RULER_VIEW_SCALE_FACTOR_CHANGED when the main view's scale changes. To set the scale independently of the main view scale, send a <CODE>
MSG_VIS_RULER_SET_SCALE</CODE>
. </P>
<P>
The <A NAME="IX_VRI_origin">
 </A>
<CODE>
VRI_origin</CODE>
 field allows you to set an origin for the ruler other than (0,0). The coordinates are given in terms of the main view's coordinate system.</P>
<P>
The reference point, used for various types of mouse constraint, is stored in the <A NAME="IX_VRI_reference">
 </A>
<CODE>
VRI_reference</CODE>
 field.</P>
<P>
<CODE>
VRI_mouseMark</CODE>
<A NAME="IX_VRI_mouseMark">
 </A>
 contains the coordinate at which the mouse tick is currently being drawn.</P>
<P>
The <A NAME="IX_VRI_window">
 </A>
<CODE>
VRI_window</CODE>
 field, initiated automatically, holds the window handle of the main view.</P>
<P>
The <A NAME="IX_VRI_slave">
 </A>
<CODE>
VRI_slave</CODE>
 field holds the ruler's slave ruler; see the documentation for VRA_MASTER, above, to learn about master and slave rulers.</P>
<P>
The<CODE>
 VRI_grid</CODE>
<A NAME="IX_VRI_grid">
 </A>
 field contains the information used to maintain the grid associated with a ruler.</P>
<P>
The <A NAME="IX_VRI_vectorSlope">
 </A>
<CODE>
VRI_vectorSlope</CODE>
 defines the slope of a vector that may be used with vector mouse constraints.</P>
<P>
The <A NAME="IX_VRI_guideArray">
 </A>
<CODE>
VRI_guideArray</CODE>
 field keeps track of the location where guideline data is stored; this field is initiated automatically.</P>
<P>
The <A NAME="IX_VRI_guideInfluence">
 </A>
<CODE>
VRI_guideInfluence</CODE>
 contains the influence to use when constraining the mouse position to guidelines. Guidelines will only attract the mouse if it is within a certain distance of them--this distance is the &quot;influence&quot; of the guidelines. It is measured in pixels, not points; thus, the guide influence is independent of scale. </P>
<P>
The <A NAME="IX_VRI_desiredSize">
 </A>
<CODE>
VRI_desiredSize</CODE>
 field contains the ruler's idea of its ideal thickness. By default, this is set so that the ruler will have room to draw its numbers and tick marks normally; if you will be subclassing the VisRuler to add more gadgetry, you may wish to use a different value here.</P>
<P>
The <A NAME="IX_VRI_invalOD">
 </A>
<CODE>
VRI_invalOD</CODE>
 field contains the object descriptor of the object which should be redrawn when the ruler needs to draw something differently to the main view; by the ruler's default behavior, this will be updated automatically via a <CODE>
MSG_VIS_RULER_GAINED_SELECTION</CODE>
.</P>
<P>
The <A NAME="IX_VRI_transformGState">
 </A>
<CODE>
VRI_transformGState</CODE>
 field contains the handle of a GState. This GState contains the transformation which is used to transform the coordinate system used with mouse constraints.</P>

<H5 CLASS="RefETitle">
<A NAME="IX_MSG_VIS_RULER_SET_TYPE">
 </A>
MSG_VIS_RULER_SET_TYPE</H5>
<PRE CLASS="syntax">void	MSG_VIS_RULER_SET_TYPE(
        VisRulerType type);</PRE>
<P>
This message sets the <CODE>
VRI_type</CODE>
 field.</P>


<H5 CLASS="RefETitle">
<A NAME="IX_MSG_VIS_RULER_GET_TYPE">
 </A>
MSG_VIS_RULER_GET_TYPE</H5>
<PRE CLASS="syntax">VisRulerType MSG_VIS_RULER_GET_TYPE();</PRE>
<P>
This message returns the value in the <CODE>
VRI_type</CODE>
 field.</P>


<H5 CLASS="RefETitle">
<A NAME="IX_MSG_VIS_RULER_SET_CONSTRAIN_STRATEGY">
 </A>
MSG_VIS_RULER_SET_CONSTRAIN_STRATEGY</H5>
<PRE CLASS="syntax">void MSG_VIS_RULER_SET_CONSTRAIN_STRATEGY(
        VisRulerConstrainStrategy 				setflags,
        VisRulerConstrainStrategy 				clearflags);</PRE>
<P>
This message sets the default mouse constrain strategy for the ruler.</P>
<P CLASS="refField">
Parameters:	<EM>setflags</EM>	Flags to set.</P>
<DL>
<DT>
<EM>clearflags</EM></DT><DD>Flags to clear.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>


<H5 CLASS="RefETitle">
<A NAME="IX_MSG_VIS_RULER_GET_CONSTRAIN_STRATEGY">
 </A>
MSG_VIS_RULER_GET_CONSTRAIN_STRATEGY</H5>
<PRE CLASS="syntax">VisRulerConstrainStrategy
MSG_VIS_RULER_GET_CONSTRAIN_STRATEGY();</PRE>
<P>
This message gets the current default constrain strategy for the ruler.</P>


<H5 CLASS="RefETitle">
<A NAME="IX_MSG_VIS_RULER_SET_IGNORE_ORIGIN">
 </A>
MSG_VIS_RULER_SET_IGNORE_ORIGIN</H5>
<PRE CLASS="syntax">void MSG_VIS_RULER_SET_IGNORE_ORIGIN(
        Boolean 		ignore);</PRE>
<P>
This message sets the &quot;ignore origin&quot; state.</P>
<P CLASS="refField">
Parameters:	<EM>ignore</EM>	Set <EM>
true</EM>
 (i.e. non-zero) to ignore the origin. Set <EM>
false</EM>
 (i.e. zero) not to ignore the origin.</P>
<P CLASS="refField">
Return:	Nothing.</P>


<H5 CLASS="RefETitle">
<A NAME="IX_MSG_VIS_RULER_SET_ORIGIN">
 </A>
MSG_VIS_RULER_SET_ORIGIN</H5>
<PRE CLASS="syntax">void MSG_VIS_RULER_SET_ORIGIN(
        sdword 		pointInt, 
        word 		pointFrac);</PRE>
<P>
Use this message to set the ruler's origin point.</P>


<H5 CLASS="RefETitle">
<A NAME="IX_MSG_VIS_RULER_GET_ORIGIN">
 </A>
MSG_VIS_RULER_GET_ORIGIN</H5>
<PRE CLASS="syntax">void MSG_VIS_RULER_GET_ORIGIN(
        DWFixedReturn *retval);</PRE>
<P>
Use this message to retrieve the ruler's origin point.</P>
<P CLASS="refField">
Structures:	</P>
<PRE>typedef struct {
	word 		unused;
	word 		<A NAME="IX_DWFR_&ldots;"> </A>DWFR_frac;
	sdword 		DWFR_int;
} <A NAME="IX_DWFixedReturn"> </A>DWFixedReturn;</PRE>


<H5 CLASS="RefETitle">
<A NAME="IX_MSG_VIS_RULER_SET_REFERENCE">
 </A>
MSG_VIS_RULER_SET_REFERENCE</H5>
<PRE CLASS="syntax">void MSG_VIS_RULER_SET_REFERENCE( @stack
        sdword 		yInt, 
        word 		yFrac, 
        sdword 		xInt, 
        word 		xFrac);</PRE>
<P>
Set the ruler's reference point.</P>


<H5 CLASS="RefETitle">
<A NAME="IX_MSG_VIS_RULER_SET_VECTOR">
 </A>
MSG_VIS_RULER_SET_VECTOR</H5>
<PRE CLASS="syntax">void MSG_VIS_RULER_SET_VECTOR( @stack
        sdword 		yInt, 
        word 		yFrac, 
        sdword 		xInt, 
        word 		xFrac);</PRE>
<P>
Set the point to use to define the &quot;vector&quot;--together with the reference point, this will form a slope which may be used for mouse constraints. </P>


<H5 CLASS="RefETitle">
<A NAME="IX_MSG_VIS_RULER_SET_MIN_INCREMENT">
 </A>
MSG_VIS_RULER_SET_MIN_INCREMENT</H5>
<PRE CLASS="syntax">void	MSG_VIS_RULER_SET_MIN_INCREMENT(
        MinIncrementType min);</PRE>
<P>
This message sets the <CODE>
VRI_minIncrement</CODE>
 field to the passed value. It must be passed the proper <CODE>
MinIncrementType</CODE>
 value.</P>


<H5 CLASS="RefETitle">
<A NAME="IX_MSG_VIS_RULER_SET_SCALE">
 </A>
MSG_VIS_RULER_SET_SCALE</H5>
<PRE CLASS="syntax">void	MSG_VIS_RULER_SET_SCALE(
        WWFixedAsDWord scale);</PRE>
<P>
This message sets the <CODE>
VRI_scale</CODE>
 field.</P>

<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="Ruler_2.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">2 Ruler Setup</A> 
<!-- to next --> | <A HREF="Ruler_4.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">4 Managing Rulers</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
