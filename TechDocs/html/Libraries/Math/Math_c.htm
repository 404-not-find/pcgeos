<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: Math_c.htm,v 1.2 97/09/05 12:31:53 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE> Floating Point Math Routines</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">


<H1 CLASS="subsectionTitle">
<A HREF="index.htm">The Math Library</A>: 4.3 <A HREF="Math_9.htm">Direct FP Operations</A>: 
Floating Point Math Routines</H1>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="Math_9.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="Math_b.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">4.2 The Floating Point Stack</A> 
<!-- to next --> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
<P>
The Float Library provides a number of routines to modify data on the FP stack. These routines can be categorized in several major groups:</P>
<UL>
<LI>
Constant Routines</LI>
<LI>
Math Routines</LI>
<LI>
Transcendental Routines</LI>
<LI>
Conversion Routines</LI>
<LI>
Date and Time Routines</LI>
</UL>

<H2 CLASS="HeadingCApp">
<A NAME="IX_Constants:Floating-Point;Constants:Routines;Routines:Floating-Point Routines">
 </A>
Constant Routines</H2>
<PRE>Float0(), FloatPoint5(), Float1(), FloatMinusPoint5(), FloatMinus1(),Float2(), Float5(), Float10(), Float3600(), Float16384(), Float86400()</PRE>
<PRE>FloatPi(), FloatPiDiv2(),FloatLg10(), FloatLn2(), FloatLn10(), FloatSqrt2()</PRE>
<P>
The Constant Routines provide a means of quickly obtaining an often used number or an often used operation with a constant operand. Each of these functions pushes the constant FP value onto the top of the FP stack. (For example, <CODE>
FloatMinusPoint5()</CODE>
 pushes -.5 onto the FP stack.)</P>
<P>
<CODE>
FloatPi()</CODE>
, <CODE>
FloatPiDiv2()</CODE>
, <CODE>
FloatLg10()</CODE>
, <CODE>
FloatLn2()</CODE>
, <CODE>
FloatLn10()</CODE>
, and<CODE>
 FloatSqrt2() </CODE>
each push the specified transcendental constant onto the FP stack: p,p/2, the log of 10, the natural log of 2, the natural log of 10,and the square root of 2, respectively. (See also Transcendental Routines.)</P>


<H2 CLASS="HeadingCApp">
<A NAME="IX_Constants:Floating-Point;Constants:Operands;Operands:Floating-Point Routines">
 </A>
Constant Operands</H2>
<PRE>FloatMultiply2(), FloatMultiply10(), FloatDivide2(), FloatDivide10(), Float10ToTheX()</PRE>
<P>
<CODE>
FloatMultiply2(), FloatMultiply10(), FloatDivide2(), FloatDivide10() </CODE>
perform the specified operations on the contents of S1, either multiplying or dividing the contents of S1 by 2 or 10, and push the result onto the FP stack. The original value in S1 is popped off of the stack.</P>
<P>
<CODE>
Float10ToTheX() </CODE>
pushes 10 to a passed exponent onto the FP stack.</P>


<H2 CLASS="HeadingCApp">
<A NAME="IX_Math:Algebraic Routines;Routines:Floating-Point Algebra">
 </A>
Algebraic Routines</H2>
<PRE>FloatAbs(), FloatAdd(), FloatSub(), FloatDivide(), FloatMultiply(), FloatDIV(), FloatMod(),FloatFactorial(), FloatNegate(), FloatInverse()</PRE>
<P>
The Math Routines perform various operations on numbers already placed on the FP stack. All of the following routines pop the operated numbers off of the stack and push the result onto S1.</P>
<P>
<CODE>
FloatAdd() </CODE>
adds the contents of S1 and S2, and pushes the result onto the top of the FP stack. The original values are popped off the stack.</P>
<P>
<CODE>
FloatSub() </CODE>
subtracts<CODE>
 </CODE>
the contents of S1 from the contents of S2, and pushes the result onto the top of the FP stack. The original values are popped off the stack.</P>
<P>
Note that, in general, numbers will be pushed onto the stack in the order they would normally be operated on. For example, to obtain X1-X2, the programmer would first push X1, then X2, and call <CODE>
FloatSub</CODE>
, as in the following diagram:
<IMG SRC="Math_c_sub.gif">

</P>
<P>
since X1 would now be in location S2, while X2 is in location S1.</P>
<P>
<CODE>
FloatMultiply() </CODE>
multiplies the contents of S1 and S2 and pushes the result onto the top of the FP stack. The original values are popped off the stack.</P>
<P>
<CODE>
FloatDivide() </CODE>
divides the contents of S2 by the contents of S1 and pushes the result onto the top of the FP stack. The original values are popped off the stack.</P>
<P>
<CODE>
FloatDIV() </CODE>
performs a <CODE>
FloatDivide()</CODE>
, truncating the fractional portion of the number and returning only the integer result. The original values are popped off the stack.</P>
<P>
<CODE>
FloatMod() </CODE>
pushes S2 mod S1 (the remainder of <CODE>
FloatDivide()</CODE>
) onto the top of the FP stack. The original values are popped off the stack.</P>
<P>
<CODE>
FloatAbs() </CODE>
pushes the absolute value of S1 onto the top of the FP stack. The original value is popped off the stack.</P>
<P>
<CODE>
FloatFactorial() </CODE>
pushes the factorial (x!) of the value in S1 onto the top of the FP stack. The original value is popped off the stack. </P>
<P>
<CODE>
FloatNegate() </CODE>
negates the value in S1 and pushes the result onto the top of the FP stack. The<CODE>
 </CODE>
original value is popped off the stack. </P>
<P>
<CODE>
FloatInverse() </CODE>
pushes the inverse of the value in S1 (-S1) onto the top of the FP stack. The original value is popped off of the stack.</P>


<H2 CLASS="HeadingCApp">
<A NAME="IX_Math:Comparison Routines;Routines:Floating-Point Comparison">
 </A>
Comparison Routines</H2>
<PRE><CODE>FloatMax(), FloatMin(), FloatLt0(), FloatEq0(), FloatGt0()</CODE></PRE>
<P>
<CODE>
FloatMax() </CODE>
performs a compare of the FP numbers in S1 and S2 and, if necessary, swaps the greater number into S1.</P>
<P>
<CODE>
FloatMin() </CODE>
performs a compare of the FP numbers in S1 and S2 and, if necessary, swaps the lesser number into S1.</P>
<P>
<CODE>
FloatLt0(), FloatEq0(), FloatGt0() </CODE>
check whether the FP number in S1 is less than zero, equal to zero, or greater than zero. The carry bit is set to TRUE if the relationship is true. The original value is popped off of the stack. </P>


<H2 CLASS="HeadingCApp">
<A NAME="IX_Math:Fractions and Integers;Routines:Floating-Point Fractions and Integers">
 </A>
Fractional and Integral Routines</H2>
<PRE>FloatFrac(), FloatTrunc(), FloatInt(), FloatIntFrac(), FloatRound()</PRE>
<P>
<CODE>
FloatFrac() </CODE>
pushes the fractional portion of S1 onto the FP stack. The original value is popped off of the stack. </P>
<P>
<CODE>
FloatTrunc() </CODE>
pushes the integral portion of the contents of S1 onto the FP stack. This amounts to a rounding of the FP number toward zero, so that <CODE>
FloatTrunc() </CODE>
performed on -7.8 would return -7. The original value is popped off the stack. </P>
<P>
<CODE>
FloatInt() </CODE>
rounds S1 down to its integral component, so that <CODE>
FloatInt() </CODE>
performed on -7.8 would return -8. Note that for negative numbers, this is different from <CODE>
FloatTrunc()</CODE>
. The original value is popped off the stack.</P>
<P>
<CODE>
FloatIntFrac() </CODE>
splits a number into its fractional and integral parts, with the fractional part in S1 and the integral part in S2. The original value is popped off the stack.</P>
<P>
<CODE>
FloatRound() </CODE>
rounds S1 to a given number of decimal places. <CODE>
FloatRound() </CODE>
passed with zero as an argument rounds S1 to the nearest integer, rounding up if greater than or equal to .5, rounding down if less than .5</P>


<H2 CLASS="HeadingCApp">
<A NAME="IX_Math:Random Numbers;Routines:Random Numbers">
 </A>
Routines that Return Random Values</H2>
<PRE>FloatRandom(), FloatRandomN(), FloatRandomize()</PRE>
<P>
<CODE>
FloatRandom() </CODE>
pushes a random number between 0 (inclusive) and 1 (exclusive) onto the stack. </P>
<P>
<CODE>
FloatRandomN() </CODE>
pushes a random integer between 0 (inclusive) and N (exclusive) onto the stack. </P>
<P>
<CODE>
FloatRandomize()</CODE>
 primes the random number generator. This routine expects a seed and some <CODE>
RandomGenInitFlags</CODE>
. If the flag RGIF_USE_SEED is passed, then a developer-supplied seed will be used. Otherwise, a seed based on the timer clock will be used. </P>
<P>
<CODE>
FloatRandomize() </CODE>
should always be called before any of the <CODE>
FloatRandom() </CODE>
routines to ensure a high degree of randomness.</P>
<P>
The random number generation method uses the linear congruential method, an algorithm which ensures a high degree of randomness in the computation method. </P>


<H2 CLASS="HeadingCApp">
Transcendental Functions</H2>
<P>
Transcendental functions are functions that cannot be constructed using normal arithmetic routines. Care must be taken with the following routines to ensure that they are operating on a valid range of values. Otherwise, the routines will return an error. </P>

<H3 CLASS="HeadingD">
<A NAME="IX_Math:Trigonometric Routines;Routines:Floating-Point Trigonometry">
 </A>
Trigonometric Routines</H3>
<PRE>FloatSin(), FloatCos(), FloatTan(), FloatArcSin(), FloatArcCos(), FloatArcTan(), FloatArcTan2(), FloatSinh(), FloatCosh(), FloatTanh(), FloatArcSinh(), FloatArcCosh(), FloatArcTanh()</PRE>
<P>
<CODE>
FloatSin(), FloatCos()</CODE>
, and<CODE>
 FloatTan() </CODE>
perform the given operation on the contents of S1, pushing the result onto the FP stack. S1 must be expressed in radians. The original value is popped off of the stack.</P>
<P>
<CODE>
FloatArcSin(), FloatArcCos()</CODE>
, and <CODE>
FloatArcTan() </CODE>
perform<CODE>
 </CODE>
the given inverse operation on S1, pushing the result onto the FP stack. The result is given in radians. The original value is popped off of the stack.</P>
<P>
<CODE>
FloatArcTan2() </CODE>
calculates the arc tangent given cartesian coordinates <EM>
x</EM>
 and <EM>
y</EM>
. The arctangent is calculated from the x-axis through the origin to the given point. The value returned is expressed in radians, between -p (exclusive) and +p (inclusive). The original values are popped off of the stack.</P>
<P>
<CODE>
FloatSinh(), FloatCosh()</CODE>
, and <CODE>
FloatTanh() </CODE>
perform the given hyperbolic operations on S1, pushing the result onto the FP stack. The original value is popped off of the stack.</P>
<P>
<CODE>
FloatArcSinh(), FloatArcCosh()</CODE>
, and<CODE>
 FloatArcTanh() </CODE>
perform the given inverse hyperbolic operations on S1, pushing the result onto the FP stack. The original value is popped off of the stack.</P>


<H3 CLASS="HeadingD">
<A NAME="IX_Math:Exponential Routines;Routines:Floating-Point Exponents">
 </A>
Exponential Routines</H3>
<PRE>FloatExp(), FloatExponential(), FloatLg(), FloatLog(), FloatLn(), FloatLn1plusX(), FloatSqr(), FloatSqrt()</PRE>
<P>
<CODE>
FloatExp() </CODE>
performs the exponentiation of <EM>
e</EM>
 to the power of S1, pushing the result onto the FP stack. The original value is popped off of the stack.</P>
<P>
<CODE>
FloatExponential() </CODE>
performs the exponentiation of S2 to the power of S1, pushing the result onto the FP stack. The original values are popped off of the stack.</P>
<P>
<CODE>
FloatLg()</CODE>
 performs the logarithm to the base 2 on S1, pushing the result onto the FP stack. The original value is popped off of the stack.</P>
<P>
<CODE>
FloatLog()</CODE>
 performs the logarithm to the base 10 on S1. The original value is popped off the stack.</P>
<P>
<CODE>
FloatLn() </CODE>
performs the natural logarithm (log base <EM>
e</EM>
) on S1. The original value is popped off the stack.</P>
<P>
<CODE>
FloatLn1plusX() </CODE>
performs the natural log of (1 + S1). The original value is popped off the stack.</P>
<P>
<CODE>
FloatSqr() </CODE>
performs the square of S1, pushing<CODE>
 </CODE>
the result onto the FP stack. The original value is popped off the stack.</P>
<P>
<CODE>
FloatSqrt() </CODE>
performs the square root of S1, pushing the result onto the FP stack. The original value is popped off the stack.</P>



<H2 CLASS="HeadingCApp">
<A NAME="IX_Math:Conversion Routines;Routines:Floating-Point Conversion">
 </A>
Conversion Routines</H2>
<P>
At some point 80-bit FP numbers may need to be converted into different formats, or you may need to convert these differently formatted numbers into a floating point representation. The Math Library provides for this contingency. </P>

<H3 CLASS="HeadingD">
Conversions Between Integers and FP Numbers</H3>
<PRE>FloatDwordToFloat(), FloatWordToFloat(), FloatFloatToDword()</PRE>
<P>
<CODE>
FloatDwordToFloat() </CODE>
converts a passed double-word signed integer into a floating point number, and pushes that number onto the FP stack. </P>
<P>
<CODE>
FloatWordToFloat() </CODE>
converts<CODE>
 </CODE>
a passed word signed integer into a floating point number, and pushes that number onto the FP stack.</P>
<P>
<CODE>
FloatFloatToDword() </CODE>
converts the FP number in S1 into a double-word signed integer. The FP number is converted into an integer by rounding the FP number to zero decimal places.</P>
<P>
You can convert a FP number into a word value by using <CODE>
FloatFloatToDword()</CODE>
 and just using the low word.</P>


<H3 CLASS="HeadingD">
Conversions Between 80 bit FP Numbers and Other Floats</H3>
<PRE>FloatGeos80ToIEEE64(), FloatGeos80ToIEEE32(), FloatIEEE64ToGeos80(), FloatIEEE32ToGeos80()</PRE>
<P>
<CODE>
FloatGeos80ToIEEE64()</CODE>
 converts a GEOS FP number (80 bits) into a 64 bit floating point number (in C, a type of <CODE>
double</CODE>
).</P>
<P>
<CODE>
FloatGeos80ToIEEE32()</CODE>
 converts a GEOS FP number (80 bits) into a 32 bit floating point number (in C, a type of <CODE>
float</CODE>
).</P>
<P>
<CODE>
FloatIEEE64ToGeos80()</CODE>
 converts a 64 bit FP number into a GEOS 80 bit FP number (in C, a type of <CODE>
long</CODE>
 <CODE>
double</CODE>
).</P>
<P>
<CODE>
FloatIEEE32ToGeos80()</CODE>
 converts a 32 bit FP number into a GEOS 80 bit FP number (in C, a type of <CODE>
long</CODE>
 <CODE>
double</CODE>
).</P>


<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="Math_9.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="Math_b.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">4.2 The Floating Point Stack</A> 
<!-- to next --> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
