<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: Hardware_5.htm,v 1.1 97/06/02 15:50:44 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE> The Prefetch Queue</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">


<H1 CLASS="subsectionTitle">
<A HREF="index.htm">Machine Architecture</A>: 2.3 <A HREF="Hardware_2.htm">8086 Architecture Overview</A>: 
The Prefetch Queue</H1>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="Hardware_2.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="Hardware_4.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">2.2 Registers</A> 
<!-- to next --> | <A HREF="Hardware_6.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">2.4 Inherent Optimizations</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
<P>
Programmers who code in assembly language should be familiar with how the 8086 fetches data and instructions from memory. Good programmers can take advantage of the more efficient instructions to cut down on processor time for given operations.</P>
<P>
The 8086 takes four clock cycles to fetch a single word from memory. To speed up instruction processing, the 8086 has a <EM>
prefetch queue</EM>
, a buffer of six bytes into which pending instructions are put. The 8086 is also broken into two separate processing units: The <EM>
Execution Unit</EM>
 executes instructions while the <EM>
Bus Interface Unit</EM>
 (BIU) fetches pending instructions and stuffs them into the prefetch queue.</P>
<P>
The main goal of this separation is to make as much use of the bus as possible, even when an instruction that does not access memory is being executed. For example, if an instruction takes eight cycles to execute and does not access memory, the BIU could meanwhile fill four instructions into the prefetch queue. Therefore, while slow instructions are still slow, the instructions after them appear to be quicker.</P>
<P>
However, jump and branch instructions negate this prefetch effect. When a branch or jump is executed, the prefetch queue is flushed and must again be filled.</P>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="Hardware_2.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="Hardware_4.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">2.2 Registers</A> 
<!-- to next --> | <A HREF="Hardware_6.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">2.4 Inherent Optimizations</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
