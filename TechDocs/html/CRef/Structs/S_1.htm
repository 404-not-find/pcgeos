<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: S_1.htm,v 1.4 97/08/21 13:47:52 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE>GEOS C Structs: AccessPointStandardProperty ...</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="index.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">GEOS C Structs:  ...</A> 
<!-- to next --> | <A HREF="S_2.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">AppLaunchFlags ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</DIV>
<DIV>
<A NAME="IX_AccessPointStandardProperty">
 </A>
<H1 CLASS="refHeading">
AccessPointStandardProperty</H1>
<PRE CLASS="syntax">typedef enum {
        APSP_NAME = 0x0,
        APSP_PHONE = 0x2,
        APSP_USER = 0x4,
        APSP_SECRET = 0x6,
        APSP_ADDRESS = 0x8,
        APSP_MASK = 0xa,
        APSP_GATEWAY = 0xc,
        APSP_DNS1 = 0xe,
        APSP_DNS2 = 0x10,
        APSP_DATA_BITS = 0x12,
        APSP_STOP_BITS = 0x14,
        APSP_PARITY = 0x16,
        APSP_DUPLEX = 0x18,
        APSP_MODEM_INIT = 0x1a,
        APSP_BS = 0x1c,
        APSP_HOSTNAME = 0x1e,
        APSP_INTERNET_ACCPNT = 0x20,
        APSP_PROMPT_SECRET = 0x22,					/* This property is an integer */
        APSP_AUTOMATIC = 0x4000,
        APSP_UNDEFINED = 0xffff,

             /* The following are only available on build 4 or more recent
                of the Nokia 9000i Communicator. */

        APSP_USE_LOGIN_APP = 0x24,
        APSP_LOGIN_APP_NAME = 0x26,
        APSP_SCRIPT_NAME = 0x28,
        APSP_CCARD_NAME = 0x2a,
        APSP_CCARD_ACCESS = 0x2c,
        APSP_CCARD_ID = 0x2e,
        APSP_CCARD_PREFIX = 0x30,
        APSP_CCARD_SEQUENCE = 0x32,
        APSP_COMPRESSION = 0x34,  
} AccessPointStandardProperty;</PRE>
<P>
All of the property data associated with these standard properties are strings, except where noted.</P>
<P>
Any <CODE>
AccessPointStandardProperty</CODE>
 value can be combined (bitwise-OR'd) with APSP_AUTOMATIC to make an alternative form of the name.  This library puts no special interpretation on automatic names, but they are intended to represent values which are obtained from automatic configuration and not from the user.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
</DIV>
<DIV>
<A NAME="IX_AccessPointType">
 </A>
<H1 CLASS="refHeading">
AccessPointType</H1>
<PRE CLASS="syntax">typedef enum {
    APT_INTERNET = 0x1,
    APT_TERMINAL,
    APT_TELNET,
    APT_APP_LOCAL,
} AccessPointType;
#define APT_ALL (0)</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	accpnt.goh</P>
</DIV>
<DIV>
<A NAME="IX_AUAF_&ldots;">
 </A>
<A NAME="IX_AddUndoActionFlags">
 </A>
<H1 CLASS="refHeading">
AddUndoActionFlags</H1>
<PRE CLASS="syntax">typedef WordFlags AddUndoActionFlags;
#define AUAF_NOTIFY_BEFORE_FREEING											 		  			0x8000
#define AUAF_NOTIFY_IF_FREED_WITHOUT_BEING_PLAYED_BACK		 0x4000</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="IX_AUAS_&ldots;">
 </A>
<A NAME="IX_AddUndoActionStruct">
 </A>
<H1 CLASS="refHeading">
AddUndoActionStruct</H1>
<PRE CLASS="syntax">typedef struct {
UndoActionStruct 				AUAS_data;
optr 				AUAS_output;
AddUndoActionFlags 				AUAS_flags;
} AddUndoActionStruct;</PRE>
<P>
The &quot;undo&quot; structures work together to provide information vital to processes which will be working with undo events.</P>
</DIV>
<DIV>
<A NAME="IX_AppAttachFlags">
 </A>
<A NAME="IX_AAF_&ldots;">
 </A>
<H1 CLASS="refHeading">
AppAttachFlags</H1>
<PRE CLASS="syntax">typedef WordFlags AppAttachFlags;
#define AAF_RESTORING_FROM_STATE						0x8000
#define AAF_STATE_FILE_PASSED						0x4000
#define AAF_DATA_FILE_PASSED						0x2000</PRE>
<P>
These flags are passed to the process when the application is launching or being restored from a state file. The flags indicate whether the application is being launched from a state file, has a state file, and/or has a data file.</P>
<P>
Note that if AAF_RESTORING_FROM_STATE is set, then AAF_STATE_FILE_PASSED will also be set.</P>
</DIV>
<DIV>
<A NAME="IX_AppInstanceReference">
 </A>
<A NAME="IX_AIR_&ldots;">
 </A>
<H1 CLASS="refHeading">
AppInstanceReference</H1>
<PRE CLASS="syntax">typedef struct {
/* AIR_fileName:
 * Application being launched. Pathname is relative to application 
 * directory (which, of course, may be overriden with a direct path
 * to the application). */
PathName 				AIR_fileName;</PRE>
<PRE CLASS="syntax">/* AIR_stateFile:
 * State filename. File is assumed to be in standard directory for
 * GEOS state files. If the first byte is &quot;0&quot;, then there is no
 * state file for this application. This structure is copied into the
 * field as an aid in restarting applications, and if it comes across
 * one with this byte as 0, it will not restart it. */
FileLongName 				AIR_stateFile;</PRE>
<PRE CLASS="syntax">/* AIR_diskHandle:
 * Disk handle for app (passed in) IF 0, use System disk, if -1, use
 * AIR_diskName. In the field, if this is a placeholder structure, this
 * word is the handle of the application object we are waiting to detach. */
DiskHandle 				AIR_diskHandle;</PRE>
<PRE CLASS="syntax">/* AIR_savedDiskData:
 * Start of data stored by DiskSave when instance is saved to state file. */
byte 				AIR_savedDiskData[1];</PRE>
<PRE CLASS="syntax">} AppInstanceReference;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="IX_AppLaunchBlock">
 </A>
<A NAME="IX_ALB_&ldots;">
 </A>
<H1 CLASS="refHeading">
AppLaunchBlock</H1>
<PRE CLASS="syntax">typedef struct {
/* ALB_appRef:
 * Instance reference. Contains full pathname to application, as 
 * referenced from app directory, plus the name of a state file. 
 * Is enough info to launch application again, restored. (State file 
 * need not be passed to GeodeLoad) */
AppInstanceReference 				ALB_appRef;</PRE>
<PRE CLASS="syntax">/* ALB_appMode:
 * Application attach mode method. Should be one of the following:
 * MSG_GEN_PROCESS_RESTORE_FROM_STATE:
 * 	State file must be passed; no data file should be passed.
 * MSG_GEN_PROCESS_OPEN_APPLICATION:
 * 	State file normally should not be passed, although one could be to
 * 	accomplish ui templates. A data file may be passed into the 
 * 	application as well.
 * MSG_GEN_PROCESS_OPEN_ENGINE:
 * 	State file normally should not be passed. The data file on which the 
 * 	engine will operate must be passed. If zero, the default data file 
 * 	should be used (enforced by app, not GenProcessClass).*/
Message 				ALB_appMode;</PRE>
<PRE CLASS="syntax">/* ALB_launchFlags:
 * Miscellaneous flags to specify desired application launch type. */
AppLaunchFlags 				ALB_launchFlags;</PRE>
<PRE CLASS="syntax">/* ALB_diskHandle:
 * Disk handle for data path. (Set as application's current path in 
 * GenProcess' MSG_META_ATTACH handler.) */
MemHandle 				ALB_diskHandle;</PRE>
<PRE CLASS="syntax">/* ALB_path:
 * Data path for application to use as initial path. (Usually this is 
 * a directory of any data file passed.) (Set as application current
 * path in GenProcess' MSG_META_ATTACH handler.)
char 				ALB_path[PATH_BUFFER_SIZE];</PRE>
<PRE CLASS="syntax">/* ALB_dataFile:
 * Name of data file passed in to be opened (0 if none). Pathname is 
 * relative to above path. */
char 				ALB_dataFile[PATH_BUFFER_SIZE];</PRE>
<PRE CLASS="syntax">/* ALB_genParent:
 * Generic parent for new application (0 to put on default field). (Should 
 * be passed NULL to MSG_GEN_FIELD_LAUNCH_APPLICATION).
optr 				ALB_genParent;</PRE>
<PRE CLASS="syntax">/* ALB_userLoadAckOutput, ALB_userLoadAckMessage:
 * Together, these form an Action Descriptor which will be activated when 
 * the application has been launched (used in conjunction with 
 * ALF_SEND_LAUNCH_REQUEST_TO_UI_TO_HANDLE). (Set to NULL/0 if you don't 
 * want to send anything). 
 * The acknowledgement will come with three arguments: the GeodeHandle 
 * (non-NULL if successful), a word value which will be zero if there was
 * an error, and the word value set in ALB_userLoackAckID (below).*/
optr 				ALB_userLoadAckOutput;</PRE>
<PRE CLASS="syntax">Message 				ALB_userLoadAckMessage;
/* ALB_userLoadAckID:
 * ID sent out via above action descriptor, if any. */
word 				ALB_userLoadAckID;</PRE>
<PRE CLASS="syntax">/* ALB_extraData:
 * Extra data to send to process (possibly a handle to 
 * block containing arguments). */
word 				ALB_extraData;</PRE>
<PRE CLASS="syntax">} AppLaunchBlock;</PRE>
<P>
This structure is used when an application is first starting up. It is an argument of various messages which will be intercepted by system classes. The first fields (<CODE>
ALB_appRef</CODE>
, <CODE>
ALB_appMode</CODE>
, <CODE>
ALB_launchFlags</CODE>
, and <CODE>
ALB_uiLevel</CODE>
) are preserved in the application's state file. The other information must be set correctly on launch.</P>
</DIV>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="index.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">GEOS C Structs:  ...</A> 
<!-- to next --> | <A HREF="S_2.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">AppLaunchFlags ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
