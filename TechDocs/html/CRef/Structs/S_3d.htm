<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: S_3d.htm,v 1.1 97/06/02 12:45:52 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE>GEOS C Structs: TextMode ...</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="S_3c.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">SystemDrawMask ...</A> 
<!-- to next --> | <A HREF="S_3e.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">TextReferenceType ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</DIV>
<DIV>
<A NAME="IX_TextMode">
 </A>
<H1 CLASS="refHeading">
TextMode</H1>
<PRE CLASS="syntax">typedef ByteFlags TextMode;
#define TM_TRACK_KERN						0x40
#define TM_PAIR_KERN 						0x20
#define TM_PAD_SPACES 						0x10
#define TM_DRAW_BASE 						0x08
#define TM_DRAW_BOTTOM 						0x04
#define TM_DRAW_ACCENT 						0x02
#define TM_DRAW_OPTIONAL_HYPHENS 						0x01</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="IX_TextReference">
 </A>
<A NAME="IX_TR_&ldots;">
 </A>
<H1 CLASS="refHeading">
TextReference</H1>
<PRE CLASS="syntax">typedef struct {
TR_type		TextReferenceType;
TR_ref		TextReferenceUnion;</PRE>
<PRE CLASS="syntax">} TextReference;</PRE>
<P>
&nbsp;</P>
</DIV>
<DIV>
<A NAME="IX_TextReferenceBlock">
 </A>
<A NAME="IX_TRB_handle">
 </A>
<H1 CLASS="refHeading">
TextReferenceBlock</H1>
<PRE CLASS="syntax">typedef struct {
MemHandle		TRB_handle;
} TextReferenceBlock;</PRE>
<P>
This structure corresponds to a <CODE>
TextReferenceType</CODE>
 of TRT_BLOCK. It is used with MSG_VIS_TEXT_REPLACE_TEXT and MSG_VIS_TEXT_GET_TEXT_RANGE to reference text used by those messages.</P>
<P>
TRB_<CODE>
handle </CODE>
stores the handle of the text buffer. No entries need to be filled in to allocate a destination buffer. The heap allocation request will be made with the HAF_NO_ERR flag. If VTGRF_RESIZE is passed then either the passed block or the allocated block will be resized to accommodate the text.</P>
</DIV>
<DIV>
<A NAME="IX_TextReferenceBlockChunk">
 </A>
<A NAME="IX_TRBC_ref">
 </A>
<H1 CLASS="refHeading">
TextReferenceBlockChunk</H1>
<PRE CLASS="syntax">typedef struct {
optr		TRBC_ref;
} TextReferenceBlockChunk;</PRE>
<P>
This structure corresponds to a <CODE>
TextReferenceType</CODE>
 of TRT_OPTR. It is used with MSG_VIS_TEXT_REPLACE_TEXT and MSG_VIS_TEXT_GET_TEXT_RANGE to reference text used by those messages.</P>
<P>
TRBC_<CODE>
ref </CODE>
stores the optr to a text buffer (a group of character)s. The handle field of TRBC<CODE>
_ref</CODE>
 must be filled in. </P>
<P>
It is assumed that the LMem heap will be able to accommodate this allocation. The caller is responsible for ensuring that this is the case.</P>
<P>
If VTGRF_RESIZE is passed then either the passed block or the allocated block will be resized to accommodate the text.</P>
</DIV>
<DIV>
<A NAME="IX_TextReferenceDBItem">
 </A>
<A NAME="IX_TRDBI_&ldots;">
 </A>
<H1 CLASS="refHeading">
TextReferenceDBItem</H1>
<PRE CLASS="syntax">typedef struct {
FileHandle 		TRDBI_file;
DBItem		TRDBI_item;
DBGroup		TRDBI_group;
} TextReferenceDBItem;</PRE>
<P>
This structure corresponds to a <CODE>
TextReferenceType</CODE>
 of TRT_DB_ITEM. It is used with MSG_VIS_TEXT_REPLACE_TEXT and MSG_VIS_TEXT_GET_TEXT_RANGE to reference text used by those messages.</P>
<P>
TRDBI__<CODE>
file </CODE>
stores the VM file associated with this DB item.</P>
<P>
TRDBI_<CODE>
item</CODE>
 stores the DB item itself.</P>
<P>
TRDBI_<CODE>
group</CODE>
 stores the DB group the item belongs to.</P>
<P>
Both TRDBI_<CODE>
file</CODE>
 and TRDBI_<CODE>
group</CODE>
 must be filled in if you want a VM block to be allocated.</P>
<P>
If the TRDBI_<CODE>
group</CODE>
 field is set to DB_UNGROUPED then the item will be allocated ungrouped. TRDBI_group will hold the group in which the item was allocated on return.</P>
<P>
If VTGRF_RESIZE is passed then either the passed block or the allocated block will be resized to accommodate the text.</P>
</DIV>
<DIV>
<A NAME="IX_TextReferenceHugeArray">
 </A>
<A NAME="IX_TRHA_&ldots;">
 </A>
<H1 CLASS="refHeading">
TextReferenceHugeArray</H1>
<PRE CLASS="syntax">typedef struct {
FileHandle		TRHA_file;
word		TRHA_array;
} TextReferenceHugeArray;</PRE>
<P>
This structure corresponds to a <CODE>
TextReferenceType</CODE>
 of TRT_HUGE_ARRAY. It is used with MSG_VIS_TEXT_REPLACE_TEXT and MSG_VIS_TEXT_GET_TEXT_RANGE to reference text used by those messages.</P>
<P>
TRHA<CODE>
_file </CODE>
stores the VM file associated with this huge array.</P>
<P>
TRHA_<CODE>
array</CODE>
 stores the Huge Array.</P>
<P>
The TRHA_<CODE>
file</CODE>
 field must be set if you want a huge-array to be allocated.</P>
<P>
If VTGRF_RESIZE is passed then either the passed block or the allocated block will be resized to accommodate the text.</P>
</DIV>
<DIV>
<A NAME="IX_TextReferencePointer">
 </A>
<A NAME="IX_TRP_pointer">
 </A>
<H1 CLASS="refHeading">
TextReferencePointer</H1>
<PRE CLASS="syntax">typedef struct {
char _far 		*TRP_pointer;
} TextReferencePointer;</PRE>
<P>
This structure corresponds to a <CODE>
TextReferenceType</CODE>
 of TRT_POINTER. It is used with MSG_VIS_TEXT_REPLACE_TEXT and MSG_VIS_TEXT_GET_TEXT_RANGE to reference text used by those messages.</P>
<P>
TRP<CODE>
_pointer</CODE>
 stores the pointer to the text. This field must be filled in.</P>
<P>
VTGRF_RESIZE has no meaning with this sort of reference. VTGRF_ALLOCATE and VTGRF_ALLOCATE_ALWAYS are not valid flags to pass with this type of text reference. </P>
<P>
This reference is the safest way to copy text out of a text object. Since the caller allocates the block it can also handle errors in the allocation.</P>
</DIV>
<DIV>
<A NAME="IX_TextReferenceSegmentChunk">
 </A>
<A NAME="IX_TRSC_&ldots;">
 </A>
<H1 CLASS="refHeading">
TextReferenceSegmentChunk</H1>
<PRE CLASS="syntax">typedef struct {
ChunkHandle			TRSC_chunk;
Segment			TRSC_segment;
} TextReferenceSegmentChunk;</PRE>
<P>
This structure corresponds to a <CODE>
TextReferenceType</CODE>
 of TRT_SEGMENT_CHUNK. It is used with MSG_VIS_TEXT_REPLACE_TEXT and MSG_VIS_TEXT_GET_TEXT_RANGE to reference text used by those messages.</P>
<P>
TRSC_<CODE>
segment</CODE>
 stores the segment address of the text chunk. TRSC<CODE>
_chunk</CODE>
 stores the chunk offset to the text.</P>
<P>
It is assumed that the LMem heap will be able to accommodate this allocation. The caller is responsible for ensuring that this is the case.</P>
<P>
If VTGRF_RESIZE is passed then either the passed block or the allocated block will be resized to accommodate the text.</P>
</DIV>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="S_3c.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">SystemDrawMask ...</A> 
<!-- to next --> | <A HREF="S_3e.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">TextReferenceType ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
