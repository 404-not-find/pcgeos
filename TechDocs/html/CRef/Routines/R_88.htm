<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: R_88.htm,v 1.2 97/06/25 18:42:05 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE>GEOS C Routines: SocketGetAddressController() ...</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_87.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">SocketClose() ...</A> 
<!-- to next --> | <A HREF="R_89.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">SocketInterrupt() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</DIV>
<DIV>
<A NAME="IX_SocketGetAddressController()">
 </A>
<H1 CLASS="refHeading">
SocketGetAddressController()</H1>
<PRE CLASS="syntax">ClassStruct * SocketGetAddressController(
        char 			*domain)</PRE>
<P>
Given a domain name, you can create some UI gadgetry for choosing addresses within that domain. Call <CODE>
SocketGetAddressController()</CODE>
 to get the class of an appropriate controller.</P>
<P>
This routine takes a buffer containing the name of the domain for which to create a controller. It returns a <CODE>
ClassStruct</CODE>
 pointer which may be passed to <CODE>
<A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInstantiate()">ObjInstantiate()</A></CODE>
.</P>
<P>
For API information about address controllers, see XXX XREF Socket chapter XXX.</P>
<P>
If the routine returns zero, there was an error. Call <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
 to find out what the error was (it will be a <CODE>
SocketError</CODE>
 value). Look out for SE_UNKNOWN_DOMAIN.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_88.htm#IX_SocketGetDomains()">SocketGetDomains()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInstantiate()">ObjInstantiate()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_SocketGetAddressMedium()">
 </A>
<H1 CLASS="refHeading">
SocketGetAddressMedium()</H1>
<PRE CLASS="syntax">SocketError SocketGetAddressMedium(
        SocketAddress 		*sa,
        MediumAndUnit 		*mau);</PRE>
<P>
To find out which port would be used to connect to a given address, call <CODE>
SocketGetAddressMedium()</CODE>
. The socket need not actually be connected. Depending on the medium to be used, you might try to connect to the other site via some other domain or to not make the connection at all.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_SocketGetAddressSize()">
 </A>
<H1 CLASS="refHeading">
SocketGetAddressSize()</H1>
<PRE CLASS="syntax">int SocketGetAddressSize(
        char 		*domain);</PRE>
<P>
To find out the maximum address data size for a given domain, call <CODE>
SocketGetAddressSize()</CODE>
. This can be helpful when allocating memory large enough to handle a full address.</P>
<P>
This routine returns zero on error. Call ThreadGetError() to find out what the error was--if <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
 returns zero, then there wasn't really an error; this domain just doesn't require an address buffer.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_SocketGetDomainMedia()">
 </A>
<H1 CLASS="refHeading">
SocketGetDomainMedia()</H1>
<PRE CLASS="syntax">ChunkHandle SocketGetDomainMedia(
        char 		*domain,
        optr 		mediaList);</PRE>
<P>
If you're ever curious to know which sort of hardware ports the user's machine uses to connect up to a given domain, call <CODE>
SocketGetDomainMedia()</CODE>
. This returns a chunk array of <CODE>
MediumType</CODE>
 structures. If you have a choice of domains to make a given connection, you might consider which medium would be used to make the connection.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_SocketGetDomains()">
 </A>
<H1 CLASS="refHeading">
SocketGetDomains()</H1>
<PRE CLASS="syntax">ChunkHandle SocketGetDomains(
        optr 	domainList);</PRE>
<P>
The <CODE>
SocketGetDomains()</CODE>
 routine takes the optr of a chunk array and fills in said array with elements, each of which contains a string, each string being the name of a supported domain. This chunk array has a standard <CODE>
ChunkArrayHeader</CODE>
 header and variable sized elements. </P>
<P>
If the return value is zero, there was an error. Call <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetError()">ThreadGetError()</A></CODE>
 to find out what it was.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_SocketGetMediumAddress()">
 </A>
<H1 CLASS="refHeading">
SocketGetMediumAddress()</H1>
<PRE CLASS="syntax">SocketError SocketGetMediumAddress( 
        char 		*domain, 
        bye 		*buffer,
        int 		*bufsize, 
        MediumAndUnit 		*mau);</PRE>
<P>
This routine determines the local address of the connection using a particular medium. If another machine were to connect to this machine via that medium, this is the address it would use.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
domain</EM>
 </DT><DD>The domain name (a null-terminated string).</DD>
<DT>
<EM>
buffer</EM>
</DT><DD>Buffer to hold the address information.</DD>
<DT>
<EM>
bufsize</EM>
</DT><DD>Size of buffer, in bytes.</DD>
<DT>
<EM>
mau</EM>
</DT><DD>The medium.</DD>
</DL>
<P>
If the routine returns SE_NORMAL, then the address was computed successfully. The <EM>buffer</EM> buffer will be filled with as much of the address data as fit; the <EM>bufsize</EM> number will have changed to the total size of the address data--if this was larger than the size of <EM>buffer</EM>, then the address was truncated.</P>
</DIV>
<DIV>
<A NAME="IX_SocketGetPeerName()">
 </A>
<H1 CLASS="refHeading">
SocketGetPeerName()</H1>
<PRE CLASS="syntax">SocketError SocketGetPeerName(
        Socket 		s,
        SocketAddress 		*addr);</PRE>
<P>
If a socket is connected, call <CODE>
SocketGetPeerName()</CODE>
 to get the address of the socket at the other end of the connection.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
s</EM>
</DT><DD>The connected socket to examine.</DD>
<DT>
<EM>
addr</EM>
</DT><DD>Buffer holding hollow <CODE>
SocketAddress</CODE>
 structure. The <CODE>
SA_domain</CODE>
, <CODE>
SA_domainSize</CODE>
, and <CODE>
SA_addressSize</CODE>
 fields should be initialized. The buffer should be large enough to hold a <CODE>
SocketAddress</CODE>
 structure and address data. </DD>
</DL>
<P>
It returns SE_NORMAL (i.e., zero) if there was no error; otherwise it will return some <CODE>
SocketError</CODE>
 value. The addr buffer will be filled in with address information. If either the domain name or address buffer isn't large enough to hold its string, the resulting truncated string will not be null-terminated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_SocketGetSocketName()">
 </A>
<H1 CLASS="refHeading">
SocketGetSocketName()</H1>
<PRE CLASS="syntax">SocketError SocketGetSocketName(
        Socket 		s,
        SocketAddress 		*addr);</PRE>
<P>
To find out the address used to represent the socket's own side of the connection, call <CODE>
SocketGetSocketName()</CODE>
.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
s</EM>
</DT><DD>The connected socket to examine.</DD>
<DT>
<EM>
addr</EM>
</DT><DD>Buffer holding hollow <CODE>
SocketAddress</CODE>
 structure. The <CODE>
SA_domain</CODE>
, <CODE>
SA_domainSize</CODE>
, and <CODE>
SA_addressSize</CODE>
 fields should be initialized. The buffer should be large enough to hold a <CODE>
SocketAddress</CODE>
 structure and address data. </DD>
</DL>
<P>
It returns SE_NORMAL (i.e., zero) if there was no error; otherwise it will return some <CODE>
SocketError</CODE>
 value. The addr buffer will be filled in with address information. If either the domain name or address buffer isn't large enough to hold its string, the resulting truncated string will not be null-terminated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_SocketGetIntSocketOption()">
 </A>
<H1 CLASS="refHeading">
SocketGetIntSocketOption()</H1>
<PRE CLASS="syntax">int 	SocketGetIntSocketOption(
        Socket		skt,
        SocketOption		opt);</PRE>
<P>
This routine checks one of a socket's options, returning the current setting for that option. The return value's meaning depends upon the passed </P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>skt</EM></DT><DD>The socket to check.</DD>
<DT>
<EM>opt</EM></DT><DD>Which option to check. The following options are available:</DD>
<DT>
</DT><DD>SO_RECV_BUF: the maximum size of the socket's buffer for incoming data. A value of -1 means no limit.</DD>
<DT>
</DT><DD>SO_SEND_BUF: the maximum size of the socket's buffer for outgoing data. A value of -1 means no limit.</DD>
<DT>
</DT><DD>SO_INLINE: Non-zero if urgent data is forced into the same queue as regular data; zero to treat urgent data specially.</DD>
<DT>
</DT><DD>SO_NODELAY: Non-zero if domain driver should send all packets immediately; zero to allow the driver to save up packets to send as larger blocks.</DD>
<DT>
</DT><DD>SO_OWNER: Get the handle of the Socket's owning thread.</DD>
</DIV>
</DL>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_87.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">SocketClose() ...</A> 
<!-- to next --> | <A HREF="R_89.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">SocketInterrupt() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
