<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: R_8.htm,v 1.2 97/06/25 18:40:36 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE>GEOS C Routines: ChunkArrayGetCountHandles() ...</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_7.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">ChunkArrayElementToPtr() ...</A> 
<!-- to next --> | <A HREF="R_9.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">ChunkArraySort() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</DIV>
<DIV>
<A NAME="IX_ChunkArrayGetCountHandles()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayGetCountHandles()</H1>
<PRE CLASS="syntax">word	ChunkArrayGetCountHandles(
        MemHandle		mh,				/* Handle of LMem heap's block */
        ChunkHandle		ch);				/* Handle of chunk array */</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayGetCount()">ChunkArrayGetCount()</A></CODE>
, except that the chunk array is specified by its global and local handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_ChunkArrayGetElement()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayGetElement()</H1>
<PRE CLASS="syntax">void	ChunkArrayGetElement(
        optr	array,					/* optr to chunk array */
        word	elementNumber,					/* Index of element to copy */
        void *	buffer);					/* Address to copy element to */</PRE>
<P>
This routine copies an element in a chunk array into the passed buffer. It is your responsibility to make sure the buffer is large enough to hold the element.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the LMem heap's block on the global heap (unless it is fixed). Make sure the buffer is large enough to hold the element.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayPtrToElement()">ChunkArrayPtrToElement()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayElementToPtr()">ChunkArrayElementToPtr()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ChunkArrayGetElementHandles()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayGetElementHandles()</H1>
<PRE CLASS="syntax">void	ChunkArrayGetElementHandles(
        Memhandle		mh,					/* Handle of LMem heap's block */
        ChunkHandle		array,					/* Handle of chunk array */
        word		elementNumber,					/* Index of element to copy */
        void *		buffer);					/* Address to copy element to */</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayGetElement()">ChunkArrayGetElement()</A></CODE>
, except that the chunk array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the LMem heap's block on the global heap (unless it is fixed). Make sure the buffer is large enough to hold the element.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayPtrToElement()">ChunkArrayPtrToElement()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayElementToPtr()">ChunkArrayElementToPtr()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ChunkArrayInsertAt()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayInsertAt()</H1>
<PRE CLASS="syntax">void *	ChunkArrayInsertAt(
        optr		array,				/* Handle of chunk array */
        void *		insertPointer,				/* Address at which to insert
							 * element */</PRE>
<PRE CLASS="syntax">        word		elementSize);				/* Size of new element (ignored
							 * if elements are uniform-sized) */</PRE>
<P>
This routine inserts a new element in a chunk array. You specify the location by passing a pointer to an element. A new element will be allocated at that location; thus, the element which was pointed to will be shifted, so it ends up immediately after the new element. The new element will be zero-initialized.</P>
<P>
The routine is passed three arguments: the optr of the array, the address where the new element should be inserted, and the size of the new element. (If the array is of uniform-size elements, the size argument will be ignored.) </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	Only the chunk-handle portion of the optr is significant; the memory block is implicit in the pointer to the element.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (if it is not fixed).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the address passed is not the address of an element already in the chunk array, results are undefined. The routine may cause heap compaction or resizing; all pointers within the block are invalidated.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_5.htm#IX_ChunkArrayAppend()">ChunkArrayAppend()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_6.htm#IX_ChunkArrayDelete()">ChunkArrayDelete()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ChunkArrayInsertAtHandle()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayInsertAtHandle()</H1>
<PRE CLASS="syntax">void *	ChunkArrayInsertAtHandle(
        ChunkHandle		chunk,				/* Handle of chunk array */
        void *		insertPointer,				/* Address at which to insert
							 * element */</PRE>
<PRE CLASS="syntax">        word		elementSize);				/* Size of new element (ignored
							 * if elements are uniform-sized) */</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayInsertAt()">ChunkArrayInsertAt()</A></CODE>
, except that the chunk array is specified by its chunk handle. (The global block is implicit in the pointer passed.)</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_ChunkArrayPtrToElement()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayPtrToElement()</H1>
<PRE CLASS="syntax">word	ChunkArrayPtrToElement(
        optr	array,						/* Handle of chunk array */
        void *	element);						/* Address of element */</PRE>
<P>
This routine takes the address of an element in a chunk array, as well as an optr to the array. It returns the element's zero-based index.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
chunkarr.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	Only the chunk-handle portion of the optr is significant; the memory block is implicit in the pointer to the element.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap (unless it is fixed).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the address passed is not the address of the beginning of an element, results are unpredictable.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_7.htm#IX_ChunkArrayElementToPtr()">ChunkArrayElementToPtr()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ChunkArrayPtrToElementHandle()">
 </A>
<H1 CLASS="refHeading">
ChunkArrayPtrToElementHandle()</H1>
<PRE CLASS="syntax">word 	ChunkArrayPtrToElementHandle(
        ChunkHandle		array,			/* chunk handle of chunk array */
        void *		element);			/* Pointer to element to delete */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_8.htm#IX_ChunkArrayPtrToElement()">ChunkArrayPtrToElement()</A></CODE>
, except that the chunk array is indicated by its chunk handle. (The global block is implicit in the pointer passed.)</P>
</DIV>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_7.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">ChunkArrayElementToPtr() ...</A> 
<!-- to next --> | <A HREF="R_9.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">ChunkArraySort() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
