<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: R_78.htm,v 1.3 97/07/28 11:42:22 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE>GEOS C Routines: ObjDoRelocation() ...</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_77.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">ObjDeref() ...</A> 
<!-- to next --> | <A HREF="R_79.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">ObjFreeChunk() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</DIV>
<DIV>
<A NAME="IX_ObjDoRelocation()">
 </A>
<H1 CLASS="refHeading">
ObjDoRelocation()</H1>
<PRE CLASS="syntax">Boolean	ObjDoRelocation( /* returns <EM>true</EM> if error */
        ObjRelocationType		type,				/* type of relocation */
        MemHandle		block,				/* handle of info block */
        void		* sourceData,				/* source of relocation */
        void		* destData);				/* relocated value */</PRE>
<P>
This routine relocates a given word or dword argument and is used for resolving handles and pointers to movable objects. Most often, relocation and unrelocation occur when resources are loaded, swapped, or saved, and this is in most cases taken care of by the kernel.</P>
<P>
<CODE>
ObjDoRelocation()</CODE>
 takes four parameters:</P>
<DL>
<DT>
<CODE>
type</CODE>
</DT><DD>The type of relocation to be performed (<CODE>
RelocationType</CODE>
). This can be one of the three values shown below.</DD>
<DT>
<CODE>
block</CODE>
</DT><DD>The handle of the block containing the relocation.</DD>
<DT>
<CODE>
sourceData</CODE>
</DT><DD>A pointer to the source of the relocation; this pointer should be cast to the proper type (word or dword) when calling the routine.</DD>
<DT>
<CODE>
destData</CODE>
</DT><DD>A pointer to the value to be returned; this pointer should be cast appropriately when the routine is called. The exact type of return value depends on <CODE>
sourceData</CODE>
 and <CODE>
type</CODE>
, above.</DD>
</DL>
<P>
The type of relocation to be done affects the type of data passed in <CODE>
sourceData</CODE>
 and <CODE>
destData</CODE>
. The relocation type is passed in the type parameter and must be one of the following enumerations of <CODE>
RelocationType</CODE>
:</P>
<DL>
<DT>
RELOC_RELOC_HANDLE</DT><DD>
The relocation will be from a resource ID to a handle. The <CODE>
sourceData</CODE>
 pointer should be cast to type word, and the <CODE>
destData</CODE>
 pointer should be cast to type Handle.</DD>
<DT>
RELOC_RELOC_SEGMENT</DT><DD>
The relocation will be from a resource ID to a segment address. The <CODE>
sourceData</CODE>
 pointer should be cast to type word, and the <CODE>
destData</CODE>
 pointer should be cast to type Segment.</DD>
<DT>
RELOC_RELOC_ENTRY_POINT</DT><DD>
The relocation will be from either a resource ID or an entry number to an entry point. Both the <CODE>
sourceData</CODE>
 pointer and the <CODE>
destData</CODE>
 pointer should be cast to type dword.</DD>
</DL>
<P>
<CODE>
ObjDoRelocation()</CODE>
 returns an error flag that will be <CODE>
true</CODE>
 if an error occurs, <CODE>
false</CODE>
 otherwise.</P>
<P>
The relocation done by this routine can be undone with <CODE>
<A HREF="../../CRef/Routines/R_78.htm#IX_ObjDoUnRelocation()">ObjDoUnRelocation()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="IX_ObjDoUnRelocation()">
 </A>
<H1 CLASS="refHeading">
ObjDoUnRelocation()</H1>
<PRE CLASS="syntax">Boolean	ObjDoUnRelocation( /* returns <EM>true</EM> if error */
        ObjRelocationType		type,				/* type of relocation */
        MemHandle		block,				/* handle of info block */
        void		* sourceData,				/* source of relocation */
        void		* destData);				/* relocated value */</PRE>
<P>
This routine unrelocates a given word or dword. It translates a handle, a segment address, or an entry point back into a resource ID. The translation done is the exact reverse of that done by <CODE>
<A HREF="../../CRef/Routines/R_78.htm#IX_ObjDoRelocation()">ObjDoRelocation()</A></CODE>
. See that routine (above) for more information.</P>
<P>
<CODE>
ObjDoUnRelocation()</CODE>
 returns an error flag that will be <CODE>
true</CODE>
 if an error occurs and <CODE>
false</CODE>
 if the unrelocation is successful. The unrelocated resource ID will be returned pointed to by the <CODE>
destData</CODE>
 pointer.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_78.htm#IX_ObjDoRelocation()">ObjDoRelocation()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ObjDuplicateMessage()">
 </A>
<H1 CLASS="refHeading">
ObjDuplicateMessage()</H1>
<PRE CLASS="syntax">EventHandle ObjDuplicateMessage(
        EventHandle msg);				/* event to duplicate */</PRE>
<P>
This routine duplicates a prerecorded event, returning the event handle of the new event. Pass the handle of the event to be duplicated. You can then change information about the event with <CODE>
<A HREF="../../CRef/Routines/R_70.htm#IX_MessageSetDestination()">MessageSetDestination()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="IX_ObjDuplicateResource()">
 </A>
<H1 CLASS="refHeading">
ObjDuplicateResource()</H1>
<PRE CLASS="syntax">MemHandle ObjDuplicateResource(
        MemHandle		blockToDup,					/* handle of resource; must
								 * <EM>not</EM> be loaded */</PRE>
<PRE CLASS="syntax">        GeodeHandle		owner,					/* owner of duplicate */
        ThreadHandle		burdenThread);					/* burden thread of duplicate */</PRE>
<P>
This routine duplicates an entire object resource block. The new block will be put on the &quot;saved blocks&quot; list so it gets saved to the geode's state file. Usually this is used by the UI to make editable copies of an application's UI resources to ensure the proper state information gets saved. This routine takes three parameters:</P>
<DL>
<DT>
<CODE>
blockToDup</CODE>
</DT><DD>The handle of the block to be duplicated. The block must not be resident in memory when <CODE>
ObjDuplicateResource()</CODE>
 is called. Also, it can only be a &quot;template&quot; resource--a resource that does not get used by the UI or the application directly, but only gets copied via this routine.</DD>
<DT>
<CODE>
owner</CODE>
</DT><DD>The owner geode of the new block. This should be the geode handle of the owning geode or zero to have the calling geode own it. If you pass an <CODE>
owner</CODE>
 of -1, the new block will be owned by the same geode that owns the original.</DD>
<DT>
<CODE>
burdenThread</CODE>
</DT><DD>
The thread that will run the block and handle its messages. This should be a thread handle or zero to have the calling thread run the block. Passing a <CODE>
burdenThread</CODE>
 of -1 makes the new resource have the same burden thread as the original.</DD>
</DL>
<P>
<CODE>
ObjDuplicateResource()</CODE>
 returns the handle of the newly created block, which will be unlocked and may or may not be resident in memory.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjFreeDuplicate()">ObjFreeDuplicate()</A></CODE>,
<CODE>MSG_META_BLOCK_FREE</CODE>,
<CODE><A HREF="../../CRef/Routines/R_7b.htm#IX_ObjLockObjBlock()">ObjLockObjBlock()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ObjEnableDetach()">
 </A>
<H1 CLASS="refHeading">
ObjEnableDetach()</H1>
<PRE CLASS="syntax">void	ObjEnableDetach(
        optr	obj);		/* object calling this routine */</PRE>
<P>
This routine acts as an object's handler for <CODE>
MSG_META_ACK</CODE>
. This handler decrements the acknowledgment count (incremented with <CODE>
<A HREF="../../CRef/Routines/R_79.htm#IX_ObjIncDetach()">ObjIncDetach()</A></CODE>
) and, if the count is zero, enables the detach mechanism so the object can be fully detached. Because the detach mechanism is implemented in <CODE>
MetaClass</CODE>
, it is highly unlikely you will ever call this routine.</P>
<P>
The lone parameter of this routine is the optr of the calling object (or, in the case of <CODE>
MSG_META_ACK</CODE>
, the object sending acknowledgment).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may resize and/or move chunks and object blocks, thereby invalidating all pointers and segment addresses.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	metaC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_META_DETACH</CODE>,
<CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitDetach()">ObjInitDetach()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjIncDetach()">ObjIncDetach()</A></CODE>,
<CODE>MSG_META_ACK</CODE>.</P>
</DIV>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_77.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">ObjDeref() ...</A> 
<!-- to next --> | <A HREF="R_79.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">ObjFreeChunk() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
