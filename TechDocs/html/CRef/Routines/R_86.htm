<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: R_86.htm,v 1.2 97/06/25 18:41:45 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE>GEOS C Routines: SocketBind() ...</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_85.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">SGC_MACHINE ...</A> 
<!-- to next --> | <A HREF="R_87.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">SocketClose() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</DIV>
<DIV>
<A NAME="IX_SocketBind()">
 </A>
<H1 CLASS="refHeading">
SocketBind()</H1>
<PRE CLASS="syntax">SocketError SocketBind(
        Socket 		s,
        SocketPort 		p,
        SocketBindFlags 		flags);</PRE>
<P>
Use the <CODE>
SocketBind()</CODE>
 routine to associate a socket with a port number on this side of the connection. </P>
<P>
For any given domain, normally only one socket on the machine may be bound to any port number. If you have used <CODE>
SocketBind()</CODE>
 to bind some other socket to this port, then you may only bind another socket to the port by setting the SBF_REUSE_PORT in the flags argument. If you have used <CODE>
<A HREF="../../CRef/Routines/R_86.htm#IX_SocketBindInDomain()">SocketBindInDomain()</A></CODE>
 to bind some other socket to this port, then you may not use <CODE>
SocketBind()</CODE>
 to bind another socket to the port.</P>
<P>
A given socket may only be bound to one port.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
s</EM>
</DT><DD>The socket to bind.</DD>
<DT>
<EM>
p</EM>
</DT><DD>The port to monitor.</DD>
<DT>
<EM>
flags</EM>
</DT><DD>Set the SBF_REUSE_PORT to bind the socket to the port even if another socket is bound to it. (You may not use this flag with datagram sockets.)</DD>
</DL>
<P>
If successful, the routine will return SE_NORMAL (i.e., zero). Otherwise, it will return some other <CODE>
SocketError</CODE>
 value. Be on the lookout for SE_SOCKET_ALREADY_BOUND, SE_PORT_IN_USE, or SE_BIND_CONFLICT.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketBindInDomain()">SocketBindInDomain()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_SocketBindInDomain()">
 </A>
<H1 CLASS="refHeading">
SocketBindInDomain()</H1>
<PRE CLASS="syntax">SocketError SocketBindInDomain(
        Socket 		s,
        SocketPort 		p,
        SocketBindFlags 		flags,
        TCHAR 		*domain);</PRE>
<P>
Use the <CODE>
SocketBindInDomain()</CODE>
 routine to associate a socket with a port number and domain on this side of the connection. </P>
<P>
For any given domain, normally only one socket on the machine may be bound to any port number in any given domain. If you have used <CODE>
SocketBindInDomain()</CODE>
 to bind some other socket to this port and domain, then you may only bind another socket to the port and domain by setting the SBF_REUSE_PORT in the flags argument. If you have used <CODE>
<A HREF="../../CRef/Routines/R_86.htm#IX_SocketBind()">SocketBind()</A></CODE>
 to bind some other socket to this port, then you may not use <CODE>
SocketBindInDomain()</CODE>
 to bind another socket to the port.</P>
<P>
A given socket may only be bound to one port.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
s</EM>
</DT><DD>The socket to bind</DD>
<DT>
<EM>
p</EM>
</DT><DD>The port to monitor</DD>
<DT>
<EM>
flags</EM>
</DT><DD>Set the SBF_REUSE_PORT to bind the socket to the port even if another socket is bound to it.</DD>
<DT>
<EM>
domain</EM>
</DT><DD>The domain to monitor</DD>
</DL>
<P>
If successful, the routine will return SE_NORMAL (i.e., zero). Otherwise, it will return some other <CODE>
SocketError</CODE>
 value. Be on the lookout for SE_SOCKET_ALREADY_BOUND, SE_PORT_IN_USE, or SE_BIND_CONFLICT.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketBind()">SocketBind()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_SocketCheckListen()">
 </A>
<H1 CLASS="refHeading">
SocketCheckListen()</H1>
<PRE CLASS="syntax">int SocketCheckListen(
        SocketPort 		p,
        TCHAR 		*domain,
        int 		bufsize);</PRE>
<P>
Use the <CODE>
SocketCheckListen()</CODE>
 command on a port to find out the domain for the first connect request on a listening socket--that is, the first connection request which has not yet been accepted. You might think of this as a limited form of &quot;caller ID&quot;--a chance to find out a bit about the incoming connection before you accept it. If <CODE>
SocketCheckListen()</CODE>
 returns SE_PORT_NOT_LISTENING, it means that you have not passed it a port to which a socket is listening.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
p</EM>
</DT><DD>The port to check</DD>
<DT>
<EM>
domain</EM>
</DT><DD>Buffer to hold the domain name</DD>
<DT>
<EM>
bufsize</EM>
</DT><DD>The size of the <EM>
domain</EM>
 buffer</DD>
</DL>
<P>
It returns the length of the domain name. If the return value is zero, there was an error. Look out for SE_PORT_NOT_LISTENING, which signals that there is no socket bound to the port in question which is listening.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketBind()">SocketBind()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketBindInDomain()">SocketBindInDomain()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_89.htm#IX_SocketListen()">SocketListen()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_SocketCheckReady()">
 </A>
<H1 CLASS="refHeading">
SocketCheckReady()</H1>
<PRE CLASS="syntax">int SocketCheckReady(
        SocketCheckRequest 		*requests,
        int 		numRequests,
        int 		timeout);</PRE>
<P>
To check one or more sockets to see if they have received data, received connection requests, or are ready to write, call <CODE>
SocketCheckReady()</CODE>
. It can check connections for incoming data or just incoming urgent data. </P>
<P>
For programs which need to poll many sockets, <CODE>
SocketCheckReady()</CODE>
 provides a tidy means to do this without spawning a thread for each socket.</P>
<P>
The <CODE>
SocketCheckReady()</CODE>
 routine takes an array of <CODE>
SocketCheckRequest</CODE>
 structures. Each one of these structures contains a socket and a condition. <CODE>
SocketCheckReady()</CODE>
 looks at each <CODE>
SocketCheckRequest</CODE>
 structure in the array and returns the index of the first structure whose socket meets the condition.</P>
<P>
Thus, to determine if a given socket is properly set-up so that you can send data through it, you would pass <CODE>
SocketCheckReady()</CODE>
 a one-element array (represented in pseudo-code):</P>
<PRE>{ mySocket, SC_WRITE, 0 }</PRE>
<P>
To check several sockets to see whether any of them had received any connection requests, pass <CODE>
SocketCheckReady()</CODE>
 an array of the form (represented in pseudo-code):</P>
<PRE>{ socket1, SC_ACCEPT, 0 },
{ socket2, SC_ACCEPT, 0 },
{ socket3, SC_ACCEPT, 0 }</PRE>
<P>
For any socket, you may check for one or more of the following conditions:</P>
<DL>
<DT>
SC_ACCEPT</DT><DD>
If a socket is listening for a connection, this condition indicates that another socket is in fact trying to connect to the listening socket.</DD>
<DT>
SC_READ</DT><DD>If a socket is connected, this condition indicates that a packet of data has come in and is ready to be read.</DD>
<DT>
SC_EXCEPTION</DT><DD>
If a socket is connected, this condition indicates that the socket has figured out that something has gone wrong with its connection.</DD>
<DT>
SC_URGENT</DT><DD>If a socket is connected, this condition indicates that it has received a packet of data that was marked urgent.</DD>
<DT>
SC_WRITE</DT><DD>This condition indicates that data may be sent through the socket.</DD>
</DL>
<P>
If you query a socket about a condition that does not apply to its current state (e.g., ask a non-listening socket if it is ready to accept), then <CODE>
SocketCheckReady()</CODE>
 will return SE_IMPROPER_CONDITION.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
requests</EM>
</DT><DD>The array of <CODE>
SocketCheckRequests</CODE>
 structures, as described above.</DD>
<DT>
<EM>
numRequests</DT><DD>
</EM>
Number of elements in the <EM>
requests</EM>
 array.</DD>
<DT>
<EM>
timeout</EM>
</DT><DD>Time to wait for success, in 1/60 second ticks, or SOCKET_NO_TIMEOUT to try as long as possible.</DD>
</DL>
<P>
The routine returns the index of the first <CODE>
SocketCheckRequest</CODE>
 to meet its conditions.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_85.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">SGC_MACHINE ...</A> 
<!-- to next --> | <A HREF="R_87.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">SocketClose() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
