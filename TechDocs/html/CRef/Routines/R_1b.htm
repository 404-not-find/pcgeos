<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: R_1b.htm,v 1.2 97/06/25 18:11:54 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE>GEOS C Routines: DiskGetDrive() ...</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_1a.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">DiskForEach() ...</A> 
<!-- to next --> | <A HREF="R_1c.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">DiskSave() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</DIV>
<DIV>
<A NAME="IX_DiskGetDrive()">
 </A>
<H1 CLASS="refHeading">
DiskGetDrive()</H1>
<PRE CLASS="syntax">word	DiskGetDrive(
        DiskHandle		dh);</PRE>
<P>
This routine returns the drive number associated with a registered disk. Note that it will do this even if the drive is no longer usable (e.g. if a network drive has been unmapped).</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you pass a standard path constant, this routine will return information about the disk containing the main <STRONG CLASS="fileName">
geos.ini</STRONG>
 file.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_19.htm#IX_DiskFind()">DiskFind()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRegisterDisk()">DiskRegisterDisk()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_DiskGetVolumeFreeSpace()">
 </A>
<H1 CLASS="refHeading">
DiskGetVolumeFreeSpace()</H1>
<PRE CLASS="syntax">dword	DiskGetVolumeFreeSpace( 
        DiskHandle		dh);</PRE>
<P>
This routine returns the amount of free space (measured in bytes) on the specified disk. If the disk is, by nature, not writable (e.g. a CD-ROM disk), <CODE>
DiskGetVolumeFreeSpace()</CODE>
 returns zero and clears the thread's error value. If an error condition exists, <CODE>
DiskGetVolumeFreeSpace()</CODE>
 returns zero and sets the thread's error value.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you pass a standard path constant, this routine will return information about the disk containing the main <STRONG CLASS="fileName">
geos.ini</STRONG>
 file.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskGetVolumeInfo()">DiskGetVolumeInfo()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_DiskGetVolumeInfo()">
 </A>
<H1 CLASS="refHeading">
DiskGetVolumeInfo()</H1>
<PRE CLASS="syntax">word	DiskGetVolumeInfo(  /* Returns 0 if successful */
        DiskHandle		dh,
        DiskInfoStruct		*info);			/* Routine fills this structure */</PRE>
<P>
This routine returns general information about a disk. It returns the following four pieces of information:</P>
<UL>
<LI>
The size of each disk block in bytes. When space is allocated, it is rounded up to the nearest whole block.</LI>
<LI>
The number of free bytes on the disk.</LI>
<LI>
The total number of bytes on the disk; this is the total of free and used space.</LI>
<LI>
The disk's volume name. If the volume is unnamed, the current temporary name will be returned.</LI>
</UL>
<P>
The information is written to the passed <CODE>
DiskInfoStruct</CODE>
. If an error condition occurs, <CODE>
DiskGetVolumeInfo()</CODE>
 will return the error code and set the thread's error value; otherwise, it will return zero.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you pass a standard path constant, this routine will return information about the disk containing the main <STRONG CLASS="fileName">
geos.ini</STRONG>
 file.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
</P>
</DIV>
<DIV>
<A NAME="IX_DiskGetVolumeName()">
 </A>
<H1 CLASS="refHeading">
DiskGetVolumeName()</H1>
<PRE CLASS="syntax">void	DiskGetVolumeName(
        DiskHandle		dh,
        char *		buffer);			/* Must be VOLUME_NAME_LENGTH_ZT bytes
						 * long */</PRE>
<P>
This routine copies the disk's volume name (as a null-terminated string) to the passed buffer. If an error occurs, it sets the thread's error value. If the volume has no name, the routine returns the current temporary name.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	<CODE>
DiskGetVolumeName()</CODE>
 does not check the size of the buffer passed. If the buffer is not at least VOLUME_NAME_LENGTH_ZT bytes long, the routine may write beyond its boundaries.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you pass a standard path constant, this routine will return information about the disk containing the main <STRONG CLASS="fileName">
geos.ini</STRONG>
 file.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskGetVolumeInfo()">DiskGetVolumeInfo()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_1c.htm#IX_DiskSetVolumeName()">DiskSetVolumeName()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_DiskRegisterDisk()">
 </A>
<H1 CLASS="refHeading">
DiskRegisterDisk()</H1>
<PRE CLASS="syntax">DiskHandle 	DiskRegisterDisk(
        word	driveNumber); </PRE>
<P>
This routine registers a disk in the specified drive and assigns it a disk handle. (The disk handle persists only to the end of the current session of GEOS.) If the disk already has a handle, <CODE>
DiskRegisterDisk()</CODE>
 will return it. If the disk does not have a name, GEOS will assign it a temporary name (such as &quot;UNNAMED1&quot;) and display an alert box telling the user what the temporary name is. (This is done only the first time the disk is registered in each session.) Note that the temporary name is not written to the disk; thus, it persists only until the end of the current session of GEOS.</P>
<P>
If this routine returns a disk handle, there's a disk in the drive; if it doesn't, there may still be a disk in the drive, but the disk is unformatted.</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	There is no harm in registering the same disk several times. Thus, if you want to get the disk handle for the disk in a specific drive, you can simply call <CODE>
DiskRegisterDisk()</CODE>
.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRegisterDiskSilently()">DiskRegisterDiskSilently()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_DiskRegisterDiskSilently()">
 </A>
<H1 CLASS="refHeading">
DiskRegisterDiskSilently()</H1>
<PRE CLASS="syntax">DiskHandle 	DiskRegisterDiskSilently(
        word		driveNumber);</PRE>
<P>
This routine is almost identical to <CODE>
<A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRegisterDisk()">DiskRegisterDisk()</A></CODE>
 (described immediately above). There is only one difference: If GEOS assigns a temporary name to the disk, it will not present an alert box to the user.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1b.htm#IX_DiskRegisterDisk()">DiskRegisterDisk()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
</P>
</DIV>
<DIV>
<A NAME="IX_DiskRestore()">
 </A>
<A NAME="IX_DiskRestoreError">
 </A>
<A NAME="IX_DRE_&ldots;">
 </A>
<H1 CLASS="refHeading">
DiskRestore()</H1>
<PRE CLASS="syntax">DiskHandle 	DiskRestore(
        void *		buffer,			/* buffer written by DiskSave() */
        DiskRestoreError _pascal (*callback)	
			(const char 						*driveName,
			 const char 						*diskName,
			 void 						**bufferPtr,</PRE>
<PRE CLASS="syntax">        		 DiskRestoreError 						error);</PRE>
<P>
<CODE>
DiskRestore()</CODE>
 examines a buffer written by <CODE>
<A HREF="../../CRef/Routines/R_1c.htm#IX_DiskSave()">DiskSave()</A></CODE>
 and returns the handle of the disk described by that buffer. If that disk is already registered, <CODE>
DiskRestore()</CODE>
 will simply return its handle. If the disk is not registered and is not in the drive, <CODE>
DiskRestore()</CODE>
 will call the specified callback routine. The callback routine should be declared _pascal. The callback routine is passed four arguments:</P>
<UL>
<LI>
A null-terminated string containing the name of the drive for the disk.</LI>
<LI>
A null-terminated string containing the disk's volume label.</LI>
<LI>
A pointer to a variable in the <CODE>
DiskRestore()</CODE>
 routine. This variable is itself a pointer to the opaque data structure provided by <CODE>
<A HREF="../../CRef/Routines/R_1c.htm#IX_DiskSave()">DiskSave()</A></CODE>
. If the callback routine takes any action which causes that structure to move (e.g. if it causes the global or local heap containing the buffer to be shuffled), it should update the pointer in <CODE>
DiskRestore()</CODE>
.</LI>
<LI>
A member of the <CODE>
DiskRestoreError</CODE>
 enumerated type. This is the error which <CODE>
DiskRestore()</CODE>
 would have returned if there had not been a callback routine. This is usually DRE_REMOVABLE_DRIVE_DOESNT_HOLD_DISK.</LI>
</UL>
<P>
The callback routine should prompt the user to insert a disk. If the callback routine was successful, it should return DRE_DISK_IN_DRIVE (which is guaranteed to be equal to zero). Otherwise, it should return a member of the <CODE>
DiskRestoreError</CODE>
 enumerated type; usually it will return DRE_USER_CANCELLED_RESTORE. Note that the callback routine will not generally know if the user has inserted a disk; it generally just displays an alert box and returns when the user clicks &quot;OK.&quot; After the callback routine returns, <CODE>
DiskRestore()</CODE>
 registers the disk and makes sure that it's the correct one; if it is not, it calls the callback routine again.</P>
<P>
You can pass a null function pointer to <CODE>
DiskRestore()</CODE>
 instead of providing a callback routine. In this case, <CODE>
DiskRestore()</CODE>
 will fail if the disk has not been registered and is not currently in the drive.</P>
<P>
<CODE>
DiskRestore()</CODE>
 returns the handle of the disk. If it fails for any reason, it returns a null handle and sets the thread's error value to a member of the <CODE>
DiskRestorenError</CODE>
 enumerated type. This type has the following members:</P>
<DL>
<DT>
DRE_DISK_IN_DRIVE</DT><DD>
This is returned by the callback routine. This is guaranteed to equal zero.</DD>
<DT>
DRE_DRIVE_NO_LONGER_EXISTS</DT><DD>
The disk is associated with a drive which is no longer attached to the system.</DD>
<DT>
DRE_REMOVABLE_DRIVE_DOESNT_CONTAIN_DISK</DT><DD>
The disk is unregistered, and it is not currently in the drive associated with it. If a callback routine was provided, <CODE>
DiskRestore()</CODE>
 will call it under these circumstances.</DD>
<DT>
DRE_USER_CANCELLED_RESTORE</DT><DD>
This is returned by the callback routine if the user cancels the restore.</DD>
<DT>
DRE_COULDNT_CREATE_NEW_DISK_HANDLE</DT><DD>
<CODE>
DiskRestore()</CODE>
 was unable to register the disk in the appropriate drive because it couldn't create a new disk handle.</DD>
<DT>
DRE_REMOVABLE_DRIVE_IS_BUSY</DT><DD>
The appropriate drive is busy with a time-consuming operation (e.g. a disk format).</DD>
<DT>
DRE_NOT_ATTACHED_TO_SERVER</DT><DD>
The disk was from a network server to which we are not logged in.</DD>
<DT>
DRE_PERMISSION_DENIED</DT><DD>
The disk was on a network which is now denying access to it.</DD>
<DT>
DRE_ALL_DRIVES_USED</DT><DD>
The disk was on a network volume that isn't mounted, but there is no drive left to which it can be mapped.</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1c.htm#IX_DiskSave()">DiskSave()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
disk.h</STRONG>
 </P>
</DIV>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_1a.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">DiskForEach() ...</A> 
<!-- to next --> | <A HREF="R_1c.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">DiskSave() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
