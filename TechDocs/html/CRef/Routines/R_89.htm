<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: R_89.htm,v 1.2 97/06/25 18:42:15 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE>GEOS C Routines: SocketInterrupt() ...</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_88.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">SocketGetAddressController() ...</A> 
<!-- to next --> | <A HREF="R_8a.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">SocketRemoveLoadOnMsg() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</DIV>
<DIV>
<A NAME="IX_SocketInterrupt()">
 </A>
<H1 CLASS="refHeading">
SocketInterrupt()</H1>
<PRE CLASS="syntax">SocketError SocketInterrupt(
        Socket 		s);</PRE>
<P>
This routine attempts to interrupt a <CODE>
<A HREF="../../CRef/Routines/R_85.htm#IX_SocketAccept()">SocketAccept()</A></CODE>
 or a <CODE>
<A HREF="../../CRef/Routines/R_89.htm#IX_SocketRecv()">SocketRecv()</A></CODE>
 pending on the passed socket <EM>s</EM>.</P>
</DIV>
<DIV>
<A NAME="IX_SocketInterruptResolve()">
 </A>
<H1 CLASS="refHeading">
SocketInterruptResolve()</H1>
<PRE CLASS="syntax">SocketError SocketInterruptResolve(
        TCHAR 		*domain,
        byte 		*address,
        int  		addrSize);</PRE>
<P>
This routine attempts to interrupt the resolution of the specified address.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
domain</EM>
</DT><DD>The name of the domain.</DD>
<DT>
<EM>
address</EM>
</DT><DD>The address which is being resolved.</DD>
<DT>
<EM>
addrSize</EM>
</DT><DD>The size of the <EM>address</EM> buffer.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This function is unreliable.  It may not interrupt the desired resolve call,if it executes before the resolve call has begun to be processed.  If may also cause other, parallel resolve in the same domain to be interrupted.</P>
</DIV>
<DIV>
<A NAME="IX_SocketListen()">
 </A>
<H1 CLASS="refHeading">
SocketListen()</H1>
<PRE CLASS="syntax">SocketError SocketListen(
        Socket 		s,
        int 		qSize);</PRE>
<P>
To listen for incoming sequenced packet or stream connections, call <CODE>
SocketListen()</CODE>
. The socket must be bound to a port before it can listen. You may allow more than one connection through the port-specify the maximum number of connections as an argument to <CODE>
SocketListen()</CODE>
. </P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
<EM>
s</EM>
</DT><DD>The <CODE>
Socket</CODE>
 which should listen for incoming connections. The socket should be bound to a port. </DD>
<DT>
<EM>
qSize</EM>
</DT><DD>The number of incoming connections which may be accepted via the socket.</DD>
</DL>
<P>
The <CODE>
SocketListen()</CODE>
 routine causes the passed socket to &quot;listen&quot; for accepting connections. If another socket is already listening at the port, the <CODE>
SocketListen()</CODE>
 routine will return SE_PORT_ALREADY_LISTENING.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketBind()">SocketBind()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_85.htm#IX_SocketAccept()">SocketAccept()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_86.htm#IX_SocketCheckReady()">SocketCheckReady()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_SocketOpenDomainMedium()">
 </A>
<H1 CLASS="refHeading">
SocketOpenDomainMedium()</H1>
<PRE CLASS="syntax">SocketError SocketOpenDomainMedium(
        SocketAddress 		*addr,
        int 		timeout);</PRE>
<P>
This routine opens a &quot;raw&quot; connection using the specified medium. Exactly what is meant by a &quot;raw&quot; connection depends upon the domain involved. In the case of TCP, this routine will dial the modem and create a PPP connection to the PPP server--but will not send any TCP packets.</P>
<P>
If there is already a &quot;raw&quot; connection, this routine will return SE_NORMAL, just as if it had just opened the connection. </P>
<P>
If the device's phone is busy, this routine will return SE_MEDIUM_BUSY.</P>
<P>
This routine takes the following arguments:</P>
<DL>
<DT>
addr</DT><DD>The address to connect to.</DD>
<DT>
timeout</DT><DD>How many 1/60 second ticks to wait for a connection. Pass SOCKET_NO_TIMEOUT to wait forever.</DD>
</DL>
<P>
When done with the connection, close it with <CODE>
<A HREF="../../CRef/Routines/R_87.htm#IX_SocketCloseDomainMedium()">SocketCloseDomainMedium()</A></CODE>
.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_87.htm#IX_SocketCloseDomainMedium()">SocketCloseDomainMedium()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_SocketRecv()">
 </A>
<H1 CLASS="refHeading">
SocketRecv()</H1>
<PRE CLASS="syntax">int SocketRecv(
        Socket 		s,
        void 		*buffer,
        int 		bufSize,
        int 		timeout,
        SocketRecvFlags 		flags,
        SocketAddress 		*addr);</PRE>
<P>
The <CODE>
SocketRecv()</CODE>
 routine receives data from the socket. After filling the passed buffer with data, the socket will discard its copy of the received data to make room for the next piece of incoming data.</P>
<P>
To &quot;peek&quot; at the next packet of incoming data, call <CODE>
SocketRecv()</CODE>
 and pass the SRF_PEEK flag. This allows you to get the size of the next packet of incoming data and even to non-destructively look at the contents of that packet. </P>
<P>
When using packet-based delivery type sockets (sequenced packet or datagram delivery sockets), you can only receive whole packets-if you grab data from the socket, but don't grab all the data in the packet, the rest of the data will be lost. Thus, it's a good idea to establish a maximum packet size for sockets using these delivery types.If you're not sure how much room you'll need to receive a packet, call <CODE>
SocketRecv()</CODE>
 with the SRF_PEEK flag-this allows you to &quot;peek&quot; at the incoming data without causing the socket to discard its copy.</P>
<P>
The <CODE>
SocketRecv()</CODE>
 routine takes the following arguments:</P>
<DL>
<DT>
<EM>
s</EM>
</DT><DD>The socket from which to grab the data.</DD>
<DT>
<EM>
buffer</EM>
</DT><DD>Buffer to fill with data. </DD>
<DT>
<EM>
bufSize</EM>
</DT><DD>Size of the data buffer. If this smaller than the amount of data, and the socket delivery type is packet-based, the data that doesn't fit in the buffer will be lost; if the socket is a stream socket, then socket will retain the remaining data.</DD>
<DT>
<EM>
timeout</EM>
</DT><DD>How many 1/60 second ticks to wait for incoming data. Pass SOCKET_NO_TIMEOUT to wait forever.</DD>
<DT>
<EM>
flags</EM>
</DT><DD>This flags field allows you to specify some options. Set the SRF_ADDRESS flag if you want the address of the sending machine in <EM>
addr</EM>
. Set the SRF_URGENT flag to only receive a packet marked urgent. Set the SRF_PEEK flag to &quot;peek&quot; at the incoming packet, leaving it in the socket.</DD>
<DT>
<EM>
addr</EM>
<STRONG>
</DT><DD></STRONG>
If you pass the SRF_ADDRESS_FLAG, then pass an empty <CODE>
SocketAddress</CODE>
 buffer. Make sure the buffer has room for the address data after the <CODE>
SocketAddress</CODE>
 structure. The structure's <CODE>
SA_domain</CODE>
, <CODE>
SA_domainSize</CODE>
, and <CODE>
SA_addressSize</CODE>
 fields should be initialized. If either the domain or address buffer isn't long enough to hold its string, the resulting truncated string will not be null-terminated.</DD>
</DL>
<P>
The <CODE>
SocketRecv()</CODE>
 routine returns the size of the received buffer. If this size is zero, there may be an error in the connection. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
socket.goh</STRONG>
 </P>
</DIV>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_88.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">SocketGetAddressController() ...</A> 
<!-- to next --> | <A HREF="R_8a.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">SocketRemoveLoadOnMsg() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
