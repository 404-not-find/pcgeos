<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: R_73.htm,v 1.2 97/06/25 18:37:44 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE>GEOS C Routines: NameArrayAdd() ...</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_72.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">ModemSetMessageDataNotify() ...</A> 
<!-- to next --> | <A HREF="R_74.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">NameArrayFind() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</DIV>
<DIV>
<A NAME="IX_NameArrayAdd()">
 </A>
<H1 CLASS="refHeading">
NameArrayAdd()</H1>
<PRE CLASS="syntax">word	NameArrayAdd(
        optr 		arr,				/* optr of name array */
        const char		* nameToAdd,				/* Name of new element */
        word		nameLength,				/* Length of name; pass zero if
						 * name string is null-terminated */</PRE>
<PRE CLASS="syntax">        NameArrayAddFlags		flags,				/* Described below */
        const	void	* data);				/* Copy this data to new element */</PRE>
<P>
This routine creates a new element in a name array, copying the passed name and data into the new element. If no element with the passed name exists, <CODE>
NameArrayAdd()</CODE>
 will create the element and return its token. If an element with the same name already exists, the existing element's reference count will be incremented and its token will be returned. The routine takes the following arguments:</P>
<DL>
<DT>
<CODE>
array</CODE>
</DT><DD>The optr of the name array.</DD>
<DT>
<CODE>
nameToAdd</DT><DD>
</CODE>
The name of the new element. This string may contain nulls.</DD>
<DT>
<CODE>
nameLength</DT><DD>
</CODE>
The length of the name string, in bytes. If you pass zero, <CODE>
NameArrayAdd()</CODE>
 will assume the string is null-terminated.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
NameArrayAddFlags</CODE>
, described below.</DD>
<DT>
<CODE>
data</CODE>
</DT><DD>The data to copy into the new element.</DD>
</DL>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	The argument is passed a set of <CODE>
NameArrayAddFlags</CODE>
. Only one flag is currently defined:</P>
<DL>
<DT>
NAAF_SET_DATA_ON_REPLACE</DT><DD>
If an element with the specified name exists and this flag is set, the data passed will be copied into the data area of the existing element. If this flag is not set, the existing element will not be changed.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may resize the name array; therefore, all pointers to the LMem heap are invalidated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
</DIV>
<DIV>
<A NAME="IX_NameArrayAddHandles()">
 </A>
<H1 CLASS="refHeading">
NameArrayAddHandles()</H1>
<PRE CLASS="syntax">dword	NameArrayAddHandles(
        MemHandle 		mh,				/* Handle of LMem heap */
        ChunkHandle 		arr,				/* Chunk handle of name array */
        const char * 		nameToAdd,				/* Name of new element */
        word		nameLength,				/* Length of name; pass zero if
						 * name string is null-terminated */</PRE>
<PRE CLASS="syntax">        NameArrayAddFlags		flags,				/* Described below */
        const	void *	data);				/* Copy this data to new element */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_73.htm#IX_NameArrayAdd()">NameArrayAdd()</A></CODE>
 above, except that the name array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may resize the name array; therefore, all pointers to within the LMem heap are invalidated.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
</DIV>
<DIV>
<A NAME="IX_NameArrayChangeName()">
 </A>
<H1 CLASS="refHeading">
NameArrayChangeName()</H1>
<PRE CLASS="syntax">void	NameArrayChangeName(
        optr 		array,			/* optr of name array */
        word		token,			/* Token of element to be changed */
        const char * 		newName,			/* New name for element */
        word		nameLength);				/* Length of name in bytes; pass
						 * zero if name string is
						 * null-terminated */</PRE>
<P>
This routine changes the name of an element in a name array.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the new name is longer than the old, the chunk will be resized, invalidating all pointers to within the LMem heap.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
</DIV>
<DIV>
<A NAME="IX_NameArrayChangeNameHandles()">
 </A>
<H1 CLASS="refHeading">
NameArrayChangeNameHandles()</H1>
<PRE CLASS="syntax">dword	NameArrayChangeNameHandles(
        MemHandle 		mh,				/* Handle of LMem heap */
        ChunkHandle 		array,				/* Chunk handle of name array */
        word		token,				/* Token of element to be changed */
        const char * 		newName,				/* New name for element */
        word		nameLength);				/* Length of name in bytes; pass
						 * zero if name string is
						 * null-terminated */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_73.htm#IX_NameArrayChangeName()">NameArrayChangeName()</A></CODE>
 above, except that the name array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the new name is longer than the old, the chunk will be resized, invalidating all pointers to within the LMem heap.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
</DIV>
<DIV>
<A NAME="IX_NameArrayCreate()">
 </A>
<H1 CLASS="refHeading">
NameArrayCreate()</H1>
<PRE CLASS="syntax">ChunkHandle 	NameArrayCreate(
        MemHandle 		mh,				/* Global handle of LMem heap */
        word		dataSize,				/* Size of data section for
						 * each element */</PRE>
<PRE CLASS="syntax">        word		headerSize);				/* Size of header; pass
						 * zero for default header */</PRE>
<P>
This routine creates a name array in the indicated LMem heap. It creates a <CODE>
NameArrayHeader</CODE>
 structure at the head of a new chunk. If you want to leave extra space before the start of the array, you can pass a larger header size; if you want to use the standard header, pass a header size of zero.</P>
<P>
You must specify the size of the data portion of each element when you create the array. The name portion will be variable sized.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
<P CLASS="refField"><STRONG>
Tips and Tricks:</STRONG>	If you want extra space after the <CODE>
NameArrayHeader</CODE>
, you may want to create your own header structure, the first element of which is a <CODE>
NameArrayHeader</CODE>
. You can pass the size of this header to <CODE>
NameArrayCreate()</CODE>
 and access the data in your header via the structure fields.</P>
<P CLASS="refField"><STRONG>
Be Sure To:</STRONG>	Lock the block on the global heap before calling this routine (unless it is fixed). If you pass a header size, make sure it is larger than <CODE>
sizeof(NameArrayHeader)</CODE>
.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
</DIV>
<DIV>
<A NAME="IX_NameArrayCreateAt()">
 </A>
<H1 CLASS="refHeading">
NameArrayCreateAt()</H1>
<PRE CLASS="syntax">ChunkHandle 	NameArrayCreateAt(
        optr	array,	/* Turn this chunk into a name array */
        word	dataSize,	/* Size of data section of each element */
        word	headerSize); 	/* Size of header; pass zero for default header */</PRE>
<P>
This routine is just like <CODE>
<A HREF="../../CRef/Routines/R_73.htm#IX_NameArrayCreate()">NameArrayCreate()</A></CODE>
 above, except that the element array is created in a pre-existing chunk. The contents of that chunk will be destroyed.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the chunk isn't large enough, it will be resized. This will invalidate all pointers to chunks in that block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
</DIV>
<DIV>
<A NAME="IX_NameArrayCreateAtHandles()">
 </A>
<H1 CLASS="refHeading">
NameArrayCreateAtHandles()</H1>
<PRE CLASS="syntax">ChunkHandle 	NameArrayCreateAtHandles(
        MemHandle 		mh,				/* Global handle of LMem heap */
        ChunkHandle 		chunk,				/* the chunk for the array */
        word		dataSize,				/* Size of data for each element */
        word		headerSize);				/* Size of header; pass
						 * zero for default header */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_73.htm#IX_NameArrayCreateAt()">NameArrayCreateAt()</A></CODE>
 above, except that the name array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	If the chunk isn't large enough, it will be resized. This will invalidate all pointers to chunks in that block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
</DIV>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_72.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">ModemSetMessageDataNotify() ...</A> 
<!-- to next --> | <A HREF="R_74.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">NameArrayFind() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
