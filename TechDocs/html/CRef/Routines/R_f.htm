<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: R_f.htm,v 1.2 97/06/25 18:48:46 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE>GEOS C Routines: ContactMatchNumber() ...</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_e.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">ContactGetDBHandle() ...</A> 
<!-- to next --> | <A HREF="R_10.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">DataStoreCreate() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</DIV>
<DIV>
<A NAME="IX_ContactMatchNumber()">
 </A>
<H1 CLASS="refHeading">
ContactMatchNumber()</H1>
<PRE CLASS="syntax">RecordID	ContactMatchNumber( 
        TCHAR		number,
        ContdbCallType		type,
        FieldID		*field,
        word		*numMatches );</PRE>
<P>
This function takes a phone number, searches all fields of the specified type in all records of the Contact database, returning the <CODE>
RecordID</CODE>
 and <CODE>
FieldID</CODE>
 of the matching field, if any; if there was no match, it returns -1.</P>
<P>
This function takes the following arguments:</P>
<DL>
<DT>
<EM>number</EM></DT><DD>String containing the phone number to match. </DD>
<DT>
<EM>type</EM></DT><DD>The type of phone number to match; one of CCT_PHONE, CCT_SMS, CCT_FAX, CCT_EMAIL, CCT_GSM_FAX, CCT_ANY.</DD>
<DT>
<EM>field</EM></DT><DD>Pointer to a <CODE>
FieldID</CODE>
 buffer. The function will fill this buffer in with the <CODE>
FieldID</CODE>
 of the matching field, if any.</DD>
<DT>
<EM>numMatches</DT><DD>
</EM>Pointer to a word buffer. The function will fill this buffer in with the number of matching records found.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ContactEnsureEmptyField()">ContactEnsureEmptyField()</A></CODE>,
<CODE>FoamDBSetFieldData()</CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ContactRecreateFieldLabel()">
 </A>
<H1 CLASS="refHeading">
ContactRecreateFieldLabel()</H1>
<PRE CLASS="syntax">void ContdbRecreateFieldLabel(
        TCHAR 		*subLabel,
        TCHAR 		*destination,
        int 		fieldType);</PRE>
<P>
This utility function takes a field sub-label (e.g., &quot;GSM/PCN&quot;) and field type and creates a label from them (e.g. &quot;Tel(GSM)&quot;. It will translate standard labels from English to the user's language. (Some field sublabels are standard, such as the &quot;GSM&quot; in &quot;Tel(GSM)&quot; and will be translated; the user's custom sublabels will not be translated.) This function takes the following arguments:</P>
<DL>
<DT>
<EM>subLabel</EM></DT><DD>The sublabel string.</DD>
<DT>
<EM>destination</EM></DT><DD>String buffer to hold the field name.</DD>
<DT>
<EM>fieldType</EM></DT><DD>The <CODE>
ContdbFieldType</CODE>
 value of the field.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_e.htm#IX_ContactImportDBFromTextFile()">ContactImportDBFromTextFile()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ContactReleaseDBHandle()">
 </A>
<H1 CLASS="refHeading">
ContactReleaseDBHandle()</H1>
<PRE CLASS="syntax">void	ContactReleaseDBHandle( void );</PRE>
<P>
This function releases the Contact database's handle, signalling that the application is done with the database for now. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_e.htm#IX_ContactGetDBHandle()">ContactGetDBHandle()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_f.htm#IX_ContactReleaseDBHandle()">ContactReleaseDBHandle()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ContactSaveRecord()">
 </A>
<H1 CLASS="refHeading">
ContactSaveRecord()</H1>
<PRE CLASS="syntax">dword	ContactSaveRecord(
        MemHandle 		record);</PRE>
<P>
This functionsaves the passed record in the database, inserting it in the proper sort order. It returns the record's <CODE>
RecordID</CODE>
 number.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>FoamDBDiscardRecord()</CODE>,
<CODE>FoamDBDeleteRecord()</CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ContactSetTemplateRecord()">
 </A>
<H1 CLASS="refHeading">
ContactSetTemplateRecord()</H1>
<PRE CLASS="syntax">void	ContactSetTemplateRecord( 
        MemHandle 		record);</PRE>
<P>
This functionmakes the passed record the Contact database's template record. It also frees that contact's handle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
contdb.goh</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_d.htm#IX_ContactCreateRecordFromTemplate()">ContactCreateRecordFromTemplate()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ContdbTranslateSubFieldLabelToEnglish()">
 </A>
<H1 CLASS="refHeading">
ContdbTranslateSubFieldLabelToEnglish()</H1>
<PRE CLASS="syntax">void	ContdbTranslateSubFieldLabelToEnglish(
        TCHAR 		*subLabel,
        TCHAR 		*destination);</PRE>
<P>
This function translates a foreign sub-label to its english equivalent. This function only recognizes certain &quot;standard&quot; sublabels; the user's custom labels will not be translated. This function takes two arguments: a buffer containing the string to translate and a string buffer to hold the translation.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_16.htm#IX_DBAllocUngrouped()">DBAllocUngrouped()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_DataStoreAddField()">
 </A>
<H1 CLASS="refHeading">
DataStoreAddField()</H1>
<PRE CLASS="syntax">DataStoreStructureError	DataStoreAddField(
        word		dsToken,
        FieldDescriptor		*fieldDescPtr,
        FieldID		*fieldIDPtr);</PRE>
<P>
Adds a field to the datastore and writes the new field's <CODE>
FieldID</CODE>
 to <EM>fieldIDPtr</EM>. Returns a <CODE>
DataStoreStructureError</CODE>
 value (DSSE_NO_ERROR if successful). Takes the following arguments:</P>
<DL>
<DT>
<EM>dsToken</EM></DT><DD>Session token to the opened datastore.</DD>
<DT>
<EM>fieldDescPtr</DT><DD>
</EM>Pointer to a <CODE>
FieldDescriptor</CODE>
 structure. Set FD<CODE>
_flags</CODE>
 to FF_PRIMARY_KEY if the field is part of the key.</DD>
<PRE>		typedef struct {
			FieldData		FD_data;
			TCHAR		*FD_name;
		} FieldDescriptor;</PRE>
<PRE>		typedef struct {
			FieldType		FD_type;
			FieldCategory		FD_category;
			FieldFlags		FD_flags;
		} FieldData;</PRE>
<DT>
fieldIDPtr</DT><DD>Pointer to the <CODE>
FieldID</CODE>
 of the added field.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
datastor.h</STRONG>
</P>
</DIV>
<DIV>
<A NAME="IX_DataStoreBuildIndex()">
 </A>
<H1 CLASS="refHeading">
DataStoreBuildIndex()</H1>
<PRE CLASS="syntax">DataStoreStructureError	DataStoreBuildIndex(
        word					dsToken,
        MemHandle					*indexBlockHan,
        word					dataSize,
        DataStoreIndexCallbackParams					*paramsPtr,
        sword _pascal (*CallbackRoutine) (
        	word	dsToken,
        	DataStoreIndexCallbackParams	*paramsPtr));</PRE>
<P>
Builds an index of <CODE>
RecordNum</CODE>
s (low word only) based on either a specified field or a callback function. Returns a <CODE>
DataStoreStructureError</CODE>
 value (DSSE_NO_ERROR if successful). Takes the following arguments:</P>
<DL>
<DT>
<EM>dsToken</EM>	</DT><DD>
Session token to the opened datastore.</DD>
<DT>
<EM>indexBlockHan</DT><DD>
</EM>Pointer to the handle of the index block.</DD>
<DT>
<EM>dataSize	</DT><DD>
</EM>Number of bytes of data to write to the index block.</DD>
<DT>
<EM>paramsPtr	</DT><DD>
</EM>Pointer to a <CODE>
DataStoreIndexCallbackParams</CODE>
 structure. To build an index on a field, specify the field in DSICP<CODE>
_indexField</CODE>
. Set DSICP<CODE>
_sortOrder</CODE>
 to SO_ASCENDING or SO_DESCENDING. If you specify a callback, the caller will pass DSICP<CODE>
_cbData</CODE>
, DSICP<CODE>
_rec1</CODE>
 and DSICP<CODE>
_rec2</CODE>
 to the callback.</DD>
<PRE>		typedef struct {
			FieldID		DSICP_indexField;
			SortOrder		DSICP_sortOrder;
			void		*DSICP_cbData;
			RecordHeader		*DSICP_rec1;
			RecordHeader		*DSICP_rec1;
		} DataStoreIndexCallbackParams;</PRE>
<DT>
<EM>CallbackRoutine</DT><DD>
</EM>Subroutine to determine which of two passed records comes before the other. The function should return:<BR>
<BR>
-1 if <CODE>
DSICP_rec1</CODE>
 comes before <CODE>
DSICP_rec2<BR>
</CODE>
1 if <CODE>
DSICP_rec1</CODE>
 comes after <CODE>
DSICP_rec2</CODE>
</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Cannot call this routine on datastores that contain more than 4,000 records (will return DSSE_INDEX_RECORD_NUMBER_LIMIT_EXCEEDED).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
datastor.h</STRONG>
</P>
</DIV>
<DIV>
<A NAME="IX_DataStoreClose()">
 </A>
<H1 CLASS="refHeading">
DataStoreClose()</H1>
<PRE CLASS="syntax">DataStoreError	DataStoreClose(
        word		dsToken);	/* session token to opened datastore */</PRE>
<P>
Closes the datastore if no other application has it open; otherwise, closes the &quot;session&quot; associated with <EM>
dsToken</EM>
. Returns a <CODE>
DataStoreError</CODE>
 value (DSE_NO_ERROR if successful).</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	Returns DSE_CLOSE_WITH_LOCKED_RECORD if the calling session has a record locked.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
datastor.h</STRONG>
</P>
</DIV>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_e.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">ContactGetDBHandle() ...</A> 
<!-- to next --> | <A HREF="R_10.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">DataStoreCreate() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
