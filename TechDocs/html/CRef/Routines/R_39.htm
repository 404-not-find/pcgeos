<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: R_39.htm,v 1.2 97/06/25 18:23:37 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE>GEOS C Routines: GrDestroyBitmap() ...</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_38.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">GrClearBitmap() ...</A> 
<!-- to next --> | <A HREF="R_3a.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">GrDrawCurve() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</DIV>
<DIV>
<A NAME="IX_GrDestroyBitmap()">
 </A>
<A NAME="IX_BMDestroy">
 </A>
<A NAME="IX_BMD_&ldots;">
 </A>
<H1 CLASS="refHeading">
GrDestroyBitmap()</H1>
<PRE CLASS="syntax">void	GrDestroyBitmap(
        GStateHandle		gstate,			/* GState containing bitmap */
        BMDestroy 		flags);			/* flags for removing data */</PRE>
<P>
Free the bitmap and disassociate it with its window. Depending on the passed flag, the bitmap's data may be freed or preserved. Thus, it is possible to remove the GString used to edit the bitmap while maintaining the bitmap in a drawable state.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE>typedef ByteEnum BMDestroy;
/* 	BMD_KILL_DATA, 
 	BMD_LEAVE_DATA */</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_GrDestroyGString()">
 </A>
<A NAME="IX_GStringKillType">
 </A>
<A NAME="IX_GSKT_&ldots;">
 </A>
<H1 CLASS="refHeading">
GrDestroyGString()</H1>
<PRE CLASS="syntax">void	GrDestroyGString(
        Handle		gstring,			/* Handle of GString */
        GStateHandle		gstate,			/* NULL, or handle of another
					 * gstate to free*/</PRE>
<PRE CLASS="syntax">        GStringKillType		type);			/* Kill type for data removal */</PRE>
<P>
Destroys a GString. Depending on the <CODE>
GStringKillType</CODE>
 argument, this either constitutes removing the GState from the GString data; or freeing both the GState and the GString's data. If you have been drawing the GString to a GState, you should pass the GState's handle as <EM>
gstate</EM>
, and this routine will do some cleaning up.</P>
<P CLASS="refField"><STRONG>
Structures:</STRONG>	</P>
<PRE>typedef ByteEnum GStringKillType;
/* 	GSKT_KILL_DATA, 
	GSKT_LEAVE_DATA */</PRE>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
gstring.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_GrDestroyPalette()">
 </A>
<H1 CLASS="refHeading">
GrDestroyPalette()</H1>
<PRE CLASS="syntax">void	GrDestroyPalette(
        GStateHandle gstate);			/* GState of palette to destroy */</PRE>
<P>
Free any custom palette associated with the current window.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_GrDestroyState()">
 </A>
<H1 CLASS="refHeading">
GrDestroyState()</H1>
<PRE CLASS="syntax">void	GrDestroyState(
        GStateHandle gstate);			/* GState to be destroyed */</PRE>
<P>
Free a graphics state block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_GrDrawArc()">
 </A>
<H1 CLASS="refHeading">
GrDrawArc()</H1>
<PRE CLASS="syntax">void	GrDrawArc(
        GStateHandle		gstate,				/* GState to draw to */
        sword		left,				/* bounds of box outlining arc */
        sword		top,
        sword		right,
        sword		bottom,
        word		startAngle,				/* angles in degrees
        word		endAngle,				 * counter-clockwise */
        ArcCloseType		arcType);				/* how the arc is closed */</PRE>
<P>
Draw an arc along the ellipse that is specified by a bounding box, from the starting angle to the ending angle.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_GrDrawArc3Point()">
 </A>
<H1 CLASS="refHeading">
GrDrawArc3Point()</H1>
<PRE CLASS="syntax">void	GrDrawArc3Point(
        GStateHandle		gstate,			/* GState to draw to */
        const ThreePointArcParams 	*params);			</PRE>
<P>
Draw a circular arc, given three points along the arc; both endpoints and any other point on the arc.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_GrDrawArc3PointTo()">
 </A>
<H1 CLASS="refHeading">
GrDrawArc3PointTo()</H1>
<PRE CLASS="syntax">void	GrDrawArc3PointTo(
        GStateHandle		gstate,			/* GState to draw to */
        const ThreePointArcToParams *params);</PRE>
<P>
As <CODE>
GrDrawArc3Point()</CODE>
, above, except that the current position is automatically used as one of the endpoints.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_GrDrawBitmap()">
 </A>
<H1 CLASS="refHeading">
GrDrawBitmap()</H1>
<PRE CLASS="syntax">void	GrDrawBitmap(
        GStateHandle		gstate,					/* GState to draw to */
        sword		x,					/* x starting point */
        sword		y,					/* y starting point */
        const	Bitmap	* bm,					/* pointer to the bitmap */
        Bitmap * _pascal (*callback) (Bitmap *bm));							/* NULL for no callback */</PRE>
<P>
Draw a bitmap. Note that if the bitmap takes up a great deal of memory, it is necessary to manage its memory when drawing. If the bitmap resides in a <CODE>
HugeArray</CODE>
 (true of any bitmap created using <CODE>
<A HREF="../../CRef/Routines/R_38.htm#IX_GrCreateBitmap()">GrCreateBitmap()</A></CODE>
), then calling <CODE>
<A HREF="../../CRef/Routines/R_3a.htm#IX_GrDrawHugeBitmap()">GrDrawHugeBitmap()</A></CODE>
 will automatically take care of memory management. Otherwise, you may wish to provide a suitable callback routine. This routine should be declared _pascal and is passed a pointer into the passed bitmap and is expected to return a pointer to the next slice. This allows the bitmap to be drawn in horizontal bands, or swaths.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_GrDrawBitmapAtCP()">
 </A>
<H1 CLASS="refHeading">
GrDrawBitmapAtCP()</H1>
<PRE CLASS="syntax">void	GrDrawBitmapAtCP(
        GStateHandle		gstate,					/* GState to draw to */
        const	Bitmap	* bm,					/* pointer to the bitmap */
        Bitmap * _pascal (*callback) (Bitmap *bm));							/* NULL for no callback */</PRE>
<P>
This routine is the same as<CODE>
 GrDrawBitmap()</CODE>
, above, except that the bitmap is drawn at the current position.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_GrDrawChar()">
 </A>
<H1 CLASS="refHeading">
GrDrawChar()</H1>
<PRE CLASS="syntax">void	GrDrawChar(
        GStateHandle		gstate,			/* GState to draw to */
        sword		x,			/* x position at which to draw */
        sword		y,			/* y position at which to draw */
        word		ch);			/* character of type Chars */</PRE>
<P>
Draw a character at the given position with the current text drawing attributes.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_GrDrawCharAtCP()">
 </A>
<H1 CLASS="refHeading">
GrDrawCharAtCP()</H1>
<PRE CLASS="syntax">void	GrDrawCharAtCP(
        GStateHandle		gstate,			/* GState to draw to */
        word		ch);			/* character of type Chars */</PRE>
<P>
Draw a character at the current position with the current text drawing attributes.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
graphics.h</STRONG>
 </P>
</DIV>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_38.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">GrClearBitmap() ...</A> 
<!-- to next --> | <A HREF="R_3a.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">GrDrawCurve() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
