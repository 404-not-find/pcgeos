<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: R_95.htm,v 1.2 97/06/25 18:44:30 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE>GEOS C Routines: TextSearchInString() ...</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_94.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">SysShutdown() ...</A> 
<!-- to next --> | <A HREF="R_96.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">ThreadAttachToQueue() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</DIV>
<DIV>
<A NAME="IX_TextSearchInString()">
 </A>
<H1 CLASS="refHeading">
TextSearchInString()</H1>
<PRE CLASS="syntax">char *	TextSearchInSTring(
        const char		*str1,
        conat char		*startPtr,
        const char		*endPtr,
        word		strSize,
        const char		*str2,
        word		str2Size,
        word		searchOptions,
        word		*matchLen);</PRE>
<P>
This routine searches in a single text chunk for a passed text string. If a match is found, a pointer to that match (and the length of the match) are returned in passed buffers. </P>
<P>
<EM>
str1</EM>
 is a pointer to the main string you will be searching in.</P>
<P>
<EM>
startPtr</EM>
 and <EM>
endPtr</EM>
 are pointers to locations within <EM>
str1</EM>
 to begin and end the search.</P>
<P>
<EM>
strSize</EM>
 stores the size of <EM>
str1</EM>
, or zero if null-terminated.</P>
<P>
<EM>
str2</EM>
 stores the match string, which may include wildcards (type <CODE>
WildCard</CODE>
).</P>
<P>
<EM>
str2Size</EM>
 stores the size of <EM>
str2</EM>
, or zero if null-terminated.</P>
<P>
<EM>
searchOptions</EM>
 stores the <CODE>
SearchOptions</CODE>
 to use by the search mechanism. The high byte should be zeroed.</P>
<P>
<EM>
matchLen</EM>
 stores a buffer to store the size of the matched word. (The matched word itself is returned by the routine.)</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
Objects/vTextC.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_TextSearchInHugeArray()">
 </A>
<H1 CLASS="refHeading">
TextSearchInHugeArray()</H1>
<PRE CLASS="syntax">dword	TextSearchInSTring(
        char		*str2,
        word		str2Size,
        dword		str1Size,
        dword		curOffset,
        dword		endOffset,
        FileHandle		hugeArrayFile,
        VMBlockHandle		hugeArrayBlock,
        word		searchOptions,
        word		*matchLen);</PRE>
<P>
This routine searches in a huge array for a passed text string. If a match is found, a dword offset to the match (and the length of the match) are returned in passed buffers. </P>
<P>
<EM>
str2</EM>
 stores the match string, which may include wildcards (type <CODE>
WildCard</CODE>
).</P>
<P>
<EM>
str2Size</EM>
 stores the size of <EM>
str2</EM>
, or zero if null-terminated.</P>
<P>
<EM>
str1Size</EM>
 stores the total length of the string being searched.</P>
<P>
<EM>
curOffset</EM>
 stores the offset from the start of str1 to the first character to check.</P>
<P>
<EM>
endOffset</EM>
 stores the offset from the start of str1 to the last character to check.</P>
<P>
<EM>
hugeArrayFile</EM>
 stores the file handle of the huge array.</P>
<P>
<EM>
hugeArrayBlock</EM>
 stores the VM block handle of the huge array.</P>
<P>
<EM>
searchOptions</EM>
 stores the <CODE>
SearchOptions</CODE>
 to use by the search mechanism. The high byte should be zeroed.</P>
<P>
<EM>
matchLen</EM>
 stores a buffer to store the size of the matched word. (The matched word itself is returned by the routine.)</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
Objects/vTextC.goh</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_TGI_PRIORITY() macro">
 </A>
<H1 CLASS="refHeading">
TGI_PRIORITY()</H1>
<PRE CLASS="syntax">byte	TGI_PRIORITY(<EM>val</EM>);
        word	<EM>val</EM>;</PRE>
<P>
This macro extracts the thread priority from the value returned by <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetInfo()">ThreadGetInfo()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="IX_TGI_RECENT_CPU_USAGE() macro">
 </A>
<H1 CLASS="refHeading">
TGI_RECENT_CPU_USAGE()</H1>
<PRE CLASS="syntax">byte	TGI_RECENT_CPU_USAGE(<EM>val</EM>);
        word	<EM>val</EM>;</PRE>
<P>
This macro extracts the recent CPU usage from the value returned by <CODE>
<A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGetInfo()">ThreadGetInfo()</A></CODE>
.</P>
</DIV>
<DIV>
<A NAME="IX_ThreadAllocSem()">
 </A>
<H1 CLASS="refHeading">
ThreadAllocSem()</H1>
<PRE CLASS="syntax">SemaphoreHandle ThreadAllocSem(
        word	value);			/* allowable locks on the semaphore */</PRE>
<P>
This routine allocates and initializes a new semaphore for private use by a multithreaded application. Pass the value with which to initialize the semaphore; this value represents the number of threads that can grab the semaphore before other grab attempts will block. Typically, the passed value will be one. The routine returns the handle of the new semaphore.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
sem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPSem()">ThreadPSem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadVSem()">ThreadVSem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_96.htm#IX_ThreadFreeSem()">ThreadFreeSem()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadPTimedSem()">ThreadPTimedSem()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ThreadAllocThreadLock()">
 </A>
<H1 CLASS="refHeading">
ThreadAllocThreadLock()</H1>
<PRE CLASS="syntax">ThreadLockHandle ThreadAllocThreadLock();</PRE>
<P>
This routine allocates a special semaphore called a thread lock. With a normal semaphore, a thread that grabs the semaphore twice without releasing it will deadlock; with a thread lock, a thread can grab it more than once in succession. The thread has to release it once for each time it grabs the thread lock, however.</P>
<P>
In all other aspects, however, the thread lock resembles a normal semaphore. <CODE>
ThreadAllocThreadLock()</CODE>
 returns the handle of the new thread lock.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
sem.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_97.htm#IX_ThreadGrabThreadLock()">ThreadGrabThreadLock()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_98.htm#IX_ThreadReleaseThreadLock()">ThreadReleaseThreadLock()</A></CODE>.</P>
</DIV>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_94.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">SysShutdown() ...</A> 
<!-- to next --> | <A HREF="R_96.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">ThreadAttachToQueue() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
