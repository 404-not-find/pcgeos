<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: R_74.htm,v 1.2 97/06/25 18:37:54 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE>GEOS C Routines: NameArrayFind() ...</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_73.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">NameArrayAdd() ...</A> 
<!-- to next --> | <A HREF="R_75.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">ObjCompFindChildByOptr() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</DIV>
<DIV>
<A NAME="IX_NameArrayFind()">
 </A>
<H1 CLASS="refHeading">
NameArrayFind()</H1>
<PRE CLASS="syntax">word	NameArrayFind(
        optr 		array,				/* optr to name array */
        const char		* nameToFind,				/* Find element with this name */
        word		nameLength,				/* Pass zero if name string is
						 * null-terminated */</PRE>
<PRE CLASS="syntax">        void *		returnData);				/* Copy data section into this
						 * buffer */</PRE>
<P>
This routine locates the element with the specified name. It returns the token of the element and copies its data section into the passed buffer. If there is no element with the specified name, the routine will return CA_NULL_ELEMENT. The routine takes the following arguments:</P>
<DL>
<DT>
<CODE>
array</CODE>
</DT><DD>The optr of the name array.</DD>
<DT>
<CODE>
nameToAdd</DT><DD>
</CODE>
The name of the element to find. This string may contain nulls.</DD>
<DT>
<CODE>
nameLength</DT><DD>
</CODE>
The length of the name string, in bytes. If you pass zero, <CODE>
NameArrayFind()</CODE>
 will assume the string is null-terminated.</DD>
<DT>
<CODE>
returnData</CODE>
</DT><DD>The data section of the element is written to this buffer.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	You must make sure the <CODE>
returnData</CODE>
 buffer is large enough to hold an element's data portion; otherwise, data after the buffer will be overwritten.</P>
</DIV>
<DIV>
<A NAME="IX_NameArrayFindHandles()">
 </A>
<H1 CLASS="refHeading">
NameArrayFindHandles()</H1>
<PRE CLASS="syntax">word	NameArrayFindHandles(
        MemHandle		mh,				/* Handle of LMem heap */
        ChunkHandle 		array,				/* Handle of name array */
        const char *		nameToFind,				/* Find element with this name */
        word		nameLength,				/* Pass zero if name string is
						 * null-terminated */</PRE>
<PRE CLASS="syntax">        void *		returnData);				/* Copy data section into this
						 * buffer */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_74.htm#IX_NameArrayFind()">NameArrayFind()</A></CODE>
 above, except that the name array is specified by its global and chunk handles (instead of with an optr).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	chunkarr.h</P>
</DIV>
<DIV>
<A NAME="IX_NEC()">
 </A>
<H1 CLASS="refHeading">
NEC()</H1>
<PRE CLASS="syntax">NEC(<EM>line</EM>)</PRE>
<P>
This macro defines a line of code that will only be compiled into the <EM>
non</EM>
-error-checking version of the geode. The <CODE>
line</CODE>
 parameter of the macro is the actual line of code. When the non-EC version of the program is compiled, the line will be treated as a normal line of code; when the EC version is compiled, the line will be ignored.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_1e.htm#IX_EC() macro">EC()</A></CODE>.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	ec.h</P>
</DIV>
<DIV>
<A NAME="IX_ObjBlockGetOutput()">
 </A>
<H1 CLASS="refHeading">
ObjBlockGetOutput()</H1>
<PRE CLASS="syntax">optr	ObjBlockGetOutput(
        MemHandle mh);			/* handle of the subject object block */</PRE>
<P>
This routine returns the optr of the output destination object set for the specified object block. The output object is stored in the object block's header in the <CODE>
OLMBH_output</CODE>
 field. If the block has no output set, NullOptr will be returned.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjLMemBlockHeader">ObjLMemBlockHeader</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ObjBlockSetOutput()">
 </A>
<H1 CLASS="refHeading">
ObjBlockSetOutput()</H1>
<PRE CLASS="syntax">void	ObjBlockSetOutput(
        MemHandle		mh,			/* handle of the subject object block */
        optr		o);			/* optr of the new output object */</PRE>
<P>
This routine sets the <CODE>
OLMBH_output</CODE>
 field in the specified object block's header. The optr passed in <CODE>
o</CODE>
 will be set as the block's output.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjLMemBlockHeader">ObjLMemBlockHeader</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ObjCompAddChild()">
 </A>
<H1 CLASS="refHeading">
ObjCompAddChild()</H1>
<PRE CLASS="syntax">void	ObjCompAddChild(
        optr	obj,		/* optr of parent composite */
        optr	objToAdd,		/* optr of new child */
        word	flags,		/* CompChildFlags */
        word	masterOffset,		/* offset to master part */
        word	compOffset,		/* offset to comp field in master part */
        word	linkOffset);		/* offset to link field in master part */</PRE>
<P>
This routine adds the given object to an object tree as the child of another specified object. It returns nothing. You will not likely want to use this routine; instead, you will probably use the messages listed below under &quot;See Also.&quot; The parameters of this routine are</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the parent composite object. The parent must be a composite; if it is not, an error will result.</DD>
<DT>
<CODE>
objToAdd</CODE>
</DT><DD>The optr of the child object. The child must have a link instance field (defined with <CODE>
@link</CODE>
).</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>A record of <CODE>
CompChildFlags</CODE>
. These flags indicate whether the object should initially be marked dirty as well as where in the parent's child list the new child should be placed (first, second, last, etc.).</DD>
<DT>
<CODE>
masterOffset</DT><DD>
</CODE>
The offset within the parent's instance chunk to the master group's offset. (The value that would appear in the parent class' <CODE>
Class_masterOffset</CODE>
 field in its <CODE>
ClassStruct</CODE>
 structure.)</DD>
<DT>
<CODE>
compOffset</CODE>
</DT><DD>The offset within the parent's instance chunk to the composite field.</DD>
<DT>
<CODE>
linkOffset</CODE>
</DT><DD>The offset within the parent's instance chunk to the link field.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may resize and move LMem and Object blocks on the heap, thereby invalidating all segment addresses and pointers.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	metaC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_VIS_ADD_CHILD</CODE>,
<CODE>MSG_GEN_ADD_CHILD</CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ObjCompFindChildByNumber()">
 </A>
<H1 CLASS="refHeading">
ObjCompFindChildByNumber()</H1>
<PRE CLASS="syntax">optr	ObjCompFindChildByNumber(
        optr	obj,		/* parent's optr */
        word	childToFind,		/* zero-based child number */
        word	masterOffset,		/* offset to master part */
        word	compOffset,		/* offset to comp field in master part */
        word	linkOffset);		/* offset to link field in master part */</PRE>
<P>
This routine returns the optr of the passed object's child; the child is specified based on its position in the object's child list. You will not often use this routine, but you will probably use the messages listed under &quot;See Also&quot; instead. The routine's parameters are listed below:</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the parent object.</DD>
<DT>
<CODE>
childToFind</DT><DD>
</CODE>
The zero-based number of the child to be found. For example, to return the first child's optr, pass zero or CCO_FIRST; to return the last child's optr, pass CCO_LAST.</DD>
<DT>
<CODE>
masterOffset</DT><DD>
</CODE>
The offset within the parent's instance chunk to the master group's offset. (The value that would appear in the parent class' <CODE>
Class_masterOffset</CODE>
 field in its <CODE>
ClassStruct</CODE>
 structure.)</DD>
<DT>
<CODE>
compOffset</CODE>
</DT><DD>The offset within the parent's instance chunk to the composite field.</DD>
<DT>
<CODE>
linkOffset</CODE>
</DT><DD>The offset within the parent's instance chunk to the link field.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	metaC.goh</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_GEN_FIND_CHILD</CODE>,
<CODE>MSG_VIS_FIND_CHILD</CODE>.</P>
</DIV>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_73.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">NameArrayAdd() ...</A> 
<!-- to next --> | <A HREF="R_75.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">ObjCompFindChildByOptr() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
