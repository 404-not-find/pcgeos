<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: R_7c.htm,v 1.2 97/06/25 18:39:40 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE>GEOS C Routines: ObjResizeMaster() ...</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_7b.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">ObjIsClassADescendant() ...</A> 
<!-- to next --> | <A HREF="R_7d.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">ObjVarAddData() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</DIV>
<DIV>
<A NAME="IX_ObjResizeMaster()">
 </A>
<H1 CLASS="refHeading">
ObjResizeMaster()</H1>
<PRE CLASS="syntax">void	ObjResizeMaster(
        optr	obj,		/* object to have its master part resized */
        word	masterOffset,		/* master offset of proper master part */
        word	newSize);		/* new size for the master part */</PRE>
<P>
This routine resizes a master part of an object's instance chunk. It is typically used to allocate space for a master part or to resize the master part to zero (as when the Vis part of a visible object is removed in <CODE>
MSG_VIS_CLOSE</CODE>
). This routine must be passed the following three parameters:</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the object whose master part is to be resized.</DD>
<DT>
<CODE>
masterOffset</DT><DD>
</CODE>
The offset into the object's instance chunk where the offset to the master part is kept (this is the same offset held in the master class' <CODE>
Class_masterOffset</CODE>
 field).</DD>
<DT>
<CODE>
newSize</CODE>
</DT><DD>The new size of the master part. This can be found in the master class' <CODE>
Class_instanceSize</CODE>
 field.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine may resize and/or move chunks or object blocks, thereby invalidating stored segment addresses and pointers.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Structs/S_6.htm#IX_ClassStruct">ClassStruct</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitializeMaster()">ObjInitializeMaster()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7a.htm#IX_ObjInitializePart()">ObjInitializePart()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ObjResizeMasterHandles()">
 </A>
<H1 CLASS="refHeading">
ObjResizeMasterHandles()</H1>
<PRE CLASS="syntax">void	ObjResizeMasterHandles(
        MemHandle		mh,				/* handle portion of optr */
        ChunkHandle		ch,				/* chunk portion of optr */
        word		masterOffset,				/* offset to master part */
        word		newSize);				/* new size of master part */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_7c.htm#IX_ObjResizeMaster()">ObjResizeMaster()</A></CODE>
 except that the object is specified with its handles rather than its optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="IX_ObjSaveBlock()">
 </A>
<H1 CLASS="refHeading">
ObjSaveBlock()</H1>
<PRE CLASS="syntax">void	ObjSaveBlock(
        MemHandle mh);			/*handle of block to be marked for saving */</PRE>
<P>
This routine sets up an object or LMem block to be saved to its owner's state file. The block's handle must be passed in <CODE>
mh</CODE>
. The block must be an object block.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_7b.htm#IX_ObjMapSavedToState()">ObjMapSavedToState()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_7b.htm#IX_ObjMapStateToSaved()">ObjMapStateToSaved()</A></CODE>.</P>
</DIV>

<DIV>
<A NAME="IX_ObjSetFlags()">
 </A>
<H1 CLASS="refHeading">
ObjSetFlags()</H1>
<PRE CLASS="syntax">void	ObjSetFlags(
        optr		o,				/* object whose flags will be set */
        ObjChunkFlags 		bitsToSet,				/* flags to set */
        ObjChunkFlags		bitsToClear);				/* flags to clear */</PRE>
<P>
This routine sets the chunk flags for the specified object. Flags that should be set are passed in <CODE>
bitsToSet</CODE>
, and flags that should be cleared are passed in <CODE>
bitsToClear</CODE>
. Typically, applications will not use this routine but will rather let the kernel maintain the object's flags.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_79.htm#IX_ObjGetFlags()">ObjGetFlags()</A></CODE>,
<CODE><A HREF="../../CRef/Structs/S_2a.htm#IX_ObjChunkFlags">ObjChunkFlags</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ObjSetFlagsHandles()">
 </A>
<H1 CLASS="refHeading">
ObjSetFlagsHandles()</H1>
<PRE CLASS="syntax">void	ObjSetFlagsHandles(
        MemHandle		mh,				/* handle portion of optr */
        ChunkHandle		ch,				/* chunk portion of optr */
        ObjChunkFlags		bitsToSet,				/* flags to set */
        ObjChunkFlags		bitsToClear);				/* flags to clear */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_7c.htm#IX_ObjSetFlags()">ObjSetFlags()</A></CODE>
 except that the object is specified via its handles rather than its optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="IX_ObjTestIfObjBlockRunByCurThread()">
 </A>
<H1 CLASS="refHeading">
ObjTestIfObjBlockRunByCurThread()</H1>
<PRE CLASS="syntax">Boolean	ObjTestIfObjBlockRunByCurThread(
        MemHandle mh);			/* handle of object block */</PRE>
<P>
This routine checks if the calling thread is running the specified object block. This routine can be used to determine if calls to objects in the block are across threads or internal to the calling thread. Pass this routine the handle of the object block to be checked--if the object block is a VM block, the thread for the VM file is checked rather than that for the block.</P>
<P>
If the block is run by the calling thread, the return value is <CODE>
true</CODE>
. If a different thread runs the block, the return is <CODE>
false</CODE>
 (zero).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="IX_ObjUnrelocateEntryPoint()">
 </A>
<H1 CLASS="refHeading">
ObjUnrelocateEntryPoint()</H1>
<PRE CLASS="syntax">void	ObjUnrelocateEntryPoint(
        EntryPointRelocation *			relocData,
        void *			entryPoint);</PRE>
</DIV>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_7b.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">ObjIsClassADescendant() ...</A> 
<!-- to next --> | <A HREF="R_7d.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">ObjVarAddData() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
