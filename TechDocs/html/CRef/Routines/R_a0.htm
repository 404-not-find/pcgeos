<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: R_a0.htm,v 1.3 97/06/25 18:46:48 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE>GEOS C Routines: UtilAsciiToHex32() ...</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_9f.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">UserRemoveAutoExec() ...</A> 
<!-- to next --> | <A HREF="R_a1.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">VirtualSerialSetFormat() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</DIV>
<DIV>
<A NAME="IX_UtilAsciiToHex32()">
 </A>
<A NAME="IX_Math:UtilAsciiToHex32()">
 </A>
<A NAME="IX_UtilAsciiToHexError">
 </A>
<A NAME="IX_UATH_&ldots;">
 </A>
<H1 CLASS="refHeading">
UtilAsciiToHex32()</H1>
<PRE CLASS="syntax">Boolean	UtilAsciiToHex32(
        const char *		string,
        dword *		value);</PRE>
<P>
This routine converts a null-terminated ASCII string into a 32-bit integer. The string may begin with a hyphen, indicating a negative number. Aside from that, the string may contain nothing but numerals until the null termination. It may not contain whitespace.</P>
<P>
If the routine is successful, it will return <EM>
false</EM>
 and write an equivalent signed long integer to <EM>
*value</EM>
. If it fails, it will return <EM>
true</EM>
 and write a member of the <CODE>
UtilAsciiToHexError</CODE>
 enumerated type to <EM>
*value</EM>
. This type contains the following members:</P>
<DL>
<DT>
UATH_NON_NUMERIC_DIGIT_IN_STRING</DT><DD>
This string contained a non-numeric character before the trailing null (other than the allowed leading hyphen).</DD>
<DT>
UATH_CONVERT_OVERFLOW</DT><DD>
The string specified a number to large to be expressed as a signed 32-bit integer.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
system.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_Math:UtilHex32ToAscii()">
 </A>
<A NAME="IX_UtilHex32ToAscii()">
 </A>
<H1 CLASS="refHeading">
UtilHex32ToAscii()</H1>
<PRE CLASS="syntax">word	UtilHex32ToAscii(
        char *		buffer,
        dword		value, 
        UtilHexToAsciiFlags 		flags);</PRE>
<P>
This routine converts a 32-bit unsigned integer to its ASCII representation and writes it to the specified buffer. It returns the length of the string (not counting the nulll termination, if any). The routine is passed the following arguments:</P>
<DL>
<DT>
<EM>
buffer</EM>
</DT><DD>This is a pointer to a character buffer. The buffer must be long enough to accommodate the largest string; that is, there must be ten bytes for the characters, plus one for the trailing null (if necessary).</DD>
<DT>
<CODE>
value</CODE>
</DT><DD>This is the value to convert to ASCII.</DD>
<DT>
<CODE>
flags</CODE>
</DT><DD>This is a record of <CODE>
UtilHexToAscii</CODE>
 flags. The following flags are available:</DD>
<DT>
UHTAF_INCLUDE_LEADING_ZEROS</DT><DD>
Pad the string with leading zeros to a length of ten total characters.</DD>
<DT>
UHTAF_NULL_TERMINATE</DT><DD>
Add a null to the end of the string. If this flag is set, the buffer must be at least 11 bytes long. If it is clear, the buffer may be ten bytes long.</DD>
</DL>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
system.h</STRONG>
 </P>
</DIV>
<DIV>
<A NAME="IX_VarDataFlagsPtr() macro">
 </A>
<H1 CLASS="refHeading">
VarDataFlagsPtr()</H1>
<PRE CLASS="syntax">VarDataFlags 	VarDataFlagsPtr(
        void *	ptr);</PRE>
<P>
This macro fetches the flags of a variable data type when given a pointer to the extra data for the type. The flags are stored in a <CODE>
VarDataFlags</CODE>
 record. Only the flags VDF_EXTRA_DATA and/or VDF_SAVE_TO_STATE will be returned.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
object.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	You must pass a pointer to the <EM>
beginning</EM>
 of the vardata entry's extra data space.</P>
</DIV>
<DIV>
<A NAME="IX_VarDataSizePtr() macro">
 </A>
<H1 CLASS="refHeading">
VarDataSizePtr()</H1>
<PRE CLASS="syntax">word	VarDataSizePtr(
        void *	ptr);</PRE>
<P>
This macro fetches the size of a variable data entry when given a pointer to the extra data for the type.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
object.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	You must pass a pointer to the <EM>
beginning</EM>
 of the vardata entry's extra data space.</P>
</DIV>
<DIV>
<A NAME="IX_VarDataTypePtr() macro">
 </A>
<H1 CLASS="refHeading">
VarDataTypePtr()</H1>
<PRE CLASS="syntax">word	VarDataTypePtr(
        void *	ptr);</PRE>
<P>
This macro fetches the type of a variable data entry when given a pointer to the extra data of the entry. The type is stored in a <CODE>
VarDataFlags</CODE>
 record. All flags outside the VDF_TYPE section will be cleared.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
object.h</STRONG>
 </P>
<P CLASS="refField"><STRONG>
Warning:</STRONG>	You must pass a pointer to the <EM>
beginning</EM> of the vardata entry's extra data space.</P>
</DIV>

<DIV>
<A NAME="IX_VirtualSerialClose()">
 </A>
<H1 CLASS="refHeading">
VirtualSerialClose()</H1>
<PRE CLASS="syntax">VirtualSerialStatus 	VirtualSerialClose ( void  );</PRE>
<P>
Waits until all outgoing data is sent to remote unit, then flushes incoming data buffer and closes connection to remote unit. 
</P>
<P>
Returns VS_OK if data was successfully written.</P>
<P>
Returns VS_CLOSED if stream was already closed.</P>
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG> This is a low-level routine whose use is discouraged in favor of <CODE>ModemClose()</CODE>. Do not call any Virtual Serial function except <CODE>VirtualSerialOpen()</CODE> after calling this function.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">vserlib.h</STRONG>
</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_a0.htm#IX_VirtualSerialOpen()">VirtualSerialOpen()</A></CODE>.</P>
</DIV>

<DIV>
<A NAME="IX_VirtualSerialFlush()">
 </A>
<H1 CLASS="refHeading">
VirtualSerialFlush()</H1>
<PRE CLASS="syntax">VirtualSerialStatus 	VirtualSerialFlush(
	 word 		flushMode);</PRE>
<P>
Flushes data from incoming buffer. The <EM>flushMode</EM> sets the operation direction. It may be:

<DL>
<DT>STREAM_READ
<DD>Flushes the incoming data buffer.
<DT>STREAM_WRITE
<DD>Is ignored. 
<DT>STREAM_BOTH
<DD>Same as STREAM_READ.
</DL>
<P>Returns VS_OK if the stream successfully flushed.
<P>Returns VS_CLOSED if the stream is not open.
</P>
<P CLASS="refField"><STRONG>
</P>
Include:	<STRONG CLASS="fileName">
vserlib.h </STRONG>
</P>
</DIV>

<DIV>
<A NAME="IX_VirtualSerialOpen()">
 </A>
<H1 CLASS="refHeading">
VirtualSerialOpen()</H1>
<PRE CLASS="syntax">VirtualSerialStatus	 VirtualSerialOpen(
	VSOpenFlags 		stream_open_mode,    /* Fail or wait if stream is busy */
	word 		input_buffer_size,    /* # of bytes 1...4096 of input buffer */
	word 		output_buffer_size,    /* Ignore. Automatically set to 4352 bytes. */
	word 		timeout);    /* # of ticks to wait and retry if the stream is busy. */</PRE>
<P>
This routine lets the client open a stream to the phone. Should the Virtual Phone data resource be in use and if <EM>stream_open_mode</EM> is set to SOF_NOBLOCK then the function fails immediately; otherwise, if <EM>stream_open_mode</EM> is set to SOF_TIMEOUT, the function will try again until it is either successful or <EM>timeout</EM> number of ticks (1 ... 32768) elapse. <EM>input_buffer_size</EM> is the size (in bytes 1...4096) of the input buffer. The <EM>output_buffer_size</EM> should be ignored, as the output buffer is set to 4352 bytes. 
<P>
Returns VS_OK if successful.</P>
<P>
Returns VS_DATA_RESOURCE_RESERVED if VP data resource is already in use. 
<P>
Returns VS_STREAM_ALREADY_OPEN if stream has already been opened by another client. 
<P>
Returns VS_CANNOT_ALLOC if cannot allocate memory for the streams buffer.
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG> This is a low-level routine whose use is discouraged in favor of <CODE>ModemOpen()</CODE>. This routine must return VS_OK before client can start using other Virtual Serial functions. Outgoing data is not buffered in VirtualSerial library, but sent directly from calling client's buffer.</P>
</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vserlib.h </STRONG>
</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_a0.htm#IX_VirtualSerialClose()">VirtualSerialClose()</A></CODE>.</P>
</DIV>



<DIV>
<A NAME="IX_VirtualSerialRead()">
 </A>
<H1 CLASS="refHeading">
VirtualSerialRead()</H1>
<PRE CLASS="syntax">VirtualSerialStatus 	VirtualSerialRead(
        VSBlockingMode		blocking_mode, /* to block or not to block */
        word		data_size, /* # of bytes of data to be read */
        byte		*ptr_to_buffer, /* buffer to hold data */
        word		*bytes_read); /* # of bytes actually read */</PRE>
<P>
Copies incoming data to buffer. If there is less than <EM>data_size</EM> number of bytes in the buffer and STREAM_BLOCK was specified in <EM>blocking_mode</EM>, will block until enough data becomes available; if there is less than <EM>data_size</EM> number of bytes in the buffer and STREAM_NO_BLOCK was specified, returns immediately with VS_SHORT_READ_WRITE.</P>
<P>
Returns VS_OK if data was successfully written.</P>
<P>
Returns VS_CLOSED if stream is not open.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vserlib.h </STRONG>
</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_a0.htm#IX_VirtualSerialReadByte()">VirtualSerialReadByte()</A></CODE>.</P>
</DIV>

<DIV>
<A NAME="IX_VirtualSerialReadByte()">
 </A>
<H1 CLASS="refHeading">
VirtualSerialReadByte()</H1>
<PRE CLASS="syntax">VirtualSerialStatus 	VirtualSerialReadByte(
        VSBlockingMode		blockingMode, /* to block or not to block */
        byte		*dataByte); /* buffer to hold read data */</PRE>
     
<P>
This routine reads a byte from the stream into <EM>dataByte</EM>. If the stream is empty and <EM>blockingMode</EM> is set to STREAM_BLOCK then the routine will wait for the request to be filled, or if STREAM_NO_BLOCK is specified the routine will immediately return an error.
<P>
Returns VS_OK if data was successfully written to <EM>dataByte</EM>.</P>
<P>
Returns VS_SHORT_READ_WRITE if the data was not available and STREAM_NO_BLOCK was specified.
<P>
Returns VS_CLOSED if the stream is not open.
<P CLASS="refField"><STRONG>
<STRONG>Warning:</STRONG></STRONG> STREAM_BLOCK mode is dangerous to use: if the opposite end does
not send data this function will block forever.</P>

<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vserlib.h </STRONG>
</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_a0.htm#IX_VirtualSerialRead()">VirtualSerialRead()</A></CODE>,
<CODE><A HREF="../../CRef/Routines/R_a1.htm#IX_VirtualSerialWriteByte()">VirtualSerialWriteByte()</A></CODE>.</P>
</DIV>


<DIV>
<A NAME="IX_VirtualSerialSendDTR()">
 </A>
<H1 CLASS="refHeading">
VirtualSerialSendDTR()</H1>
<PRE CLASS="syntax">VirtualSerialStatus 	VirtualSendDTR(
        byte		DTR_status);</PRE>
<P>
Sends Data Terminal Ready status to modem. </P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vserlib.h</STRONG>
<CODE>
</CODE>
</P>
</DIV>


<DIV>
<A NAME="IX_VirtualSerialSetFlowControl()">
 </A>
<H1 CLASS="refHeading">
VirtualSerialSetFlowControl()</H1>
<PRE CLASS="syntax">VirtualSerialStatus 	VirtualSerialSetFlowControl(
        VSFlowControl		flow_control_mode); /* software or hardware */</PRE>
<P>
Selects the flow control method used between the modem and the VirtualSerial Library. <EM>flow_control_mode</EM> can be set to either VSFC_SOFTWARE or VSFC_HARDWARE.</P>
<P>
Returns VS_OK if successfully set or VS_CLOSED if stream is not open.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
vserlib.h </STRONG>
<CODE>
</CODE>
</P>
</DIV>

<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_9f.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">UserRemoveAutoExec() ...</A> 
<!-- to next --> | <A HREF="R_a1.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">VirtualSerialSetFormat() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
