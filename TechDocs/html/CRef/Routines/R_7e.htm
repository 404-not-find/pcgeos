<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: R_7e.htm,v 1.2 97/06/25 18:40:12 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE>GEOS C Routines: ObjVarDeleteDataAt() ...</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_7d.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">ObjVarAddData() ...</A> 
<!-- to next --> | <A HREF="R_7f.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">ObjVarScanData() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</DIV>
<DIV>
<A NAME="IX_ObjVarDeleteDataAt()">
 </A>
<H1 CLASS="refHeading">
ObjVarDeleteDataAt()</H1>
<PRE CLASS="syntax">void	ObjVarDeleteDataAt(
        optr	obj,			/* object to delete from */
        word	extraDataOffset);			/* offset to extra data to delete */</PRE>
<P>
This routine deletes the specified vardata entry from the given object's instance chunk. The vardata entry is specified by its pointer as returned by <CODE>
<A HREF="../../CRef/Routines/R_7d.htm#IX_ObjVarAddData()">ObjVarAddData()</A></CODE>
, <CODE>
<A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarFindData()">ObjVarFindData()</A></CODE>
, and <CODE>
<A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDerefData()">ObjVarDerefData()</A></CODE>
. To delete an entry specified by its data type, use <CODE>
<A HREF="../../CRef/Routines/R_7d.htm#IX_ObjVarDeleteData()">ObjVarDeleteData()</A></CODE>
, above.</P>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine should be called only by the object whose vardata is affected. To operate on other objects' vardata remotely, use messages provided by <CODE>
MetaClass</CODE>
 (see below under &quot;See Also&quot;).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_META_DELETE_VAR_DATA</CODE>,
<CODE><A HREF="../../CRef/Routines/R_7d.htm#IX_ObjVarDeleteData()">ObjVarDeleteData()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ObjVarDeleteDataAtHandles()">
 </A>
<H1 CLASS="refHeading">
ObjVarDeleteDataAtHandles()</H1>
<PRE CLASS="syntax">void	ObjVarDeleteDataAtHandles(
        MemHandle		mh,			/* handle portion of optr */
        ChunkHandle		ch,			/* chunk portion of optr */
        word	extraDataOffset);				/* offset to extra data to delete */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDeleteDataAt()">ObjVarDeleteDataAt()</A></CODE>
 except that the object is specified via its handles rather than its optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="IX_ObjVarDeleteDataRange()">
 </A>
<H1 CLASS="refHeading">
ObjVarDeleteDataRange()</H1>
<PRE CLASS="syntax">void	ObjVarDeleteDataRange(
        optr 		obj,					/* object to delete from */
        word		rangeStart,					/* start of range */
        word		rangeEnd,					/* end of range */
        Boolean		useStateFlag);					/* save to state flag */</PRE>
<P>
This routine deletes all data entries within a given range for the passed object. The range is specified by beginning and ending data types and is inclusive. The four parameters to this routine are</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the object whose data entries are to be deleted.</DD>
<DT>
<CODE>
rangeStart</CODE>
</DT><DD>The lowest number data type to be deleted. Both the VDF_SAVE_TO_STATE flag and the VDF_EXTRA_DATA flag are ignored.</DD>
<DT>
<CODE>
rangeEnd</CODE>
</DT><DD>The highest number data type to be deleted. Both the VDF_SAVE_TO_STATE flag and the VDF_EXTRA_DATA flag are ignored.</DD>
<DT>
<CODE>
useStateFlag</DT><DD>
</CODE>
A flag indicating whether entries with their VDF_SAVE_TO_STATE flags should be deleted. Pass <CODE>
true</CODE>
 (nonzero) to take the state flag into account; pass <CODE>
false</CODE>
 (zero) to delete all entries in the range.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine should be called only by the object whose vardata is affected. To operate on other objects' vardata remotely, use messages provided by <CODE>
MetaClass</CODE>
 (see below under &quot;See Also&quot;).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_META_DELETE_VAR_DATA</CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ObjVarDeleteDataRangeHandles()">
 </A>
<H1 CLASS="refHeading">
ObjVarDeleteDataRangeHandles()</H1>
<PRE CLASS="syntax">void	ObjVarDeleteDataRangeHandles(
        MemHandle		mh,					/* handle portion of optr */
        ChunkHandle		ch,					/* chunk portion of optr */
        word		rangeStart,					/* start of range */
        word		rangeEnd,					/* end of range */
        Boolean		useStateFlag);					/* save to state flag */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDeleteDataRange()">ObjVarDeleteDataRange()</A></CODE>
 except that the object is specified via its handles rather than its optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	object.h</P>
</DIV>
<DIV>
<A NAME="IX_ObjVarDerefData()">
 </A>
<H1 CLASS="refHeading">
ObjVarDerefData()</H1>
<PRE CLASS="syntax">void	* ObjVarDerefData(
        optr		obj,				/* object having data type */
        VardataKey		dataType);				/* data type to dereference */</PRE>
<P>
This routine is exactly like <CODE>
<A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarFindData()">ObjVarFindData()</A></CODE>
, below, except that it does not return a null pointer if the data type is not found. Do not use this routine unless you are absolutely sure the data type is in the object; otherwise, results are unpredictable.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
object.h </STRONG>
</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE><A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarFindData()">ObjVarFindData()</A></CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ObjVarDerefDataHandles()">
 </A>
<H1 CLASS="refHeading">
ObjVarDerefDataHandles()</H1>
<PRE CLASS="syntax">void	* ObjVarDerefDataHandles(
        MemHandle		mh,				/* handle portion of optr */
        ChunkHandle		ch,				/* chunk portion of optr */
        VardataKey		dataType);				/* data type to dereference */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDerefData()">ObjVarDerefData()</A></CODE>
 except that the object is specified via its handles rather than its optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
object.h </STRONG>
</P>
</DIV>
<DIV>
<A NAME="IX_ObjVarFindData()">
 </A>
<H1 CLASS="refHeading">
ObjVarFindData()</H1>
<PRE CLASS="syntax">void	* ObjVarFindData(
        optr		obj,				/* object to be checked */
        VardataKey		dataType);				/* data type to find */</PRE>
<P>
This routine searches an object's variable data for a given data type. If the type is found, <CODE>
ObjVarFindData()</CODE>
 returns a pointer to the entry's extra data; if the entry has no extra data, an opaque pointer is returned which may be used with <CODE>
<A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarDeleteDataAt()">ObjVarDeleteDataAt()</A></CODE>
. If the entry is not found, a null pointer is returned. The pointer returned by this routine must be used before any subsequent operations on the object's block; the pointer may be invalidated by other LMem or object operations.</P>
<P>
The two parameters of this routine are</P>
<DL>
<DT>
<CODE>
obj</CODE>
</DT><DD>The optr of the object affected. This should be the caller's optr.</DD>
<DT>
<CODE>
dataType</CODE>
</DT><DD>The <CODE>
VardataKey</CODE>
 word declaring the data type and its flags. Both the VDF_SAVE_TO_STATE flag and the VDF_EXTRA_DATA flag are ignored.</DD>
</DL>
<P CLASS="refField"><STRONG>
Warnings:</STRONG>	This routine should be called only by the object whose vardata is affected. To operate on other objects' vardata remotely, use messages provided by <CODE>
MetaClass</CODE>
 (see below under &quot;See Also&quot;).</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
object.h </STRONG>
</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <CODE>MSG_META_FIND_VAR_DATA</CODE>.</P>
</DIV>
<DIV>
<A NAME="IX_ObjVarFindDataHandles()">
 </A>
<H1 CLASS="refHeading">
ObjVarFindDataHandles()</H1>
<PRE CLASS="syntax">void	* ObjVarFindDataHandles(
        MemHandle		mh,				/* handle portion of optr */
        ChunkHandle		ch,				/* chunk portion of optr */
        VardataKey		dataType);				/* data type to find */</PRE>
<P>
This routine is the same as <CODE>
<A HREF="../../CRef/Routines/R_7e.htm#IX_ObjVarFindData()">ObjVarFindData()</A></CODE>
 except that the object is specified via its handles rather than its optr.</P>
<P CLASS="refField"><STRONG>
Include:</STRONG>	<STRONG CLASS="fileName">
object.h </STRONG>
</P>
</DIV>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="R_7d.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">ObjVarAddData() ...</A> 
<!-- to next --> | <A HREF="R_7f.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">ObjVarScanData() ...</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
