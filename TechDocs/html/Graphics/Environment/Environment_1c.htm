<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: Environment_1c.htm,v 1.1 97/06/02 15:08:15 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE> Kernel Routines</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">


<H1 CLASS="subsectionTitle">
<A HREF="index.htm">Graphics Environment</A>: 10.1 <A HREF="Environment_1b.htm">Working With Video Drivers</A>: 
Kernel Routines</H1>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="Environment_1b.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="Environment_1b.htm"><IMG SRC="../../docImages/prevUp.gif" BORDER="0" ALT="Prev: ">10 Working With Video Drivers</A> 
<!-- to next --> | <A HREF="Environment_1d.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">10.2 Direct Calls to the Driver</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
<PRE>GrInvalRect(), GrInvalRectDWord(), GrGrabExclusive(), GrGetExclusive(), GrReleaseExclusive(), GrBitBlt(), GrGetBitmap(), GrGetWinHandle()</PRE>
<P>
Sometimes the geode may want more power over the driver. It can see what device coordinates correspond to a set of standard GEOS coordinates or vice versa.

</P>
<P>
<A NAME="IX_GrInvalRect()">
 </A>
It is possible to update part of a drawing without exposing the whole window. Calling <CODE>
GrInvalRect()</CODE>
 causes a passed rectangular area to be updated; the area outside the rectangle will be unaffected.<A NAME="IX_GrInvalRectDWord()">
 </A>
<CODE>
 GrInvalRectDWord()</CODE>
 works the same way, but for large coordinate spaces.</P>
<P>
Programs can also seize exclusive access to a video driver by calling the <CODE>
GrGrabExclusive()</CODE>
<A NAME="IX_GrGrabExclusive()">
 </A>
 command, which allows only the passed GState to alter what is shown on the screen. This routine is useful for programs such as screen dumps who want to accomplish something concerning the screen without worrying that programs in other threads will change the screen in the meantime.<A NAME="IX_GrReleaseExclusive()">
 </A>
 <CODE>
GrReleaseExclusive()</CODE>
 ends the exclusive access to the screen so that other GStates can update.</P>
<P>
To find out if the video exclusive is presently grabbed, call <CODE>
GrGetExclusive()</CODE>
<A NAME="IX_GrGetExclusive()">
 </A>
. This will return the handle of the GState presently in possession of the exclusive, or zero if there is no such GState.</P>
<P>
<CODE>
GrBitBlt()</CODE>
<A NAME="IX_GrBitBlt()">
 </A>
 is an advanced function used to quickly copy or move data within video memory. Effectively, it can copy or move a rectangular part of the document space to another part of that space--the passed <A NAME="IX_BLTM_&ldots;">
 </A>
<A NAME="IX_BLTMode">
 </A>
BLTMode will determine whether the area is copied or moved. This might be used in an arcade game or animation program to move simple pictures around the screen very quickly. Pass this function the source and destination rectangles, and whether you are copying or moving the block. After calling <CODE>
GrBitBlt()</CODE>
, the changes have been made to video memory but have not actually been drawn to the screen. Make sure that the affected areas are redrawn by invalidating the appropriate area. If speed is a concern, and if you're using <CODE>
GrBitBlt()</CODE>
 it probably is, you'll probably want to restrict the clipping area when the drawing is refreshed.</P>
<P>
<CODE>
GrGetBitmap()</CODE>
<A NAME="IX_GrGetBitmap()">
 </A>
 basically returns a dump of an arbitrary display area. It is an advanced function and should be used with some caution. If asked to dump an area from a GState being displayed to screen, <CODE>
GrGetBitmap()</CODE>
 won't check to see if the dumped area is obscured by another window, and so your dump might include a picture of that other window. However, if you're working with some sort of offscreen bitmap, this function provides a way to look at large portions of it a time.<A NAME="IX_GrGetPoint()">
 </A>
 Note that to look at smaller areas, you might prefer to use <CODE>
GrGetPoint()</CODE>
, an optimized, easier to use function to find out the color of a pixel.</P>
<P>
At some times, it may prove useful to know what window, if any, is associated with a GState. To find out, call <A NAME="IX_GrGetWinHandle()">
 </A>
<CODE>
GrGetWinHandle()</CODE>
.</P>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="Environment_1b.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="Environment_1b.htm"><IMG SRC="../../docImages/prevUp.gif" BORDER="0" ALT="Prev: ">10 Working With Video Drivers</A> 
<!-- to next --> | <A HREF="Environment_1d.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">10.2 Direct Calls to the Driver</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
