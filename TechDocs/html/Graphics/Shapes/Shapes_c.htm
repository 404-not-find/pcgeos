<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: Shapes_c.htm,v 1.2 97/09/05 11:49:40 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE> Drawing Bitmaps</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">


<H1 CLASS="subsectionTitle">
<A HREF="index.htm">Drawing Graphics</A>: 2.10 <A HREF="Shapes_2.htm">Shapes</A>: 
<A NAME="60826">
 </A>
Drawing Bitmaps</H1>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="Shapes_2.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="Shapes_b.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">2.9 Bézier Curves and Splines</A> 
<!-- to next --> | <A HREF="Shapes_d.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">2.11 Paths</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
<PRE>GrDrawBitmap(), GrDrawBitmapAtCP, GrFillBitmap(), GrFillBitmapAtCP(), GrDrawHugeBitmap(), GrDrawHugeBitmapAtCP(), GrDrawImage()</PRE>
<P>
<A NAME="IX_Bitmaps">
 </A>
In this section only drawing bitmaps will be discussed. For information on creating and modifying bitmaps, see <A HREF="../../Graphics/Environment/Environment_11.htm#30652">the Graphics Environment chapter</A>.</P><P>
<CODE>
GrDrawBitmap()</CODE>
<A NAME="IX_GrDrawBitmap()">
 </A>
 draws a bitmap. This routine is very versatile. It can draw simple and complex bitmaps. It can draw compacted or uncompacted bitmaps, can use a bitmap-specific palette, handles strange resolutions intelligently, and generally does the right thing. If you're working with a large bitmap and want to manage its storage, you may provide a routine to pass in part of the bitmap at a time. If the bitmap is stored in a huge array (true of all bitmaps created with <CODE>
GrCreateBitmap()</CODE>
) use <CODE>
GrDrawHugeBitmap()</CODE>
 instead of <CODE>
GrDrawBitmap()</CODE>
, and it will manage memory for you. <A NAME="IX_GrDrawBitmapAtCP()">
 </A>
<CODE>
GrDrawBitmapAtCP()</CODE>
 draws a bitmap at the current position. 
<IMG SRC="Shapes_c_bitmap.gif">

</P>
<P>
If you just want to draw a monochrome bitmap, consider using the <CODE>
GrFillBitmap()</CODE>
<A NAME="IX_GrFillBitmap()">
 </A>
 command. This routine treats the bitmap like a mask, coloring the &quot;on&quot; pixels with the present area color, and leaving the &quot;off&quot; pixels alone so that whatever is underneath the bitmap can show through. This routine is heavily optimized and very fast. <A NAME="IX_GrFillBitmapAtCP()">
 </A>
<CODE>
GrFillBitmapAtCP()</CODE>
 works the same way, filling the bitmap at the current position.</P>
<P>
Use <A NAME="IX_GrDrawHugeBitmap()">
 </A>
<CODE>
GrDrawHugeBitmap()</CODE>
 to draw a bitmap that has been stored in a HugeArray data structure. Remember that any bitmaps created by <CODE>
GrCreateBitmap()</CODE>
 are stored in a <CODE>
HugeArray</CODE>
. <CODE>
GrDrawHugeBitmap()</CODE>
 will automatically take care of memory management. <CODE>
GrDrawHugeBitmapAtCP()</CODE>
<A NAME="IX_GrDrawHugeBitmapAtCP()">
 </A>
 works the same way, drawing the bitmap at the current position. <A NAME="IX_GrFillHugeBitmap()">
 </A>
<CODE>
GrFillHugeBitmap()</CODE>
 and <CODE>
GrFillHugeBitmapAtCP()</CODE>
<A NAME="IX_GrFillHugeBitmapAtCP()">
 </A>
 fill huge bitmaps.
<IMG SRC="Shapes_c_GrDrawImage.gif">

</P>
<P>
<CODE>
GrDrawImage()</CODE>
<A NAME="IX_GrDrawImage()">
 </A>
 is less adaptable but faster than <CODE>
GrDrawBitmap()</CODE>
. <CODE>
GrDrawImage()</CODE>
 has its own kind of scaling which doesn't work in the standard GEOS fashion. This routine ignores the resolutions of both device and bitmap and displays the bitmap so that each pixel of the bitmap corresponds to one pixel of the display. If the coordinate system has been scaled or rotated, <CODE>
GrDrawImage()</CODE>
 will ignore the scale and rotation when drawing the bitmap. The bitmap may be magnified, but this is not quite the same as normal scaling: The bitmap's resolution is still ignored, but each pixel of the bitmap will receive a square of pixels on the display. <CODE>
GrDrawHugeImage()</CODE>
<A NAME="IX_GrDrawHugeImage()">
 </A>
 draws the image of a bitmap stored in a <CODE>
HugeArray</CODE>
.</P>
<P>
<A NAME="IX_IF_&ldots;  (ImageFlags)">
 </A>
<A NAME="IX_ImageFlags">
 </A>
The image-drawing routines take an <CODE>
ImageFlags</CODE>
 structure which holds a flag to specify whether borders should be drawn between the pixels of the bitmap and a bit size field which specifies the magnification to use.<A NAME="marker=255604">
 </A>
</P>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="Shapes_2.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="Shapes_b.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">2.9 Bézier Curves and Splines</A> 
<!-- to next --> | <A HREF="Shapes_d.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">2.11 Paths</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
