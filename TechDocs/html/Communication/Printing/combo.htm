<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>The Spool Library</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm"></A>



<H1 CLASS="chapterTitle">

<A NAME="index.htm_97933">
 </A>
The Spool Library

</H1>
<P>
<A NAME="index.htm_IX_Printing">
 </A>
<A NAME="index.htm_IX_spool library">
 </A>
Any geode can work with printers, fax machines, and other print devices by including the spool library and instantiating a PrintControl object to handle system interactions. The <CODE>
PrintControlClass</CODE>
 provides the printing interface. It includes both user interface and an interface between the geode and the printing thread. There is also a <CODE>
PageSizeControlClass</CODE>
 which provides UI concerning page layout.</P>
<P>
Before reading this chapter, you should be familiar with the graphics system.

</P>
<P CLASS="sectionlinks">
<STRONG>
&nbsp;&nbsp;<A HREF="#Printing_1.htm">1 Introduction to Printing</A><BR>
&nbsp;&nbsp;<A HREF="#Printing_2.htm">2 Simple Printing Example</A><BR>
&nbsp;&nbsp;<A HREF="#Printing_3.htm">3 How Jobs Get Printed</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Printing_4.htm">3.1 Printing System Components</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Printing_5.htm">3.2 Chronology</A><BR>
&nbsp;&nbsp;<A HREF="#Printing_6.htm">4 Print Control Instance Data</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Printing_7.htm">4.1 Alerting the GenApplication</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Printing_8.htm">4.2 Attributes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Printing_9.htm">4.3 Page Range Information</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Printing_a.htm">4.4 Document Size</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Printing_b.htm">4.5 Print Output Object</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Printing_c.htm">4.6 Document Name Output</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Printing_d.htm">4.7 The Default Printer</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Printing_e.htm">4.8 Adding UI Gadgetry</A><BR>
&nbsp;&nbsp;<A HREF="#Printing_f.htm">5 Print Control Messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Printing_10.htm">5.1 Common Response Messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Printing_11.htm">5.2 Flow of Control Messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Printing_12.htm">5.3 Working with Instance Data</A><BR>
&nbsp;&nbsp;<A HREF="#Printing_13.htm">6 Page Size Control</A><BR>
&nbsp;&nbsp;<A HREF="#Printing_14.htm">7 Other Printing Components</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Printing_15.htm">7.1 Spooler and Scheduling</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Printing_16.htm">7.2 Printer Drivers</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#Printing_17.htm">7.3 Page Size Related Routines</A><BR>
&nbsp;&nbsp;<A HREF="#Printing_18.htm">8 Debugging Tips</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->

<HR>
<A NAME="Printing_1.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 1 
<A NAME="Printing_1.htm_12413">
 </A>
Introduction to Printing</H2>
<P>
By including a PrintControl object, an application gains access to the powers of the GEOS printing system. Below are several of the features built into GEOS:</P>
<UL>
<LI>
Single Imaging Model<BR>
You'll use the same commands to describe print jobs as you did for screen drawings. These commands work for all supported printers. Thus, anything you can draw can be printed, and the application doesn't have to worry about what model of printer is being used.</LI>
<LI>
Background Printing<BR>
Background printing allows users to continue working while their documents print. This is an example of multitasking at work. A process known as the Spooler spawns a separate thread for each active printer. Since each printer's thread priority is low, printing will take place in the background, interfering little with the user's interactions. If you want printing to take place in the foreground, your application can boost the priority of a printer thread.</LI>
<LI>
Standard UI Components<BR>
The PrintControl is a full-featured control object and it provides a UI mechanism for finding out what a user wants to print. For user choices which depend on the printer (for example, some printers have no low-quality mode), the PrintControl will take printer abilities into consideration. </LI>

<IMG SRC="Printing_1_pcp.gif">

</UL>
<UL>
<LI>
Control Over Scheduling<BR>
The Spooler normally handles jobs in FIFO (first in, first out) order. Geodes can exercise a great deal of control over the Spooler's scheduling of jobs. Any scheduling options the user might request using the Printer Control Panel, the application can request using spool routines. </LI>


</UL>
<UL>
<LI>
Managing the Printer Yourself<BR>
If you can't or won't use standard GEOS commands to describe a print job, you can use Raw Mode to send a packet of commands in the printer's own language. For example, you could send escape codes or commands from a page description language. Since this is a standard printing mode, you still benefit from all the usual spool scheduling features.</LI>
<LI>
Management of Multiple Printers<BR>
The user may have multiple printing devices hooked up and installed at one time. The system handles this situation intelligently: the Spooler maintains a separate queue for each serial or parallel port. Thus, if two printers are installed on two different ports, both may print at once. If two or more printers are installed on the same port then they share a queue. Thus, jobs for one printer won't try to print at the same time as those for another on the same port. To make sure the job prints to the correct printer, the Spooler will put up a dialog box advising the user to put the correct device on line.</LI>

<IMG SRC="Printing_1_mpq.gif">

</UL>
<HR>
<A NAME="Printing_2.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 2 
<A NAME="Printing_2.htm_17726">
 </A>
Simple Printing Example</H2>
<P>
Adding printing capability to an application is fairly simple, especially if it will be printing WYSIWYG. Somewhere in the application there is probably a message handler which is in charge of drawing the document. By including a Print Control object and writing handlers to some standard messages, it is a simple manner to redirect the document drawing commands to a printer.</P>
<P CLASS="figTitle">
Code Display 14-1 Printing Example</P>
<PRE>@include &lt;spool.goh&gt;
@object GenApplicationClass MyApp = {
	/* ...Much other GenApplication instance data omitted... */
	gcnList(MANUFACTURER_ID_GEOWORKS, GAGCNLT_SELF_LOAD_OPTIONS) = 
 		@MyPrintControl;
	ATTR_GEN_APPLICATION_PRINT_CONTROL = @MyPrintControl; 
}</PRE>
<PRE>@object PrintControlClass MyPrintControl = {
/* The PrintControlClass is a subclass of GenControlClass. Its &quot;features&quot;
 * correspond to the &quot;Print&quot; and &quot;Fax&quot; triggers in the File menu. Its instance
 * data contains information about the document to be printed, and links to
 * objects which will provide information. */</PRE>
<PRE>/* Single page documents would leave out page range UI from the Print dialog: 
	PCI_attrs = 		(@default &amp; ~(PCA_PAGE_CONTROLS| PCA_VERIFY_PRINT)); 
	PCI_startUserPage = 1;
	PCI_endUserPage = 1 */</PRE>
<PRE>/* The PCI_output, or Print Output object, is in charge of supplying the graphics
 * commands describing the print job whenever the user wants to print. This object
 * is expected to handle a MSG_PRINT_CONTROL_START_PRINTING. */	</PRE>
<PRE> * The print output object is normally either the model, target or process. */
	PCI_output = 		( TO_APP_TARGET ) ;</PRE>
<PRE>/* The PCI_docNameOutput object is supposed to provide the name of the document
 * on demand. This name is used to identify the document to the user in the Print
 * Control Panel. If this object is a GenDocumentGroup, it automatically does this.
 * If the object is not a GenDocumentGroup object, then * it must have a handler
 * for MSG_PRINT_GET_DOC_NAME that sends a nmae to the PrintControl via
 * MSG_PRINT_CONTROL_SET_DOC_NAME. */
	PCI_docNameOutput = MyGenDocumentGroup;</PRE>
<PRE>/* The PCI_docSize field specifies the size of the document to print (not to 
 * be confused with the size of the printer's paper). */</PRE>
<PRE>/* Many simple applications only support one document size,
 * and may specify it in the PrintControl and never bother with it again. </PRE>
<PRE> * We're setting the margins to all zero because they'll be updated via 
 * MSG_PRINT_CONTROL_GET_MARGINS. */
	PCI_docSizeInfo = {			(15/2*72), 
				(19/2*72), 
				0, 
				{0, 0, 0, 0}}; */
/* Many simple applications do not support multiple documents. These applications 
 * should set the GS_ENABLED flag of the PrintControl's GI_states field. */
}</PRE>
<PRE>@method MVTStartPrinting, MyVisTargetedClass, MSG_PRINT_START_PRINTING
/* We've set up our Print Control to send this message to the Target, so whatever
 * object will have the target when the user wants to print needs a handler for 
 * this message. We could have easily have put the Model or process in charge
 * of printing, changing PCI_output accordingly. It is often convenient to use
 * the same object to handle drawing to screen and to the printer. */</PRE>
<PRE>/* Arguments:		optr 		printControlOD,
		GStateHandle		gstate */</PRE>
<PRE>{
	PCMarginParams 	margins;</PRE>
<PRE>/*
 * 	Applications which allow the user to change the document size may handle
 *	the situation in more than one way. If the user has changed the page setup
 *	by working with a PageSizeControl, then the application has probably 
 * 	already been alerted to the page size. If the application has its own
 *	way of computing document size, it should use it. Such applications should
 * 	send MSG_PRINT_CONTROL_SET_DOC_SIZE and MSG_PRINT_CONTROL_SET_DOC_MARGINS 
 * 	to the PrintControl, either in this handler or else whenever the page size
 *	changes. Either time is fine, just so long as the document size is set
 * 	correctly by the time this MSG_PRINT_START_PRINTING handler is finished.</PRE>
<PRE> *	Applications	 supporting only a single document size should probably set
 *	the size (and margins) in the PrintControl's instance data, as shown
 *	above. It is also possible to send a MSG_PRINT_CONTROL_SET_DOC_SIZE on
 *	every print, but if the size never changes, this is a bit wasteful.</PRE>
<PRE> *	This application supports only one size of document. If the document
 *	doesn't fit on the page, the spooler will tile it onto multiple pages
 *	as necessary. It uses the printer's margins as the document margins: */</PRE>
<PRE>	@call 	MyPrintControl::MSG_PRINT_CONTROL_GET_PRINTER_MARGINS(
		&amp;margins, 		/* Fill in structure with printer's margins */
		TRUE);		/* ...and automatically use printer margins
				 * as document margins */</PRE>
<PRE>	@call 	self::MSG_VIS_DRAW(DF_PRINT, gstate);</PRE>
<PRE>	/* If the MSG_VIS_DRAW handler didn't end with a form feed, put one in: 
	GrNewPage(gstate, PEC_FORM_FEED); */</PRE>
<PRE>	@send 	MyPrintControl::MSG_PRINT_CONTROL_PRINTING_COMPLETED();
}</PRE>
<PRE>@method MVTDraw, MyVisTargetClass, MSG_VIS_DRAW
/* Chances are, whatever object this is has some sort of draw handler already.
 * However, if you're building up this class from scratch, you'll be glad to
 * know that commands of the following form work just as well drawing in
 * response to a print request as they do drawing anything else: */</PRE>
<PRE>{	GrSetLineColor(gstate, CF_INDEX, C_RED, 0, 0);
	GrDrawLine(gstate, 144, 144, 288, 288);
	GrNewPage(gstate, PEC_FORM_FEED);
}</PRE>
<HR>
<A NAME="Printing_3.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 3 
<A NAME="Printing_3.htm_42718">
 </A>
How Jobs Get Printed</H2>
<P>
You may wonder how and when these various features get implemented. Simply stated, the application describes the print job, which gets placed onto a queue where it remains until it is fed to a printer. For many programmers, that's enough to know. If you want a more complete explanation, read on.</P>
<P CLASS="subsectionLink">
<A HREF="#Printing_4.htm">Printing System Components</A></P>
<P CLASS="subsectionLink">
<A HREF="#Printing_5.htm">Chronology</A></P>
<HR>
<A NAME="Printing_4.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 3.1 <A HREF="#Printing_3.htm">How Jobs Get Printed</A>: 
<A NAME="Printing_4.htm_61572">
 </A>
Printing System Components</H3>
<P>
Printing involves the concerted effort of several objects running in different threads. The most important pieces of the printing system are</P>
<DL>
<DT>
<STRONG>
PrintControl</DT><DD>
</STRONG>
The printing system is big and would be difficult to interact with if not for the Print Control, which acts as a sort of intermediary. This object is a member of the <CODE>
PrintControlClass</CODE>
, a GenControl subclass provided by the spool library. It handles the UI, communication with the spool thread, and most other printing functions. Every geode which is going to print includes its own Print Control, placing the control object in its generic tree.</DD>
<DT>
<STRONG>
Print Output</DT><DD>
</STRONG>
The Print Output is an object (often the process object) chosen by the geode when creating the Print Control. This object is in charge of building print jobs and must be prepared to provide page descriptions whenever it receives a <CODE>
MSG_PRINT_START_PRINTING</CODE>
 from the Print Control.</DD>
<DT>
<STRONG>
Spooler</DT><DD></STRONG>
The Spooler handles most of the important &quot;behind the scenes&quot; work of printing. As mentioned, it handles the scheduling of jobs and manages the operations by which generic print jobs are translated for specific printers.</DD>
<DT>
<STRONG>
Printer Driver</DT><DD>
</STRONG>
GEOS printer drivers handle the back end of printing. GEOS has many printer drivers, each of which serves one or more models of printer. The driver supplies the Spooler with information about the printer and makes some final adjustments to the translated print job to get it ready for the specific printer.</DD>
</DL>
<HR>
<A NAME="Printing_5.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 3.2 <A HREF="#Printing_3.htm">How Jobs Get Printed</A>: 
<A NAME="Printing_5.htm_38080">
 </A>
Chronology</H3>
<P>
Now that you're somewhat familiar with these components, you're ready for the detailed account of how they work together to print a job. Note that the application is only involved at one point. The printing system takes care of the rest automatically.</P>
<OL>
<LI>
<STRONG>
User Activates Trigger<BR>
</STRONG>
Printing normally begins when the user activates the User Print Trigger provided by the Print Control. This trigger sends a message to the Print Control telling it to put up the Print Dialog box.</LI>


</OL>
<UL>
<LI FIXME_NumListOther>
<STRONG>
User Interacts with the Print Dialog Box<BR>
</STRONG>
The Print Control responds to the Print Trigger's message by presenting a dialog box in which the user selects such things as page range and print quality (see. The user then either initiates printing or cancels. If the user wants to print, he'll confirm this by clicking on the appropriate trigger. The application will then get a chance to veto the user's choices. The Print Control asks the dialog box to remove itself, and it then gets ready for the upcoming print job.</LI>
<LI FIXME_NumListOther>
<STRONG>
Print Control Prepares for New Job<BR>
</STRONG>
Soon the Print Control is going to ask for the page descriptions, but first it needs a place to store the data. It creates a spool file in which to store the upcoming graphics commands. It also allocates a GString handle by which the Print Output can transmit the commands. It then sends a message to the application's Print Output, signalling that the Print Output should supply the job. </LI>


</UL>
<UL>
<LI FIXME_NumListOther>
<STRONG>
Application Supplies Job<BR>
</STRONG>
Having received the Print Control's message, the Print Output supplies graphics routines to the provided GString handle, using the same commands as when printing to any other GState. This string of graphics commands ends with a message saying the job is completed. The Print Control supplies some extra information to the spooler, and the print job is ready to enter the queue. </LI>


</UL>
<UL>
<LI FIXME_NumListOther>
<STRONG>
Job Traverses Queue<BR>
</STRONG>
At this point, the spool library places the print job on a printer queue where the job waits to be printed. (Actually, the Spooler uses a trick to save on overhead. If there are no jobs for a printer, the Spooler doesn't maintain a queue for that printer. When a new job comes in for a printer that has no queue so far, a new queue is prepared for that printer and the job placed on the new queue. When the last job of a queue is printed and there are no more jobs forthcoming, the queue is removed.) The Spooler's various scheduling powers, if exercised, affect jobs in the queue. </LI>


</UL>
<UL>
<LI FIXME_NumListOther>
<STRONG>
Printing<BR>
</STRONG>
Eventually, the job reaches the head of the queue. It is now ready to print. The Spooler works with the Printer Driver to transform the print job into a form that the printer can work with. This may involve building a bitmap depicting the job, or it might involve translating the GString's commands into the commands of some other page description language, such as PostScript. </LI>


</UL>
<UL>
<LI FIXME_NumListOther>
<STRONG>
Hard Copy<BR>
</STRONG>
The printer driver sends the appropriate printer commands to the printer. If the printer doesn't have sufficient memory to hold the whole job, the driver sends only part of the job at a time.</LI>
</UL>
<HR>
<A NAME="Printing_6.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 4 
<A NAME="Printing_6.htm_27550">
 </A>
Print Control Instance Data</H2>
<P>
<A NAME="Printing_6.htm_IX_PrintControlClass">
 </A>
The PrintControl is a powerful and adaptable subclass of GenControl and contains many instance fields to fit the needs of different types of applications. Each field is described in greater detail later in this section; all are shown in <A HREF="#Printing_6.htm_93462"> Print Control Instance Data and Features</A>
.</P>
<P CLASS="figTitle">
Code Display 14-2 <A NAME="Printing_6.htm_93462">
 </A>
Print Control Instance Data and Features</P>
<PRE>		/* The following bitfield contains the PrintControl's attributes */
	@instance PrintControlAttrs 		PCI_attrs = 
				(PCA_COPY_CONTROLS | PCA_PAGE_CONTROLS |
				 PCA_QUALITY_CONTROLS | PCA_USES_DIALOG_BOX |
				 PCA_GRAPHICS_MODE | PCA_TEXT_MODE );
		/* Possible PCI_attrs flags (may be combined using | and &amp;):
		 * PCA_MARK_APP_BUSY, 				PCA_VERIFY_PRINT,
		 * PCA_SHOW_PROGRESS, 				PCA_PROGRESS_PERCENT, 
		 * PCA_PROGRESS_PAGE, 				PCA_FORCE_ROTATION 
		 * PCA_COPY_CONTROLS,				PCA_PAGE_CONTROLS,
		 * PCA_QUALITY_CONTROLS, 				PCA_USES_DIALOG_BOX,
		 * PCA_GRAPHICS_MODE,				PCA_TEXT_MODE 
		 * PCA_DEFAULT_QUALITY						*/</PRE>
<PRE>		/* The fields below are the complete and requested page ranges */
	@instance word 		PCI_startPage = 1;
	@instance word 		PCI_endPage = 1;
	@instance word 		PCI_startUserPage = 0;
	@instance word 		PCI_endUserPage = 0x7fff;</PRE>
<PRE>		/* The following field contains the default printer number */
	@instance word 		PCI_defPrinter = -1;</PRE>
<PRE>		/* The following fields deal with document dimensions */
	@instance PageSizeReport 		PCI_docSizeInfo = 0;</PRE>
<PRE>		/* Pointers to objects receiving vital messages */
	@instance optr 		PCI_output;
	@instance optr 		PCI_docNameOutput;</PRE>
<PRE>		/* The PrintControl's features determine whether to use standard
		 * print and fax triggers to bring up the Print Dialog box. */
<A NAME="Printing_6.htm_IX_PRINTCF_&ldots;"> </A><A NAME="IX_PrintControlFeatures"> </A>	typedef ByteFlags PrintControlFeatures;
	/* The following flags may be combined with | and &amp;:
		<A NAME="Printing_6.htm_IX_Printing:ui gadgetry"> </A>PRINTCF_PRINT_TRIGGER,
		<A NAME="Printing_6.htm_IX_Fax:ui gadgetry"> </A>PRINTCF_FAX_TRIGGER */
	/* To provide a non-standard print trigger, use the GenControl vardata
	 * field ATTR_GEN_CONTROL_APP_UI. */
	typedef ByteFlags PrintControlToolboxFeatures;
	/* The following flags may be combined with | and &amp;:
		PRINTCTF_PRINT_TRIGGER 
		PRINTCTF_FAX_TRIGGER */</PRE>
<PRE>	/* To include application-specific UI in the print dialog box. */
	@vardata optr ATTR_PRINT_CONTROL_APP_UI;</PRE>
<PRE>	/* This piece of temporary vardata is internal: */
	@vardata TempPrintCtrlInstance <A NAME="Printing_6.htm_IX_TEMP_PRINT_CONTROL_INSTANCE"> </A>TEMP_PRINT_CONTROL_INSTANCE;</PRE>
<PRE>	/* Its structures are defined as follows:
	typedef struct {
	 optr 			TPCI_currentSummons; ( currently active summons )
	 optr 			TPCI_progressBox; ( OD of progress dialog box */
	 ChunkHandle 			TPCI_jobParHandle; ( handle to JobParamters )
	 word 			TPCI_fileHandle; ( file handle (if printing) )
	 word 			TPCI_gstringHandle; ( gstring handle if printing )
	 word 			TPCI_printBlockHan; ( the printer block handle )
	 PrintControlAttrs 			TPCI_attrs;
	 PrintStatusFlags 			TPCI_status;
	 byte 			<A NAME="Printing_6.htm_IX_TPCI_&ldots;"> </A>TPCI_holdUpCompletionCount;
	} <A NAME="Printing_6.htm_IX_TempPrintCtrlInstance"> </A>TempPrintCtrlInstance;
	typedef ByteFlags <A NAME="Printing_6.htm_IX_PrintStatusFlags"> </A>PrintStatusFlags;
	#define <A NAME="Printing_6.htm_IX_PSF_&ldots;"> </A>PSF_FAX_AVAILABLE 0x80 ( set if a fax driver is available )
	#define PSF_ABORT 0x08 ( user wants to abort printing )
	#define PSF_RECEIVED_COMPLETED 0x04 ( MSG_..._PRINTING_COMPLETED received )
	#define PSF_RECEIVED_NAME 0x02 ( MSG_PC_SET_DOC_NAME received )
	#define PSF_VERIFIED 0x01 ( PSG_PC_VERIFY_? received ) */</PRE>
<PRE>	@vardata TempPrintCompletionEventData <A NAME="Printing_6.htm_IX_TEMP_PRINT_COMPLETION_EVENT"> </A>TEMP_PRINT_COMPLETION_EVENT;</PRE>
<PRE>	/* The TempPrintCompletionEventData structure is defined:
		typedef struct {
		 MemHandle 		<A NAME="Printing_6.htm_IX_TPCED_&ldots;"> </A>TPCED_event;
		 MessageFlags 		TPCED_messageFlags;
		} <A NAME="Printing_6.htm_IX_TempPrintCompletionEventData"> </A>TempPrintCompletionEventData; </PRE>
<P CLASS="subsectionLink">
<A HREF="#Printing_7.htm">Alerting the GenApplication</A></P>
<P CLASS="subsectionLink">
<A HREF="#Printing_8.htm">Attributes</A></P>
<P CLASS="subsectionLink">
<A HREF="#Printing_9.htm">Page Range Information</A></P>
<P CLASS="subsectionLink">
<A HREF="#Printing_a.htm">Document Size</A></P>
<P CLASS="subsectionLink">
<A HREF="#Printing_b.htm">Print Output Object</A></P>
<P CLASS="subsectionLink">
<A HREF="#Printing_c.htm">Document Name Output</A></P>
<P CLASS="subsectionLink">
<A HREF="#Printing_d.htm">The Default Printer</A></P>
<P CLASS="subsectionLink">
<A HREF="#Printing_e.htm">Adding UI Gadgetry</A></P>
<HR>
<A NAME="Printing_7.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 4.1 <A HREF="#Printing_6.htm">Print Control Instance Data</A>: 
<A NAME="Printing_7.htm_99453">
 </A>
Alerting the GenApplication</H3>
<P>
<A NAME="Printing_7.htm_IX_PrintControlClass:gcnList">
 </A>
PrintControl objects should be placed on the GenApplication's MANUFACTURER_ID_GEOWORKS/GAGCNLT_SELF_LOAD_OPTIONS general change notification list. Also, if the application is to allow printing of documents from the file from the file manager, then the PrintControl's optr should be specified in the GenApplication's ATTR_GEN_APPLICATION_PRINT_CONTROL<A NAME="Printing_7.htm_IX_ATTR_GEN_APPLICATION_PRINT_CONTROL">
 </A>
 field.</P>
<HR>
<A NAME="Printing_8.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 4.2 <A HREF="#Printing_6.htm">Print Control Instance Data</A>: 
<A NAME="Printing_8.htm_44034">
 </A>
Attributes</H3>
<PRE>PCI_attrs, MSG_PRINT_CONTROL_SET_ATTRS, MSG_PRINT_CONTROL_GET_ATTRS</PRE>
<P>
<A NAME="Printing_8.htm_IX_PCA_&ldots;">
 </A>
<A NAME="Printing_8.htm_IX_PrintControlAttrs">
 </A>
<A NAME="Printing_8.htm_IX_PCI_attrs">
 </A>
The Print Control includes several attributes which are grouped together into a record of type <CODE>
PrintControlAttrs</CODE>
. These represent some choices made when instantiating the Print Control.</P>
<DL>
<DT>
PCA_MARK_APP_BUSY</DT><DD>
Describing large print jobs can take a fair amount of time. If this bit is set, the application will reassure the user that it is busy (by showing the busy cursor) while spooling long print jobs.</DD>
<DT>
PCA_VERIFY_PRINT</DT><DD>
If this bit is set, the Print Control will ask the application for confirmation before printing anything. This request will come in the form of a <CODE>
MSG_PRINT_VERIFY_PRINT_REQUEST</CODE>
 sent to the <CODE>
PCI_output</CODE>
 object. The Print Control sends this message after the user has finished interacting with the Print dialog box so that the application can make sure that the user has made valid choices.</DD>
<DT>
PCA_SHOW_PROGRESS, PCA_PROGRESS_PERCENT, PCA_PROGRESS_PAGE</DT><DD>
When describing a large print job, it is considerate to let the user know when the application is making some kind of progress. If the first of these bits is set, the Print Control will display a progress dialog box when spooling a print job. The next two bits determine whether progress will be reported as a percentage, number of pages completed, both, or neither. Regardless of whether percents or page number progress is reported, the progress box can display an application-supplied string. </DD>
<DT>
PCA_FORCE_ROTATION</DT><DD>
If this bit is set, the output will automatically be printed rotated on the page. Normally, this bit is not set so the Spooler will make a choice to make the job fit on the minimum number of pages. The Banner program sets this bit to make sure that fanfold paper printers will create continuous banners; if it didn't print sideways, then users would have to use a lot of tape to put their banners together (they have to anyhow, if using non continuous-feed paper).</DD>
<DT>
PCA_COPY_CONTROLS</DT><DD>
This flag determines whether the Print Control will allow the user to request that multiple copies be printed. If your application uses this option, then it is vital that the print control be updated whenever the total page count of the document changes.</DD>
<DT>
PCA_PAGE_CONTROLS</DT><DD>
If this bit is set, the user will be allowed to select specific page ranges to print. Even if it seems like users would have little reason to print short ranges, it's still nice to include this option: if the printer messes up one page, it's usually irritating to have to reprint the whole document.</DD>
<DT>
PCA_QUALITY_CONTROLS</DT><DD>
If this flag is on, the user will be allowed to select which quality to print with. Note that not all printers can print at all qualities, but most support more than one mode.</DD>
<DT>
PCA_USES_DIALOG_BOX</DT><DD>
This bit determines whether the Print Control will display a dialog box containing printing choices for the user. Specialty geodes and GCM applications might want to turn this flag off; it is set by default.</DD>
<DT>
PCA_GRAPHICS_MODE, PCA_TEXT_MODE</DT><DD>
These bits determine whether the Control should support graphic mode and/or text mode output.</DD>
<DT>
PCA_DEFAULT_QUALITY</DT><DD>
These two bits contain the default print quality to use. The enumerated type <A NAME="Printing_8.htm_IX_PrintQualityEnum">
 </A>
<CODE>
PrintQualityEnum</CODE>
 defines the values available: <A NAME="Printing_8.htm_IX_PQT_">
 </A>
PQT_HIGH, PQT_MEDIUM, and PQT_LOW.</DD>
</DL>
<P>
Those attributes which are on by default are PCA_COPY_CONTROLS, PCA_PAGE_CONTROLS, PCA_QUALITY_CONTROLS, PCA_USES_DIALOG_BOX, PCA_GRAPHICS_OUTPUT, and PCA_TEXT_OUTPUT.</P>
<P>
There are messages to get and set these attributes.<A NAME="Printing_8.htm_marker=461055">
 </A>
</P>

<H6 CLASS="RefETitle">
<A NAME="Printing_8.htm_IX_MSG_PRINT_CONTROL_SET_ATTRS">
 </A>
MSG_PRINT_CONTROL_SET_ATTRS</H6>
<PRE CLASS="syntax">void	MSG_PRINT_CONTROL_SET_ATTRS(
        PrintControlAttrs 	attributes);</PRE>
<P>
Use this message to change the values stored in the <CODE>
PCI_attrs</CODE>
 structure. Pass a record of type <CODE>
PrintControlAttrs</CODE>
 containing the desired values.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<CODE>
attributes</CODE>
	The new <CODE>
PrintControlAttrs</CODE>
.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_8.htm_IX_MSG_PRINT_CONTROL_GET_ATTRS">
 </A>
MSG_PRINT_CONTROL_GET_ATTRS</H6>
<PRE CLASS="syntax">PrintControlAttrs 	MSG_PRINT_CONTROL_GET_ATTRS();</PRE>
<P>
Use this message to retrieve the values stored in the <CODE>
PCI_attrs</CODE>
 structure. It will return a record of type <CODE>
PrintControlAttrs</CODE>
 containing the desired values.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	The present print control attributes.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>

<HR>
<A NAME="Printing_9.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 4.3 <A HREF="#Printing_6.htm">Print Control Instance Data</A>: 
<A NAME="Printing_9.htm_68766">
 </A>
Page Range Information</H3>
<PRE>PCI_startPage, PCI_endPage, PCI_startUserPage, PCI_endUserPage, MSG_PRINT_CONTROL_SET_TOTAL_PAGE_RANGE, MSG_PRINT_CONTROL_GET_TOTAL_PAGE_RANGE, MSG_PRINT_CONTROL_SET_SELECTED_PAGE_RANGE, MSG_PRINT_CONTROL_GET_SELECTED_PAGE_RANGE</PRE>
<P>
<A NAME="Printing_9.htm_IX_PCI_endPage">
 </A>
<A NAME="Printing_9.htm_IX_PCI_startPage">
 </A>
The <CODE>
PCI_startPage</CODE>
 and <CODE>
PCI_endPage</CODE>
 fields should contain the page numbers of the first and last pages possible to print, known as the total page range. <A NAME="Printing_9.htm_IX_PCI_endUserPage">
 </A>
<A NAME="Printing_9.htm_IX_PCI_startUserPage">
 </A>
The <CODE>
PCI_startUserPage</CODE>
 and <CODE>
PCI_endUserPage</CODE>
 contain the beginning and ending page numbers of the range the user wants to print, often called the user page range. </P>
<P>
For documents whose page length may change (such as word processor documents), the page ranges should be updated whenever the Print dialog box goes up, at which time the application will be receiving a <CODE>
MSG_PRINT_NOTIFY_PRINT_DB</CODE>
. Normally, the user page range will start out being the same as the total page range. For most documents the first page of the total page range is page one, but applications which will include cover sheets might want the cover sheet to be page zero.</P>

<H6 CLASS="RefETitle">
<A NAME="Printing_9.htm_IX_MSG_PRINT_CONTROL_SET_TOTAL_PAGE_RANGE">
 </A>
MSG_PRINT_CONTROL_SET_TOTAL_PAGE_RANGE</H6>
<PRE CLASS="syntax">void	MSG_PRINT_CONTROL_SET_TOTAL_PAGE_RANGE(
        int 	firstPage,
        int	lastPage);</PRE>
<P>
The application should send this message to set the first and last page numbers of the document. You might want to send this message every time the document length changes or just every time the Print dialog box is put up. The Print Control warns the <CODE>
PCI_output</CODE>
 object of the occurrence of the latter event with a <CODE>
MSG_PRINT_NOTIFY_PRINT_DB</CODE>
. </P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<CODE>
firstPage</CODE>
	The page number of the document's first page.</P>
<DL>
<DT>
<EM>lastPage</EM> </DT><DD>The page number of the document's last page.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_9.htm_IX_MSG_PRINT_CONTROL_GET_TOTAL_PAGE_RANGE">
 </A>
MSG_PRINT_CONTROL_GET_TOTAL_PAGE_RANGE</H6>
<PRE CLASS="syntax">dword	MSG_PRINT_CONTROL_GET_TOTAL_PAGE_RANGE();</PRE>
<P>
This message returns two integers. These integers are the numbers of the first and last pages of the range of possible pages. These values aren't necessarily the first and last pages of the range the user wants to print. Use <CODE>
MSG_PRINT_CONTROL_GET_SELECTED_PAGE_RANGE</CODE>
 for that information.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	A double word. The high word is the first page; the low word is the last page.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_9.htm_IX_MSG_PRINT_CONTROL_SET_SELECTED_PAGE_RANGE">
 </A>
MSG_PRINT_CONTROL_SET_SELECTED_PAGE_RANGE</H6>
<PRE CLASS="syntax">void	MSG_PRINT_CONTROL_SET_SELECTED_PAGE_RANGE(
        int 	firstPage,
        int	lastPage);</PRE>
<P>
This message takes the passed values and uses them as the first and last pages that the user wants to print.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<CODE>
firstPage</CODE>
	The page number of the first page to print.</P>
<DL>
<DT>
<EM>lastPage</EM> </DT><DD>The page number of the last page to print.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_9.htm_IX_MSG_PRINT_CONTROL_GET_SELECTED_PAGE_RANGE">
 </A>
MSG_PRINT_CONTROL_GET_SELECTED_PAGE_RANGE</H6>
<PRE CLASS="syntax">dword	MSG_PRINT_CONTROL_GET_SELECTED_PAGE_RANGE();</PRE>
<P>
This message returns the user's selected range of pages to print. </P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	A double word. The high word is the first page which the user wishes to print; the low word is the last page of this range.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>

<HR>
<A NAME="Printing_a.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 4.4 <A HREF="#Printing_6.htm">Print Control Instance Data</A>: 
<A NAME="Printing_a.htm_65626">
 </A>
Document Size</H3>
<PRE><A NAME="Printing_a.htm_IX_PCI_docSizeInfo"> </A>PCI_docSizeInfo, MSG_PRINT_CONTROL_SET_DOC_SIZE, MSG_PRINT_CONTROL_GET_DOC_SIZE, MSG_PRINT_CONTROL_SET_DOC_MARGINS, MSG_PRINT_CONTROL_GET_DOC_MARGINS, MSG_PRINT_CONTROL_SET_EXTENDED_DOC_SIZE, MSG_PRINT_CONTROL_GET_EXTENDED_DOC_SIZE, MSG_PRINT_CONTROL_SET_DOC_SIZE_INFO, MSG_PRINT_CONTROL_GET_DOC_SIZE_INFO</PRE>
<P>
It is possible to specify the size of the document when creating the Print Control. Note that this is the size of the document, not the size of the piece of paper. Ideally, the document should fit on the paper, though obviously in the case of huge documents like some spreadsheets, this may not be the case. The document size includes the margin size; it is possible to set the margin size as well.</P>
<P>
The document size must be set correctly before the document is finished printing. If all documents the application produces have the same dimensions (or if you want some size to be the default), you may specify dimensions for the document when instantiating the print control. You may also set up document margins at this time.</P>
<P>
The messages listed above get and set the document and margin sizes. You must use <CODE>
MSG_PRINT_CONTROL_GET_EXTENDED_DOC_SIZE</CODE>
 and <CODE>
MSG_PRINT_CONTROL_SET_EXTENDED_DOC_SIZE</CODE>
 when working with the dimensions of 32-bit extended documents.</P>

<H6 CLASS="RefETitle">
<A NAME="Printing_a.htm_IX_MSG_PRINT_CONTROL_SET_DOC_SIZE">
 </A>
MSG_PRINT_CONTROL_SET_DOC_SIZE</H6>
<PRE CLASS="syntax">void	MSG_PRINT_CONTROL_SET_DOC_SIZE(
        int 	width,
        int	height);</PRE>
<P>
This message changes the values of the document size. It takes two integers, representing the new width and height for the document to use. It can only use 16-bit values, so use <CODE>
MSG_PRINT_CONTROL_SET_EXTENDED_DOC_SIZE</CODE>
 when working with 32-bit extended graphics spaces.</P>
<P>
Remember that the document size includes the document margins.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<CODE>
width</CODE>
	The document's width, in points.</P>
<DL>
<DT>
<EM>height</EM> </DT><DD>The document's height, in points.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_a.htm_IX_MSG_PRINT_CONTROL_GET_DOC_SIZE">
 </A>
MSG_PRINT_CONTROL_GET_DOC_SIZE</H6>
<PRE CLASS="syntax">dword	MSG_PRINT_CONTROL_GET_DOC_SIZE();</PRE>
<P>
Use this message to retrieve the present document size. The size is returned as a width and height, each expressed in points. </P>
<P>
Note that if the size might be a 32-bit value (which might happen if the document uses an extended graphics space), you must use the <CODE>
MSG_PRINT_CONTROL_GET_EXTENDED_DOC_SIZE</CODE>
. If either dimension is a 32-bit number, using a regular <CODE>
MSG_PRINT_CONTROL_GET_DOC_SIZE</CODE>
 will result in an error.</P>
<P>
Remember that the document size includes the document margins.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	A double word. The high word is the width, the low word is the height.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_a.htm_IX_MSG_PRINT_CONTROL_SET_EXTENDED_DOC_SIZE">
 </A>
MSG_PRINT_CONTROL_SET_EXTENDED_DOC_SIZE</H6>
<PRE CLASS="syntax">void	MSG_PRINT_CONTROL_SET_EXTENDED_DOC_SIZE(
        PCDocSizeParams 	*ptr);</PRE>
<P>
This message changes the values of the document size using the two passed double integers as the new width and height to use. When working with normal 16 bit graphics spaces, use <CODE>
MSG_PRINT_CONTROL_SET_DOC_SIZE</CODE>
 instead.</P>
<P>
Remember that the document size includes the document margins.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<EM>ptr</EM> 	Pointer to a <CODE>
PCDocSizeParams</CODE>
 structure containing the document size.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>
<P CLASS="refField">
Structures:	<A NAME="Printing_a.htm_IX_PCDSP_&ldots;">
 </A>
<A NAME="Printing_a.htm_IX_PCDocSizeParams">
 </A>
The <CODE>
PCDocSizeParams</CODE>
 structure has the following definition:</P>
<PRE>typedef struct {
	dword		PCDSP_width;
	dword		PCDSP_height;
} PCDocSizeParams;</PRE>


<H6 CLASS="RefETitle">
<A NAME="Printing_a.htm_IX_MSG_PRINT_CONTROL_GET_EXTENDED_DOC_SIZE">
 </A>
MSG_PRINT_CONTROL_GET_EXTENDED_DOC_SIZE</H6>
<PRE CLASS="syntax">void	MSG_PRINT_CONTROL_GET_EXTENDED_DOC_SIZE(
        PCDocSizeParams 	*ptr);</PRE>
<P>
Use this message to retrieve the present document size. It returns two double integers representing the width and height, expressed in points. If the size is a 16 bit value, you can use <CODE>
MSG_PRINT_CONTROL_GET_DOC_SIZE</CODE>
 instead.</P>
<P>
Remember that the document size includes the document margins.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<EM>ptr</EM> 	Pointer to a <CODE>
PCDocSizeParams</CODE>
 structure to hold document parameters.</P>
<P CLASS="refField">
Return:	Nothing is returned explicitly.</P>
<DL>
<DT>
<EM>ptr</EM> </DT><DD>The structure is filled with document size.</DD>
</DL>
<P CLASS="refField">
Interception:	Unlikely.</P>
<P CLASS="refField">
Structures:	The <CODE>
PCDocSizeParams</CODE>
 structure has the following definition:</P>
<PRE>typedef struct {
	dword		PCDSP_width;
	dword		PCDSP_height;
} PCDocSizeParams;</PRE>


<H6 CLASS="RefETitle">
<A NAME="Printing_a.htm_IX_MSG_PRINT_CONTROL_SET_DOC_MARGINS">
 </A>
MSG_PRINT_CONTROL_SET_DOC_MARGINS</H6>
<PRE CLASS="syntax">void	MSG_PRINT_CONTROL_SET_DOC_MARGINS(
        PCMarginParams 	*ptr);</PRE>
<P>
Use this message to set new values for the document margins. It takes four arguments, the point values to use for the left, top, right, and bottom margins.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<EM>ptr</EM> 	Pointer to a <CODE>
PCMarginParams </CODE>
structure with new document margins.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>
<P CLASS="refField">
Structures:	The <A NAME="Printing_a.htm_IX_PCMarginParams">
 </A>
<CODE>
PCMarginParams</CODE>
 structure has the following definition:</P>
<PRE>typedef struct {
	word		<A NAME="Printing_a.htm_IX_PCMP_&ldots;"> </A>PCMP_left;
	word		PCMP_top;
	word		PCMP_right;
	word		PCMP_bottom;
} PCMarginParams;</PRE>


<H6 CLASS="RefETitle">
<A NAME="Printing_a.htm_IX_MSG_PRINT_CONTROL_GET_DOC_MARGINS">
 </A>
MSG_PRINT_CONTROL_GET_DOC_MARGINS</H6>
<PRE CLASS="syntax">void	MSG_PRINT_CONTROL_GET_DOC_MARGINS(
        PCMarginParams 	*ptr);</PRE>
<P>
Use this message to get the present values for the document margins. It returns four integers. These integers represent the left, top, right, and bottom margins, expressed in typographer's points.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<EM>ptr</EM> 	Pointer to a <CODE>
PCMarginParams</CODE>
 structure which will hold return value.</P>
<P CLASS="refField">
Return:	Nothing returned explicitly. </P>
<DL>
<DT>
<EM>ptr</EM> </DT><DD>Structure filled in with document margins.</DD>
</DL>
<P CLASS="refField">
Interception:	Unlikely.</P>
<P CLASS="refField">
Structures:	The <CODE>
PCMarginParams</CODE>
 structure has the following definition:</P>
<PRE>typedef struct {
	word		PCMP_left;
	word		PCMP_top;
	word		PCMP_right;
	word		PCMP_bottom;
} PCMarginParams;</PRE>


<H6 CLASS="RefETitle">
<A NAME="Printing_a.htm_IX_MSG_PRINT_CONTROL_SET_DOC_SIZE_INFO">
 </A>
MSG_PRINT_CONTROL_SET_DOC_SIZE_INFO</H6>
<PRE CLASS="syntax">void	MSG_PRINT_CONTROL_SET_DOC_SIZE_INFO(
        PageSizeReport 	*ptr);</PRE>
<P>
Use this message to set all of the information about the document size and orientation.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<EM>ptr</EM> 	Pointer to a <CODE>
PageSizeReport </CODE>
structure.</P>
<P CLASS="refField">
Return:	Nothing. </P>
<P CLASS="refField">
Interception:	Unlikely.</P>
<P CLASS="refField">
Structures:	The <CODE>
PageSizeReport</CODE>
 structure has the following definition:</P>
<PRE>typedef struct {
	dword			PSR_width;
	dword			PSR_height;
	PageLayout			PSR_layout;
	PCMarginParams 			PSR_margins;
} PageSizeReport;</PRE>


<H6 CLASS="RefETitle">
<A NAME="Printing_a.htm_IX_MSG_PRINT_CONTROL_GET_DOC_SIZE_INFO">
 </A>
MSG_PRINT_CONTROL_GET_DOC_SIZE_INFO</H6>
<PRE CLASS="syntax">void	MSG_PRINT_CONTROL_GET_DOC_SIZE_INFO(
        PageSizeReport 	*ptr);</PRE>
<P>
Use this message to set all of the information about the document size and orientation.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<EM>ptr</EM> 	Pointer to an empty <CODE>
PageSizeReport </CODE>
structure which the message handler will fill in.</P>
<P CLASS="refField">
Return:	Nothing. </P>
<P CLASS="refField">
Interception:	Unlikely.</P>
<P CLASS="refField">
Structures:	The <CODE>
PageSizeReport</CODE>
 structure has the following definition:</P>
<PRE>typedef struct {
	dword			PSR_width;
	dword			PSR_height;
	PageLayout			PSR_layout;
	PCMarginParams 			PSR_margins;
} PageSizeReport;</PRE>

<HR>
<A NAME="Printing_b.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 4.5 <A HREF="#Printing_6.htm">Print Control Instance Data</A>: 
<A NAME="Printing_b.htm_40469">
 </A>
Print Output Object</H3>
<PRE>PCI_output, MSG_PRINT_START_PRINTING, MSG_PRINT_VERIFY_PRINT_REQUEST, MSG_PRINT_NOTIFY_PRINT_DB</PRE>
<P>
Some object is going to describe the print jobs to the Print Control. When instantiating the Print Control, set the chosen object's name in the <CODE>
PCI_output</CODE>
<A NAME="Printing_b.htm_IX_PCI_output">
 </A>
 field:</P>
<PRE>PCI_output = <EM>&lt;yourObject</EM>&gt;;</PRE>
<P>
There are three messages the Print Control may send to its output: <CODE>
MSG_PRINT_START_PRINTING, MSG_PRINT_VERIFY_PRINT_REQUEST, </CODE>
and<CODE>
 MSG_PRINT_NOTIFY_PRINT_DB</CODE>
. The Print Output must respond to <CODE>
MSG_PRINT_START_PRINTING</CODE>
, which is the signal that it's time to describe a print job. The Print Output also must respond to <CODE>
MSG_PRINT_VERIFY_PRINTING</CODE>
 if the PrintControl's PCA_VERIFY_PRINT bit has been set. Otherwise, it need not handle this message. Finally, the Print Output may have a handler for the <CODE>
MSG_PRINT_NOTIFY_DB</CODE>
, a message the PrintControl will send whenever the Print dialog box comes up or goes away.</P>

<H4 CLASS="HeadingC">
<A NAME="Printing_b.htm_15244">
 </A>
The Print Method</H4>
<P>
Assuming your geode doesn't try to do anything fancy with its own printing UI or weird scheduling, probably the most complicated thing you'll have to do when adding printing capability to your geode is write a Print Method.</P>
<P>
This message must be handled by the Print Output object, though the handler probably won't be too complicated. In its simplest form, a <CODE>
MSG_PRINT_START_PRINTING</CODE>
 handler could just call some graphics commands and finish off by sending <CODE>
MSG_PRINT_CONTROL_PRINTING_COMPLETED</CODE>
 to the PrintControl.</P>
<P>
The message is accompanied by a pointer back to the Print Control and a GString handle. Any graphics commands drawn to the GString handle will be retained and will become part of the print job. </P>
<P>
Before looking at examples, be warned that there are some requirements that every Print Method must meet:</P>
<UL>
<LI>
Be sure the document size has been set correctly. Before the job is finished and you send <CODE>
MSG_PRINT_CONTROL_PRINTING_COMPLETED</CODE>
, you must be certain the document's size and margins have been set somewhere. This may have been set using the <CODE>
PCI_docSizeInfo</CODE>
 field when defining the Print Control. If you haven't already let the Print Control know about the document size elsewhere, then you must send a <CODE>
MSG_PRINT_CONTROL_SET_DOC_SIZE</CODE>
, probably either in the MSG_PRINT_START_PRINTING or wherever your geode sets up document information in general.</LI>
<LI>
Be certain the number of pages to be printed has been correctly set. If your application hasn't already set the page range (when the Print Control was created or when the Print dialog box goes up are popular times for this), send a<CODE>
 MSG_PRINT_CONTROL_SET_TOTAL_PAGE_RANGE</CODE>
 to your Print Control. Make sure you do it before sending in the <CODE>
MSG_PRINT_CONTROL_PRINTING_COMPLETED</CODE>
.</LI>
<LI>
Be sure the document name has been set. If you use a GenDocumentGroup as your <CODE>
PCI_docNameOutput</CODE>
, this will be taken care of for you. Otherwise, some time before the <CODE>
MSG_PRINT_CONTROL_PRINTING_COMPLETED</CODE>
 is sent, your <CODE>
PCI_docNameOutput</CODE>
 object is going to be asked for the document name, and the job won't be spooled until your <CODE>
PCI_docNameOutput</CODE>
 sends the correct name back to the Print Control.</LI>
<LI>
The Print Method should end each page with a <CODE>
GrNewPage()</CODE>
; the last thing drawn before the print job ends is a <CODE>
GrNewPage()</CODE>
.</LI>
<LI>
Finally, when the Print Method<CODE>
 </CODE>
is finished describing the print job, it must end with a <CODE>
MSG_PRINT_CONTROL_PRINTING_COMPLETED</CODE>
. Otherwise, the Print Control has no way of knowing the job is ready.</LI>
</UL>
<P>
When the Print Control receives the message <CODE>
MSG_PRINT_CONTROL_PRINTING_COMPLETED</CODE>
, it responds by cleaning up and sending the print job to the spooler.</P>
<P>
Your handler can send a <CODE>
MSG_PRINT_CONTROL_REPORT_PROGRESS</CODE>
 to the Print Control if it is spooling a large job and wants to reassure the user. If something goes wrong, or if <CODE>
MSG_PRINT_CONTROL_REPORT_PROGRESS</CODE>
 returns a signal indicating the user wishes to cancel, <CODE>
MSG_PRINT_START_PRINTING</CODE>
 should send a <CODE>
MSG_PRINT_CONTROL_PRINTING_CANCELLED</CODE>
 instead.</P>

<H6 CLASS="RefETitle">
<A NAME="Printing_b.htm_IX_MSG_PRINT_START_PRINTING">
 </A>
MSG_PRINT_START_PRINTING</H6>
<PRE CLASS="syntax">void	MSG_PRINT_START_PRINTING(
        optr		printControlOD,
        GStateHandle		gstate);</PRE>
<P>
The handler for this message should call a number of graphics routines, using the passed GState. When done with graphics routines, the handler should send a <CODE>
MSG_PRINT_CONTROL_PRINTING_COMPLETED</CODE>
 (or <CODE>
MSG_PRINT_CONTROL_PRINTING_CANCELED</CODE>
) to the Print Control. The handler may have to accomplish other tasks; see the above bulleted list (the one marked as &quot;the most used and useful section of this chapter&quot;).</P>
<P CLASS="refField">
Source:	PrintControl object.</P>
<P CLASS="refField">
Destination:	The object specified in <CODE>
PCI_output</CODE>
.</P>
<P CLASS="refField">
Parameters:	<EM>printControlOD</EM>	The optr of the PrintControl object.</P>
<DL>
<DT>
<EM>gstate</EM> </DT><DD>The GState handle to draw to.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	The Print output object must intercept this message, build the print job by drawing to the passed GState, then send <CODE>
MSG_PRINT_CONTROL_PRINTING_COMPLETED</CODE>
 to the object in <CODE>
printControlOD</CODE>
.</P>



<H4 CLASS="HeadingC">
<A NAME="Printing_b.htm_91322">
 </A>
Verifying User Choices</H4>
<P>
You may write a handler for <CODE>
MSG_PRINT_VERIFY_PRINT_REQUEST</CODE>
, which will be sent to the Print Output if the PCA_VERIFY_PRINT bit has been set. The message will be sent after the user has dismissed the Print dialog box, after the system has had a chance to make sure the document fits on the paper but before the document is actually spooled.</P>
<P>
This message gives the application a chance to check out the state of the UI and make sure that the user's choices are valid. Note that the PrintControl does its own checking to make sure that the document will fit on the page. After examining the UI, the handler must send back a <CODE>
MSG_PRINT_CONTROL_VERIFY_COMPLETED</CODE>
, passing the argument to say whether it's okay to print.</P>

<H6 CLASS="RefETitle">
<A NAME="Printing_b.htm_IX_MSG_PRINT_VERIFY_PRINT_REQUEST">
 </A>
MSG_PRINT_VERIFY_PRINT_REQUEST</H6>
<PRE CLASS="syntax">void	MSG_PRINT_VERIFY_PRINT_REQUEST(
        optr 	printControlOD);</PRE>
<P>
The handler for this message should make whatever checks are necessary to make sure that the user has made valid choices with the printing UI. The handler should then send back an indication of whether the user's choices are all right by means of a MSG_PRINT_CONTROL_VERIFY_COMPLETED.</P>
<P CLASS="refField">
Source:	PrintControl object.</P>
<P CLASS="refField">
Destination:	The object specified in <CODE>
PCI_output</CODE>
.</P>
<P CLASS="refField">
Parameters:	<EM>printControlOD</EM>	The optr of the PrintControl object.</P>
<P CLASS="refField">
Return:	Nothing explicitly. However, the handler for this message must send a <CODE>
MSG_PRINT_CONTROL_VERIFY_COMPLETED</CODE>
 back to the print control.</P>
<P CLASS="refField">
Interception:	If you've set the PCA_VERIFY_PRINT flag, you must intercept this message correctly or else the print job will never start.</P>



<H4 CLASS="HeadingC">
<A NAME="Printing_b.htm_51301">
 </A>
Dialog Box Notification</H4>
<P>
The Print Control will send the Print Output a <CODE>
MSG_PRINT_NOTIFY_DB</CODE>
 every time the Print dialog box comes up or goes away. Note that this message allows the application to update the page range and print group's UI at only those times that updates are needed.</P>
<P>
This message will arrive with one argument, a pointer back to the PrintControl object that sent it. The handler for this message might wish to update the page range information using <CODE>
MSG_PRINT_CONTROL_SET_TOTAL_PAGE_RANGE</CODE>
 and <CODE>
MSG_PRINT_CONTROL_SET_SELECTED_PAGE_RANGE</CODE>
.</P>

<H6 CLASS="RefETitle">
<A NAME="Printing_b.htm_IX_MSG_PRINT_NOTIFY_PRINT_DB">
 </A>
MSG_PRINT_NOTIFY_PRINT_DB</H6>
<PRE CLASS="syntax">void	MSG_PRINT_NOTIFY_PRINT_DB(
        optr		printControlOD,
        PrintControlStatus		pcs);</PRE>
<P>
The handler for this message can do any almost anything; this message signals that the Print dialog box has just come up or gone away.</P>
<P CLASS="refField">
Source:	PrintControl object.</P>
<P CLASS="refField">
Destination:	The object specified in <CODE>
PCI_output</CODE>
.</P>
<P CLASS="refField">
Parameters:	<EM>printControlOD</EM>	The optr of the PrintControl object.</P>
<DL>
<DT>
<EM>pcs</EM> </DT><DD><A NAME="Printing_b.htm_IX_PCS_&ldots;  (PrintControlStatus)">
 </A>
<A NAME="Printing_b.htm_IX_PrintControlStatus">
 </A>
The status of the print control; either PCS_PRINT_BOX_VISIBLE or PCS_PRINT_BOX_NOT_VISIBLE.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Some Print Output objects will intercept this message to set page ranges.</P>


<HR>
<A NAME="Printing_c.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 4.6 <A HREF="#Printing_6.htm">Print Control Instance Data</A>: 
<A NAME="Printing_c.htm_87878">
 </A>
Document Name Output</H3>
<PRE>PCI_docNameOutput, MSG_PRINT_GET_DOC_NAME</PRE>
<P>
<A NAME="Printing_c.htm_IX_PCI_docNameOutput">
 </A>
The <CODE>
PCI_docNameOutput</CODE>
 field must contain the optr of an object which can tell the Spooler the document's name. The document name is displayed on the Printer Control Panel and is how the user can figure out which job is which on the queue. If a GenDocumentGroup is set as the Print Control's <CODE>
PCI_docNameOutput</CODE>
, then that object will automatically do the right thing. If you use some other type of object, it must be prepared to supply document names on demand. This demand will come in the form of a <CODE>
MSG_PRINT_GET_DOC_NAME</CODE>
.</P>
<P>
This message comes with a pointer back to the Print Control. The handler should respond by sending a <CODE>
MSG_PRINT_CONTROL_SET_DOC_NAME</CODE>
 with a string containing the name.</P>

<H6 CLASS="RefETitle">
<A NAME="Printing_c.htm_IX_MSG_PRINT_GET_DOC_NAME">
 </A>
MSG_PRINT_GET_DOC_NAME</H6>
<PRE CLASS="syntax">void	MSG_PRINT_GET_DOC_NAME(
        optr	printControlOD);</PRE>
<P>
If your <CODE>
PCI_docNameOutput</CODE>
 object is not a GenDocumentGroup, then it must have a handler for this message.</P>
<P CLASS="refField">
Source:	PrintControl object.</P>
<P CLASS="refField">
Destination:	The object specified in <CODE>
PCI_docNameOutput</CODE>
.</P>
<P CLASS="refField">
Parameters:	<EM>printControlOD</EM>	The optr of the PrintControl object.</P>
<P CLASS="refField">
Return:	Nothing returned explicitly, but should send a <CODE>
MSG_PRINT_CONTROL_SET_DOC_NAME</CODE>
 back to the Print Control.</P>
<P CLASS="refField">
Interception:	If receiving object is a GenDocument, unlikely. Otherwise, interception is necessary.</P>

<HR>
<A NAME="Printing_d.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 4.7 <A HREF="#Printing_6.htm">Print Control Instance Data</A>: 
<A NAME="Printing_d.htm_93282">
 </A>
The Default Printer</H3>
<PRE>PCI_defPrinter, MSG_PRINT_CONTROL_SET_DEFAULT_PRINTER, MSG_PRINT_CONTROL_GET_DEFAULT_PRINTER</PRE>
<P>
<A NAME="Printing_d.htm_IX_PCI_defPrinter">
 </A>
As this documentation has already stressed, one of the printing system's more important features is that it is device independent. However, certain special-purpose applications could conceivably depend on the user's printer type, and those applications may have use for the Print Control's <CODE>
PCI_defPrinter</CODE>
 field. When the Print Control first appears, it will normally have the system default printer selected. Using the <CODE>
PCI_defPrinter</CODE>
 option, another printer might be selected. The user may of course override the default printer and select another.

</P>
<P>
You can set or retrieve the value in <CODE>
PCI_defPrinter</CODE>
 with the messages listed above. For information on them, see <A HREF="#Printing_12.htm_14540"> Working with Instance Data</A>
.</P>
<P>
There are utility routines to get information about the system default printer. There are commands to retrieve information about each of the installed printers so that the application may find out whether the desired type of printer is installed and, if so, what its printer number is. These routines are described in <A HREF="#Printing_16.htm_71198"> Printer Information and Manipulation</A>
.</P>
<HR>
<A NAME="Printing_e.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 4.8 <A HREF="#Printing_6.htm">Print Control Instance Data</A>: 
<A NAME="Printing_e.htm_24809">
 </A>
Adding UI Gadgetry</H3>
<PRE>ATTR_PRINT_CONTROL_APP_UI</PRE>
<P>
If the Print Control supplies UI that meets your geode's needs, feel free to skip this section. On the other hand, if you've decided you want a non-standard print trigger or want some specialized gadgetry to appear in the application's Print dialog box, it is possible to create objects and tell the Print Control to work with them. Make sure that any objects you want to use in this fashion aren't part of a generic or visual tree already. Also, these objects must be set not usable (~<CODE>
GS_USABLE).</CODE>


</P>
<P>
Normally the user has two ways to print up a Print dialog box: the User Print Trigger or the User Fax Trigger, both appearing in the File menu. You may specify a special trigger to be used in place of the standard trigger provided by the Print Control. Normally the default trigger is not only sufficient but preferable, if only because it will automatically display with the correct appearance for the specific UI. To define your own trigger object, create the object(s), setting the correct instance data. Then, when instantiating your Print Control, include an ATTR_GEN_CONTROL_APP_UI:</P>
<PRE>ATTR_GEN_CONTROL_APP_UI = {<EM>yourTrigger</EM>};</PRE>
<P>
When this option is used at all, normally the trigger object is a simple trigger. The action descriptor of this application-defined trigger should be</P>
<PRE>GTI_output = <EM>&lt;your_PrintControl</EM>&gt;;
GTI_method = MSG_PRINT_CONTROL_INITIATE_PRINT;</PRE>
<P>
By working with the control's features, you may remove either or both of the default triggers.</P>
<P>
<A NAME="Printing_e.htm_IX_ATTR_PRINT_CONTROL_APP_UI">
 </A>
The Print Control's vardata field ATTR_PRINT_CONTROL_APP_UI allows application-specific gadgetry to appear in the Print dialog box. Create the object(s) to be included and set their instance data, then use the ATTR_PRINT_CONTROL_APP_UI field to signal that the Print Control should include the gadgetry. </P>
<PRE>ATTR_PRINT_CONTROL_APP_UI = {<EM>yourPrintGroup</EM>};</PRE>
<P>
When this option is used at all, usually a GenInteraction serves as the print group object, with children appropriate to the task at hand. This generic tree must not be destroyed unless the vardata field has been removed.</P>
<HR>
<A NAME="Printing_f.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 5 
<A NAME="Printing_f.htm_76848">
 </A>
Print Control Messages</H2>
<P>
Now you have a rather good idea of what's required to set up a Print Control. Once it's been set up, your geode may send the following messages to it.</P>
<P CLASS="subsectionLink">
<A HREF="#Printing_10.htm">Common Response Messages</A></P>
<P CLASS="subsectionLink">
<A HREF="#Printing_11.htm">Flow of Control Messages</A></P>
<P CLASS="subsectionLink">
<A HREF="#Printing_12.htm">Working with Instance Data</A></P>
<HR>
<A NAME="Printing_10.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 5.1 <A HREF="#Printing_f.htm">Print Control Messages</A>: 
<A NAME="Printing_10.htm_83936">
 </A>
Common Response Messages</H3>
<PRE>MSG_PRINT_CONTROL_VERIFY_COMPLETED, MSG_PRINT_CONTROL_SET_DOC_NAME</PRE>
<P>
These messages are normally used only to respond to messages sent out by the Print Control.</P>

<H6 CLASS="RefETitle">
<A NAME="Printing_10.htm_IX_MSG_PRINT_CONTROL_VERIFY_COMPLETED">
 </A>
MSG_PRINT_CONTROL_VERIFY_COMPLETED</H6>
<PRE CLASS="syntax">void	MSG_PRINT_CONTROL_VERIFY_COMPLETED(
        Boolean 	continue);</PRE>
<P>
If you have decided to verify the user's Print dialog box choices, you must send this message back to the Print Control in response to <CODE>
MSG_PRINT_VERIFY_PRINT_REQUEST</CODE>
. If <EM>
true</EM>
 is passed, the Print Control will continue preparing the job for printing. If the value passed is <EM>
false</EM>
, the print will be cancelled. It is up to the application to explain the problem to the user.</P>
<P CLASS="refField">
Source:	Unrestricted, normally the <CODE>
PCI_output</CODE>
 object.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<EM>continue</EM>	Flag signalling whether printing should continue or be cancelled.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_10.htm_IX_MSG_PRINT_CONTROL_SET_DOC_NAME">
 </A>
MSG_PRINT_CONTROL_SET_DOC_NAME</H6>
<PRE CLASS="syntax">void	MSG_PRINT_CONTROL_SET_DOC_NAME(
        char	* string);</PRE>
<P>
This message must be sent by the <CODE>
PCI_docNameOutput</CODE>
 before the print job can be spooled. It is sent in response to a <CODE>
MSG_PRINT_GET_DOC_NAME</CODE>
 from the Print Control. The <EM>string</EM> argument should be something that will allow the user to recognize the print job in the Printer Control Panel.</P>
<P CLASS="refField">
Source:	Unrestricted--normally the <CODE>
PCI_docNameOutput</CODE>
 object.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<EM>string</EM>	The document's name, as a null-terminated string. Maximum length of this string is FILE_LONGNAME_LENGTH+1.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>

<HR>
<A NAME="Printing_11.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 5.2 <A HREF="#Printing_f.htm">Print Control Messages</A>: 
<A NAME="Printing_11.htm_88534">
 </A>
Flow of Control Messages</H3>
<PRE>MSG_PRINT_CONTROL_PRINTING_COMPLETED, MSG_PRINT_CONTROL_REPORT_PROGRESS, MSG_PRINT_CONTROL_PRINTING_CANCELLED, MSG_PRINT_CONTROL_REPORT_STRING, MSG_PRINT_CONTROL_INITIATE_PRINT, MSG_PRINT_CONTROL_PRINT, MSG_PRINT_CONTROL_INITIATE_OUTPUT_UI</PRE>
<P>
Sending these messages to the Print Control signals that a new stage of printing is ready to begin.</P>

<H6 CLASS="RefETitle">
<A NAME="Printing_11.htm_IX_MSG_PRINT_CONTROL_PRINTING_COMPLETED">
 </A>
MSG_PRINT_CONTROL_PRINTING_COMPLETED</H6>
<PRE CLASS="syntax">void	MSG_PRINT_CONTROL_PRINTING_COMPLETED();</PRE>
<P>
This message signals the Print Control that the application is finished describing the print job. The application must send this message (or a <CODE>
MSG_PRINT_CONTROL_PRINTING_CANCELLED</CODE>
) some time after receiving a <CODE>
MSG_PRINT_START_PRINTING</CODE>
.</P>
<P CLASS="refField">
Source:	The object that received <CODE>
MGS_PRINT_START_PRINTING</CODE>
.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely, unadvised.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_11.htm_IX_MSG_PRINT_CONTROL_REPORT_PROGRESS">
 </A>
MSG_PRINT_CONTROL_REPORT_PROGRESS</H6>
<PRE CLASS="syntax">Boolean	MSG_PRINT_CONTROL_REPORT_PROGRESS(
        PCProgressType 	progress,
        int 	pageOrPercent);</PRE>
<P>
This message may be sent between the time the Print Output receives a <CODE>
MSG_PRINT_START_PRINTING</CODE>
 and the time it sends a <CODE>
MSG_PRINT_CONTROL_PRINTING_COMPLETED</CODE>
. Its arguments include a progress type (page number or percentage) and a number representing the progress. It returns a Boolean value, which will normally be <EM>
true</EM>
 but will be <EM>
false</EM>
 if the user wishes to cancel printing.</P>
<P>
The application should send out this message periodically over the course of a long print job, probably about once per page. Progress may be reported as a page number, a percentage of the job completed, or as a null-terminated string. </P>
<P>
If the return value is <EM>
false</EM>
, the application should stop drawing to the print GString immediately and send the Print Control a <CODE>
MSG_PRINT_CONTROL_PRINTING_CANCELLED</CODE>
. The return value may be safely ignored, but if the user wishes to cancel printing, it's polite to cancel immediately instead of making him wait until the MSG_PRINT_START_PRINTING has finished describing the entire job.</P>
<P CLASS="refField">
Source:	The object that received <CODE>
MGS_PRINT_START_PRINTING</CODE>
 when building a time-consuming job.</P>
<P CLASS="refField">
Destination:	The PrintControl object specified by <CODE>
MSG_PRINT_START_PRINTING</CODE>
.</P>
<P CLASS="refField">
Parameters:	<EM>progress</EM> 	How progress is being reported, by page (PCPT_PAGE) or percent (PCPT_PERCENT).</P>
<DL>
<DT>
<EM>pageOrPercent</EM></DT><DD>How much progress has been made.</DD>
</DL>
<P CLASS="refField">
Return:	Flag signalling that printing should continue. If the flag is <EM>
false</EM>
 (i.e. zero), then the user wants to cancel printing, and it would be polite to stop.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>
<P CLASS="refField">
Structures:	The <A NAME="Printing_11.htm_IX_PCProgressType">
 </A>
<CODE>
PCProgressType</CODE>
 enumeration is defined:</P>
<PRE><A NAME="Printing_11.htm_IX_PCPT_&ldots;"> </A>typedef enum {
 PCPT_PAGE,
 PCPT_UNUSED1, /* Unused type */
 PCPT_PERCENT,
 PCPT_UNUSED2, /* Unused type */
 PCPT_TEXT
} PCProgressType;</PRE>


<H6 CLASS="RefETitle">
<A NAME="Printing_11.htm_IX_MSG_PRINT_CONTROL_REPORT_PROGRESS_STRING">
 </A>
MSG_PRINT_CONTROL_REPORT_PROGRESS_STRING</H6>
<PRE CLASS="syntax">@alias(MSG_PRINT_CONTROL_REPORT_PROGRESS) \ 
Boolean	MSG_PRINT_CONTROL_REPORT_PROGRESS_STRING(
        PCProgressType 	progress,
        Chars 	*progressString);</PRE>
<P>
This message may be sent between the time the Print Output receives a <CODE>
MSG_PRINT_START_PRINTING</CODE>
 and the time it sends a <CODE>
MSG_PRINT_CONTROL_PRINTING_COMPLETED</CODE>
. Its arguments include a text string giving some indication of progress. This message returns a Boolean value, which will normally be <EM>
true</EM>
 but will be <EM>
false</EM>
 if the user wishes to cancel printing.</P>
<P>
The application should send out this message periodically over the course of a long print job, probably about once per page. Progress may be reported as a page number, a percentage of the job completed, or as a null-terminated string. </P>
<P>
If the return value is <EM>
false</EM>
, the application should stop drawing to the print GString immediately and send the Print Control a <CODE>
MSG_PRINT_CONTROL_PRINTING_CANCELLED</CODE>
. The return value may be safely ignored, but if the user wishes to cancel printing, it's polite to cancel immediately instead of making him wait until the MSG_PRINT_START_PRINTING has finished describing the entire job.</P>
<P CLASS="refField">
Source:	The object that received <CODE>
MGS_PRINT_START_PRINTING</CODE>
 when building a time-consuming job.</P>
<P CLASS="refField">
Destination:	The PrintControl object specified by <CODE>
MSG_PRINT_START_PRINTING</CODE>
.</P>
<P CLASS="refField">
Parameters:	<EM>progress</EM> 	This must be PCPT_TEXT. The reason that this parameter has only one possible value is that this message is actually an alias of <CODE>
MSG_PRINT_CONTROL_REPORT_PROGRESS</CODE>
, handled by the same assembly routine.</P>
<DL>
<DT>
<EM>progressString</EM></DT><DD>A string of text, giving an indication of progress.</DD>
</DL>
<P CLASS="refField">
Return:	Flag signalling that printing should continue. If the flag is <EM>
false</EM>
 (i.e. zero), then the user wants to cancel printing, and it would be polite to stop.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>
<P CLASS="refField">
Structures:	The <CODE>
PCProgressType</CODE>
 enumeration is defined:</P>
<PRE>typedef enum {
 PCPT_PAGE,
 PCPT_UNUSED1, /* Unused type */
 PCPT_PERCENT,
 PCPT_UNUSED2, /* Unused type */
 PCPT_TEXT
} PCProgressType;</PRE>


<H6 CLASS="RefETitle">
<A NAME="Printing_11.htm_IX_MSG_PRINT_CONTROL_INITIATE_OUTPUT_UI">
 </A>
MSG_PRINT_CONTROL_INITIATE_OUTPUT_UI</H6>
<PRE CLASS="syntax">void MSG_PRINT_CONTROL_INITIATE_OUTPUT_UI(
        PrinterDriverType type);</PRE>
<P>
Display the output dialog box.</P>
<P CLASS="refField">
Source:	Anything.</P>
<P CLASS="refField">
Destination:	PrintControl object.</P>
<P CLASS="refField">
Parameters:	<EM>
type</EM>
	PrinterDriverType value specifying what sort of printer device.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Rare. This messages is generally used internally only, as the PrintControl normally provides all the UI neededfor printing.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_11.htm_IX_MSG_PRINT_CONTROL_PRINTING_CANCELLED">
 </A>
MSG_PRINT_CONTROL_PRINTING_CANCELLED</H6>
<PRE CLASS="syntax">void	MSG_PRINT_CONTROL_PRINTING_CANCELLED();</PRE>
<P>
The application may send this message to the PrintControl after receiving a <CODE>
MSG_PRINT_START_PRINTING</CODE>
. Do not send both this message and a <CODE>
MSG_PRINT_CONTROL_PRINTING_COMPLETED</CODE>
 for a single print job.</P>
<P>
The application may send this message to cancel a document while describing a print job, before it would send the <CODE>
MSG_PRINT_CONTROL_PRINTING_COMPLETED</CODE>
.</P>
<P CLASS="refField">
Source:	Unrestricted, probably the <CODE>
PCI_output</CODE>
. </P>
<P CLASS="refField">
Destination:	The PrintControl object specified by <CODE>
MSG_PRINT_START_PRINTING</CODE>
.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_11.htm_IX_MSG_PRINT_CONTROL_INITIATE_PRINT">
 </A>
MSG_PRINT_CONTROL_INITIATE_PRINT</H6>
<PRE CLASS="syntax">void	MSG_PRINT_CONTROL_INITIATE_PRINT();</PRE>
<P>
This message, normally sent by the Print trigger in the File menu, is the signal that the Print Control should display the Print dialog box. Geodes with custom print triggers should make sure that those triggers send this message to the Print Control. Geodes using the Print Control's provided print trigger need not send this message.</P>
<P CLASS="refField">
Source:	Unrestricted--typically the user print trigger (or fax trigger).</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_11.htm_IX_MSG_PRINT_CONTROL_PRINT">
 </A>
MSG_PRINT_CONTROL_PRINT</H6>
<PRE CLASS="syntax">void	MSG_PRINT_CONTROL_PRINT();</PRE>
<P>
This message, normally sent by the Print trigger in the Print dialog box, is the signal that the user has made his printing choices and is ready for the Print Control to verify those choices and spool the job. </P>
<P CLASS="refField">
Source:	Unrestricted--typically the Print trigger in the Print Dialog Box.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>

<HR>
<A NAME="Printing_12.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 5.3 <A HREF="#Printing_f.htm">Print Control Messages</A>: 
<A NAME="Printing_12.htm_14540">
 </A>
Working with Instance Data</H3>
<PRE>MSG_PRINT_CONTROL_SET_OUTPUT, MSG_PRINT_CONTROL_GET_OUTPUT, MSG_PRINT_CONTROL_SET_DOC_NAME_OUTPUT, MSG_PRINT_CONTROL_GET_DOC_NAME_OUTPUT, MSG_PRINT_CONTROL_SET_DEFAULT_PRINTER, MSG_PRINT_CONTROL_GET_DEFAULT_PRINTER, MSG_PRINT_CONTROL_GET_PRINT_MODE, MSG_PRINT_CONTROL_GET_PAPER_SIZE, MSG_PRINT_CONTROL_GET_PRINTER_MARGINS, MSG_PRINT_CONTROL_CALC_DOC_DIMENSIONS, MSG_PRINT_CONTROL_VERIFY_DOC_MARGINS, MSG_PRINT_CONTROL_VERIFY_DOC_SIZE</PRE>
<P>
The Print Control handles many messages which allow the geode to retrieve and alter the values of the instance data.</P>

<H6 CLASS="RefETitle">
<A NAME="Printing_12.htm_IX_MSG_PRINT_CONTROL_SET_OUTPUT">
 </A>
MSG_PRINT_CONTROL_SET_OUTPUT</H6>
<PRE CLASS="syntax">void 	MSG_PRINT_CONTROL_SET_OUTPUT(
        optr 	objectPtr);</PRE>
<P>
This message, used very rarely, specifies that a different object should become the Print Output. Pass the optr of the object to use.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<EM>objectPtr</EM> 	The optr of the new <CODE>
PCI_output</CODE>
.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_12.htm_IX_MSG_PRINT_CONTROL_GET_OUTPUT">
 </A>
MSG_PRINT_CONTROL_GET_OUTPUT</H6>
<PRE CLASS="syntax">optr 	MSG_PRINT_CONTROL_GET_OUTPUT();</PRE>
<P>
This message returns the optr of the Print Output.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	The optr of the current <CODE>
PCI_output</CODE>
 object.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_12.htm_IX_MSG_PRINT_CONTROL_SET_DOC_NAME_OUTPUT">
 </A>
MSG_PRINT_CONTROL_SET_DOC_NAME_OUTPUT</H6>
<PRE CLASS="syntax">void 	MSG_PRINT_CONTROL_SET_DOC_NAME_OUTPUT(
        optr 	document);</PRE>
<P>
This message, used very rarely, specifies that a different object should become the Document Name Output object. Pass the optr of the object to use.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<EM>objectPtr</EM> 	The optr of the new <CODE>
PCI_docNameOutput</CODE>
.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_12.htm_IX_MSG_PRINT_CONTROL_GET_DOC_NAME_OUTPUT">
 </A>
MSG_PRINT_CONTROL_GET_DOC_NAME_OUTPUT</H6>
<PRE CLASS="syntax">optr 	MSG_PRINT_CONTROL_GET_DOC_NAME_OUTPUT();</PRE>
<P>
This message returns the optr of the Document Name Output object.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	The optr of the Document Name output object.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_12.htm_IX_MSG_PRINT_CONTROL_SET_DEFAULT_PRINTER">
 </A>
MSG_PRINT_CONTROL_SET_DEFAULT_PRINTER</H6>
<PRE CLASS="syntax">void 	MSG_PRINT_CONTROL_SET_DEFAULT_PRINTER(
        int 	printerNum);		/* -1 for system's default printer */</PRE>
<P>
This message sets the application default printer, to be used the next time the print dialog box appears. Pass the printer number of the printer to use. Passing a value of -1 means that the system default printer should be used.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<EM>printerNum</EM>	Number of the new default printer.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_12.htm_IX_MSG_PRINT_CONTROL_GET_DEFAULT_PRINTER">
 </A>
MSG_PRINT_CONTROL_GET_DEFAULT_PRINTER</H6>
<PRE CLASS="syntax">int 	MSG_PRINT_CONTROL_GET_DEFAULT_PRINTER();</PRE>
<P>
Use this message to retrieve the number of the present application default printer. You may not assume that this printer is the one the user is printing on, since the user may have changed to another printer. A return value of -1 means that the application will use the system default printer.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	The number of the default printer.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_12.htm_IX_MSG_PRINT_CONTROL_GET_PRINT_MODE">
 </A>
MSG_PRINT_CONTROL_GET_PRINT_MODE</H6>
<PRE CLASS="syntax">byte 	MSG_PRINT_CONTROL_GET_PRINT_MODE(); </PRE>
<P>
This message retrieves the current user-selected print mode, if any. Its possible return values include zero, meaning no mode has been selected; PM_GRAPHICS_LOW_RES; PM_GRAPHICS_MED_RES; PM_GRAPHICS_HI_RES; PM_TEXT_DRAFT; and PM_TEXT_NLQ.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	None.</P>
<P CLASS="refField">
Return:	A <CODE>
PrinterOutputModes</CODE>
 signalling the printer's quality.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>
<P CLASS="refField">
Structures:	The <A NAME="Printing_12.htm_IX_PrinterOutputModes">
 </A>
<CODE>
PrinterOutputModes</CODE>
 structure has the following definition:</P>
<PRE>typedef ByteFlags PrinterOutputModes;</PRE>
<PRE>#define <A NAME="Printing_12.htm_IX_POM_&ldots;"> </A>POM_GRAPHICS_LOW 0x10 
#define POM_GRAPHICS_MEDIUM 0x08 
#define POM_GRAPHICS_HIGH 0x04
#define POM_TEXT_DRAFT 0x02 
#define POM_TEXT_NLQ 0x01</PRE>
<P>
Each flag indicates the specified quality is available. Two useful masks which have been set up are PRINT_GRAPHICS and <A NAME="Printing_12.htm_IX_PRINT_&ldots;">
 </A>
PRINT_TEXT.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_12.htm_IX_MSG_PRINT_CONTROL_GET_PAPER_SIZE">
 </A>
MSG_PRINT_CONTROL_GET_PAPER_SIZE</H6>
<PRE CLASS="syntax">void 	MSG_PRINT_CONTROL_GET_PAPER_SIZE(
        PCMargineParams 		*retVal); </PRE>
<P>
Use this message to retrieve the Print Control's present paper size.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<EM>
retVal</EM>
	An empty <CODE>
PCMarginParams</CODE>
 structure which the message handler will fill.</P>
<P CLASS="refField">
Return:	Nothing returned explicitly; the <EM>
retVal</EM>
 structure will be filled.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_12.htm_IX_MSG_PRINT_CONTROL_GET_PAPER_SIZE_INFO">
 </A>
MSG_PRINT_CONTROL_GET_PAPER_SIZE_INFO</H6>
<PRE CLASS="syntax">void	MSG_PRINT_CONTROL_GET_PAPER_SIZE_INFO(
        PageSizeReport 	*ptr);</PRE>
<P>
Use this message to retrieve all of the information about the document size and orientation.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<EM>ptr</EM> 	Pointer to an empty <CODE>
PageSizeReport </CODE>
structure which the message handler will fill in.</P>
<P CLASS="refField">
Return:	Nothing. </P>
<P CLASS="refField">
Interception:	Unlikely.</P>
<P CLASS="refField">
Structures:	The <CODE>
PageSizeReport</CODE>
 structure has the following definition:</P>
<PRE>typedef struct {
	dword			PSR_width;
	dword			PSR_height;
	PageLayout			PSR_layout;
	PCMarginParams 			PSR_margins;
} PageSizeReport;</PRE>


<H6 CLASS="RefETitle">
<A NAME="Printing_12.htm_IX_MSG_PRINT_CONTROL_GET_PRINTER_MARGINS">
 </A>
MSG_PRINT_CONTROL_GET_PRINTER_MARGINS</H6>
<PRE CLASS="syntax">void 	MSG_PRINT_CONTROL_GET_PRINTER_MARGINS(
        MarginDimensions 		*retVal,
        Boolean 		setMargins); </PRE>
<P>
This message returns the margins enforced by the requested printer. If the boolean argument is <EM>
true</EM>
, the document margins will be set to be the same as the printer margins.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<CODE>
setMargins</CODE>
	Pass TRUE to set the document's margins equal to the printer's margins, FALSE to leave the margins as they are.</P>
<DL>
<DT>
<CODE>
retVal</CODE>
</DT><DD>A pointer to an empty <CODE>
MarginDimensions</CODE>
 structure to be filled in by the handler.</DD>
</DL>
<P CLASS="refField">
Return:	The printer's enforced margins.</P>
<P CLASS="refField">
Structures:	The following structure keeps track of all four of a document's margins.</P>
<PRE><A NAME="Printing_12.htm_IX_MarginDimensions"> </A>typedef struct {
	int 	leftMargin;		/* measured in points */
	int 	topMargin;
	int 	rightMargin;
	int 	bottomMargin;
} MarginDimensions;</PRE>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_12.htm_IX_MSG_PRINT_CONTROL_CALC_DOC_DIMENSIONS">
 </A>
MSG_PRINT_CONTROL_CALC_DOC_DIMENSIONS</H6>
<PRE CLASS="syntax">void 	MSG_PRINT_CONTROL_CALC_DOC_DIMENSIONS(
        PageSizeReport 	*ptr); </PRE>
<P>
This message calculates the maximum printable area allowed by the user-selected paper size and printer-mandated margins. This message automatically resets the document size and margins to hold these values.</P>
<P>
Note that this message correctly handles rotated pages.</P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<EM>ptr</EM>	A pointer to a <CODE>
PageSizeReport </CODE>
structure to hold return value.</P>
<P CLASS="refField">
Return:	Nothing returned explicitly.</P>
<DL>
<DT>
<EM>ptr</EM></DT><DD>The pointer to the filled <CODE>
PageSizeReport </CODE>
structure.</DD>
</DL>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_12.htm_IX_MSG_PRINT_CONTROL_CHECK_IF_DOC_WILL_FIT">
 </A>
MSG_PRINT_CONTROL_CHECK_IF_DOC_WILL_FIT</H6>
<PRE CLASS="syntax">Boolean 	MSG_PRINT_CONTROL_CHECK_IF_DOC_WILL_FIT(
        Boolean 	warning); </PRE>
<P>
This message returns <EM>
true</EM>
 if the passed document margins will fit on the selected printer. </P>
<P CLASS="refField">
Source:	Unrestricted.</P>
<P CLASS="refField">
Destination:	Any PrintControl object.</P>
<P CLASS="refField">
Parameters:	<EM>warning</EM> 	If set, the PrintControl will deliver a warning to the user.</P>
<P CLASS="refField">
Return:	Indication of whether the printer can work with the current margins (<CODE>
true</CODE>
 if so, <CODE>
false</CODE>
 if not).</P>
<P CLASS="refField">
Interception:	Unlikely.<A NAME="Printing_12.htm_marker=461127">
 </A>
</P>

<HR>
<A NAME="Printing_13.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 6 
<A NAME="Printing_13.htm_69555">
 </A>
Page Size Control</H2>
<PRE>MSG_PRINT_REPORT_PAGE_SIZE, SpoolSetDocSize(), MSG_PZC_GET_PAGE_SIZE, MSG_PZC_SET_PAGE_SIZE, </PRE>
<P>
<A NAME="Printing_13.htm_IX_PageSizeControlClass">
 </A>
Thanks to the Spooler, applications don't need to worry about what page size the user is working with. If a document is bigger than a printer's paper, then the Spooler will automatically tile the job onto as may sheets of paper as necessary. However, some applications will need to make the user decide on a page size. Page layout programs need to know what size page the user is working with. Spreadsheet programs need to make sure that cells aren't split in half by a page break.</P>
<P>
Applications which ask the user to select a page size should incorporate a PageSizeControl into their generic tree. This generic control object provides a dialog box containing page setup choices for the user.</P>
<P>
This dialog box contains UI allowing the user to specify what sort of paper the document is to be printed to: envelope, labels, or regular paper. The user may then specify a set of dimensions within that type; paper would have choices including letter sized, legal sized, and A4. The user can even set up a set of custom page dimensions.</P>
<P>
<A NAME="Printing_13.htm_IX_SpoolSetDocSize()">
 </A>
Most applications which include a PageSizeControl will probably keep track of their own page size. In this case, use <CODE>
SpoolSetDocSize()</CODE>
 to update the PageSizeControl's UI when changing the page size. When the user changes the paper size in the PageSizeControl, the control's output will receive a <CODE>
MSG_PRINT_REPORT_PAGE_SIZE</CODE>
.</P>
<P>
Applications which do not keep track of the page size but want to include a PageSizeControl may do so. However, these applications will probably need to find out the page size at a specific time, not just receive notification every time the user changes the page size. This doesn't really fit the normal controller model, and in fact such applications are asking the PageSizeControl to act not like a controller, but like an ordinary piece of UI gadgetry. Setting the PZCA_ACT_LIKE_GADGET flag in the PageSizeControl's <CODE>
PZCI_attrs</CODE>
 instance field will make the PageSizeControl act like a gadget.</P>
<P>
If the PageSizeControl is to act as a controller, it must appear on the GenApplication's GAGCNLT_SELF_LOAD_OPTIONS GCN list, as does the PrintControl.</P>
<P>
No matter how an application interacts with its PageSizeControl, it will work with the <CODE>
PageSizeReport</CODE>
 structure.</P>
<PRE><A NAME="Printing_13.htm_IX_PSR_&ldots;"> </A><A NAME="IX_PageSizeReport"> </A>typedef struct {
	dword 			PSR_width;
	dword 			PSR_height;
	PageLayout 			PSR_layout;
	PCMarginParams 			PSR_margins;
} PageSizeReport;</PRE>
<PRE><A NAME="Printing_13.htm_IX_PageLayout"> </A>typedef WordFlags PageLayout;
<A NAME="Printing_13.htm_IX_PT_&ldots;  (PageType type)"> </A><A NAME="IX_PageType"> </A>typedef enum {
	PT_PAPER,
	PT_UNUSED1, /* Unused type */
	PT_ENVELOPE,
	PT_UNUSED2, /* Unused type */
	PT_LABEL
} PageType;</PRE>
<PRE>/* Specifying a PageLayout is accomplished by 
 * OR-ing together the parts of the layout.
 * Exactly what those parts are depends on the 
 * PageType: */</PRE>
<PRE>/* Paper Layouts: 
 * 	(PT_PAPER | (PO_<EM>orient</EM> &lt;&lt; 3) ) */
<A NAME="Printing_13.htm_IX_PO_&ldots;"> </A><A NAME="IX_PaperOrientation"> </A>typedef ByteEnum 				PaperOrientation;
#define PO_PORTRAIT 					0x00
#define PO_LANDSCAPE 					0x01</PRE>
<PRE><A NAME="Printing_13.htm_IX_PLP_&ldots;"> </A><A NAME="IX_PageLayoutPapers"> </A>typedef WordFlags 				PageLayoutPaper;
#define PLP_ORIENTATION 					0x0008
#define PLP_TYPE 					0x0004 /* PT_PAPER */</PRE>
<PRE>/* Envelope Layouts: 
 * (PT_ENVELOPE | (EP_<EM>path</EM> &lt;&lt; 5) | (EO_<EM>ori</EM> &lt;&lt; 3)) */
<A NAME="Printing_13.htm_IX_EP_&ldots;"> </A><A NAME="IX_EnvelopePath"> </A>typedef ByteEnum 				EnvelopePath;
#define EP_LEFT 					0x00
#define EP_CENTER 					0x01
#define EP_RIGHT 					0x02</PRE>
<PRE><A NAME="Printing_13.htm_IX_EO_&ldots;"> </A><A NAME="IX_EnvelopeOrientation"> </A>typedef ByteEnum 				EnvelopeOrientation;
#define EO_PORTAIT_LEFT 					0x00
#define EO_PORTAIT_RIGHT 					0x01
#define EO_LANDSCAPE_UP 					0x02
#define EO_LANDSCAPE_DOWN 					0x03</PRE>
<PRE><A NAME="Printing_13.htm_IX_PLE_&ldots;"> </A><A NAME="IX_PageLayoutEnvelope"> </A>typedef WordFlags 				PageLayoutEnvelope;
#define PLE_PATH 					0x0040
#define PLE_ORIENTATION 					0x0010
#define PLE_TYPE 					0x0004 /*PT_ENVELOPE*/</PRE>
<PRE>/* Label Layouts:
 * 	(PT_LABEL | (rows &lt;&lt;8) | (cols &lt;&lt; 3)) */
<A NAME="Printing_13.htm_IX_PLL_&ldots;"> </A><A NAME="IX_PageLayoutLabel"> </A>typedef WordFlags 				PageLayoutLabel;
#define PLL_ROWS 					0x7e00 /* # rows */
#define PLL_COLUMNS 					0x01f8 /* # cols */
#define 	PLL_TYPE 				0x0004 /* PT_LABEL */</PRE>
<P CLASS="figTitle">
Code Display 14-3 PageSizeControl Features</P>
<PRE><A NAME="Printing_13.htm_IX_PSIZECF_&ldots;"> </A><A NAME="IX_PageSizeControlFeatures"> </A>typedef ByteFlags 	PageSizeControlFeatures;
/* The following flags may be combined with | and &amp;:
	PSIZECF_MARGINS, 			( Set margin sizes )
	PSIZECF_CUSTOM_SIZE,			( Custom dimension ranges )
	PSIZECF_LAYOUT,
	PSIZECF_SIZE_LIST,
	PSIZECF_PAGE_TYPE 			( Choice of standard dimensions ) */</PRE>
<PRE>#define PSIZEC_DEFAULT_FEATURES (PSIZECF_PAGE_TYPE | PSIZECF_SIZE_LIST | \
		 		PSIZECF_LAYOUT | PSIZECF_CUSTOM_SIZE) </PRE>

<H6 CLASS="RefETitle">
<A NAME="Printing_13.htm_IX_MSG_PRINT_REPORT_PAGE_SIZE">
 </A>
MSG_PRINT_REPORT_PAGE_SIZE</H6>
<PRE CLASS="syntax">void	MSG_PRINT_REPORT_PAGE_SIZE(
        PageSizeReport *psr);</PRE>
<P>
The page size control's output object should have a handler for this message. The control will send this message whenever the user has changed the page size. The handler may wish to change the bounds of some appropriate object, store the new bounds somewhere, or take some other action.</P>
<P CLASS="refField">
Source:	PageSizeControl object.</P>
<P CLASS="refField">
Destination:	The <CODE>
GCI_output</CODE>
 object.</P>
<P CLASS="refField">
Parameters:	<EM>psr</EM> 	A pointer to a <CODE>
PageSizeReport</CODE>
 structure containing the page type and size.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	The handler for this message should store the page size information. It may set the bounds of one or more visual objects.</P>
<P>
&nbsp;</P>
<P>
In addition to the standard set of generic Control instance data, the Page Size control includes some of its own. This data, as you might expect, is largely concerned with paper size and setup. The fields are listed in <A HREF="#Printing_13.htm_54994"> Page Size Control Instance Data</A>
.

</P>
<P>
<CODE>
PageSizeControls</CODE>
 use the <CODE>
PageLayout</CODE>
 data structure to hold and pass layout information such as page orientation. One part of this structure gives the type of page being described: paper, envelope, or label. The other parts of the structure have different meanings depending on the type of page. For paper, the layout keeps track of the orientation. For envelopes, the structure contains both path and orientation information. For labels, this structure keeps track of how many labels are on the sheet in each direction; these numbers are bounded by MAXIMUM_LABELS_ACROSS and MAXIMUM_LABELS_DOWN.</P>
<P CLASS="figTitle">
Code Display 14-4 <A NAME="Printing_13.htm_54994">
 </A>
Page Size Control Instance Data</P>
<PRE>@instance PageSizeControlAttrs				PZCI_attrs = 0;
	/* Possible attributes:
	 * PZCA_ACT_LIKE_GADGET
	 * PZCA_PAPER_SIZE
	 * PZCA_INITIALIZE				*/</PRE>
<PRE>	/* Current page dimensions and type/layout */
@instance dword 			PZCI_width = 0;
@instance dword 			PZCI_height = 0;
@instance PageLayout 			PZCI_layout = 0;
@instance PCMarginParams			PZCI_margins = { 0, 0, 0, 0 };</PRE>
<PRE>/* The following vardata field is internal: */
@vardata <A NAME="Printing_13.htm_IX_PageSizeControlMaxDimensions"> </A>PageSizeControlMaxDimensions <A NAME="IX_TEMP_PAGE_SIZE_CONTROL_MAX_DIMENSIONS"> </A>TEMP_PAGE_SIZE_CONTROL_MAX_DIMENSIONS;</PRE>
<PRE>/* Its structure is defined: 
typedef struct {
 	dword <A NAME="Printing_13.htm_IX_PZCMD_&ldots;"> </A>PZCMD_width; ( maximum width )
 	dword PZCMD_height; ( maximum height )
} PageSizeControlMaxDimensions; */</PRE>
<PRE>
/* Attribute to allow applications to be made aware of every change made
 * to gadgetry in the PageSizeControl. This is especially useful for applications
 * that want to add UI that will be dependent upon the state of this
 * controller. No effort is made to eliminate the redundant output of data. */</PRE>
<PRE>@vardata <A NAME="Printing_13.htm_IX_PageSizeControlChanges"> </A>PageSizeControlChanges <A NAME="IX_ATTR_PAGE_SIZE_CONTROL_UI_CHANGES"> </A>ATTR_PAGE_SIZE_CONTROL_UI_CHANGES;</PRE>
<PRE>/* This field has structure:
	typedef struct {
	 optr <A NAME="Printing_13.htm_IX_PSCC_&ldots;"> </A>PSCC_destination; ( destination for message )
	 Message PSCC_message; ( message to be sent )
	} <A NAME="Printing_13.htm_IX_PageSizeControlChanges"> </A>PageSizeControlChanges; */</PRE>
<PRE>The message should follow the prototype: */
@prototype void PAGE_SIZE_UI_CHANGES_MSG(PageSizeReport _far *psr )</PRE>
<DL>
<DT>
<CODE>
PZCI_width</CODE>
<A NAME="Printing_13.htm_IX_PZCI_&ldots;">
 </A>
, <CODE>
PZCI_height</DT><DD>
</CODE>
	These integers represent the current page dimensions, measured in points. Note that these values may never go outside the bounds described by the constants MINIMUM_PAGE_WIDTH_VALUE<A NAME="Printing_13.htm_IX_MINIMUM_PAGE_&ldots;">
 </A>
, MINIMUM_PAGE_HEIGHT_VALUE, MAXIMUM_PAGE_WIDTH_VALUE<A NAME="Printing_13.htm_IX_MAXIMUM_PAGE_&ldots;">
 </A>
, and MAXIMUM_PAGE_HEIGHT_VALUE.</DD>
<DT>
<CODE>
PZCI_layout</CODE>
	</DT><DD>
This field contains a <CODE>
PageLayout</CODE>
 structure describing the current page layout settings.</DD>
<DT>
<CODE>
PZCI_margins</DT><DD>
</CODE>
This field contains the page's margins.</DD>
</DL>
<P>
The following messages allow applications to work with a PageSizeControl directly, like a regular UI gadget. There is one message which the PageSizeControl will send to its output, and several that any object may send to the controller.</P>
<P>
Note that these messages are only useful if the PageSizeControl is operating in gadget mode (i.e. if its PZCA_ACT_LIKE_GADGET bit is set). Otherwise, the control's default behavior would override that requested by these messages. </P>
<P>
<A NAME="Printing_13.htm_IX_PZCA_&ldots;">
 </A>
<A NAME="Printing_13.htm_IX_PageSizeControlAttrs">
 </A>
The <CODE>
PageSizeControlAttrs</CODE>
 record has the following flags:</P>
<DL>
<DT>
PZCA_ACT_LIKE_GADGET</DT><DD>
The PageSizeControl object will act like any other generic gadget and will not respond to normal controller notifications.</DD>
<DT>
PZCA_PAPER_SIZE</DT><DD>
The PageSizeControl object will display paper sizes instead of document sizes. Setting this would be very rare for applications.</DD>
<DT>
PZCA_INITIALIZE</DT><DD>
The PageSizeControl object will be initialized to system default values if PZCA_ACT_LIKE_GADGET is also set.</DD>
<DT>
PZCA_LOAD_SAVE_OPTIONS</DT><DD>
Allow the controller to load and save the user's options.</DD>


</DL>
<H6 CLASS="RefETitle">
<A NAME="Printing_13.htm_IX_MSG_PZC_GET_PAGE_SIZE">
 </A>
MSG_PZC_GET_PAGE_SIZE</H6>
<PRE CLASS="syntax">void	MSG_PZC_GET_PAGE_SIZE(
        PageSizeReport		*psr);</PRE>
<P>
This message returns the present page size in terms of width, height, and layout, stored in a <CODE>
PageSizeReport</CODE>
. Note that the PageSizeControl will be sending out a <CODE>
MSG_PRINT_REPORT_PAGE_SIZE</CODE>
 every time the user applies changes to these values. </P>
<P>
Only send this message if the PageSizeControl is operating in gadget mode.</P>
<P CLASS="refField">
Source:	Unrestricted, as long as the PageSizeControl is in gadget mode.</P>
<P CLASS="refField">
Destination:	PageSizeControl object.</P>
<P CLASS="refField">
Parameters:	<CODE>
psr</CODE>
	A pointer to a <CODE>
PageSizeReport</CODE>
 structure in which the page size will be returned.</P>
<P CLASS="refField">
Return:	The <CODE>
PageSizeReport</CODE>
 structure pointed to by <CODE>
psr</CODE>
 will be filled with the page information.</P>
<P CLASS="refField">
Interception:	Unlikely.</P>


<H6 CLASS="RefETitle">
<A NAME="Printing_13.htm_IX_MSG_PZC_SET_PAGE_SIZE">
 </A>
MSG_PZC_SET_PAGE_SIZE</H6>
<PRE CLASS="syntax">void 	MSG_PZC_SET_PAGE_SIZE(
        PageSizeReport *	psr);		</PRE>
<P>
This message changes the current page size. It takes a <CODE>
PageSizeReport</CODE>
 data structure containing the new dimensions and layout. The Apply trigger of a Page Size Control normally sends this message, passing the present user page size as arguments.</P>
<P>
Only send this message if the PageSizeControl is operating in gadget mode.</P>
<P CLASS="refField">
Source:	Unrestricted, as long as the PageSizeControl is in gadget mode.</P>
<P CLASS="refField">
Destination:	PageSizeControl object.</P>
<P CLASS="refField">
Parameters:	<EM>psr</EM>	A pointer to a <CODE>
PageSizeReport</CODE>
 structure containing page information.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Unlikely.<A NAME="Printing_13.htm_marker=461169">
 </A>
</P>


<H6 CLASS="RefETitle">
MSG_PZC_SET_MAXIMUM_HEIGHT</H6>
<PRE CLASS="syntax">void MSG_PZC_SET_MAXIMUM_HEIGHT(
        dword height);</PRE>
<P>
Set the maximum height for a page.</P>
<P CLASS="refField">
Source:	Anything.</P>
<P CLASS="refField">
Destination:	PageSizeControl object.</P>
<P CLASS="refField">
Parameters:	<EM>
height</EM>
	Height, in points.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Generally should not be intercepted.</P>


<H6 CLASS="RefETitle">
MSG_PZC_SET_MAXIMUM_WIDTH</H6>
<PRE CLASS="syntax">void MSG_PZC_SET_MAXIMUM_WIDTH(
        dword width);</PRE>
<P>
Set the maximum width for a page.</P>
<P CLASS="refField">
Source:	Anything.</P>
<P CLASS="refField">
Destination:	PageSizeControl object.</P>
<P CLASS="refField">
Parameters:	<EM>
width</EM>
	Width, in points.</P>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Generally should not be intercepted.</P>

<HR>
<A NAME="Printing_14.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 7 
<A NAME="Printing_14.htm_89229">
 </A>
Other Printing Components</H2>
<P>
Most geodes can fulfill all their drawing needs by working with their Print Control. The system has two other main parts that work with printing: the first is the spool library, which controls scheduling; the second is a collection of printer drivers, which handle interactions between the printing devices and the rest of the system.</P>
<P CLASS="subsectionLink">
<A HREF="#Printing_15.htm">Spooler and Scheduling</A></P>
<P CLASS="subsectionLink">
<A HREF="#Printing_16.htm">Printer Drivers</A></P>
<P CLASS="subsectionLink">
<A HREF="#Printing_17.htm">Page Size Related Routines</A></P>
<HR>
<A NAME="Printing_15.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 7.1 <A HREF="#Printing_14.htm">Other Printing Components</A>: 
<A NAME="Printing_15.htm_74786">
 </A>
Spooler and Scheduling</H3>
<PRE>SpoolInfo(), SpoolHurryJob(), SpoolDelayJob(), SpoolModifyPriority(), SpoolVerifyPrinterPort(), SpoolCreateSpoolFile(), SpoolDelJob(), MSG_PRINT_NOTIFY_PRINT_JOB_CREATED</PRE>
<P>
Geodes may invoke certain routines that affect the Spooler, but for the most part they should avoid this practice. These routines allow the geode to take advantage of some of the Spooler's scheduling capabilities, so the geode can hurry some jobs and delay others. Most applications should not be concerned with the scheduling of printer jobs. If the user thinks that some job should be given a higher priority, he can work with the Printer Control Panel. Many of the following routines require the print job's ID. Applications that will use these routines should have a handler for <CODE>
MSG_PRINT_NOTIFY_PRINT_JOB_CREATED</CODE>
, which has reference material at the end of this section.

</P>
<P>
<A NAME="Printing_15.htm_IX_SpoolHurryJob()">
 </A>
For those applications that will be scheduling, the <CODE>
SpoolHurryJob()</CODE>
 and <CODE>
SpoolDelayJob()</CODE>
<A NAME="Printing_15.htm_IX_SpoolDelayJob()">
 </A>
 routines may come in handy. Passed a job ID, these routines move the associated job to the front or back of the queue.<A NAME="Printing_15.htm_IX_SpoolModifyPriority()">
 </A>
 <CODE>
SpoolModifyPriority()</CODE>
 changes the priority of a spool thread so that it may print in the foreground or be moved further into the background. Each function returns a code describing the Spool's Operating Status, alerting the geode if the job wasn't found, the queue was empty, the port couldn't be verified, or even if the operation was successful.

</P>
<P>
<A NAME="Printing_15.htm_IX_SpoolInfo()">
 </A>
The <CODE>
SpoolInfo() </CODE>
routine returns the list of jobs on a queue or information about any individual job. The other kind of information application writers might be interested in is the printer port status. It's sometimes unwise to spool a job when the printer is having problems, and <CODE>
SpoolVerifyPrinterPort()</CODE>
<A NAME="Printing_15.htm_IX_SpoolVerifyPrinterPort()">
 </A>
 can give some warning about problems.</P>
<P>
While the above routines are used only rarely in applications, there are others that are used even less often.<A NAME="Printing_15.htm_IX_SpoolCreateSpoolFile()">
 </A>
 <CODE>
SpoolCreateSpoolFile()</CODE>
 creates a spool file, which may be used to create a pre-generated job for the printer kept handy. Such a file would only be useful to applications that can only print one thing and don't mind leaving around an extra spool file. <CODE>
SpoolDelJob()</CODE>
<A NAME="Printing_15.htm_IX_SpoolDelJob()">
 </A>
 deletes jobs from the queue.</P>

<H6 CLASS="RefETitle">
<A NAME="Printing_15.htm_IX_MSG_PRINT_NOTIFY_PRINT_JOB_CREATED">
 </A>
MSG_PRINT_NOTIFY_PRINT_JOB_CREATED</H6>
<PRE CLASS="syntax">void 	MSG_PRINT_NOTIFY_PRINT_JOB_CREATED(
        optr	printControlOD,
        word 	jobID);		</PRE>
<P>
The PrintControl sends this message when it has sent the job to the print queue. Applications may intercept this message to retrieve the new job's ID number or for any other reason.</P>
<P CLASS="refField">
Source:	PrintControl object.</P>
<P CLASS="refField">
Destination:	<CODE>
GCI_output</CODE>
 object.</P>
<P CLASS="refField">
Parameters:	<EM>printControlOD	</EM>The optr of the PrintControl object.<EM></EM></P>
<DL>
<DT>
<EM>jobID</EM></DT><DD>Print job's ID.</DD>
</DL>
<P CLASS="refField">
Return:	Nothing.</P>
<P CLASS="refField">
Interception:	Applications that want to know the ID of created jobs should intercept this message. Note that this behavior is not encouraged, and most applications will want to leave meddling with a print job's status up to the user's discretion.</P>

<HR>
<A NAME="Printing_16.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 7.2 <A HREF="#Printing_14.htm">Other Printing Components</A>: 
<A NAME="Printing_16.htm_58536">
 </A>
Printer Drivers</H3>
<P>
Printer Drivers are very important but at the same time not something that any geode you write is going to interact with. Printer Drivers take care of translating the device-independent graphics commands into forms that individual models of printers can work with. Drivers also provide the Spooler with information about the printer and provide printer-specific UI to the Print Control.</P>
<P>
As long as a geode uses only device-independent graphics commands, that geode need not worry about printer drivers. In fact, the only geodes that require knowledge of printer drivers are those that use Raw Mode (see below) printing and access the printer drivers directly. To incorporate Raw Mode printing into a geode (normally a bad idea), keep reading. Whether or not the geode you're writing will interact with Printer Drivers, you might want to continue reading this section to find out what printer drivers do.</P>

<H4 CLASS="HeadingC">
<A NAME="Printing_16.htm_60013">
 </A>
Dumb Printers</H4>
<P>
When dealing with a printer that has no page description language, the Spooler and Printer Driver have to be clever. First the Spooler allocates an offscreen bitmap and plays back the contents of the spool file into the bitmap. It does this through the <STRONG CLASS="fileName">
vidmem</STRONG>
 driver, which has the same interface as a video driver but draws to offscreen bitmaps instead of to a device. Once the bitmap is complete, the Spooler starts feeding the bitmap to the Printer Driver, which translates the bitmap into a series of commands to the printer. If (as is often the case) the printer doesn't have enough memory to absorb a whole page's worth of data at a time, the Printer Driver feeds in one horizontal band, or &quot;swath&quot; of the bitmap at a time. This also allows for better backgrounding: The driver can feed in a swath, then block and allow other threads to complete other tasks until the printer is ready for the next swath.</P>


<H4 CLASS="HeadingC">
<A NAME="Printing_16.htm_95464">
 </A>
Smart Printers</H4>
<P>
When dealing with an &quot;intelligent&quot; printer, a printer that has its own page description language, the Spooler bypasses most of the work it has to do when dealing with dumb printers. Since an intelligent printer presumably has some commands with GEOS equivalents, the Spooler doesn't bother with creating a bitmap but just passes the GString on to the Printer Driver. The Printer Driver then builds a page description in the printer's native language based on the contents of the GString.</P>


<H4 CLASS="HeadingC">
<A NAME="Printing_16.htm_79275">
 </A>
Raw Mode</H4>
<P>
If you want to use some printer-specific command that doesn't have an equivalent in the GEOS graphics system, you will use raw mode. Raw Mode printing expects that you know what sorts of commands the printer will be expecting. If you try to send PostScript commands to a printer that doesn't understand PostScript, probably the results won't be the desired output.

</P>


<H4 CLASS="HeadingC">
<A NAME="Printing_16.htm_71198">
 </A>
Printer Information and Manipulation</H4>
<PRE>SpoolGetNumPrinters(), SpoolGetPrinterString(), SpoolGetPrinterInfo(), SpoolCreatePrinter(), SpoolDeletePrinter(), SpoolGetDefaultPrinter(), SpoolSetDefaultPrinter()</PRE>
<P>
If you want to find out something about a printer without accessing the printer driver directly, the spool library provides a number of utility routines that work with printer drivers.

</P>
<P>
Most of these functions specify which of a user's printers they wish to work with by passing its printer number. The first installed printer will be printer number zero, the second printer will be number one, and so on. Use the <CODE>
SpoolGetNumPrinters()</CODE>
<A NAME="Printing_16.htm_IX_SpoolGetNumPrinters()">
 </A>
 routine to find out how many printers have been installed. Once you have this number, you have an upper bound for printer numbers to test. There will always be fewer than MAXIMUM_NUMBER_OF_PRINTERS<A NAME="Printing_16.htm_IX_MAXIMUM_NUMBER_OF_PRINTERS">
 </A>
 printers.</P>
<P>
<A NAME="Printing_16.htm_IX_SpoolGetPrinterString()">
 </A>
The <CODE>
SpoolGetPrinterString()</CODE>
 and <CODE>
SpoolGetPrinterInfo()</CODE>
 routines return information about the printer associated with the passed printer number. <CODE>
SpoolGetPrinterString()</CODE>
 returns the a string containing the name of the printer, such as &quot;HP DeskJet on COM1.&quot; The printer string will be of length at most <A NAME="Printing_16.htm_IX_MAXIMUM_PRINTER_NAME_LENGTH">
 </A>
MAXIMUM_PRINTER_NAME_LENGTH. <A NAME="Printing_16.htm_IX_SpoolGetPrinterInfo()">
 </A>
<CODE>
SpoolGetPrinterInfo()</CODE>
 returns various pieces of information helpful to geodes that work with printers directly.</P>
<P>
The<CODE>
 SpoolCreatePrinter()</CODE>
 and <CODE>
SpoolDeletePrinter()</CODE>
 routines can install and uninstall printers, tasks probably best left to the Preferences Manager. <A NAME="Printing_16.htm_IX_SpoolDeletePrinter()">
 </A>
The<CODE>
 SpoolDeletePrinter()</CODE>
 routine uninstalls the printer corresponding to the passed printer number. It is easy to use but not something that most geodes should be doing.<A NAME="Printing_16.htm_IX_SpoolCreatePrinter()">
 </A>
 <CODE>
SpoolCreatePrinter()</CODE>
 installs a new printer, returning the new printer's printer number. Note that any geode calling this latter function is going to be expected to provide considerable information about the printer being installed. Again, this is not a routine that many geodes should be using.</P>
<P>
<CODE>
SpoolGetDefaultPrinter()</CODE>
<A NAME="Printing_16.htm_IX_SpoolGetDefaultPrinter()">
 </A>
 returns the number of the system-default printer.<A NAME="Printing_16.htm_IX_SpoolSetDefaultPrinter()">
 </A>
 <CODE>
SpoolSetDefaultPrinter()</CODE>
 makes the printer associated with the passed printer number the new system-default printer. Note that these routines are concerned with the system-default printer as opposed to the application-default printer. Most applications won't specify an application specific default printer. For these applications, the system-default printer will be the default. Of course, the user will still be allowed to select any printer, ignoring the default.</P>

<HR>
<A NAME="Printing_17.htm"></A>


<H3 CLASS="subsectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 7.3 <A HREF="#Printing_14.htm">Other Printing Components</A>: 
<A NAME="Printing_17.htm_31156">
 </A>
Page Size Related Routines</H3>
<PRE>SpoolGetNumPaperSizes(), SpoolGetPaperString(), SpoolConvertPaperSize(), SpoolCreatePaperSize(), SpoolDeletePaperSize(), SpoolGetPaperSizeOrder(), SpoolSetPaperSizeOrder(), SpoolGetDefaultPageSizeInfo(), SpoolSetDefaultPageSizeInfo()</PRE>
<P>
Most geodes won't be too concerned with what sort of page size choice the user has made. If the document fits on the page, all's well. If the document doesn't fit, the Spooler will tile the job using only as many pieces of paper as necessary. If the document size should be the same as the page size, the geode can send a <CODE>
MSG_PRINT_CONTROL_CALC_DOC_DIMENSIONS</CODE>
 to the print control.

</P>
<P>
There are several routines which deal with page sizes. Most applications have no reason to call these functions, and we will not discuss them in detail here. Some general notes are in order for those programmers who might work with these functions, though.</P>
<P>
It takes two indexes to access a page size. The first is the <CODE>
PageType</CODE>
: paper, envelope, or label. Within each type, there are up to MAX_PAPER_SIZES page sizes.<A NAME="Printing_17.htm_IX_SpoolGetNumPaperSizes()">
 </A>
 To find out the number of page sizes presently defined for a given type, use the <CODE>
SpoolGetNumPaperSizes()</CODE>
 routine.<A NAME="Printing_17.htm_IX_SpoolConvertPaperSize()">
 </A>
 To find the number of a paper size associated with a <CODE>
PageType</CODE>
 and a given set of dimensions, use the <CODE>
SpoolConvertPaperSize()</CODE>
 routine.<A NAME="Printing_17.htm_IX_SpoolGetPaperString()">
 </A>
 For the text string describing the size of the page, call <CODE>
SpoolGetPaperString()</CODE>
 (the buffer to hold the string should be of size <A NAME="Printing_17.htm_IX_MAX_PAPER_STRING_LENGTH">
 </A>
MAX_PAPER_STRING_LENGTH.</P>
<P>
To find out the order in which the page sizes of a given type are stored, call <CODE>
SpoolGetPaperSizeOrder()</CODE>
<A NAME="Printing_17.htm_IX_SpoolGetPaperSizeOrder()">
 </A>
. You may give a new order by calling <CODE>
SpoolSetPaperSizeOrder()</CODE>
<A NAME="Printing_17.htm_IX_SpoolSetPaperSizeOrder()">
 </A>
. This will affect the order in which page sizes are presented in a page size control.</P>
<P>
<A NAME="Printing_17.htm_IX_SpoolCreatePaperSize()">
 </A>
To create a new page size, call <CODE>
SpoolCreatePaperSize()</CODE>
. This routine takes a page type, a set of dimensions, and a string to describe those dimensions to the user. It returns a new page size number. To destroy a page size, call <CODE>
SpoolDeletePaperSize()</CODE>
<A NAME="Printing_17.htm_IX_SpoolDeletePaperSize()">
 </A>
. </P>
<P>
<A NAME="Printing_17.htm_IX_SpoolGetDefaultPageSizeInfo()">
 </A>
<A NAME="Printing_17.htm_IX_SpoolSetDefaultPageSizeInfo()">
 </A>
To find out or change the default page size, call <CODE>
SpoolGetDefaultPageSizeInfo()</CODE>
 or <CODE>
SpoolSetDefaultPageSizeInfo()</CODE>
. </P>
<HR>
<A NAME="Printing_18.htm"></A>


<H2 CLASS="sectionTitle">
<A HREF="#index.htm">The Spool Library</A>: 8 
<A NAME="Printing_18.htm_73080">
 </A>
Debugging Tips</H2>
<P>
Though GEOS provides an easy-to-use printer interface, mistakes are sure to happen. You may find the following information useful in catching your mistakes or for testing rigorously.</P>
<P>
Under Swat, you can see the various threads the Spooler works with. There is always one spool thread running in the background. When the first job is queued on a printer, you can see that a new thread is created for that printer. When the last job for a printer is completed, the thread exits again. </P>
<P>
Here are the most common printing mistakes:</P>
<UL>
<LI>
Forgetting to add the Print Control object to the application's Active List (the GAGCNLT_SELF_LOAD_OPTIONS GCN list).</LI>
<LI>
Not setting the document name (see <A HREF="#Printing_c.htm_87878"> Document Name Output</A>
).</LI>
<LI>
Setting the number of pages (page range) incorrectly.<A NAME="Printing_18.htm_marker=461207">
 </A>
</LI>
</UL>
<HR>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
