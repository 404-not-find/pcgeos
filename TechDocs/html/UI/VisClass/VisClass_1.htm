<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: VisClass_1.htm,v 1.1 97/06/02 16:49:06 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE> Introduction to VisClass</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">


<H1 CLASS="sectionTitle">
<A HREF="index.htm">VisClass</A>: 1 
Introduction to VisClass</H1>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="index.htm"><IMG SRC="../../docImages/prevUp.gif" BORDER="0" ALT="Prev: ">VisClass</A> 
<!-- to next --> | <A HREF="VisClass_2.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">2 The Visible Class Tree</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
<P>
<CODE>
VisClass</CODE>
 is one of the three visible classes you'll have to have a working knowledge of in order to use visible objects. Both of the others, <CODE>
VisCompClass</CODE>
 and <CODE>
VisContentClass</CODE>
, are its subclasses, and both are important in visible object trees. However, <CODE>
VisClass</CODE>
 provides the heart of the visible world.</P>
<P>
<CODE>
VisClass</CODE>
 objects do nothing useful by themselves. When you subclass <CODE>
VisClass</CODE>
 and add your own methods, however, the real power of the visible classes can be used without the programmer having to worry about the nuts and bolts of most UI issues. These classes inherently provide the following features:</P>
<DL>
<DT>
<STRONG>
Knowledge of Visible Bounds</DT><DD>
</STRONG>
Every visible object has an instance data field that defines the object's bounds in the GEOS graphic coordinate space. These bounds are used for many purposes, including drawing and input handling. See <A HREF="VisClass_e.htm#87564"> Positioning Visible Objects</A>
.</DD>
<DT>
<STRONG>
Comprehensive Visual Updating</DT><DD>
</STRONG>
When a visible object is included in an object tree displayed by a GenView object, the system automatically tells the object when it must redraw itself. For example, when the view scrolls or when part of the window becomes exposed, the system will send a drawing message through the visible tree; the objects then draw themselves at the proper location in the document space, and the view window is updated. See <A HREF="VisClass_d.htm#28950"> Drawing to the Screen</A>
.</DD>
<DT>
<STRONG>
Geometry Management</DT><DD>
</STRONG>
When visible objects are arranged as children of a VisComp or a VisContent object, they can be set up to update their size and position appropriate to the current window and view context. The VisComp and VisContent classes provide extensive and sophisticated child management functions, though custom management is also allowed and is often used. See <A HREF="VisClass_e.htm#87564"> Positioning Visible Objects</A>
, especially the messages <CODE>
MSG_VIS_RECALC_SIZE</CODE>
 and <CODE>
MSG_VIS_POSITION_BRANCH</CODE>
 in <A HREF="VisClass_e.htm#16842"> Geometry Management</A>
.</DD>
<DT>
<STRONG>
Object Tree Manipulation</DT><DD>
</STRONG>
<CODE>
VisClass</CODE>
 objects can not have children, but they can be children of <CODE>
VisCompClass</CODE>
 and <CODE>
VisContentClass</CODE>
 objects. All of these classes support extensive tree operations including passing messages up the tree, passing messages down the tree, adding branches, removing branches, and moving branches. See <A HREF="VisClass_10.htm#50052"> Working with Visible Object Trees</A>
.</DD>
<DT>
<STRONG>
Mouse Event Handling</DT><DD>
</STRONG>
When an input event occurs over the GenView window in which the visible tree is displayed, that event is immediately passed on to the VisContent object. The event then travels down the visible object tree (automatically) until it is handled by some visible object. Most often, the event is handled by the leaf object with its visible bounds directly under the mouse pointer. Individual Vis objects can also grab the mouse so that they receive input events that occur even outside their bounds. See both <A HREF="VisClass_f.htm#65723"> Handling Input</A>
 and <A HREF="../../SysObjects/Input/index.htm">the Input chapter</A>.</DT><P CLASS="WorList">
<STRONG>
Keyboard Event Handling<BR>
</STRONG>
A visible object can grab the keyboard input stream and receive keyboard events as they occur. Typically, certain keystrokes will be intercepted by the specific UI even if a visible object has the keyboard grab; this ensures the object won't usurp functions expected by the user from his specific UI. (The object can, however, override keystroke interception, though this is strongly discouraged.) See <A HREF="../../SysObjects/Input/index.htm">the Input chapter</A>.</P><DT>
<STRONG>
Interaction with Input Hierarchies<BR>
</STRONG>
<CODE>
VisClass</CODE>
 objects have an inherent knowledge of the input hierarchies. Many visible objects may need to interact with the Focus and Target input hierarchies especially, and they can also interact with the Model hierarchy as well. See <A HREF="../../SysObjects/Input/index.htm">the Input chapter</A>.</DT><P CLASS="WorList">
<STRONG>
Use of VisMonikers<BR>
</STRONG>
Typically, visible objects will draw themselves in their entirety and will not need visual monikers. Monikers are typically labels attached to objects that get displayed either on or near the object. Visual monikers are most frequently used with generic UI objects, but they can be set up and used with visible objects as well. See <A HREF="VisClass_d.htm#42180"> Using Visual Monikers</A>
.</P>
<DT>
<STRONG>
Standard MetaClass Functions<BR>
</STRONG>
Because <CODE>
VisClass</CODE>
 is a subclass of <CODE>
MetaClass</CODE>
</DL>
, it inherits all the basic, standard object functions of that class (e.g., state saving, instantiation and initialization, detaching and destruction, etc.). See <A HREF="../../SysObjects/Meta/index.htm">the MetaClass chapter</A>.</DT><P CLASS="Body">
Many programmers new to object-oriented programming may think that visible objects are used only in certain circumstances. On the contrary, visible objects may be used for nearly any purpose and to provide nearly any application-specific graphical or user interface functions. When used properly, visible objects can relieve you of hours of writing specialized code.</P>
<P>
Programmers new to OOP may need to practice with several small applications in order to gain experience using visible objects. You can also study the sample applications, many of which use visible objects extensively.</P>
<P>
Visible objects are most useful when you have well-defined items that must appear on the screen or interact with the user. Pieces in a board game provide a good example: Each piece has its own visual representation, and each piece has a special set of behaviors that depend on user actions and game context. Therefore, it makes sense to have each piece be an object of <CODE>
VisClass</CODE>
.</P>
<P>
Another, less immediately obvious, example might be a program that represents maps on the screen. The map itself could be stored as a visible composite object (<CODE>
VisCompClass</CODE>
), and each of the major subdivisions on the map could be a visible object. For example, in a map of the United States, the country would be a VisComp object, and each state could be a Vis object. Taken one step further, each state could be a composite object, and each county in the state a visible child of the state. Another step turns the counties into composite objects and each town a visible object. This arrangement lends itself to a tree structure, which is how visible objects are stored.</P>
<P>
Another example is a spreadsheet application. The spreadsheet itself could be one composite object containing a number of row objects. Each row object is a composite that holds a number of cell objects. Each cell is a visible object with the functions of the cell built into it. The row and spreadsheet composites can use the geometry manager to arrange the cells properly, thereby making the programmer free of ever having to worry where the cells are in the document. The visible object tree will automatically pass input events to the cell under the mouse pointer. Entire rows can be created, destroyed, drawn, erased, or moved with a few simple commands by the programmer.</P>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="index.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="index.htm"><IMG SRC="../../docImages/prevUp.gif" BORDER="0" ALT="Prev: ">VisClass</A> 
<!-- to next --> | <A HREF="VisClass_2.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">2 The Visible Class Tree</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
