<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: UIOverview_12.htm,v 1.2 97/09/05 14:51:22 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE> TicTacPiece Specifics</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">


<H1 CLASS="subsectionTitle">
<A HREF="index.htm">UI Overview</A>: 5.5 <A HREF="UIOverview_d.htm">A UI Example</A>: 
TicTacPiece Specifics</H1>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="UIOverview_d.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="UIOverview_11.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">5.4 TicTacBoard Specifics</A> 
<!-- to next --> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
<P>
<CODE>
TicTacPieceClass</CODE>
 contains most of the game's functionality. Since the user interacts directly with each game piece, the piece must know not only how to draw itself but also how to react to user input.</P>
<DL>
<DT>
<CODE>
MSG_PIECE_NEW_GAME</DT><DD>
</CODE>
This is the only message generated by the game itself that a game piece receives; it is sent by the TicTacBoard object when the user has pressed the New Game trigger. The game piece object responds by resetting its bounds to the original settings. It does not have to redraw or invalidate its old bounds because the TicTacBoard object will send a <CODE>
MSG_VIS_DRAW</CODE>
 later and will invalidate the entire board.</DD>
<DT>
<CODE>
MSG_VIS_DRAW</DT><DD>
</CODE>
This message notifies the object that it must draw itself and any accompanying graphics. The game piece responds by drawing the proper shape in the proper color in the proper place. Since every <CODE>
VisClass</CODE>
 object inherently knows its location and bounds, the object already knows where and how big the shape should appear. Whether a gray box or circle is drawn depends on the <CODE>
TTP_pieceType</CODE>
 instance data field.</DD>
<DT>
<CODE>
MSG_META_START_SELECT</DT><DD>
</CODE>
This message is sent by the system when the user clicks a mouse button. The UI sends the message to whatever object lies under the pointer. The UI objects then pass the message down the object tree until it gets handled. The progression sends the message to TicTacApp, which passes it to TicTacPrimary, which passes it to TicTacView, which passes it to TicTacBoard, which (by letting the default <CODE>
VisContentClass</CODE>
 method handle it) passes it to the proper game piece object (if any) under the pointer. The game piece responds by grabbing the mouse and all subsequent pointer events.</DD>
<DT>
<CODE>
MSG_META_DRAG_SELECT</DT><DD>
</CODE>
This message, like <CODE>
MSG_META_START_SELECT</CODE>
, indicates that the user has clicked a mouse button and has initiated a drag event. (Normally, this is used to select ranges or groups of objects; in TicTac, however, it is treated like <CODE>
MSG_META_START_SELECT</CODE>
.)</DD>
<DT>
<CODE>
MSG_META_DRAG</DT><DD>
</CODE>
This message is sent after the user has clicked the mouse button and is now moving the mouse pointer (and has not released the button yet). </DD>
<DT>
<CODE>
MSG_META_PTR</DT><DD>
</CODE>
This message is sent when the pointer image is over the bounds of the game piece whether or not a mouse button has been pressed. (After the object has grabbed the mouse events by handling <CODE>
MSG_META_START_SELECT</CODE>
, the pointer event is sent whenever the mouse pointer is moved.) The piece determines whether or not it is being dragged around the screen. This is known as a &quot;drag event,&quot; and the game piece responds by drawing a piece-shaped outline around the mouse pointer. This outline will follow the pointer around the screen until the user releases the mouse button (causing a <CODE>
MSG_META_END_SELECT</CODE>
, below). The outline is first drawn in either the <CODE>
MSG_META_START_SELECT</CODE>
 or <CODE>
MSG_META_DRAG_SELECT</CODE>
 handler (whichever is called to start the drag event). <CODE>
MSG_META_PTR</CODE>
 and <CODE>
MSG_META_END_SELECT</CODE>
 erase the outline before drawing a new one. The game piece will maintain three locations in its instance data: Its <CODE>
VI_bounds</CODE>
 field maintains its position when selected. Its <CODE>
TTP_orig(horiz/vert)Pos</CODE>
 fields maintain its original position when the game was first started. Its <CODE>
TTP_(horiz/vert)Pos</CODE>
 fields maintain the current position of the outline and where the object would relocate to if the move was ended now. If the event is not a drag, the object will not react because it is assumed that no mouse button has been pressed and therefore the user is taking no action. 
<IMG SRC="UIOverview_12_selectPiece.gif">

</DD>
<DT>
<CODE>
MSG_META_END_SELECT</DT><DD>
</CODE>
This message is sent when the user releases a pressed mouse button, ending the select-and-drag process. The game piece reacts by checking if the location of the pointer is a legal position on the game board. (It does this by sending a verification message to the TicTacBoard object to make sure the proposed new bounds are on the game board.) If the position is legal, the game piece moves itself there, erasing any leftover outlines (from the drag sequence) and its original image on the board. It then causes itself to draw in the new location by sending itself a <CODE>
MSG_VIS_DRAW</CODE>
. If the new location is not legally on the game board, then the object will reset all its instance data and erase any leftover outlines, causing it to revert to its location before the select-and-drag sequence began.</DD>
</DL>
<P>
Each of the methods for the above messages is shown in <A HREF="UIOverview_12.htm#79638"> Methods for TicTacPieceClass</A>
.</P>
<P CLASS="figTitle">
Code Display 6-6 <A NAME="79638">
 </A>
Methods for TicTacPieceClass</P>
<PRE>/***********************************************************************
 *
 * MESSAGE:		 MSG_PIECE_NEW_GAME for TicTacPieceClass
 *
 * DESCRIPTION:		This message causes the piece to replace itself
 *		to its original position. It is invoked when the
 *		user presses the New Game trigger; the trigger sends
 * 		MSG_TICTAC_NEW_GAME to the TicTacBoard object, and
 * 		the board object sends this message to each of
 * 		the game piece objects.
 * 
 * PARAMETERS:
 * 	void ()
 ***********************************************************************/</PRE>
<PRE>@method TicTacPieceClass, MSG_PIECE_NEW_GAME {</PRE>
<PRE>	/* Set the current (motion) positions to the original positions. */</PRE>
<PRE>    pself-&gt;TTP_vertPos = pself-&gt;TTP_origVertPos;
    pself-&gt;TTP_horizPos = pself-&gt;TTP_origHorizPos;</PRE>
<PRE>	/* Send a MSG_VIS_BOUNDS_CHANGED to ourselves to make
	 * sure the old bounds get redrawn. This message will
	 * cause an invalidation of the document where the old
	 * (passed) bounds were, causing that portion of the
	 * window to be redrawn.						*/</PRE>
<PRE>    @call self::MSG_VIS_BOUNDS_CHANGED(pself-&gt;VI_bounds.R_bottom,
			pself-&gt;VI_bounds.R_right, pself-&gt;VI_bounds.R_top,
			pself-&gt;VI_bounds.R_left);</PRE>
<PRE>	/* Set the bounds of the object (VI_bounds) back to
	 * their original values. The Rectangle structure
	 * contains four fields, each of which must be set.						*/</PRE>
<PRE>    pself-&gt;VI_bounds.R_left = pself-&gt;TTP_origHorizPos;
    pself-&gt;VI_bounds.R_top = pself-&gt;TTP_origVertPos;
    pself-&gt;VI_bounds.R_right = (pself-&gt;TTP_origHorizPos + PIECE_WIDTH);
    pself-&gt;VI_bounds.R_bottom = (pself-&gt;TTP_origVertPos + PIECE_HEIGHT);</PRE>
<PRE>	/* This method does not need to invoke a MSG_VIS_DRAW
	 * because the TicTacBoard object will do that. The
	 * piece object will later receive a MSG_VIS_DRAW that
	 * will cause the piece to be redrawn back at its
	 * original location (the newly set bounds).						*/
}</PRE>
<PRE>/***********************************************************************
 *
 * MESSAGE:		MSG_VIS_DRAW for TicTacPieceClass
 *
 * DESCRIPTION:		Draw the piece at the current location. If the piece
 *		is a &quot;box,&quot; draw a gray square. If the piece is a
 *		&quot;ring,&quot; draw a gray circle. This message is received
 *		whenever a portion of the view window becomes invalid;
 *		TicTacView will send a MSG_META_EXPOSED to TicTacBoard,
 *		which will send itself (by default) a MSG_VIS_DRAW.
 *		The MSG_VIS_DRAW will be handled and then will be
 *		passed on to each of the game pieces. Then each piece
 *		(in this handler) will draw itself at its own bounds.
 *
 * PARAMETERS:
 *	void (word drawFlags GStateHandle gstate)
 *
 ***********************************************************************/</PRE>
<PRE>@method TicTacPieceClass, MSG_VIS_DRAW {
	/* Set the mode to MM_COPY; this means that the image
	 * drawn now will be drawn over whatever is there now.*/</PRE>
<PRE>    GrSetMixMode(gstate, MM_COPY);</PRE>
<PRE>	/* If the type is TTPT_BOX, set the color to gray and
	 * draw a rectangle the size of the object's bounds.
	 * Otherwise (since there are just two types), set the
	 * color to gray and draw an ellipse of that size.						*/</PRE>
<PRE>    if (pself-&gt;TTP_pieceType == TTPT_BOX) {
	GrSetAreaColor(gstate, CF_INDEX, C_DARK_GRAY, 0, 0);
	GrFillRect(gstate, pself-&gt;VI_bounds.R_left, pself-&gt;VI_bounds.R_top,
			pself-&gt;VI_bounds.R_right, pself-&gt;VI_bounds.R_bottom);</PRE>
<PRE>    } else {
	GrSetAreaColor(gstate, CF_INDEX, C_LIGHT_GRAY, 0, 0);
	GrFillEllipse(gstate, pself-&gt;VI_bounds.R_left, pself-&gt;VI_bounds.R_top,
			pself-&gt;VI_bounds.R_right, pself-&gt;VI_bounds.R_bottom);
    }</PRE>
<PRE>	/* After handling the message, call the superclass to
	 * ensure that no default behavior has been mucked up.
	 * This is actually not necessary in this particular case. */
    @callsuper();
}</PRE>
<PRE>/***********************************************************************
 * MESSAGE:		MSG_META_START_SELECT for TicTacPieceClass
 *
 * DESCRIPTION:		Grabs the mouse and calls for future pointer events.
 *		When the user clicks in the view, TicTacView will pass
 *		the click event to TicTacBoard. Since TicTacBoardClass
 *		does not intercept the event, VisContentClass passes
 *		it on to its child object currently under the pointer.
 *
 *		When the piece object receives this message, it means
 *		it has been clicked on by the user and the mouse button
 *		is still down. The piece must grab the mouse so that it
 *		gets all future mouse events, and it must request that
 *		all future mouse events be sent to it. This ensures
 *		that if the pointer leaves the object's bounds while
 *		the button is still pressed, the piece object will still
 *		receive all the pointer events (otherwise they would be
 *		sent to whatever object was under the new pointer
 *		position).
 * PARAMETERS:
 *	void (MouseReturnParams *retVal, word xPosition,
 *			word yPosition, word inputState)
 ***********************************************************************/</PRE>
<PRE>@method TicTacPieceClass, MSG_META_START_SELECT {</PRE>
<PRE>	/* First grab the gadget exclusive so we're allowed to
	 * grab the mouse. Then grab the mouse, so all future
	 * pointer events get passed directly to the game piece. */</PRE>
<PRE>    @call @visParent::MSG_VIS_TAKE_GADGET_EXCL(oself);
    @call self::MSG_VIS_GRAB_MOUSE();						/* grab mouse */</PRE>
<PRE>	/* Finally, return that this particular click
	 * event has been processed. If this flag is
	 * not returned, the system will send out the
	 * click event again.					*/</PRE>
<PRE>    retVal-&gt;flags = MRF_PROCESSED;						/* this event processed */
}</PRE>
<PRE>/***********************************************************************
 *
 * MESSAGE:		MSG_META_DRAG_SELECT for TicTacPieceClass
 *
 * DESCRIPTION:		This message is sent to the piece object when the
 *		select button has been pressed and the mouse has been
 *		moved, resulting in a &quot;drag-select&quot; event.
 *		For event processing from the View, see the header
 *		for MSG_META_START_SELECT.
 *
 * PARAMETERS:
 *	void (MouseReturnParams *retVal, word xPosition,
 *			word yPosition, word inputState)
 ***********************************************************************/</PRE>
<PRE>@method TicTacPieceClass, MSG_META_DRAG_SELECT {
    GStateHandle gstate;					/* temporary gstate to draw to */
    WindowHandle win;					/* window handle of view window */</PRE>
<PRE>	/* Start off by setting the flag indicating that
	 * the piece is being dragged around the screen. */
    pself-&gt;TTP_dragging = TRUE;</PRE>
<PRE>	/* Next, get the window handle of the view window.
	 * Then, create a new, temporary gstate to draw into
	 * for that window.						*/</PRE>
<PRE>    win = @call TicTacView::MSG_GEN_VIEW_GET_WINDOW();
    gstate = GrCreateState(win);</PRE>
<PRE>	/* Now, set the current position of the game piece
	 * to be centered on the pointer.						*/</PRE>
<PRE>    pself-&gt;TTP_vertPos = yPosition - (PIECE_HEIGHT/2);
    pself-&gt;TTP_horizPos = xPosition - (PIECE_WIDTH/2);</PRE>
<PRE>	/* Now, set the drawing mode of the game piece
	 * to MM_INVERT to draw a new game piece outline.
	 * MM_INVERT is chosen so the outline can be redrawn
	 * in invert mode later to erase it and not destroy
	 * anything under it.					*/</PRE>
<PRE>    GrSetMixMode(gstate, MM_INVERT);</PRE>
<PRE>	/* Now draw the outline. If the game piece is of type
	 * TTPT_BOX, draw a rectangle outline. Otherwise, draw
	 * an ellipse outline.						*/</PRE>
<PRE>    if (pself-&gt;TTP_pieceType == TTPT_BOX) {
	GrDrawRect(gstate, pself-&gt;TTP_horizPos, pself-&gt;TTP_vertPos,
				(pself-&gt;TTP_horizPos + PIECE_WIDTH),
				(pself-&gt;TTP_vertPos + PIECE_HEIGHT));</PRE>
<PRE>    } else {
	GrDrawEllipse(gstate, pself-&gt;TTP_horizPos, pself-&gt;TTP_vertPos,
				(pself-&gt;TTP_horizPos + PIECE_WIDTH),
				(pself-&gt;TTP_vertPos + PIECE_HEIGHT));
    }</PRE>
<PRE>	/* Next, destroy the temporary gstate. This is important
	 * to make sure the gstate does not stay in memory and
	 * begin to slow down the system as more and more
	 * temporary gstates are created but not destroyed.						*/</PRE>
<PRE>    GrDestroyState(gstate);</PRE>
<PRE>	/* Finally, return that this event has been processed
	 * by this method.						*/</PRE>
<PRE>    retVal-&gt;flags = MRF_PROCESSED;
}</PRE>
<PRE>/***********************************************************************
 *
 * MESSAGE:		MSG_META_PTR for TicTacPieceClass
 *
 * DESCRIPTION:		This message is received whenever the pointer passes
 *		over this game piece object's bounds (and another
 *		game piece is not sitting directly on top of it).
 *		See MSG_META_START_SELECT for a description of how the event
 *		gets passed from TicTacView to this object.
 *
 *		This message can be either a drag event or a simple
 *		pointer event. If the latter, we want to do nothing
 *		because no mouse button is pressed. If the latter,
 *		we want to execute the same function as MSG_META_DRAG.
 *
 * PARAMETERS:
 *	void (MouseReturnParams *retVal, word xPosition,
 *			word yPosition, word inputState)
 *
 ***********************************************************************/</PRE>
<PRE>@method TicTacPieceClass, MSG_META_PTR {
    GStateHandle gstate;					/* temporary gstate to draw to */
    WindowHandle win;					/* window handle of view window */</PRE>
<PRE>	/* First check if this is a drag event. If not, do
	 * nothing. If so, then draw a new outline and erase
	 * the old outline.					*/</PRE>
<PRE>    if (pself-&gt;TTP_dragging) {</PRE>
<PRE>	/* Get the view's window handle and create a
	 * temporary gstate for drawing into.					*/</PRE>
<PRE>	win = @call TicTacView::MSG_GEN_VIEW_GET_WINDOW();
	gstate = GrCreateState(win);</PRE>
<PRE>	/* Set the drawing mode of the game piece to 
	 * MM_INVERT for outline drawing.					*/</PRE>
<PRE>	GrSetMixMode(gstate, MM_INVERT);</PRE>
<PRE>	/* Erase the old outline by drawing an inverse
	 * outline at the old bounds.					*/</PRE>
<PRE>	if (pself-&gt;TTP_pieceType == TTPT_BOX) {
	    GrDrawRect(gstate, pself-&gt;TTP_horizPos, pself-&gt;TTP_vertPos,
					(pself-&gt;TTP_horizPos + PIECE_WIDTH),
					(pself-&gt;TTP_vertPos + PIECE_HEIGHT));</PRE>
<PRE>	} else {
	    GrDrawEllipse(gstate, pself-&gt;TTP_horizPos, pself-&gt;TTP_vertPos,
					(pself-&gt;TTP_horizPos + PIECE_WIDTH),
					(pself-&gt;TTP_vertPos + PIECE_HEIGHT));
	}</PRE>
<PRE>	/* Now set the current motion position to be
	 * centered on the pointer.					*/</PRE>
<PRE>	pself-&gt;TTP_vertPos = yPosition - (PIECE_HEIGHT/2);
	pself-&gt;TTP_horizPos = xPosition - (PIECE_WIDTH/2);</PRE>
<PRE>	/* Draw the new outline at the current position.*/</PRE>
<PRE>	if (pself-&gt;TTP_pieceType == TTPT_BOX) {
	    GrDrawRect(gstate, pself-&gt;TTP_horizPos, pself-&gt;TTP_vertPos,
					(pself-&gt;TTP_horizPos + PIECE_WIDTH),
					(pself-&gt;TTP_vertPos + PIECE_HEIGHT));</PRE>
<PRE>	} else {
	    GrDrawEllipse(gstate, pself-&gt;TTP_horizPos, pself-&gt;TTP_vertPos,
					(pself-&gt;TTP_horizPos + PIECE_WIDTH),
					(pself-&gt;TTP_vertPos + PIECE_HEIGHT));
	}</PRE>
<PRE>	/* Destroy the temporary gstate and return that
	 * this event has been processed.						*/</PRE>
<PRE>	GrDestroyState(gstate);
    }
    retVal-&gt;flags = MRF_PROCESSED;
}</PRE>
<PRE>/***********************************************************************
 *
 * MESSAGE:		MSG_META_END_SELECT for TicTacPieceClass
 *
 * DESCRIPTION:		This message is received when the selection button has
 *		been released and this game piece had the mouse grab.
 *		All it does is release the gadget exclusive, which will
 *		cause us to end any dragging in progress and release
 *		the mouse.
 *		When we release the gadget exclusive, the UI will then
 *		sent MSG_VIS_LOST_GADGET_EXCL to this piece, which will
 *		tell us to erase the outline and draw the game piece.
 * PARAMETERS:
 *	void (MouseReturnParams *retVal, word xPosition,
 * 			word yPosition, word inputState);
 ***********************************************************************/</PRE>
<PRE>@method TicTacPieceClass, MSG_META_END_SELECT {
	/* Release the gadget exclusive, then return that the
	 * event has been processed. */
    @call @visParent::MSG_VIS_RELEASE_GADGET_EXCL(oself);
    retVal-&gt;flags = MRF_PROCESSED; /* this event processed */
}</PRE>
<PRE>/***********************************************************************
 *
 * MESSAGE:		MSG_VIS_LOST_GADGET_EXCL for TicTacPieceClass
 *
 * DESCRIPTION:		This message is received when the piece lots go of the
 *		gadget exclusive (see MSG_META_END_SELECT, above).
 *		It first checks to see if the new, proposed bounds are
 *		on the game board. If the bounds are valid, then
 *		it sets the objects VI_bounds field to the new values
 *		and causes the object to erase its original drawing
 *		and draw itself at its new bounds. If the bounds are
 *		not on the game board, it will retain the original bounds
 *		and redraw using them.
 *
 * PARAMETERS:
 *	void ()
 *
 ***********************************************************************/</PRE>
<PRE>@method TicTacPieceClass, MSG_VIS_LOST_GADGET_EXCL {
    WindowHandle win;					/* window handle of view window */
    GStateHandle gstate;					/* temporary gstate to draw to */</PRE>
<PRE>	/* First check if the piece was being dragged.
	 * If not, we don't have to do anything.					*/
    if (pself-&gt;TTP_dragging) {</PRE>
<PRE>	/* Get the window handle of the view window and
	 * create a temporary gstate for it to draw to.						*/</PRE>
<PRE>	win = @call TicTacView::MSG_GEN_VIEW_GET_WINDOW();
	gstate = GrCreateState(win);</PRE>
<PRE>	/* Set the mode for drawing the outline.						*/</PRE>
<PRE>	GrSetMixMode(gstate, MM_INVERT);</PRE>
<PRE>	/* If the game piece type is TTPT_BOX, draw a rectangle
	 * outline. Otherwise draw an ellipse outline.						*/</PRE>
<PRE>	if (pself-&gt;TTP_pieceType == TTPT_BOX) {
	    GrDrawRect(gstate, pself-&gt;TTP_horizPos, pself-&gt;TTP_vertPos,
				((pself-&gt;TTP_horizPos) + PIECE_WIDTH),
				((pself-&gt;TTP_vertPos) + PIECE_HEIGHT));</PRE>
<PRE>	} else {
	    GrDrawEllipse(gstate, pself-&gt;TTP_horizPos, pself-&gt;TTP_vertPos,
				((pself-&gt;TTP_horizPos) + PIECE_WIDTH),
				((pself-&gt;TTP_vertPos) + PIECE_HEIGHT));
	}</PRE>
<PRE>	/* Check to see if the new bounds are on the game
	 * board. If they are, set the object's bounds to the
	 * new values. If they are not, retain the original
	 * values and set the values to those last stored.						*/</PRE>
<PRE>	if (@call TicTacBoard::MSG_TICTAC_VALIDATE_BOUNDS(
					((pself-&gt;TTP_vertPos) + PIECE_HEIGHT),
					((pself-&gt;TTP_horizPos) + PIECE_WIDTH),
					pself-&gt;TTP_vertPos,
					pself-&gt;TTP_horizPos)) {</PRE>
<PRE>	/* Invalidate the original drawing of the game piece.
	 * Send the VI_bounds rectangle as the parameters
	 * because they have not been changed since the
	 * START_SELECT. This message is the equivalent of
	 * calling GrInvalRect() with the same bounds.						*/</PRE>
<PRE>	    @call self::MSG_VIS_BOUNDS_CHANGED(pself-&gt;VI_bounds.R_bottom,
					pself-&gt;VI_bounds.R_right,
					pself-&gt;VI_bounds.R_top,
					pself-&gt;VI_bounds.R_left);</PRE>
<PRE>	/* Now set the current position to be centered
	 * on the pointer image.					*/</PRE>
<PRE>	    pself-&gt;TTP_vertPos = yPosition - (PIECE_HEIGHT/2);
	    pself-&gt;TTP_horizPos = xPosition - (PIECE_WIDTH/2);</PRE>
<PRE>	/* Set the game piece object's bounds to
	 * the new coordinates.					*/</PRE>
<PRE>	    pself-&gt;VI_bounds.R_left = pself-&gt;TTP_horizPos;
	    pself-&gt;VI_bounds.R_right = (pself-&gt;TTP_horizPos) + PIECE_WIDTH;
	    pself-&gt;VI_bounds.R_top = pself-&gt;TTP_vertPos;
	    pself-&gt;VI_bounds.R_bottom = (pself-&gt;TTP_vertPos) + PIECE_HEIGHT;</PRE>
<PRE>	} else {</PRE>
<PRE>	/* If the bounds are not on the game board, then reset
	 * the current positions to be the original bounds. */</PRE>
<PRE>	    pself-&gt;TTP_horizPos = pself-&gt;VI_bounds.R_left;
	    pself-&gt;TTP_vertPos = pself-&gt;VI_bounds.R_top;
	}</PRE>
<PRE>	/* Now, the game piece must draw itself at its newly-
	 * set bounds (will draw itself over its original
	 * picture if the new bounds were invalid).						*/</PRE>
<PRE>	@call self::MSG_VIS_DRAW(0, gstate);</PRE>
<PRE>	/* Destroy the temporary gstate used for drawing. */</PRE>
<PRE>	GrDestroyState(gstate);</PRE>
<PRE>	/* Finally, clear the dragging flag to indicate that
	 * no drag event is in progress. */</PRE>
<PRE>	pself-&gt;TTP_dragging = FALSE;
    }</PRE>
<PRE>	/* Release the mouse grab now that the move has
	 * finished. Other objects in the view (other game
	 * pieces, for example) may now receive pointer,
	 * select, and drag events.						*/</PRE>
<PRE>    @call self::MSG_VIS_RELEASE_MOUSE();</PRE>
<PRE>}</PRE>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="UIOverview_d.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="UIOverview_11.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">5.4 TicTacBoard Specifics</A> 
<!-- to next --> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
