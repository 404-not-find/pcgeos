<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- This page was automatically generated from a bunch of smaller pages. -->
<META NAME="copyright" CONTENT="Copyright GEOWORKS">
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">
<TITLE>Swat Command Reference</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffdf">
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
<A NAME="index.htm"></A>



<H1 CLASS="chapterTitle">
Swat <A NAME="index.htm_97933">
 </A>
Reference

</H1>
<P>
The descriptions of the Swat commands will follow the following notational conventions:</P>
<UL>
<LI>
<CODE>
command (alternative1|alternative2|...|alternativeN)<BR>
()</CODE>
<A NAME="index.htm_IX_):in Swat usage documentation">
 </A>
<A NAME="index.htm_IX_(:in Swat usage documentation">
 </A>
 The parentheses enclose a set of alternatives separated by a vertical line. For example, the expression <CODE>
quit (cont|leave)</CODE>
 means that either <CODE>
quit cont</CODE>
 or <CODE>
quit leave </CODE>
can be used.</LI>
<LI>
<CODE>
command [optional_argument]<BR>
[] </CODE>
<A NAME="index.htm_IX_]:in Swat usage documentation">
 </A>
<A NAME="index.htm_IX_[:in Swat usage documentation">
 </A>
The brackets enclose optional arguments to the command. For example, the command <CODE>
alias [&lt;word[&lt;command&gt;]&gt;]</CODE>
 could have zero, one, or two arguments because the &lt;<EM>command</EM>&gt; and &lt;<EM>word&gt;</EM> arguments are optional. Another example would be the command <CODE>
objwalk [&lt;addr&gt;]</CODE>
, which may take zero arguments if it is meant to use the default address, and one argument if the user gives it a particular address to look at.</LI>
<LI>
<CODE>
command &lt;type_of_argument&gt;<BR>
&lt; &gt;</CODE>
<A NAME="index.htm_IX_>:in Swat usage documentation">
 </A>
<A NAME="index.htm_IX_<:in Swat usage documentation">
 </A>
 The angled brackets enclose the type of an argument rather than the actual string to be typed. For example, <CODE>
&lt;addr&gt;</CODE>
 indicates an address expression and <CODE>
&lt;argument&gt;</CODE>
 indicates some sort of argument, but <CODE>
(addr|type)</CODE>
 means either the string <CODE>
addr</CODE>
 or the string <CODE>
type</CODE>
.</LI>
<LI>
<CODE>
*   +<BR>
</CODE>
<A NAME="index.htm_IX_+:in Swat usage documentation">
 </A>
<A NAME="index.htm_IX_*:in Swat usage documentation">
 </A>
An asterisk following any of the previous constructs indicates zero or more repetitions of the construct may be typed. An addition sign indicates one or more repetitions of the construct may be used. For example, <CODE>
unalias</CODE>
 <CODE>
word</CODE>
* can be the <CODE>
unalias</CODE>
 command by itself, or it can be followed by a list of words to be unaliased.</LI>
</UL>

<P CLASS="sectionlinks">
<STRONG>
&nbsp;&nbsp;<A HREF="#SR_1.htm">_print ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_2.htm">addr-parse ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_3.htm">alias ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_4.htm">assign ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_5.htm">bits ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_6.htm">car ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_7.htm">continue-patient ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_8.htm">dbrk ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_9.htm">debug ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_a.htm">delassoc ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_b.htm">drivewalk ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_c.htm">elist ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_d.htm">fatalerr_auto_explain ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_e.htm">flagwin ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_f.htm">fpstack ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_10.htm">func ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_11.htm">getenv ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_12.htm">handsum ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_13.htm">help ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_14.htm">hwalk ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_15.htm">imem ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_16.htm">intr ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_17.htm">keyboard ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_18.htm">load ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_19.htm">memsize ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_1a.htm">noStructEnum ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_1b.htm">objmessagebrk ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_1c.htm">patchin ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_1d.htm">pdisk ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_1e.htm">pgs ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_1f.htm">pinst ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_20.htm">pobjmon ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_21.htm">print-cell ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_22.htm">printRegions ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_23.htm">ptext ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_24.htm">pvismon ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_25.htm">read-reg ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_26.htm">ret ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_27.htm">scope ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_28.htm">showcalls ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_29.htm">smatch ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_2a.htm">stdpaths ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_2b.htm">stream ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_2c.htm">symbolCompletion ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_2d.htm">text-fixup ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_2e.htm">twalk ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_2f.htm">varwin ...</A><BR>
&nbsp;&nbsp;<A HREF="#SR_30.htm">wclear ...</A><BR>
</STRONG>
</P> <!-- end of sectionlinks blob -->
<HR>
<A NAME="SR_1.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_1.htm_IX__print Swat command">
 </A>
_print</H1>

<PRE CLASS="syntax"><A NAME="SR_1.htm_IX_Formatting Swat output"> </A>_print &lt;expression&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;_print ax-10&quot;</DT><DD>
print ax less 10 decimal.</DD>
<P>
Print the value of an expression.</P>


</DL>
<P>
The difference between this command and the &quot;print&quot; command is a subtle one: if one of the arguments contains square-brackets, the Tcl interpreter will attempt to evaluate the text between the brackets as a command before _print is given the argument. If the text between the brackets is intended to be an array index, the interpreter will generate an error before the Swat expression evaluator has a chance to decide whether the text is a nested Tcl command or an array index.</P>
<P>
 For this reason, this function is intended primarily for use by Tcl procedures, not by users.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_20.htm#IX_print Swat command:command reference">print</A>,
<A HREF="../../Tools/SwatRef/SR_2.htm#IX_addr-parse Swat command">addr-parse</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1.htm_IX_abort Swat command">
 </A>
abort</H1>

<PRE CLASS="syntax">abort [&lt;frame-number&gt;]
abort [&lt;function&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;abort&quot;</DT><DD> abort executing the current frame.</DD>
<DT>
 &quot;abort 3&quot; </DT><DD>abort executing up through the third frame.</DD>
<DT>
 &quot;abort ObjMessage&quot; </DT><DD>
abort executing up through first ObjMessage.</DD>
<P>
 Abort code execution up through a given frame or routine. By &quot;abort&quot;, we me &quot;do not execute&quot;. This can be quite dangerous, as semaphores may not be ungrabbed, blocks not unlocked, flags not cleared, etc., leaving the state of objects, and if executing system code, possibly the system itself in a bad state. This command should only be used when the only alternative is to to detach (i.e. in a fatal error) as a way to possibly prolong the usefulness of the debugging session.</P>


</DL>
<UL>
<LI>
If no argument is given, code through the current frame is aborted. </LI>
<LI>
&lt;frame num&gt; are the numbers that appear at the left of the backtrace.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_d.htm#IX_finish Swat command">finish</A>,
<A HREF="../../Tools/SwatRef/SR_4.htm#IX_backtrace Swat command:command reference">backtrace</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1.htm_IX_abortframe Swat command">
 </A>
abortframe</H1>

<PRE CLASS="syntax">abortframe &lt;frame-token&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;abortframe $cur&quot;</DT><DD>
Abort all code execution through the frame whose token is in $cur.</DD>
<P>
Aborts code execution up through a particular stack frame. As no code is executed, the registers may be in a garbaged state.</P>


</DL>
<UL>
<LI>
The argument is a frame token, as returned by the &quot;frame&quot; command.</LI>
<LI>
No FULLSTOP event is dispatched when the machine actually aborts executing in the given frame. The caller must dispatch it itself, using the &quot;event&quot; command. For information about FULLSTOP events, see the <CODE>
event</CODE>
 Tcl command.</LI>
<LI>
The command returns zero if the machine aborted executing in the given frame; non-zero if it was interrupted before that could happen. </LI>
</UL>


<HR>
<A NAME="SR_2.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_2.htm_IX_Address expressions in Swat:parsing">
 </A>
<A NAME="SR_2.htm_IX_addr-parse Swat command">
 </A>
addr-parse</H1>

<PRE CLASS="syntax">addr-parse &lt;addr&gt; [&lt;addr-only&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;addr-parse *ds:si&quot; </DT><DD>
Parse the address &quot;*ds:si&quot; into its handle, offset and data-type components. In this case, the data-type will be &quot;nil&quot;.</DD>
<DT>
 &quot;addr-parse ILLEGAL_HANDLE 0&quot; </DT><DD>
Figures the value for the enumerated constant &quot;ILLEGAL_HANDLE&quot;. The handle for this non-address will be &quot;value&quot;.</DD>
</DL>
<P>
This command parses the address expression into its components, returning a list {&lt;handle&gt; &lt;offset&gt; &lt;type&gt; } as its value.</P>


<UL>
<LI>
This will generate an error if there's an error parsing the &lt;addr&gt; </LI>
<LI>
&lt;handle&gt; is the token for the handle in which the address resides, or &quot;nil&quot; if the address is absolute. This token can be given to the &quot;handle&quot; command for further processing. </LI>
<LI>
&lt;offset&gt; is a decimal number and is the offset of the address within the block indicated by the &lt;handle&gt; token. If &lt;handle&gt; is &quot;nil&quot;, this can be a 32-bit linear address. </LI>
<LI>
&lt;type&gt; is a type token for the data at the given address, if any could be determined. For example the address &quot;ds:bx&quot; has no type, as it's just a memory reference, but &quot;ds:bx.VDE_extraData&quot; will have whatever type the structure field &quot;VDE_extraData&quot; possesses. This token can be passed to the &quot;type&quot; or &quot;value&quot; commands for further processing.</LI>
<LI>
If the expression doesn't refer to data that can be fetched from the patient (e.g. &quot;foo*3&quot;) &lt;handle&gt; will be returned as the string &quot;value&quot; instead of a normal handle token. &lt;offset&gt; is then a value-list for the resulting value, and &lt;type&gt; is the type description by means of which the value list can be interpreted. </LI>
<LI>
The optional &lt;addr-only&gt; argument is zero or non-zero to indicate the willingness or unwillingness, respectively, of the caller to receive a value list in return. If &lt;addr-only&gt; is absent or non-zero, any expression that can only be expressed as a value will generate an error. The single exception to this is if the expression involves pointer arithmetic. For example &quot;pself+1&quot; normally would be returned as a value list for a far pointer, as the result cannot be fetched from the PC. When &lt;addr-only&gt; is absent or non-zero, &quot;addr-parse&quot; pretends the expression was &quot;*(pself+1)&quot;, allowing simple specification of an address by the user for those commands that just address memory.</LI>
<LI>
The &lt;offset&gt; element of the returned list is very useful when you want to allow the user to give you anything, be it a register or a number or an enumerated constant or whatever. You can pass the argument you were given to [index [addr-parse $arg] 1] and end up with an appropriate decimal number. Be sure to pass &lt;addr-only&gt; as 0, however, or else you'll generate an error. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2e.htm#IX_value Swat command">value</A>,
<A HREF="../../Tools/Tcl/TTCL_f.htm#IX_handle Tcl structure">handle</A>,
<A HREF="../../Tools/Tcl/TTCL_f.htm#IX_type Tcl structure">type</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2.htm_IX_addr-preprocess Swat command">
 </A>
addr-preprocess</H1>

<PRE CLASS="syntax"><A NAME="SR_2.htm_IX_Address expressions in Swat:parsing"> </A>addr-preprocess &lt;addr&gt; &lt;seg-var&gt; &lt;off-var&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;addr-preprocess $args s o&quot; </DT><DD>
Parse the address expression in $args, storing the segment portion in $s and the offset portion in $o in the current scope.</DD>
</DL>

<P>
Preprocesses an address expression into a form that is easier to manipulate and faster to reparse.</P>

<UL>
<LI>
&lt;seg-var&gt; is the name of a variable in the caller's scope in which the segment of the address is stored. It should be treated as opaque, as it may or may not be numeric. </LI>
<LI>
&lt;off-var&gt; is the name of a variable in the caller's scope in which the offset of the address is stored. This will always be numeric. </LI>
<LI>
Returns the 3-list returned by addr-parse, in case you have a use for the type token stored in the list. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2.htm#IX_addr-parse Swat command">addr-parse</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2.htm_IX_addr-with-obj-flag Swat command">
 </A>
addr-with-obj-flag</H1>

<PRE CLASS="syntax">addr-with-obj-flag</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var addr [addr-with-obj-flag $addr]&quot; </DT><DD>
If $addr is &quot;-i&quot;, returns the address of the current implied grab.</DD>
</DL>
<P>
This is a utility routine that can be used by any command that deals with objects where the user may reasonably want to operate on the leaf object of one of the hierarchies, or the windowed object under the mouse. It can be given one of a set of flags that indicate where to find the address of the object on which to operate.</P>

<UL>
<LI>
Special values accepted for &lt;address&gt;:</LI>
<DL>
<DT>
            -a </DT><DD><A NAME="SR_2.htm_IX_GenApplication object">
 </A>
<A NAME="SR_2.htm_IX_Patients:application object">
 </A>
<A NAME="SR_2.htm_IX_Objects:application object">
 </A>
the current patient's application object</DD>
<DT>
            -i </DT><DD><A NAME="SR_2.htm_IX_Mouse:accessing window under, with Swat">
 </A>
the current &quot;implied grab&quot;: the windowed object over which the mouse is currently located</DD>
<DT>
            -f </DT><DD><A NAME="SR_2.htm_IX_Keyboard:focus">
 </A>
<A NAME="SR_2.htm_IX_Focus">
 </A>
the leaf of the keyboard-focus hierarchy</DD>
<DT>
            -t </DT><DD><A NAME="SR_2.htm_IX_Target:finding with Swat">
 </A>
the leaf of the target hierarchy</DD>
<DT>
            -m </DT><DD><A NAME="SR_2.htm_IX_Model:finding with Swat">
 </A>
the leaf of the model hierarchy</DD>
<DT>
            -c </DT><DD><A NAME="SR_2.htm_IX_Content:finding with Swat">
 </A>
the content for the view over which the mouse is currently located</DD>
<DT>
            -kg </DT><DD><A NAME="SR_2.htm_IX_Keyboard:finding keyboard grab with Swat">
 </A>
the leaf of the keyboard-grab hierarchy</DD>
<DT>
            -mg </DT><DD><A NAME="SR_2.htm_IX_Mouse:finding mouse grab with Swat">
 </A>
the leaf of the mouse-grab hierarchy</DD>
</DL>
<LI>
If &lt;address&gt; is empty, this will return the contents of the local variable &quot;oself&quot; within the current frame, if it has one, or *ds:si </LI>
<LI>
If &lt;address&gt; isn't one of the above, this just returns &lt;address&gt;. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_15.htm#IX_impliedgrab Swat command">impliedgrab</A>,
<A HREF="../../Tools/SwatRef/SR_6.htm#IX_content Swat command">content</A>,
<A HREF="../../Tools/SwatRef/SR_e.htm#IX_focusobj Swat command">focusobj</A>,
<A HREF="../../Tools/SwatRef/SR_2c.htm#IX_targetobj Swat command">targetobj</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_modelobj Swat command">modelobj</A>,
<A HREF="../../Tools/SwatRef/SR_17.htm#IX_keyboardobj Swat command">keyboardobj</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_mouseobj Swat command">mouseobj</A>.


<HR>
<A NAME="SR_3.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_3.htm_IX_Command completion in Swat:abbreviations">
 </A>
<A NAME="SR_3.htm_IX_alias Swat command:command reference">
 </A>
alias</H1>

<PRE CLASS="syntax">alias [&lt;name&gt; [&lt;body&gt;]]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;alias p print&quot; </DT><DD>
Execute &quot;print&quot; when the user types the command &quot;p&quot;. Any arguments to &quot;p&quot; get passed to &quot;print&quot; in the order they were given.</DD>
<DT>
 &quot;alias while {for {} $1 {} $2}&quot; </DT><DD>
Executes an appropriate &quot;for&quot; loop when the &quot;while&quot; command is executed with its two arguments: a test expression and a body of commands to execute. </DD>
<DT>
&quot;alias&quot; </DT><DD>Prints all the defined aliases.</DD>
<DT>
&quot;alias while&quot; </DT><DD>
Prints what the &quot;while&quot; command is aliased to.</DD>
</DL>
<P>
 This is a short-cut to allow you to make commands you commonly type easier to use, and to define simple new commands quickly.</P>


<UL>
<LI>
If you give no arguments the current aliases are all displayed.</LI>
<LI>
If you give a single argument, the name of an existing alias, the command that will be executed when you use the alias is printed.</LI>
<LI>
The &lt;body&gt; string is usually in curly braces, as it usually involves whitespace and can contain newlines for the longer aliases.</LI>
<LI>
You can use the pseudo-variables $1, $2, etc. in the &lt;body&gt; to represent the 1st, 2nd, etc. argument given when the alias is invoked. They are pseudo-variables as the &quot;var&quot; command will not operate on them, nor are they available to any procedure invoked by the alias.</LI>
<LI>
You can also interpolate a range of the arguments using $&lt;start&gt;-&lt;end&gt;. If you do not give an &lt;end&gt;, then the arguments from &lt;start&gt; to the last one will be interpolated.</LI>
<LI>
$* will interpolate all the arguments.</LI>
<LI>
$# will interpolate the actual number of arguments.</LI>
<LI>
If you do not use any of these pseudo-variables, all the arguments given to the alias will be appended to the &lt;body&gt;.</LI>
<LI>
Interpolation of the values for these pseudo-variables occurs regardless of braces in the &lt;body&gt;.</LI>
<LI>
It is an error to specify an argument number when there are fewer than that many arguments given to the alias.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2e.htm#IX_unalias Swat command">unalias</A>.



<H1 CLASS="refHeading">
<A NAME="SR_3.htm_IX_Structures:formatting Swat output">
 </A>
<A NAME="SR_3.htm_IX_alignFields Swat variable">
 </A>
alignFields</H1>

<PRE CLASS="syntax">var alignFields [(0|1)]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var alignFields 1&quot; </DT><DD>
Sets the &quot;print&quot; command to align the values for all the fields of a given structure.</DD>
</DL>
<P>
Determines whether structure-field values follow immediately after the field name or if all values are indented to the same level. The &quot;print&quot; command and other display commands use this variable when formatting their output.</P>


<UL>
<LI>
Having all values indented to the same level makes it easier for some people to locate a particular field in a structure. It is not without cost, however, in that Swat must determine the length of the longest field name before it can print anything. </LI>
<LI>
The default value for this variable is zero.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_20.htm#IX_print Swat command:command reference">print</A>.



<H1 CLASS="refHeading">
<A NAME="SR_3.htm_IX_antifreeze Swat command">
 </A>
antifreeze</H1>

<PRE CLASS="syntax">antifreeze &lt;patient&gt;
antifreeze :&lt;n&gt;
antifreeze &lt;patient&gt;:&lt;n&gt;
antifreeze &lt;id&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;antifreeze term&quot;</DT><DD>
Promotes the application thread for &quot;term&quot; to be the &quot;most-runnable&quot;</DD>
<DT>
&quot;antifreeze :1&quot;</DT><DD>
Does likewise for thread #1 of the current patient</DD>
<DT>
&quot;antifreeze 16c0h&quot; </DT><DD>
Does likewise the thread whose handle is 16c0h</DD>
<DT>
&quot;antifreeze&quot;</DT><DD>Promotes the current thread to be the &quot;most-runnable.&quot;</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_f.htm#IX_freeze Swat command">freeze</A>.



<H1 CLASS="refHeading">
<A NAME="SR_3.htm_IX_antithaw Swat command">
 </A>
antithaw</H1>

<PRE CLASS="syntax">antithaw &lt;patient&gt;
antithaw :&lt;n&gt;
antithaw &lt;patient&gt;:&lt;n&gt;
antithaw &lt;id&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;antithaw term&quot;</DT><DD>
Allows the application thread for &quot;term&quot; to run normally.</DD>
<DT>
&quot;antithaw :1&quot;</DT><DD>
Allows thread #1 of the current patient to run normally.</DD>
<DT>
&quot;antithaw 16c0h&quot; </DT><DD>
Allow the thread whose handle is 16c0h to run normally.</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2d.htm#IX_thaw Swat command">thaw</A>.



<H1 CLASS="refHeading">
<A NAME="SR_3.htm_IX_appobj Swat command">
 </A>
appobj</H1>

<PRE CLASS="syntax"><A NAME="SR_3.htm_IX_GenApplication object"> </A><A NAME="IX_Objects:application object"> </A><A NAME="IX_Patients:application object"> </A>appobj [&lt;patient&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pobj [appobj draw]&quot; </DT><DD>
prints the GenApplication object for draw.</DD>
<DT>
&quot;pobj [appobj]&quot;</DT><DD>
prints the GenApplication object for the current application (equivalent to &quot;pobj -a&quot;).</DD>
</DL>
<P>
Returns the address of the GenApplication object for the given patient, or the current one if you give no patient.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_15.htm#IX_impliedgrab Swat command">impliedgrab</A>.



<H1 CLASS="refHeading">
<A NAME="SR_3.htm_IX_Swat:online help">
 </A>
<A NAME="SR_3.htm_IX_apropos Swat command">
 </A>
apropos</H1>

<PRE CLASS="syntax">apropos [&lt;string&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;apropos vis&quot; </DT><DD>
Find all commands related to vis</DD>
<DT>
 &quot;apropos text&quot; </DT><DD>
Find all commands related to text </DD>
<P>
Search the list of commands and command help for all entries containing &lt;string&gt;. Lists each command and its synopsis. </P>


</DL>
<P>
&lt;string&gt; may actually be a pattern, as described in the help for the &quot;string&quot; command (under &quot;string match&quot;). It automatically has a leading and following * tacked onto it to cause it to match anywhere within a help string.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_13.htm#IX_help Swat command:command reference">help</A>.



<H1 CLASS="refHeading">
<A NAME="SR_3.htm_IX_Arrays in Swat:setting elements">
 </A>
<A NAME="SR_3.htm_IX_aset Swat command">
 </A>
aset</H1>

<PRE CLASS="syntax">aset &lt;array-name&gt; &lt;index&gt; &lt;value&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;aset foo $i $n&quot;</DT><DD>
Sets the $i'th element (counting from zero) of the value stored in the variable foo to $n.</DD>
</DL>
<P>
Allows you to treat a list stored in a variable as an array, setting arbitrary elements of that array to arbitrary values.</P>


<UL>
<LI>
&lt;array-name&gt; is the name of the variable, not the value of the variable to be altered.</LI>
<LI>
This command returns nothing.</LI>
<LI>
The index must be within the bounds of the current value for the variable. If it is out of bounds, aset will generate an error.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_index Tcl command">index</A>.



<H1 CLASS="refHeading">
<A NAME="SR_3.htm_IX_Associative lists in Swat:searching">
 </A>
<A NAME="SR_3.htm_IX_assoc Swat command">
 </A>
assoc</H1>

<PRE CLASS="syntax">assoc &lt;list&gt; &lt;key&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;assoc $classes GenPrimaryClass&quot;</DT><DD>
Examines the sublists of $classes and returns the first one whose first element is the string GenPrimaryClass.</DD>
</DL>
<P>
 Searches an associative list to find an element with a particular key. The list is itself made up of lists, each of whose first element is a key.</P>


<UL>
<LI>
 A typical associative list is made of key/value pairs, like this:<BR>
 {{&lt;key&gt; &lt;value&gt;} {&lt;key&gt; &lt;value&gt;} ...}</LI>
<LI>
 If an element is found whose &lt;key&gt; matches the passed &lt;key&gt;, the entire element is returned as the result. If no &lt;key&gt; matches, nil is returned.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_6.htm#IX_car Swat command">car</A>,
<A HREF="../../Tools/SwatRef/SR_6.htm#IX_cdr Swat command">cdr</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_range Tcl command">range</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_list Tcl command">list</A>,
<A HREF="../../Tools/SwatRef/SR_a.htm#IX_delassoc Swat command">delassoc</A>.


<HR>
<A NAME="SR_4.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_4.htm_IX_Variables:assign Swat command">
 </A>
<A NAME="SR_4.htm_IX_Registers:setting value with Swat">
 </A>
<A NAME="SR_4.htm_IX_assign Swat command:command reference">
 </A>
assign</H1>

<PRE CLASS="syntax">assign &lt;addr&gt; &lt;value&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;assign ip ip+2&quot; 	</DT><DD>
Add 2 to the value of IP in the current frame.</DD>
<DT>
 &quot;assign {word ds:si} 63h&quot; </DT><DD>
Store 63h in the word at ds:si</DD>
</DL>
</DL>
<P>
Performs an assignment to a patient variable or register (but not to an element of the value history). The first argument is the variable or register to be assigned and the second argument is the value to assign to it (which may be a regular address expression). If the first expression doesn't indicate a type, &quot;word&quot; is assumed. Only <CODE>
byte</CODE>
, <CODE>
word</CODE>
 or <CODE>
dword</CODE>
 types are supported.</P>


<UL>
<LI>
When assigning to an sptr, the value assigned will be the segment of the block indicated by the &lt;value&gt;, unless &lt;value&gt; is an absolute address (or just a number), in which case the low 16 bits of the offset will be used instead.</LI>
<LI>
Similar behavior occurs when assigning to an fptr, except if the &lt;value&gt; is an absolute address, in which case the linear address in the offset portion of the &lt;value&gt; will be decomposed into a segment and an offset.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_15.htm#IX_imem Swat command:command reference">imem</A>,
<A HREF="../../Tools/SwatRef/SR_2e.htm#IX_value Swat command">value</A>.



<H1 CLASS="refHeading">
<A NAME="SR_4.htm_IX_att Swat command:command reference">
 </A>
att</H1>

<PRE CLASS="syntax">att [&lt;args&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;att&quot;</DT><DD>attach Swat to GEOS.</DD>
<P>
Attach Swat to GEOS.</P>


</DL>
<P>
The args argument can be one of the following:</P>
<DL>
<DT>
-s</DT><DD>reboot GEOS with error checking, attach, and stop</DD>
<DT>
-sn</DT><DD>reboot GEOS without error checking, attach, and stop</DD>
<DT>
-f</DT><DD>restart GEOS with error checking and attach after a pause</DD>
<DT>
-r</DT><DD>restart GEOS with error checking and attach</DD>
<DT>
-rn</DT><DD>restart GEOS without error checking and attach</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_a.htm#IX_detach Swat command:command reference">detach</A>,
<A HREF="../../Tools/SwatRef/SR_24.htm#IX_quit Swat command:command reference">quit</A>.



<H1 CLASS="refHeading">
<A NAME="SR_4.htm_IX_attach Swat command:command reference">
 </A>
attach</H1>

<PRE CLASS="syntax">attach [&lt;boot&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;attach&quot;</DT><DD>attach to the target PC</DD>
</DL>
<P>
Attach swat to the target PC.</P>


<UL>
<LI>
The boot argument is &quot;-b&quot; to bootstrap and &quot;+b&quot; to not. Normally, Swat will try to read symbolic information about all running geodes; bootstrapping specifies that Swat should only read symbolic information for these geodes when it must. </LI>
<LI>
If you give no &lt;boot&gt; argument, swat will use the most-recent one.</LI>
<LI>
By default, swat will locate the symbols for all geodes and threads active on the PC when it attaches.</LI>
<LI>
If any geode has changed since you detached from the PC, its symbols are re-read.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_4.htm#IX_att Swat command:command reference">att</A>,
<A HREF="../../Tools/SwatRef/SR_a.htm#IX_detach Swat command:command reference">detach</A>,
<A HREF="../../Tools/SwatRef/SR_24.htm#IX_quit Swat command:command reference">quit</A>.



<H1 CLASS="refHeading">
<A NAME="SR_4.htm_IX_Tcl:loading command files">
 </A>
<A NAME="SR_4.htm_IX_Files:loading Tcl files">
 </A>
<A NAME="SR_4.htm_IX_autoload Swat command:command reference">
 </A>
autoload</H1>

<PRE CLASS="syntax">autoload &lt;function&gt; &lt;flags&gt; &lt;file&gt; [&lt;class&gt; &lt;docstring&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;autoload cycles 1 timing&quot;</DT><DD>
load the file &quot;timing.tcl&quot; when the cycles command is first executed. The user must type the command completely.</DD>
<DT>
&quot;autoload print 2 print&quot;</DT><DD>
load the file &quot;print.tcl&quot; when the print command is first executed. The user may abbreviate the command and the Tcl interpreter will not evaluate its arguments.</DD>
</DL>
<P>
This command allows the first invocation of a command to automatically force the transparent reading of a file of Tcl commands.</P>


<UL>
<LI>
autoload takes 3 or 5 arguments: the command, an integer with bit flags telling how the interpreter should invoke the command, the file that should be read to define the command (this may be absolute or on load-path) and an optional help class and string for the command.</LI>
<LI>
The help class and string need only be given if the file to be loaded isn't part of the system library (doesn't have its help strings extracted when Swat is built).</LI>
<LI>
The &lt;flags&gt; argument has the following bit-flags:</LI>
</UL>
<DL>
<DT>
0</DT><DD>User must type the command's name exactly. The command will be defined by &quot;defsubr&quot; or &quot;defdsubr&quot; when &lt;file&gt; is loaded.</DD>
<DT>
1</DT><DD>The interpreter will not evaluate arguments passed to the command. All arguments will be merged into a single string and passed to the command as one argument. The command will use the special &quot;noeval&quot; argument when it is defined.</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_defsubr Tcl command">defsubr</A>,
<A HREF="../../Tools/SwatRef/SR_9.htm#IX_defcommand Swat command">defcommand</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_proc Tcl command">proc</A>.



<H1 CLASS="refHeading">
<A NAME="SR_4.htm_IX_Patients:listing active frames of">
 </A>
<A NAME="SR_4.htm_IX_Stack:examining backtrace">
 </A>
<A NAME="SR_4.htm_IX_backtrace Swat command:command reference">
 </A>
backtrace</H1>

<PRE CLASS="syntax">backtrace [-r&lt;reg&gt;* ][&lt;frames to list&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;backtrace&quot;</DT><DD>print all the frames in the patient</DD>
<DT>
&quot;backtrace -rax&quot;</DT><DD>
print all the frames and the contents of AX in each one.</DD>
<DT>
&quot;where 5&quot;</DT><DD>print the last five frames</DD>
<DT>
&quot;w 5&quot;</DT><DD>print the last five frames</DD>
</DL>
<P>
Print all the active stack frames for the patient.</P>


<UL>
<LI>
The &lt;frames to list&gt; argument is the number of frames to print. If not specified, then all are printed.</LI>
<LI>
If a numeric argument is not passed to backtrace then it attempts to display method calls in the form:</LI>
<PRE>        MSG_NAME(cx, dx, bp) =&gt; className (^l####h:####h)</PRE>
<P>
	      Here &lt;cx&gt;, &lt;dx&gt;, and &lt;bp&gt; are the values passed in these registers. &lt;className&gt; is the name of the class which handled the message. ^l####h:####h is the address of the object (block, chunk handle) handling the message.</P>
<LI>
If a numeric argument is passed to backtrace then the attempt to decode the message is not done and the single line above expands into:</LI>
<PRE>	 far ProcCallModuleRoutine(), geodesResource.asm:476
	 near ObjCallMethodTable(), objectClass.asm:1224</PRE>
<P>
	      This is generally less useful, but sometimes it's what you need. </P>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2e.htm#IX_up Swat command">up</A>,
<A HREF="../../Tools/SwatRef/SR_a.htm#IX_down Swat command">down</A>,
<A HREF="../../Tools/SwatRef/SR_10.htm#IX_func Swat command">func</A>.

<H1 CLASS="refHeading">
bin</H1>

<PRE CLASS="syntax">bin &lt;number&gt; [&lt;field-width&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;bin 5&quot;</DT><DD> returns &quot;0101&quot; (five in binary)</DD>
<DT>
&quot;bin 10h&quot;</DT><DD>returns &quot;0001 0000&quot;</DD>
<DT>
&quot;bin 10h 3&quot; </DT><DD>returns &quot;0000 0001 0000&quot;</DD>
</DL>
<P>
Prints numbers in binary.</P>


<UL>
<LI>
The field width is in nibbles.</LI>
<LI>
The default field width is the minium number of nibbles to display the number.</LI>
</UL>

<H1 CLASS="refHeading">
<A NAME="SR_4.htm_IX_Key bindings in Swat">
 </A>
<A NAME="SR_4.htm_IX_bindings Swat command">
 </A>
bindings</H1>

<PRE CLASS="syntax">bindings</PRE>
<P>
Shows all current key bindings</P>



<H1 CLASS="refHeading">
<A NAME="SR_4.htm_IX_Key bindings in Swat">
 </A>
<A NAME="SR_4.htm_IX_bind-key Swat command">
 </A>
bind-key</H1>

<PRE CLASS="syntax">bind-key &lt;ascii_value&gt; &lt;function&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;bind-key \321 scroll_srcwin_down&quot;</DT><DD>
Binds scroll-down key to the scroll_srcwin_down Tcl routine.</DD>
</DL>
<P>
Binds an ASCII value to a function.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_3.htm#IX_alias Swat command:command reference">alias</A>,
<A HREF="../../Tools/SwatRef/SR_2e.htm#IX_unbind-key Swat command">unbind-key</A>.


<HR>
<A NAME="SR_5.htm"></A>



<H1 CLASS="refHeading">
bits</H1>

<PRE CLASS="syntax">bits [&lt;address&gt;] [&lt;length&gt;] [&lt;type&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;bits&quot; </DT><DD>lists 16 bytes worth of bits at ds:si</DD>
<DT>
    &quot;bits ds:di 8&quot; 	</DT><DD>
lists 8 bytes worth of bits at ds:di</DD>
<DT>
    &quot;bits ds:di 24 w&quot; </DT><DD>
lists 24 words worth of bits at ds:di</DD>
</DL>
<P>
Examine memory as a dump of bits in sets of 8, 16, or 32 (byte,word, or dword).</P>

<UL>
<LI>
The address argument is the address to examine.  If not specified, the address after the last examined memory location is used.  If no address has been examined then ds:si is used for the address.</LI>
<LI>
The length argument is the number of units to examine.  It defaults to 16.</LI>
<LI>
They type argument is bytes, words or dwords.  It defaults to bytes.</LI>
<LI>
Pressing return after this command continues the list.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_5.htm_IX_break-taken Swat command">
 </A>
break-taken</H1>

<PRE CLASS="syntax"><A NAME="SR_5.htm_IX_Breakpoints:detecting"> </A>break-taken [&lt;flag&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;break-taken&quot;	</DT><DD>
Returns 1 if the machine stopped because of a breakpoint.</DD>
<DT>
&quot;break-taken 0&quot;</DT><DD>
Specify that no breakpoint was actually taken to stop the machine.</DD>
<P>
Obscure. This is used to determine if the machine stopped because a breakpoint was hit and taken.</P>


</DL>
<P>
Setting the <CODE>
break-taken</CODE>
 flag is a rather obscure operation. It is useful primarily in complex commands that single-step the machine until a particular address is reached, or a breakpoint is taken when a breakpoint must be used to skip over a procedure call, or condense multiple iterations of an instruction with a REP prefix into 1. For an example of this use, refer to the &quot;cycles&quot; command. </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_f.htm#IX_brk Tcl structure:command reference">brk</A>,
<A HREF="../../Tools/SwatRef/SR_16.htm#IX_irq Swat command">irq</A>.



<H1 CLASS="refHeading">
<A NAME="SR_5.htm_IX_brkload Swat command">
 </A>
<A NAME="SR_5.htm_IX_Breakpoints:on handles">
 </A>
<A NAME="SR_5.htm_IX_Handles:monitoring with Swat">
 </A>
brkload</H1>

<PRE CLASS="syntax">brkload [&lt;handle&gt;] </PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;brkload Interface&quot; </DT><DD>
Stop the machine when the Interface resource is loaded or swapped in.</DD>
<DT>
 &quot;brkload bx&quot;</DT><DD>Stop the machine when the resource whose handle ID is in BX is loaded or swapped in.</DD>
<DT>
 &quot;brkload&quot; </DT><DD>Stop watching for the previously-specified resource to be loaded.</DD>
</DL>
<P>
Stop the machine when a particular resource is loaded into memory.</P>


<UL>
<LI>
Only one brkload may be active at a time; registering a second one automatically unregisters the first. </LI>
<LI>
If you give no &lt;handle&gt; argument, the previously-set brkload will be unregistered.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_f.htm#IX_handle Tcl structure">handle</A>.



<H1 CLASS="refHeading">
<A NAME="SR_5.htm_IX_byteAsChar Swat variable">
 </A>
byteAsChar</H1>

<PRE CLASS="syntax">var byteAsChar [(0|1)]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var byteAsChar 1&quot; </DT><DD>
Print byte variables as characters.</DD>
</DL>
<P>
Determines how unsigned character variables are printed: if set non-zero, they are displayed as characters, else they are treated as unsigned integers.</P>


<UL>
<LI>
If $<EM>byteAsChar</EM>
 is 0, $<EM>intFormat</EM> is used. </LI>
<LI>
The default value for this variable is 0.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_5.htm_IX_Memory:examining with Swat">
 </A>
<A NAME="SR_5.htm_IX_Text:displaying bytes as">
 </A>
<A NAME="SR_5.htm_IX_bytes Swat command:command reference">
 </A>
bytes</H1>

<PRE CLASS="syntax">bytes [&lt;address&gt;] [&lt;length&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;bytes&quot;</DT><DD>lists 16 bytes at DS:SI</DD>
<DT>
&quot;bytes ds:di 32&quot;</DT><DD>
lists 32 bytes at DS:SI</DD>
</DL>
<P>
Examine memory as a dump of bytes and characters.</P>

<UL>
<LI>
The &lt;address&gt; argument is the address to examine. If not specified, the address after the last examined memory location is used. If no address has been examined then DS:SI is used for the address.</LI>
<LI>
The &lt;length&gt; argument is the number of bytes to examine. It defaults to 16.</LI>
<LI>
Pressing &lt;Return&gt; after this command continues the list.</LI>
<LI>
Characters which are not typical ASCII values are displayed as a period.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_30.htm#IX_words Swat command:command reference">words</A>,
<A HREF="../../Tools/SwatRef/SR_b.htm#IX_dwords Swat command:command reference">dwords</A>,
<A HREF="../../Tools/SwatRef/SR_15.htm#IX_imem Swat command:command reference">imem</A>,
<A HREF="../../Tools/SwatRef/SR_4.htm#IX_assign Swat command:command reference">assign</A>.



<H1 CLASS="refHeading">
<A NAME="SR_5.htm_IX_call Swat command">
 </A>
call</H1>

<PRE CLASS="syntax"><A NAME="SR_5.htm_IX_Routines:calling from Swat"> </A>call &lt;function&gt; [&lt;function args&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	&quot;call MyFunc&quot;<BR>
&quot;call MyDraw ax 1 bx 1 cx 10h dx 10h&quot;<BR>
&quot;call FindArea box.bottom 5 box.right 5 push box&quot;'</P>
<P>
Call a function in the current thread.</P>

<UL>
<LI>
The &lt;function&gt; argument is the function to call. If it is a NEAR function, the thread must already be executing in the function's segment.</LI>
<LI>
The function arguments are in pairs &lt;variable/register&gt; &lt;value&gt;. These pairs are passed to the &quot;assign&quot; command. As a special case, if the variable is &quot;push&quot;, the value (a word) is pushed onto the stack and is popped when the call finishes (if it completes successfully).</LI>
<LI>
All current registers are preserved and restored when the call is complete. Variables are not.</LI>
<LI>
Once the call has completed, you are left in a sub-interpreter to examine the state of the machine. Type &quot;break&quot; to get back to the top level.</LI>
<LI>
If the machine stops for any other reason than the call's completion, the saved register state is discarded and you are left wherever the machine stopped. You will not be able to get a stack trace above the called function, but if the call eventually completes, and no registers have actually been modified, things will get back on track.</LI>
<LI>
You may not call a function from a thread that has retreated into the kernel. This function also will not allow you to call <CODE>
ThreadExit()</CODE>
. Use the &quot;exit&quot; function to do that.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_4.htm#IX_assign Swat command:command reference">assign</A>,
<A HREF="../../Tools/SwatRef/SR_5.htm#IX_call-patient Swat command">call-patient</A>,
<A HREF="../../Tools/SwatRef/SR_1b.htm#IX_patch Swat command">patch</A>.



<H1 CLASS="refHeading">
<A NAME="SR_5.htm_IX_Routines:calling from Swat">
 </A>
<A NAME="SR_5.htm_IX_call-patient Swat command">
 </A>
call-patient</H1>

<PRE CLASS="syntax">call-patient &lt;function&gt; ((&lt;reg&gt;|push) &lt;value&gt;)*</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;call-patient MemLock bx $h&quot; </DT><DD>
Locks down the block whose handle ID is in $h.</DD>
</DL>
<P>
This is a utility routine, not intended for use from the command line, that will call a routine in the PC after setting registers to or pushing certain values. </P>


<UL>
<LI>
Returns non-zero if the call completed successfully. </LI>
<LI>
If the call is successful, the registers reflect the state of the machine upon return from the called routine. The previous machine state is preserved and can be retrieved, by invoking restore-state, or thrown away, by invoking discard-state. The caller <EM>
must</EM>
 invoke one of these to clean up. </LI>
<LI>
Arguments after &lt;function&gt; are as for &quot;call&quot;. </LI>
<LI>
If the called routine is in movable memory, this will lock the containing block down before issuing the call, as you'd expect. </LI>
<LI>
Calling anything that makes message calls while on the geos:0 thread is a hazardous undertaking at best.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_5.htm#IX_call Swat command">call</A>.


<HR>
<A NAME="SR_6.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_6.htm_IX_Lists in Swat:car Swat command">
 </A>
<A NAME="SR_6.htm_IX_car Swat command">
 </A>
car</H1>

<PRE CLASS="syntax">car &lt;list&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;car $args&quot;</DT><DD>Returns the first element of $args.</DD>
</DL>
<P>
Returns the first element of a list.</P>


<P>
This is a lisp-ism for those most comfortable with that language. It can be more-efficiently implemented by saying [index &lt;list&gt; 0]</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_6.htm#IX_cdr Swat command">cdr</A>.



<H1 CLASS="refHeading">
<A NAME="SR_6.htm_IX_Lists in Swat:cdr Swat command">
 </A>
<A NAME="SR_6.htm_IX_cdr Swat command">
 </A>
cdr</H1>

<PRE CLASS="syntax">cdr &lt;list&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;cdr $args&quot;</DT><DD>Returns the remaining arguments yet to be processed.</DD>
</DL>
<P>
Returns all but the first element of a list.</P>


<P>
This is a lisp-ism for those most comfortable with that language. It can be more-efficiently implemented by saying [range &lt;list&gt; 1 end]</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_6.htm#IX_car Swat command">car</A>.



<H1 CLASS="refHeading">
<A NAME="SR_6.htm_IX_classes Swat command">
 </A>
classes</H1>

<PRE CLASS="syntax">classes [&lt;patient&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;classes &quot;</DT><DD>Print list of classes in current patient.</DD>
<DT>
&quot;classes myapp&quot;</DT><DD>
Print list of classes in myapp patient.</DD>
</DL>
<P>
Prints list of classes defined by the given patient.</P>


<P>
Remember that &quot;brk&quot; will take address arguments of the form &lt;class&gt;::&lt;message&gt;, so you can use this function and set a breakpoint using &quot;brk MyTextClass::<CODE>
MSG_MY_TEXT_MESSAGE</CODE>
&quot;. If you need a breakpoint that's limited to one object, use objbrk instead.</P>



<H1 CLASS="refHeading">
<A NAME="SR_6.htm_IX_Registers:flag register:clearing flags with Swat">
 </A>
<A NAME="SR_6.htm_IX_Flags register:clearing with Swat">
 </A>
<A NAME="SR_6.htm_IX_clrcc Swat command">
 </A>
clrcc</H1>

<PRE CLASS="syntax">clrcc &lt;flag&gt; [&lt;value&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;clrcc c&quot;</DT><DD>clear the carry flag</DD>
</DL>
<P>
Clear a flag in the target computer.</P>


<P>
The first argument is the first letter of the flag to clear. The following is a list of the flags:<BR>
<STRONG>
t</STRONG>
		trap<BR>
<STRONG>
i	</STRONG>
	interrupt enable<BR>
<STRONG>
d</STRONG>
		direction<BR>
<STRONG>
o</STRONG>
		overflow<BR>
<STRONG>
s	</STRONG>
	sign<BR>
<STRONG>
z</STRONG>
		zero<BR>
<STRONG>
a	</STRONG>
	auxiliary carry<BR>
<STRONG>
p</STRONG>
		parity<BR>
<STRONG>
c	</STRONG>
	carry</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_27.htm#IX_setcc Swat command">setcc</A>,
<A HREF="../../Tools/SwatRef/SR_6.htm#IX_compcc Swat command">compcc</A>,
<A HREF="../../Tools/SwatRef/SR_10.htm#IX_getcc Swat command">getcc</A>.



<H1 CLASS="refHeading">
<A NAME="SR_6.htm_IX_Display windows in Swat:columns Swat command">
 </A>
<A NAME="SR_6.htm_IX_columns Swat command">
 </A>
columns</H1>

<PRE CLASS="syntax">columns</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;columns&quot;</DT><DD>
Return the number of columns on the screen.</DD>
</DL>
<P>
Retrieves the width of the screen, if known, to allow various commands (most notably &quot;print&quot;) to size their output accordingly.</P>



<H1 CLASS="refHeading">
<A NAME="SR_6.htm_IX_Registers:flags register:complementing flags with Swat">
 </A>
<A NAME="SR_6.htm_IX_Flags register:complementing flags with Swat">
 </A>
<A NAME="SR_6.htm_IX_compcc Swat command">
 </A>
compcc</H1>

<PRE CLASS="syntax">compcc &lt;flag&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;compcc c&quot;</DT><DD>complement the carry flag</DD>
</DL>
<P>
Complement a flag in the target computer.</P>


<P>
The first argument is the first letter of the flag to complement. The following is a list of the flags:<BR>
<STRONG>
t</STRONG>
		trap<BR>
<STRONG>
i	</STRONG>
	interrupt enable<BR>
<STRONG>
d</STRONG>
		direction<BR>
<STRONG>
o	</STRONG>
	overflow<BR>
<STRONG>
s	</STRONG>
	sign<BR>
<STRONG>
z</STRONG>
		zero<BR>
<STRONG>
a</STRONG>
		auxiliary carry<BR>
<STRONG>
p</STRONG>
		parity<BR>
<STRONG>
c	</STRONG>
	carry<BR>
This command is handy to insert in a patch to flip a flag bit.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_27.htm#IX_setcc Swat command">setcc</A>,
<A HREF="../../Tools/SwatRef/SR_6.htm#IX_clrcc Swat command">clrcc</A>.



<H1 CLASS="refHeading">
<A NAME="SR_6.htm_IX_Strings in Swat:common prefix">
 </A>
<A NAME="SR_6.htm_IX_Command completion in Swat:completion Swat command">
 </A>
<A NAME="SR_6.htm_IX_Swat:command completion">
 </A>
<A NAME="SR_6.htm_IX_completion Swat command">
 </A>
completion</H1>

<PRE CLASS="syntax">completion &lt;list-of-names&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;completion {martial marital}&quot;</DT><DD>
Returns &quot;mar,&quot; the common prefix.</DD>
</DL>
<P>
Figures the common prefix from a set of strings. Used for the various forms of completion supported by top-level-read.</P>

<H1 CLASS="refHeading">
<A NAME="SR_6.htm_IX_Structures:formatting Swat output">
 </A>
<A NAME="SR_6.htm_IX_condenseSmall Swat variable">
 </A>
condenseSmall</H1>

<PRE CLASS="syntax">var condenseSmall [(0|1)]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var condenseSpecial 0&quot; </DT><DD>
Force even small structures to be printed one field per line.</DD>
</DL>
<P>
Controls whether &quot;print&quot; attempts to condense the output by printing small (&lt; 4 bytes) structures (which are usually records in assembly language) as a list of &lt;name&gt; = &lt;int&gt;, where &lt;name&gt; is the field name and &lt;int&gt; is a signed integer.</P>


<P>
The default value of this variable is one.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_20.htm#IX_print Swat command:command reference">print</A>,
<A HREF="../../Tools/SwatRef/SR_6.htm#IX_condenseSpecial Swat variable">condenseSpecial</A>.



<H1 CLASS="refHeading">
<A NAME="SR_6.htm_IX_Structures:formatting Swat output">
 </A>
<A NAME="SR_6.htm_IX_condenseSpecial Swat variable">
 </A>
condenseSpecial</H1>

<PRE CLASS="syntax">var condenseSpecial [(0|1)]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var condenseSpecial 0&quot; </DT><DD>
Turns off the special formatting of various types of structures by &quot;print&quot;.</DD>
</DL>
<P>
Controls the formatting of certain structures in more-intuitive ways than the bare structure fields.</P>

<UL>
<LI>
The default value of this variable is 1. </LI>
<LI>
The current list of structures treated specially are: <CODE>
Semaphore</CODE>, <CODE>
Rectangle</CODE>, Output Descriptor, <CODE>
TMatrix</CODE>, <CODE>
BBFixed</CODE>, <CODE>
WBFixed</CODE>, <CODE>
WWFixed</CODE>, <CODE>
DWFixed</CODE>, <CODE>
WDFixed</CODE>, <CODE>
DDFixed</CODE>, <CODE>
FileDate</CODE>, <CODE>
FileTime</CODE>, <CODE>
FloatNum</CODE>, <CODE>
SpecWinSizeSpec</CODE>.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_20.htm#IX_print Swat command:command reference">print</A>,
<A HREF="../../Tools/SwatRef/SR_6.htm#IX_condenseSmall Swat variable">condenseSmall</A>.



<H1 CLASS="refHeading">
<A NAME="SR_6.htm_IX_Errors:continuing after in Swat">
 </A>
<A NAME="SR_6.htm_IX_cont Swat command:command reference">
 </A>
cont</H1>

<PRE CLASS="syntax">cont</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;cont&quot;</DT><DD>continue execution</DD>
<DT>
&quot;c&quot;</DT><DD>continue execution</DD>

</DL>
<P>
Continue GEOS.</P>

<UL>
<LI>
If the global variable <CODE>
waitForPatient</CODE>
 is non-zero, this command waits for the machine to stop again before it returns.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_11.htm#IX_go Swat command">go</A>,
<A HREF="../../Tools/SwatRef/SR_16.htm#IX_istep Swat command:command reference">istep</A>,
<A HREF="../../Tools/SwatRef/SR_2a.htm#IX_step Swat command">step</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_next Swat command">next</A>,
<A HREF="../../Tools/SwatRef/SR_a.htm#IX_detach Swat command:command reference">detach</A>,
<A HREF="../../Tools/SwatRef/SR_24.htm#IX_quit Swat command:command reference">quit</A>.



<H1 CLASS="refHeading">
<A NAME="SR_6.htm_IX_Content:finding with Swat">
 </A>
<A NAME="SR_6.htm_IX_content Swat command">
 </A>
content</H1>

<PRE CLASS="syntax">content</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;vistree [content]&quot;</DT><DD>
 print the visual tree of the content of the view under the mouse.</DD>
</DL>
<P>
Print the address of the content under the view with the current implied grab. </P>

<UL>
<LI>
This command is normally used with vistree to get the visual tree of a content by placing the mouse on the content's view window and issuing the command in the example. </LI>
<LI>
If the pointer is not over a GenView object, this is the same as the &quot;impliedgrab&quot; command.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2c.htm#IX_systemobj Swat command">systemobj</A>,
<A HREF="../../Tools/SwatRef/SR_10.htm#IX_gentree Swat command:command reference">gentree</A>,
<A HREF="../../Tools/SwatRef/SR_15.htm#IX_impliedgrab Swat command">impliedgrab</A>.


<HR>
<A NAME="SR_7.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_7.htm_IX_continue-patient Swat command">
 </A>
<A NAME="SR_7.htm_IX_Errors:continuing after with Swat">
 </A>
continue-patient</H1>

<PRE CLASS="syntax">continue-patient</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;continue-patient&quot;</DT><DD>
Allow the target machine to continue executing GEOS.</DD>
<P>
Tell the Swat stub to let the target machine continue where it left off.</P>


</DL>
<P>
This command does not wait for the machine to stop again before it returns; once the machine is running, you're free to do whatever you want, whether it's calling &quot;wait&quot; or examining memory periodically.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2a.htm#IX_step-patient Swat command">step-patient</A>.



<H1 CLASS="refHeading">
<A NAME="SR_7.htm_IX_cup Swat command">
 </A>
cup</H1>

<PRE CLASS="syntax">cup &lt;class&gt;
cup &lt;object&gt;
cup &lt;flags&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;cup ui::GenDocumentControlClass&quot; </DT><DD>
Print class hierarchy of named class</DD>
<DT>
&quot;cup ^l2850h:0034h&quot; </DT><DD>
Print class hierarchy of object</DD>
<DT>
&quot;cup -f&quot; </DT><DD>Print class hierarchy of focus object</DD>
<DT>
&quot;cup -p&quot; </DT><DD>Print class hierarchy of process</DD>
</DL>
<P>
Walks up the class hierarchy, starting at a given class, printing each class encountered. May be passed an object, in which case the class of the object will be used as a starting place.</P>

<H1 CLASS="refHeading">
<A NAME="SR_7.htm_IX_current-level Swat command">
 </A>
current-level</H1>

<PRE CLASS="syntax">current-level</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var l [current-level]&quot;</DT><DD>
Store the current interpreter nesting level in $l.</DD>
</DL>
<P>
Returns the number of invocations of &quot;top-level&quot; (i.e. the main command input loop) currently active.</P>

<UL>
<LI>
This is currently used only to modify the command prompt to indicate the current nesting level.</LI>
<LI>
The top-most command loop is level one.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2d.htm#IX_top-level Swat command">top-level</A>.



<H1 CLASS="refHeading">
<A NAME="SR_7.htm_IX_Registers:current-registers Swat command">
 </A>
<A NAME="SR_7.htm_IX_current-registers Swat command">
 </A>
<A NAME="SR_7.htm_IX_Threads:examining registers">
 </A>
current-registers</H1>

<PRE CLASS="syntax">current-registers</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;current-registers&quot;</DT><DD>
Returns a list of the current registers for the current thread.</DD>
</DL>
<P>
Returns all the registers for the current thread as a list of decimal numbers.</P>

<UL>
<LI>
The mapping from element number to register name is contained in the global variable &quot;regnums&quot;, which is an assoc-list whose elements contain the name of the register, then the element number. </LI>
<LI>
For your own consumption, the list is ordered ax, cx, dx, bx, sp, bp, si, di, es, cs, ss, ds, ip, flags. You should use the &quot;regnums&quot; variable when programming, however, as this may change at some point (e.g. to accommodate the additional registers in the 386).</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_7.htm_IX_Structures:formatting Swat output">
 </A>
<A NAME="SR_7.htm_IX_cvtrecord Swat command">
 </A>
cvtrecord</H1>

<PRE CLASS="syntax">cvtrecord &lt;type&gt; &lt;number&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;cvtrecord [symbol find type HeapFlags] 36&quot; </DT><DD>
Return a value list for the number 36 cast to a <CODE>
HeapFlags</CODE>
 record.</DD>
</DL>
<P>
Creates a value list for a record from a number, for use in printing out the number as a particular record using <CODE>
fmtval</CODE>.</P>

<UL>
<LI>
&lt;type&gt; is a type token for a record (or a structure made up exclusively of bitfields). </LI>
<LI>
&lt;number&gt; must be an actual number suitable for the &quot;expr&quot; command. It cannot be a register or variable or some such. Use &quot;getvalue&quot; to obtain an integer from such an expression. </LI>
<LI>
Returns a value list suitable for &quot;value store&quot; or for &quot;fmtval&quot;.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2e.htm#IX_value Swat command">value</A>,
<A HREF="../../Tools/SwatRef/SR_e.htm#IX_fmtval Swat command">fmtval</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_expr Tcl command">expr</A>,
<A HREF="../../Tools/SwatRef/SR_11.htm#IX_getvalue Swat command">getvalue</A>.



<H1 CLASS="refHeading">
<A NAME="SR_7.htm_IX_Timing with Swat">
 </A>
<A NAME="SR_7.htm_IX_cycles Swat command">
 </A>
cycles</H1>
<P>
Count instruction cycles from now until the given address is reached. Prints out each instruction as it is executed, along with the cycles it took. If no address is given, executes until a breakpoint is hit. Takes the following (optional) flags:</P>
<DL>
<DT>
<STRONG>
 -r</STRONG>
 </DT><DD>Print routines called, the total cycles for each routine, and a running total, not the cycles for each instruction.</DD>
<DT>
<STRONG>
 -i</STRONG>
 </DT><DD>Same as -r, but indents to show calling level. Not recommended for counting cycles over deeply nested routines.</DD>
<DT>
<STRONG>
 -I</STRONG>
 </DT><DD>Same as -i, except uses (#) to indicate call level</DD>
<DT>
<STRONG>
 -f</STRONG>
 </DT><DD>Stop counting when this routine finishes</DD>
<DT>
<STRONG>
 -n</STRONG>
 </DT><DD>Does not whine about interrupts being off</DD>
<DT>
<STRONG>
 -x</STRONG>
 &lt;<STRONG>
routine</STRONG>
&gt; </DT><DD>
Step over calls to &lt;routine&gt;</DD>
<DT>
 -x &lt;<STRONG>
routine</STRONG>
&gt;=&lt;<STRONG>
val</STRONG>
&gt; </DT><DD>
Step over calls to &lt;routine&gt; and assume that the call takes &lt;val&gt; cycles for timing purposes</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2d.htm#IX_timingProcessor Swat variable">timingProcessor</A>.

<HR>
<A NAME="SR_8.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_8.htm_IX_dbrk Swat command">
 </A>
<A NAME="SR_8.htm_IX_Breakpoints:delayed">
 </A>
<A NAME="SR_8.htm_IX_Delayed breakpoints">
 </A>
dbrk</H1>

<PRE CLASS="syntax">dbrk &lt;addr&gt; &lt;num&gt; [&lt;command&gt;|default]
dbrk set &lt;break&gt; &lt;num&gt; [&lt;command&gt;|default]
dbrk list [&lt;break&gt;]
dbrk {clear,delete} &lt;break&gt;
dbrk cur &lt;break&gt; &lt;num&gt;
dbrk max &lt;break&gt; &lt;num&gt;
dbrk cmd &lt;break&gt; [&lt;command&gt;]
dbrk reset &lt;break&gt;
dbrk enable &lt;break&gt;
dbrk disable &lt;break&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;dbrk ObjMessage 30&quot;</DT><DD>
Break at the 30th call to ObjMessage</DD>
<DT>
&quot;dbrk set 5 30&quot;</DT><DD>
Break after hitting brk5 30 times.</DD>
<DT>
&quot;dbrk set brk3 10 default&quot;          </DT><DD>
Break after hitting brk3 10 times; Each time brk3 is hit, perform the default command.</DD>
<DT>
&quot;dbrk cmd brk2 {echo foo}&quot;</DT><DD>
Echo a string whenever brk2 is hit.</DD>
<DT>
&quot;dbrk cmd brk2 default&quot;</DT><DD>
Use the default command for brk2.</DD>
<DT>
&quot;dbrk disable 2&quot;</DT><DD>
Stop counting brk2; it will now always be taken.</DD>
</DL>
<P>
This command creates &quot;delayed&quot; breakpoints, creating breakpoints that don't activate until they've been hit a specified nuber of times.</P>


<UL>
<LI>
<EM>
break</EM>
 may be a number, or a full breakpoint token (brk&lt;n&gt;) <EM>
num</EM>
 is a number; and <EM>
command</EM>
 is a string that will be evaluated. If <EM>
command</EM>
 may also be the string &quot;default&quot;, in which case a default command will be used.  The first argument to dbrk may be abbreviated; only the first 3 characters are significant.</LI>
<LI>
Deleting a breakpoint with &quot;brk del&quot; removes the dbrk also.</LI>
<LI>
With the exception of brk, all the commands that take &lt;break&gt; must be given a breakpoint that has been delayed.  The &quot;dbrk list&quot; command will show these.</LI>
<LI>
&quot;dbrk list&quot; will show how many times a breakpoint has been hit, the maximum number of times to skip the breakpoint, and the command to evaluate whenever the breakpoint is hit.  If no breakpoint is passed, the status of all dbrks will be shown.</LI>
<LI>
&quot;dbrk clear&quot; and &quot;dbrk delete&quot; are synonyms.  These commands will cause the delayed breakpoint to become normal again, and clear out the global variables used to store the dbrk's state: brk<EM>
N</EM>
cur, brk<EM>
N</EM>
max, brk<EM>
N</EM>
cmd where <EM>
N</EM>
 is a number.</LI>
<LI>
&quot;dbrk cur&quot;, &quot;dbrk max&quot;, and &quot;dbrk cmd&quot; set the current count, the maximum count, and the command of the specified breakpoint respectively.</LI>
<LI>
&quot;dbrk reset <EM>
break</EM>
&quot; is a quick way of saying &quot;dbrk cur <EM>
break</EM>
 0&quot;</LI>
<LI>
&quot;dbrk enable&quot; and &quot;dbrk disable&quot; are used to enable and disable a dbrk.  Disabled dbrks will always be taken, and their counter will not be incremented.</LI>
<LI>
Since this command is just a front-end to brk cmd, you can use dbrk and brk cond to create more complex breakpoints; for instance, you can &quot;mwatch <CODE>
MSG_VIS_DRAW</CODE>
&quot;, then &quot;dbrk set <EM>
brk</EM>
 30 print-method&quot; to break after <CODE>
MSG_VIS_DRAW</CODE>
 has been received 30 times.</LI>
</UL>

<H1 CLASS="refHeading">
<A NAME="SR_8.htm_IX_dcache Swat command">
 </A>
dcache</H1>

<PRE CLASS="syntax">dcache bsize &lt;blockSize&gt;
dcache length &lt;numBlocks&gt;
dcache stats
dcache params
dcache (on|off)</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;dcache bsize 16&quot; </DT><DD>
Set the number of bytes fetched at a time to 16.</DD>
<DT>
 &quot;dcache length 1024&quot; </DT><DD>
Allow 1024 blocks of the current block size to be in the cache at a time.</DD>
<DT>
 &quot;dcache off&quot; </DT><DD>Disables the Swat data cache.</DD>
</DL>
<P>
Controls the cache Swat uses to hold data read from the target machine while the machine is stopped.</P>

<UL>
<LI>
Data written while the machine is stopped actually get written to the cache, not the PC, and the modified blocks are written when the machine is continued. </LI>
<LI>
The default cache block size is 32 bytes, with a default cache length of 64 blocks. </LI>
<LI>
It is a very rare thing to have to turn the data cache off. You might need to do this while examining the changing registers of a memory-mapped I/O device. </LI>
<LI>
The &lt;blockSize&gt; must be a power of 2 and no more than 128. </LI>
<LI>
Changing the block size causes all cached blocks to be flushed (any modified cache blocks are written to the PC).</LI>
<LI>
Changing the cache length will only flush blocks if there are more blocks currently in the cache than are allowed by the new length. </LI>
<LI>
The &quot;dcache stats&quot; command prints statistics giving some indication of the efficacy of the data cache. It does not return anything. </LI>
<LI>
The &quot;dcache params&quot; command returns a list {&lt;blockSize&gt; &lt;numBlocks&gt;} giving the current parameters of the data cache. There are some operations where you might want to adjust the size of the cache either up or down, but need to reset the parameters when the operation completes. This is what you need to do this.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_f.htm#IX_cache Tcl structure">cache</A>.



<H1 CLASS="refHeading">
<A NAME="SR_8.htm_IX_Routines:monitoring with Swat">
 </A>
<A NAME="SR_8.htm_IX_dcall Swat command">
 </A>
dcall</H1>

<PRE CLASS="syntax">dcall [&lt;args&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;dcall Dispatch&quot;</DT><DD>
Display when the routine Dispatch is called</DD>
<DT>
&quot;dcall none&quot;</DT><DD>
stop displaying all routines</DD>
</DL>
<P>
Display calls to a routine.</P>

<UL>
<LI>
The &lt;args&gt; argument normally is the name of the routine to monitor. Whenever a call is made to the routine its name is displayed.</LI>
<LI>
If `none' or no argument is passed, then all the routines will stop displaying.</LI>
<LI>
Dcall uses breakpoints to display routine names. By looking at the list of breakpoints you can see which routines display their names and you can stop them individually by disabling or deleting their breakpoints.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_28.htm#IX_showcalls Swat command">showcalls</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_mwatch Swat command">mwatch</A>.


<HR>
<A NAME="SR_9.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_9.htm_IX_Tcl:debugging">
 </A>
<A NAME="SR_9.htm_IX_debug Swat command">
 </A>
debug</H1>

<PRE CLASS="syntax">debug &lt;proc-name&gt;*</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;debug&quot;</DT><DD>Enter the Tcl debugger immediately.</DD>
<DT>
&quot;debug fooproc&quot;</DT><DD>
Enter the Tcl debuffer when the interpreter is about to execute the command &quot;fooproc&quot;.</DD>
</DL>
<P>
This command is used when debugging Tcl commands. It sets a breakpoint at the start of any Tcl command. Also serves as a breakpoint in the middle of a Tcl procedure, if executed with no argument.</P>

<UL>
<LI>
The breakpoint for &lt;proc-name&gt; can be removed using the &quot;undebug&quot; command. </LI>
<LI>
&lt;proc-name&gt; need not be a Tcl procedure. Setting a breakpoint on a built-in command is not for the faint-of-heart, however, as there are some commands used by the Tcl debugger itself. Setting a breakpoint on such a command will cause instant death.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2e.htm#IX_undebug Swat command">undebug</A>.



<H1 CLASS="refHeading">
<A NAME="SR_9.htm_IX_Tcl:debugging">
 </A>
<A NAME="SR_9.htm_IX_debugger Swat command">
 </A>
debugger</H1>

<PRE CLASS="syntax">var debugger [&lt;command-name&gt;]</PRE>
<P>
Name of the command when things go wrong. The function is passed two arguments: a condition and the current result string from the interpreter. The condition is &quot;enter&quot; if entering a command whose debug flag is set, &quot;exit&quot; if returning from a frame whose debug flag is set, &quot;error&quot; if an error occurred and the &quot;debugOnError&quot; variable is non-zero, &quot;quit&quot; if quit (^  is typed and the &quot;debugOnReset&quot; variable is non-zero, or &quot;other&quot; for some other cause (e.g. &quot;debug&quot; being invoked from within a function).</P>



<H1 CLASS="refHeading">
<A NAME="SR_9.htm_IX_debugOnError Swat variable">
 </A>
debugOnError</H1>

<PRE CLASS="syntax">var debugOnError [(0|1)]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var debugOnError 1&quot;</DT><DD>
Turn on debugging when there's a Tcl error.</DD>

</DL>
<P>
Enter debug mode when Swat encounters a Tcl error. </P>

<UL>
<LI>
The 0|1 simply is a false|true to stop and debug upon encountering an error in a Tcl command. </LI>
<LI>
If an error is caught with the catch command, Swat will not enter debug mode. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_9.htm#IX_debugger Swat command">debugger</A>.



<H1 CLASS="refHeading">
<A NAME="SR_9.htm_IX_Tcl:defining procedures">
 </A>
<A NAME="SR_9.htm_IX_defcmd Swat command">
 </A>
<A NAME="SR_9.htm_IX_help Swat command:defining help for commands">
 </A>
defcmd</H1>

<PRE CLASS="syntax">defcmd &lt;name&gt; &lt;args&gt; &lt;help-class&gt; &lt;help-string&gt; &lt;body&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	Look at almost any .tcl file in the system library for an example; a complete example set would be too large to give here.</P>
<P>
This creates a new Tcl procedure with on-line help whose name the user may abbreviate when invoking.</P>

<UL>
<LI>
&lt;help-class&gt; is a Tcl list of places in which to store the &lt;help-string&gt;, with the levels in the help tree separated by periods. The leaf node for each path is added by this command and is &lt;name&gt;, so a command &quot;foo&quot; with the &lt;help-class&gt; &quot;prog.tcl&quot; would have its &lt;help-string&gt; stored as &quot;prog.tcl.foo.&quot;</LI>
<LI>
Because the name you choose for a procedure defined in this manner can have an impact on the unique abbreviation for another command, you should use this sparingly.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_9.htm#IX_defcommand Swat command">defcommand</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_proc Tcl command">proc</A>,
<A HREF="../../Tools/SwatRef/SR_13.htm#IX_help Swat command:command reference">help</A>.



<H1 CLASS="refHeading">
<A NAME="SR_9.htm_IX_help Swat command:defining help for commands">
 </A>
<A NAME="SR_9.htm_IX_Tcl:defining procedures">
 </A>
<A NAME="SR_9.htm_IX_defcommand Swat command">
 </A>
defcommand</H1>

<PRE CLASS="syntax">defcommand &lt;name&gt; &lt;args&gt; &lt;help-class&gt; &lt;help-string&gt; &lt;body&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	Look at almost any .tcl file in the system library for an example.</P>
<P>
This creates a new Tcl procedure with on-line help whose name must be given exactly when the user wishes to invoke it.</P>


<P>
&lt;help-class&gt; is a Tcl list of places in which to store the &lt;help-string&gt;, with the levels in the help tree separated by periods. The leaf node for each path is added by this command and is &lt;name&gt;, so a command &quot;foo&quot; with the &lt;help-class&gt; &quot;prog.tcl&quot; would have its &lt;help-string&gt; stored as &quot;prog.tcl.foo.&quot;</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_9.htm#IX_defcmd Swat command">defcmd</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_proc Tcl command">proc</A>,
<A HREF="../../Tools/SwatRef/SR_13.htm#IX_help Swat command:command reference">help</A>.



<H1 CLASS="refHeading">
<A NAME="SR_9.htm_IX_help Swat command:defining new help topics">
 </A>
<A NAME="SR_9.htm_IX_defhelp Swat command">
 </A>
defhelp</H1>

<PRE CLASS="syntax">defhelp &lt;topic&gt; &lt;help-class&gt; &lt;help-string&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;defhelp breakpoint top {Commands relating to the setting of breakpoints}&quot;</DT><DD>
Sets the help for &quot;breakpoint&quot; in the &quot;top&quot; category to the given string.</DD>
</DL>
<P>
This is used to define the help string for an internal node of the help tree (a node that is used in the path for some other real topic, such as a command or a variable).</P>

<UL>
<LI>
This cannot override a string that resides in the <STRONG CLASS="fileName">
/pcgeos/tcl/doc</STRONG>
 file.</LI>
<LI>
You only really need this if you have defined your own help-topic category.</LI>
<LI>
&lt;help-class&gt; is a Tcl list of places in which to store the &lt;help-string&gt;, with the levels in the help tree separated by periods. The leaf node for each path is added by this command and is &lt;name&gt;, so a command &quot;foo&quot; with the &lt;help-class&gt; &quot;prog.tcl&quot; would have its &lt;help-string&gt; stored as &quot;prog.tcl.foo.&quot;</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_13.htm#IX_help Swat command:command reference">help</A>.



<H1 CLASS="refHeading">
<A NAME="SR_9.htm_IX_Tcl:defining variables">
 </A>
<A NAME="SR_9.htm_IX_defvar Swat command">
 </A>
<A NAME="SR_9.htm_IX_help Swat command:defining help for variables">
 </A>
defvar</H1>

<PRE CLASS="syntax">defvar &lt;name&gt; &lt;value&gt; [&lt;help-class&gt; &lt;help-string&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;defvar printRegions 0&quot; </DT><DD>
Define &quot;printRegions&quot; as a global variable and give it the value zero, if it didn't have a value already.</DD>
</DL>
<P>
This command is used in .tcl files to define a global variable and give it an initial value, should the variable not have been defined before.</P>

<UL>
<LI>
If the variable is one the user may want to change, give it on-line help using the &lt;help-class&gt; and &lt;help-string&gt; arguments.</LI>
<LI>
&lt;help-class&gt; is a Tcl list of places in which to store the &lt;help-string&gt;, with the levels in the help tree separated by periods. The leaf node for each path is added by this command and is &lt;name&gt;, so a command &quot;foo&quot; with the &lt;help-class&gt; &quot;variable.output&quot; would have its &lt;help-string&gt; stored as &quot;variable.output.foo.&quot;</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_var Tcl command">var</A>,
<A HREF="../../Tools/SwatRef/SR_13.htm#IX_help Swat command:command reference">help</A>.


<HR>
<A NAME="SR_a.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_a.htm_IX_Associative lists in Swat:deleting elements">
 </A>
<A NAME="SR_a.htm_IX_delassoc Swat command">
 </A>
delassoc</H1>

<PRE CLASS="syntax">delassoc &lt;list&gt; &lt;key&gt; [&lt;foundvar&gt; [&lt;elvar&gt;]]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;delassoc $val murphy&quot;</DT><DD>
Returns $val without the sublist whose first element is the string &quot;murphy.&quot;</DD>
</DL>
<P>
Deletes an entry from an associative list.</P>

<UL>
<LI>
 &lt;foundvar&gt;, if given, is the name of a variable in the caller's scope that is to be set non-zero if an element in &lt;list&gt; was found whose &lt;key&gt; matched the given one. If no such element was found (and therefore deleted), the variable is set zero.</LI>
<LI>
&lt;elvar&gt;, if given, is the name of a variable in the caller's scope that receives the element that was deleted from the list. If no element was deleted, the variable remains untouched.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_3.htm#IX_assoc Swat command">assoc</A>.



<H1 CLASS="refHeading">
<A NAME="SR_a.htm_IX_detach Swat command:command reference">
 </A>
detach</H1>

<PRE CLASS="syntax">detach [&lt;options&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;detach cont&quot;</DT><DD>
continue GEOS and quit swat</DD>
</DL>
<P>
Detach swat from the PC.</P>

<UL>
<LI>
The &lt;option&gt; argument may be one of the following: <CODE>
continue</CODE>
: continue GEOS and detach swat; <CODE>
leave</CODE>
: keep GEOS stopped and detach swat. Anything else causes swat to just detach.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_4.htm#IX_attach Swat command:command reference">attach</A>,
<A HREF="../../Tools/SwatRef/SR_24.htm#IX_quit Swat command:command reference">quit</A>.



<H1 CLASS="refHeading">
<A NAME="SR_a.htm_IX_dirs Swat command">
 </A>
<A NAME="SR_a.htm_IX_Files:examining directory stack with Swat">
 </A>
dirs</H1>

<PRE CLASS="syntax">dirs</PRE>
<P>
Prints the directory stack for the current thread.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_24.htm#IX_pwd Swat command">pwd</A>,
<A HREF="../../Tools/SwatRef/SR_2a.htm#IX_stdpaths Swat command">stdpaths</A>.



<H1 CLASS="refHeading">
<A NAME="SR_a.htm_IX_discard-state Swat command">
 </A>
discard-state</H1>

<PRE CLASS="syntax">discard-state</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;discard-state&quot;</DT><DD>
Throw away the values for all the thread's registers as saved by the most recent call to <CODE>
save-state</CODE>
.</DD>
</DL>
<P>
Throw away the state saved by the most-recent <CODE>
save-state</CODE>
 command.</P>


<P>
This is usually only used in response to an error that makes it pointless to return to the point where the <CODE>
save-state</CODE>
 was performed.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_26.htm#IX_save-state Swat command">save-state</A>,
<A HREF="../../Tools/SwatRef/SR_25.htm#IX_restore-state Swat command">restore-state</A>.



<H1 CLASS="refHeading">
<A NAME="SR_a.htm_IX_Files:listing current disks with Swat">
 </A>
<A NAME="SR_a.htm_IX_diskwalk Swat command">
 </A>
diskwalk</H1>

<PRE CLASS="syntax">diskwalk &lt;drive&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;diskwalk 	F&quot; </DT><DD>
Prints the disks registered in drive F.</DD>
<DT>
&quot;diskwalk&quot;</DT><DD>Prints all the disks registered with the system.</DD>
</DL>
<P>
Prints out the information on registered disks.</P>


<P>
The Flags column is a string of single-character flags with the following meanings:</P>
<DL>
<DT>
<STRONG>
w</STRONG>
</DT><DD>The disk is writable.</DD>
<DT>
<STRONG>
V</STRONG>
 </DT><DD>The disk is always valid, i.e. it's not removable.</DD>
<DT>
<STRONG>
S </STRONG>
</DT><DD>The disk is stale. This is set if the drive for the disk has been deleted.</DD>
<DT>
<STRONG>
u</STRONG>
 </DT><DD>The disk is unnamed, so the system has made up a name for it.</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_b.htm#IX_drivewalk Swat command">drivewalk</A>.



<H1 CLASS="refHeading">
<A NAME="SR_a.htm_IX_Display windows in Swat">
 </A>
<A NAME="SR_a.htm_IX_display Swat command">
 </A>
display</H1>

<PRE CLASS="syntax">display &lt;lines&gt; &lt;command&gt;
display list
display del &lt;num&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;display list&quot;</DT><DD>
list all the commands displayed</DD>
<DT>
&quot;display 1 {piv Vis VCNI_viewHeight}&quot;</DT><DD>
always display the view height</DD>
<DT>
&quot;display del 2&quot;</DT><DD>
delete the second display command</DD>
</DL>
<P>
Manipulate the display at the bottom of Swat's screen.</P>

<UL>
<LI>
If you give a numeric &lt;lines&gt; argument, the next argument, &lt;command&gt;, is a standard Tcl command to execute each time the machine halts. The output of the command is directed to a window &lt;lines&gt; lines high, usually located at the bottom of the screen.</LI>
<LI>
You can list all the active displays by giving &quot;list&quot; instead of a number as the first argument.</LI>
<LI>
If the first argument is &quot;del&quot;, you can give the number of a display to delete as the &lt;num&gt; argument. &lt;num&gt; comes either from the value this command returned when the display was created, or from the list of active displays shown by typing &quot;display list&quot;.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_30.htm#IX_wtop Swat command">wtop</A>,
<A HREF="../../Tools/SwatRef/SR_30.htm#IX_wcreate Swat command">wcreate</A>.

<H1 CLASS="refHeading">
<A NAME="SR_a.htm_IX_Memory:examining DOS memory with Swat">
 </A>
<A NAME="SR_a.htm_IX_dosMem Swat command">
 </A>
dosMem</H1>

<PRE CLASS="syntax">dosMem</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;dosMem&quot;</DT>
<P>
Traverse DOS' chain of memory blocks, providing information about each.</P>



</DL>
<H1 CLASS="refHeading">
<A NAME="SR_a.htm_IX_Stack:changing frames">
 </A>
<A NAME="SR_a.htm_IX_down Swat command">
 </A>
down</H1>

<PRE CLASS="syntax">down [&lt;frame offset&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;down&quot;</DT><DD>move the frame one frame down the stack</DD>
<DT>
&quot;down 4&quot;</DT><DD>move the frame four frames down the stack</DD>
</DL>
<P>
Move the frame down the stack.</P>

<UL>
<LI>
The frame offset argument is the number of frames to move down the stack. If no argument is given then the current frame is moved down one frame.</LI>
<LI>
This command may be repeated by pressing &lt;Return&gt;.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_4.htm#IX_backtrace Swat command:command reference">backtrace</A>,
<A HREF="../../Tools/SwatRef/SR_2e.htm#IX_up Swat command">up</A>.


<HR>
<A NAME="SR_b.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_b.htm_IX_Files:listing Drives with Swat">
 </A>
<A NAME="SR_b.htm_IX_drivewalk Swat command">
 </A>
drivewalk</H1>

<PRE CLASS="syntax">drivewalk</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;drivewalk&quot;	</DT><DD>
Prints the table of drives known to the system.</DD>
</DL>
<P>
Prints out all disk drives known to the system, along with their current status.</P>


<UL>
<LI>
The Flags column is a string of single character flags with the following meanings:</LI>
<DL>
<DT>
        L</DT><DD>The drive is accessible to the local machine only, i.e. it's not visible over a network. </DD>
<DT>
           R </DT><DD>The drive is read-only.</DD>
<DT>
           F </DT><DD>Disks may be formatted in the drive.</DD>
<DT>
           A </DT><DD>The drive is actually an alias for a path on another drive.</DD>
<DT>
           B </DT><DD>The drive is busy, performing some extended operation, such as formatting or copying a disk.</DD>
<DT>
            r </DT><DD>The drive uses disks that may be removed by the user.</DD>
<DT>
           n</DT><DD> The drive is accessed over the network. </DD>
</DL>
<LI>
The Locks column can reflect one of three states: </LI>
<DL>
<DT>
          none </DT><DD>The drive isn't being accessed by any thread. </DD>
<DT>
          Excl</DT><DD>The drive is locked for exclusive access by a single thread.</DD>
<DT>
          &lt;num&gt; </DT><DD>The drive is locked for shared access for a particular disk, whose handle is the number. This is followed by the volume name of the disk, in square brackets.</DD>
</DL>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_a.htm#IX_diskwalk Swat command">diskwalk</A>.



<H1 CLASS="refHeading">
<A NAME="SR_b.htm_IX_Stack:examining with Swat">
 </A>
<A NAME="SR_b.htm_IX_dumpstack Swat command">
 </A>
dumpstack</H1>

<PRE CLASS="syntax">dumpstack [&lt;address&gt;] [&lt;length&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;dumpstack&quot;	</DT><DD>
dump the stack at SS:SP</DD>
<DT>
&quot;ds ds:si 10&quot;  </DT><DD>
dump ten words starting at DS:SI</DD>
</DL>
<P>
Dump the stack and perform some simple interpretation upon it.</P>


<UL>
<LI>
The &lt;address&gt; argument is the address of the list of words to dump. This defaults to SS:SP.</LI>
<LI>
The &lt;length&gt; argument is the number of words to dump. This defaults to 50.</LI>
<LI>
This dumps the stack and tries to make symbolic sense of the values, in terms of handles, segments, and routines.</LI>
<LI>
After doing a dumpstack, if you just hit return without entering a new command, by default you will see a continuation of the dumpstack.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_4.htm#IX_backtrace Swat command:command reference">backtrace</A>.



<H1 CLASS="refHeading">
<A NAME="SR_b.htm_IX_dwordIsPtr Swat variable">
 </A>
dwordIsPtr</H1>

<PRE CLASS="syntax">var dwordIsPtr [(0|1)]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var dwordIsPtr 1&quot; </DT><DD>
Tells &quot;print&quot; to print all double-word variables as if they were far pointers (segment:offset).</DD>
</DL>
<P>
Controls whether dword (a.k.a. long) variables are printed as 32-bit unsigned integers or untyped far pointers.</P>


<UL>
<LI>
For debugging C code, a value of 0 is more appropriate, while 1 is best for debugging assembly language. </LI>
<LI>
The default value for this variable is 1.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_15.htm#IX_intFormat Swat variable">intFormat</A>,
<A HREF="../../Tools/SwatRef/SR_20.htm#IX_print Swat command:command reference">print</A>.



<H1 CLASS="refHeading">
<A NAME="SR_b.htm_IX_dwords Swat command:command reference">
 </A>
<A NAME="SR_b.htm_IX_Memory:examining with Swat">
 </A>
dwords</H1>

<PRE CLASS="syntax">dwords [&lt;address&gt;] [&lt;length&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;dwords&quot;</DT><DD>lists 4 double words at DS:SI</DD>
<DT>
&quot;dwords ds:di 8&quot;</DT><DD>
lists 8 double words at DS:DI</DD>
</DL>
<P>
Examine memory as a dump of double words (32 bit hex numbers).</P>


<UL>
<LI>
The &lt;address&gt; argument is the address to examine. If not specified, the address after the last examined memory location is used. If no address has be examined then DS:SI is used for the address.</LI>
<LI>
The &lt;length&gt; argument is the number of dwords to examine. It defaults to 4.</LI>
<LI>
Pressing &lt;Return&gt; after this command continues the list.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_5.htm#IX_bytes Swat command:command reference">bytes</A>,
<A HREF="../../Tools/SwatRef/SR_30.htm#IX_words Swat command:command reference">words</A>,
<A HREF="../../Tools/SwatRef/SR_15.htm#IX_imem Swat command:command reference">imem</A>,
<A HREF="../../Tools/SwatRef/SR_4.htm#IX_assign Swat command:command reference">assign</A>.



<H1 CLASS="refHeading">
<A NAME="SR_b.htm_IX_ec Swat command">
 </A>
<A NAME="SR_b.htm_IX_Errors:error checking level">
 </A>
ec</H1>

<PRE CLASS="syntax">ec [&lt;args&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;ec&quot;</DT><DD>list the error checking turned on</DD>
<DT>
&quot;ec +vm&quot;</DT><DD>add vmem file structure checking</DD>
<DT>
&quot;ec all&quot;</DT><DD>turn on all error checking (slow)</DD>
<DT>
&quot;ec save none&quot;</DT><DD>
save the current error checking and then use none</DD>
<DT>
&quot;ec restore&quot;</DT><DD>use the saved error checking flags</DD>
</DL>
<P>
Get or set the error checking level active in the kernel.</P>

<UL>
<LI>
The following arguments may occur in any combination:</LI>
<DL>
<DT>
 &lt;<STRONG>
flag</STRONG>
&gt;</DT><DD>turn on &lt;flag&gt;</DD>
<DT>
+&lt;<STRONG>
flag</STRONG>
&gt;</DT><DD>turn on &lt;flag&gt;</DD>
<DT>
-&lt;<STRONG>
flag</STRONG>
&gt;</DT><DD>turn off &lt;flag&gt;</DD>
<DT>
<STRONG>
all</STRONG>
</DT><DD>turn on all error checking flags</DD>
<DT>
<STRONG>
ALL</STRONG>
</DT><DD>turn on all error checking flags</DD>
<DT>
<STRONG>
none</STRONG>
</DT><DD>turn off all error checking flags</DD>
<DT>
<STRONG>
sum</STRONG>
 &lt;<STRONG>
handle</STRONG>
&gt;</DT><DD>
<A NAME="SR_b.htm_IX_Memory:monitoring checksum with Swat">
 </A>
turn on checksum checking for the memory block with the given handle (&quot;ec sum bx&quot;). The current contents of the block will be summed and that sum regenerated and checked for changes at strategic points in the system (e.g. when a call between modules occurs).</DD>
<DT>
-<STRONG>
sum</STRONG>
</DT><DD>turn off checksum checking</DD>
<DT>
<STRONG>
save</STRONG>
</DT><DD>save the current error checking</DD>
<DT>
<STRONG>
restore</STRONG>
</DT><DD>restore the saved error checking flags
 where &lt;flag&gt; may be one of the following:</DD>
<DL>
<DT>
<STRONG>
analVM</STRONG>
</DT><DD><A NAME="SR_b.htm_IX_Virtual memory:error checking">
 </A>
perform over-aggressive checking of vmem files</DD>
<DT>
<STRONG>
graphics</STRONG>
</DT><DD>graphics checking</DD>
<DT>
<STRONG>
heapFree</STRONG>
</DT><DD><A NAME="SR_b.htm_IX_Heap:error checking">
 </A>
heap free block checking</DD>
<DT>
<STRONG>
lmemFree</STRONG>
</DT><DD><A NAME="SR_b.htm_IX_Local memory:error checking">
 </A>
lmem free area checking</DD>
<DT>
<STRONG>
lmemInternal</DT><DD>
</STRONG>
internal lmem error checking</DD>
<DT>
<STRONG>
lmemObject</DT><DD>
</STRONG>
<A NAME="SR_b.htm_IX_Objects:lmem object error checking">
 </A>
lmem object checking</DD>
<DT>
<STRONG>
normal</STRONG>
</DT><DD>normal error checking</DD>
<DT>
<STRONG>
region</STRONG>
</DT><DD>region checking segment extensive</DD>
<DT>
<STRONG>
segment</STRONG>
</DT><DD>adds register checking to Swat. If this flag is turned on, Swat will check whether ds and es are valid memory handle at various points in the debugging cycle by calling <CODE>
ECCheckSegment()</CODE>
.<A NAME="SR_b.htm_IX_Registers:error checking">
 </A>
</DD>
<DT>
<STRONG>
lmemMove</STRONG>
</DT><DD>force lmem blocks to move whenever possible</DD>
<DT>
<STRONG>
unlockMove</DT><DD>
</STRONG>
forces unlocked blocks to move whenever possible. This ensures that your code isn't referencing into an unstable block location. I.e., a block which may move, but usually doesn't , therefore causing non-reproducible (and quite frustrating) errors. </DD>
<DT>
<STRONG>
vm</STRONG>
</DT><DD><A NAME="SR_b.htm_IX_Virtual memory:error checking">
 </A>
vmem file structure checking</DD>
<DT>
<STRONG>
vmemDiscard</DT><DD>
</STRONG>
force vmem blocks to be discarded if possible</DD>
</DL>
</DL>
<LI>
If there isn't an argument, `ec' reports the current error checking flags.</LI>
<LI>
Each time GEOS is run the ec flags are cleared. The saved flags are preserved between sessions. The ec flags may be saved and then restored after restarting GEOS so that the flag settings are not lost when restarting GEOS.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_30.htm#IX_why Swat command:command reference">why</A>.



<H1 CLASS="refHeading">
<A NAME="SR_b.htm_IX_Formatting Swat output">
 </A>
<A NAME="SR_b.htm_IX_echo Swat command">
 </A>
echo</H1>

<PRE CLASS="syntax">echo [-n] &lt;string&gt;+</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;echo -n yes?&quot;</DT><DD>
Prints &quot;yes?&quot; without a newline.</DD>
<DT>
&quot;echo hi mom&quot;</DT><DD>
Prints &quot;hi mom&quot; followed by a newline.</DD>
</DL>
<P>
Prints its arguments, separated by spaces.</P>


<P>
If the first argument is &quot;-n&quot;, no newline is printed after the arguments.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_e.htm#IX_flush-output Swat command">flush-output</A>.


<HR>
<A NAME="SR_c.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_c.htm_IX_Events:displaying with Swat">
 </A>
<A NAME="SR_c.htm_IX_elist Swat command">
 </A>
elist</H1>

<PRE CLASS="syntax">elist [&lt;patient&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;elist&quot;</DT><DD>list the events for the current thread and patient</DD>
<DT>
&quot;elist ui&quot;</DT><DD>list the events for the last thread of the ui patient</DD>
<DT>
&quot;elist :1&quot;</DT><DD>list the events for the first thread of the current patient</DD>
<DT>
&quot;elist geos:2&quot;</DT><DD>
list the events for the second thread of the GEOS patient</DD>

</DL>
<P>
Display all events pending for a patient.</P>

<P>
The &lt;patient&gt; argument is of the form `patient:thread'. Each part of the patient name is optional, and if nothing is specified then the current patient is listed.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_28.htm#IX_showcalls Swat command">showcalls</A>.



<H1 CLASS="refHeading">
<A NAME="SR_c.htm_IX_ensure-swat-attached Swat command">
 </A>
ensure-swat-attached</H1>

<PRE CLASS="syntax">ensure-swat-attached</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;ensure-swat-attached&quot;</DT><DD>
Stop if Swat isn't attached to GEOS.</DD>
</DL>
<P>
If Swat is not attached to GEOS, display an error and stop a command.</P>


<P>
Use this command at the start of any other command that accesses the target PC. Doing so protects the user from the numerous warnings that can result from an attempt to read memory when not attached.</P>



<H1 CLASS="refHeading">
<A NAME="SR_c.htm_IX_Queues, event:finding with Swat">
 </A>
<A NAME="SR_c.htm_IX_eqfind Swat command">
 </A>
eqfind</H1>

<PRE CLASS="syntax">eqfind [-p]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;eqfind&quot; list all event queues in the system.</DT>
<DT>
 &quot;eqfind -p&quot; list and print all event queues in the system.</DT>
<P>
Display all event queues in the system.</P>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_c.htm#IX_elist Swat command">elist</A>,
<A HREF="../../Tools/SwatRef/SR_c.htm#IX_eqlist Swat command">eqlist</A>,
<A HREF="../../Tools/SwatRef/SR_c.htm#IX_erfind Swat command">erfind</A>.



<H1 CLASS="refHeading">
<A NAME="SR_c.htm_IX_Queues, event:displaying events in">
 </A>
<A NAME="SR_c.htm_IX_Events:displaying">
 </A>
<A NAME="SR_c.htm_IX_eqlist Swat command">
 </A>
eqlist</H1>

<PRE CLASS="syntax">eqlist &lt;queue handle&gt; &lt;name&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;eqlist 8320 geos:2&quot;</DT><DD>
show the event list for geos:2</DD>
</DL>
<P>
Display all events in a queue.</P>

<UL>
<LI>
The queue handle argument is the handle to a queue.</LI>
<LI>
The name argument is the name of the queue.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_c.htm#IX_elist Swat command">elist</A>.



<H1 CLASS="refHeading">
<A NAME="SR_c.htm_IX_Events:finding recorded">
 </A>
<A NAME="SR_c.htm_IX_erfind Swat command">
 </A>
erfind</H1>

<PRE CLASS="syntax">erfind [-p]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;erfind&quot; list all recorded event handles in the system.</DT>
<DT>
&quot;erfind -p&quot; list and print all recorded event handles in the system.</DT>
<P>
Display all record event handles in the system. These are events that have been recorded but not necessarily sent anywhere, so they will not appear in the queue of any thread.</P>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_c.htm#IX_elist Swat command">elist</A>,
<A HREF="../../Tools/SwatRef/SR_c.htm#IX_eqlist Swat command">eqlist</A>,
<A HREF="../../Tools/SwatRef/SR_c.htm#IX_eqfind Swat command">eqfind</A>,
<A HREF="../../Tools/SwatRef/SR_1d.htm#IX_pevent Swat command">pevent</A>.



<H1 CLASS="refHeading">
<A NAME="SR_c.htm_IX_exit">
 </A>
exit</H1>

<PRE CLASS="syntax">exit &lt;patient&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;exit faxmon&quot;</DT><DD>
Causes the faxmon application to exit.</DD>
</DL>
<P>
Sends messages required to make an application quit.</P>

<P>
This command does nothing when you're stopped at <CODE>
FatalError</CODE>
, as it will wait until the machine is idle before attempting to send <CODE>
MSG_META_QUIT</CODE>
; continuing from <CODE>
FatalError</CODE>
 will cause the system to exit.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_26.htm#IX_run Swat command">run</A>.



<H1 CLASS="refHeading">
<A NAME="SR_c.htm_IX_exit-thread Swat command">
 </A>
exit-thread</H1>

<PRE CLASS="syntax">exit-thread [&lt;exit-code&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;exit-thread&quot; </DT><DD>
Exit the current thread, returning zero to its parent.</DD>
<DT>
&quot;exit-thread 1&quot; </DT><DD>
Exit the current thread, returning one to its parent.</DD>
</DL>
<P>
Exit the current thread.</P>

<UL>
<LI>
The exit code argument is the status to return to the current thread's parent, which defaults to zero. </LI>
<LI>
Do not invoke this function for an event-driven thread; send it a <CODE>
MSG_META_DETACH</CODE>
 instead. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_24.htm#IX_quit Swat command:command reference">quit</A>.



<H1 CLASS="refHeading">
<A NAME="SR_c.htm_IX_Errors:determining cause of crash">
 </A>
<A NAME="SR_c.htm_IX_explain Swat command">
 </A>
explain</H1>

<PRE CLASS="syntax">explain</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	&quot;explain&quot;</P>
<P>
Print a more detailed description of why the system crashed, if possible.</P>

<UL>
<LI>
This must be run from within the frame of the <CODE>
FatalError()</CODE>
 function. Sometimes GEOS is not quite there. In this case, step an instruction or two and then try the &quot;why&quot; command again.</LI>
<LI>
This simply looks up the enumerated constant for the error code in the AX register in the <CODE>
FatalErrors</CODE>
 enumerated type defined by the geode that called <CODE>
FatalError()</CODE>
. For example, if a function in the kernel called <CODE>
FatalError()</CODE>
, AX would be looked up in geos::FatalErrors, while if a function in your application called <CODE>
FatalError()</CODE>
, this function would look it up in the FatalErrors type defined by your application. Each assembly application defines this enumerated type by virtue of having included <STRONG CLASS="fileName">
ec.def</STRONG>
.</LI>
<LI>
This command also relies on programmers having explained their FatalErrors when defining them.</LI>
<LI>
For certain fatal errors, additional information is provided by invoking the command &lt;patient&gt;::&lt;error code name&gt;, if it exists.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_c.htm_IX_Strings in Swat:explode Swat command">
 </A>
<A NAME="SR_c.htm_IX_explode Swat command">
 </A>
explode</H1>

<PRE CLASS="syntax">explode &lt;string&gt; [&lt;sep-set&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;explode $args&quot; </DT><DD>
Breaks the string stored in the variable &quot;args&quot; into a list of its individual letters.</DD>
<DT>
 &quot;explode $file /&quot; </DT><DD>
Breaks the string stored in the variable &quot;file&quot; into a list of its components, using &quot;/&quot; as the boundary between components when performing the split.</DD>
<P>
 Breaks a string into a list of its component letters, allowing them to be handled quickly via a foreach loop, or the map or mapconcat commands.</P>


</DL>
<P>
This is especially useful for parsing command switches. </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_foreach Tcl command">foreach</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_index Tcl command">index</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_range Tcl command">range</A>.


<HR>
<A NAME="SR_d.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_d.htm_IX_Errors:fatalerr_auto_explain Swat variable">
 </A>
<A NAME="SR_d.htm_IX_fatalerr_auto_explain Swat variable">
 </A>
fatalerr_auto_explain</H1>

<PRE CLASS="syntax">var fatalerr_auto_explain [(0|1)]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var fatalerr_auto_explain 0&quot; </DT><DD>
Turn off automatic generation of the explanation for any fatal-error hit.</DD>
</DL>
<P>
Determines if the &quot;why&quot; command will automatically provide you with an explanation of any fatal error you encounter. If non-zero, they will be provided whenever <CODE>
FatalError</CODE>
 is hit.</P>

<UL>
<LI>
Explanations are loaded from &lt;patient&gt;.fei files stored in the system Tcl library directory when an error in &lt;patient&gt; is encountered. </LI>
<LI>
You can also obtain an explanation of an error via the &quot;explain&quot; command.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_d.htm_IX_optr:extracting from memory with Swat">
 </A>
<A NAME="SR_d.htm_IX_fetch-optr Swat command">
 </A>
fetch-optr</H1>

<PRE CLASS="syntax">fetch-optr &lt;handle&gt; &lt;offset&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;fetch-optr $h $o.GI_comp.CP_firstChild&quot;</DT><DD>
 Fetch the optr from the GI_comp.CP_firstChild field of the object at ^h$h:$o.</DD>
</DL>
<P>
Extracts an optr from memory, coping with the data in the block that holds the optr not having been relocated yet.</P>

<UL>
<LI>
&lt;offset&gt; is an actual offset, not a chunk handle, while &lt;handle&gt; is a handle ID, not a handle token. </LI>
<LI>
Returns a two-list {&lt;handle&gt; &lt;chunk&gt;}, where &lt;handle&gt; is the handle ID from the optr, and &lt;chunk&gt; is the chunk handle (low word) from the optr. </LI>
<LI>
We decide whether to relocate the optr ourselves based on the LMF_RELOCATED bit in the <CODE>
LMBH_flags</CODE>
 field of the block's header. There are times, e.g. during the call to MSG_META_RELOCATE for an object, when this bit doesn't accurately reflect the state of the class pointer and we will return an error when we should not.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_d.htm_IX_Files:fhandle Swat command">
 </A>
<A NAME="SR_d.htm_IX_Handles:file handles:fhandles Swat command">
 </A>
<A NAME="SR_d.htm_IX_fhandle Swat command">
 </A>
fhandle</H1>

<PRE CLASS="syntax">fhandle &lt;handle id&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	&quot;fhandle 3290h&quot;</P>
<P>
Print out a file handle.</P>

<UL>
<LI>
The &lt;handle id&gt; argument is the handle number. File handles are listed in the first column of the `fwalk' command.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_10.htm#IX_fwalk Swat command">fwalk</A>.



<H1 CLASS="refHeading">
<A NAME="SR_d.htm_IX_Structures:field Swat command">
 </A>
<A NAME="SR_d.htm_IX_field Swat command">
 </A>
field</H1>

<PRE CLASS="syntax">field &lt;list&gt; &lt;field name&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;field [value fetch ds:si MyBox] topLeft&quot;</DT><DD>
return the offset of the topLeft field in MyBox</DD>
</DL>
<P>
Return the value for the field's offset in the structure.</P>

<UL>
<LI>
The &lt;list&gt; argument is a structure-value list from the &quot;value&quot; command.</LI>
<LI>
The &lt;field name&gt; argument is the field in the structure.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2e.htm#IX_value Swat command">value</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_piv Swat command">piv</A>.



<H1 CLASS="refHeading">
<A NAME="SR_d.htm_IX_fieldwin Swat command">
 </A>
fieldwin</H1>

<PRE CLASS="syntax">fieldwin</PRE>
<P>
Print the address of the target machine's current top-most field window.</P>



<H1 CLASS="refHeading">
<A NAME="SR_d.htm_IX_Searching for text with Swat">
 </A>
<A NAME="SR_d.htm_IX_find Swat command">
 </A>
find</H1>

<PRE CLASS="syntax">find [-ir] &lt;string&gt; [&lt;filename&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;find FileRead&quot; </DT><DD>
Find next occurrence of string &quot;FileRead&quot; in currently viewed file </DD>
<DT>
&quot;find FI_foo poof.goc&quot;</DT><DD>
 find first occurrence of string &quot;FI_foo&quot; in file poof.goc.</DD>
<DT>
 &quot;find -ir myobject&quot; </DT><DD>
case-insensitive reverse search for most recent occurrence of string &quot;myobject&quot; in currently viewed file</DD>
</DL>
<P>
Finds a string in a file and brings the line with that string to the middle of Swat's source window.</P>

<UL>
<LI>
If no file argument is specified, find will find the next instance of the string in the already viewed file starting from the current file position. </LI>
<LI>
There must already be a source window displayed for find to work. </LI>
<LI>
Possible options to find are:</LI>
<DL>
<DT>
          <STRONG>
-r</STRONG>
 </DT><DD>reverse search</DD>
<DT>
          <STRONG>
-i</STRONG>
 </DT><DD>case insensitive search</DD>

</DL>
</UL>
<H1 CLASS="refHeading">
<A NAME="SR_d.htm_IX_find-opcode Swat command">
 </A>
find-opcode</H1>

<PRE CLASS="syntax">find-opcode &lt;addr&gt; &lt;byte&gt;+</PRE>
<P>
Locates the mnemonic for an opcode and decodesit. Accepts the address from which the opcode bytes were fetched, and one or more opcode bytes as arguments. Returns a list of data from the opcode descriptor:</P>
<P>
 {name length branch-type args modrm bRead bWritten inst}</P>
<P>
<EM>
length</EM>
 is the length of the instruction.</P>
<P>
<EM>
branch</EM>
-<EM>
type</EM>
 is one of: </P>
<DL>
<DT>
<STRONG>
1</STRONG>
</DT><DD> none (flow passes to next instruction)</DD>
<DT>
<STRONG>
j</STRONG>
 </DT><DD>absolute jump</DD>
<DT>
<STRONG>
b</STRONG>
</DT><DD> pc-relative jump (branch)</DD>
<DT>
<STRONG>
r</STRONG>
 </DT><DD>near return</DD>
<DT>
<STRONG>
R</STRONG>
 </DT><DD>far return</DD>
<DT>
<STRONG>
i</STRONG>
</DT><DD> interrupt return</DD>
<DT>
<STRONG>
I</STRONG>
 </DT><DD>interrupt instruction</DD>
</DL>
<P>
Any argument descriptor that doesn't match is to be taken as a literal. E.g. AX as a descriptor means AX is that operand.</P>
<P>
modrm is the modrm byte for the opcode.</P>
<P>
<EM>
bRead</EM>
 is the number of bytes that may be read by the instruction, if one of its operands is in memory.</P>
<P>
 <EM>
bWritten</EM>
 is the number of bytes that may be written by the instruction, if one of its operands is in memory.</P>
<P>
<EM>
inst</EM>
 is the decoded form of the instruction. If not enough bytes were given to decode the instruction, <EM>
inst</EM>
 is returned as empty.</P>



<H1 CLASS="refHeading">
<A NAME="SR_d.htm_IX_Stepping through code:finishing a frame">
 </A>
<A NAME="SR_d.htm_IX_finish Swat command">
 </A>
finish</H1>

<PRE CLASS="syntax">finish [&lt;frame num&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;finish&quot;</DT><DD>finish executing the current frame</DD>
<DT>
&quot;finish 3&quot;</DT><DD>finish executing up to the third frame</DD>
</DL>
<P>
Finish the execution of a frame.</P>

<UL>
<LI>
The &lt;frame num&gt; argument is the number of the frame to finish. If none is specified then the current frame is finished up. The number to use is the number which appears in a backtrace.</LI>
<LI>
The machine continues to run until the frame above is reached.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_4.htm#IX_backtrace Swat command:command reference">backtrace</A>.



<H1 CLASS="refHeading">
<A NAME="SR_d.htm_IX_Stepping through code:finishing a frame">
 </A>
<A NAME="SR_d.htm_IX_finishframe Swat command">
 </A>
finishframe</H1>

<PRE CLASS="syntax">finishframe [&lt;frame-token&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;finishframe $cur&quot;</DT><DD>
Run the machine to continue until it has returned from a particular stack frame.</DD>
</DL>
<P>
Allows the machine to continue until it has returned from a particular stack frame.</P>

<UL>
<LI>
No FULLSTOP event is dispatched when the machine actually finishes executing in the given frame. The caller must dispatch it itself, using the &quot;event&quot; command.</LI>
<LI>
The command returns zero if the machine finished executing in the given frame; non-zero if it was interrupted before that could happen. </LI>
<LI>
The argument is a frame token, as returned by the &quot;frame&quot; command.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_f.htm#IX_event Tcl structure">event</A>,
<A HREF="../../Tools/SwatRef/SR_f.htm#IX_frame Swat command:command reference">frame</A>,
<A HREF="../../Tools/SwatRef/SR_d.htm#IX_finish Swat command">finish</A>.


<HR>
<A NAME="SR_e.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_e.htm_IX_Flags register:in display window">
 </A>
<A NAME="SR_e.htm_IX_Registers:flags register:displaying">
 </A>
<A NAME="SR_e.htm_IX_Display windows in Swat:flags register">
 </A>
<A NAME="SR_e.htm_IX_flagwin Swat command">
 </A>
flagwin</H1>

<PRE CLASS="syntax">flagwin [&lt;on&gt;|off]</PRE>
<P>
Turns on or off a window providing a continuous display of the machine flags (e.g. zero, carry).</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1d.htm#IX_pflags Swat command">pflags</A>.



<H1 CLASS="refHeading">
<A NAME="SR_e.htm_IX_flowobj Swat command">
 </A>
flowobj</H1>

<PRE CLASS="syntax">flowobj</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pobject [flowobj]&quot;</DT><DD>
print out the flow object.</DD>
</DL>
<P>
Prints out address of the uiFlowObj, which is the object which grabs the mouse.</P>


<P>
This command is normally used with <CODE>
pobject</CODE>
 to print out the object.</P>



<H1 CLASS="refHeading">
<A NAME="SR_e.htm_IX_flush-output Swat command">
 </A>
flush-output</H1>

<PRE CLASS="syntax">flush-output</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;flush-output&quot;</DT><DD>
Forces pending output to be displayed.</DD>
</DL>
<P>
Flushes any pending output (e.g. waiting for a newline) to the screen.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_b.htm#IX_echo Swat command">echo</A>.



<H1 CLASS="refHeading">
<A NAME="SR_e.htm_IX_optr:from global and local handle">
 </A>
<A NAME="SR_e.htm_IX_fmtoptr Swat command">
 </A>
fmtoptr</H1>

<PRE CLASS="syntax">fmtoptr &lt;handle-id&gt; &lt;chunk&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;fmtoptr 3160h o&quot;	</DT><DD>
Prints a description of the object whose address is ^l3160h:0 (likely a thread/process).</DD>
</DL>
<P>
Takes a global and a local handle and prints a description of the object described by that optr.</P>


<UL>
<LI>
If the global handle is a thread or a process, the thread's name (process thread for a process handle) and the chunk handle (as an additional word of data for the message) are printed.</LI>
<LI>
<A NAME="SR_e.htm_IX_Queues, event:in optrs">
 </A>
If the global handle is a queue handle, the queue handle and the chunk handle are printed, with a note that the thing's a queue.</LI>
<LI>
If Swat can determine the object's class, the optr, full classname, and current far pointer are printed. In addition, if the chunk has its low bit set, the word &quot;parent&quot; is placed before the output, to denote that the optr likely came from a link and is the parent of the object containing the optr.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_20.htm#IX_print Swat command:command reference">print</A>.



<H1 CLASS="refHeading">
<A NAME="SR_e.htm_IX_Formatting Swat output">
 </A>
<A NAME="SR_e.htm_IX_fmtval Swat command">
 </A>
fmtval</H1>

<PRE CLASS="syntax">fmtval &lt;value-list&gt; &lt;type-token&gt; &lt;indent&gt; [&lt;tail&gt; [&lt;one-line&gt;]]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;fmtval [value fetch foo] [symbol find type FooStruct] 0&quot;</DT><DD>
Prints the value of the variable foo, which is assumed to be of type FooStruct.</DD>
</DL>
<P>
This is the primary means of producing nicely-formatted output of data in Swat. It is used by both the &quot;print&quot; and &quot;_print&quot; commands and is helpful if you want to print the value of a variable without entering anything into the value history.</P>


<UL>
<LI>
&lt;value-list&gt; is the return value from &quot;value fetch&quot;. You can, of course, construct one of these if you feel so inclined.</LI>
<LI>
&lt;type-token&gt; is the token for the type-description used when fetching the value. </LI>
<LI>
&lt;indent&gt; is the base indentation for all output. When &quot;fmtval&quot; calls itself recursively, it increases this by 4 for each recursive call. </LI>
<LI>
&lt;tail&gt; is an optional parameter that exists solely for use in formatting nested arrays. It is a string to print after the entire value has been formatted. You will almost always omit it or pass the empty string.</LI>
<LI>
&lt;one-line&gt; is another optional parameter used almost exclusively for recursive calls. It indicates if the value being formatted is expected to fit on a single line, and so &quot;fmtval&quot; should not force a newline to be output at the end of the value. The value should be 0 or 1.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_20.htm#IX_print Swat command:command reference">print</A>,
<A HREF="../../Tools/SwatRef/SR_1.htm#IX__print Swat command">_print</A>,
<A HREF="../../Tools/SwatRef/SR_e.htm#IX_fmtoptr Swat command">fmtoptr</A>,
<A HREF="../../Tools/SwatRef/SR_2d.htm#IX_threadname Swat command">threadname</A>.



<H1 CLASS="refHeading">
<A NAME="SR_e.htm_IX_Focus:finding with Swat">
 </A>
<A NAME="SR_e.htm_IX_focus Swat command">
 </A>
focus</H1>

<PRE CLASS="syntax">focus [&lt;object&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;focus&quot; </DT><DD>print focus hierarchy from the system object down</DD>
<DT>
 &quot;focus -i&quot; </DT><DD>print focus hierarchy from implied grab down</DD>
<DT>
 &quot;focus ^l4e10h:20h&quot; </DT><DD>
print focus hierarchy from ^l4e10h:20h down</DD>
<DT>
 &quot;focus [content]&quot; </DT><DD>
print focus hierarchy from content under mouse.</DD>
</DL>
<P>
Prints the focus hierarchy below an object.</P>


<UL>
<LI>
If no argument is specified, the system object is used. </LI>
<LI>
The special object flags may be used to specify &lt;object&gt;.  For a list of these flags, see pobject.</LI>
<LI>
Remember that the object you start from may have the focus within its part of the hierarchy, but still not have the focus because something in a different part of the tree has it. </LI>
<LI>
The variable &quot;printNamesInObjTrees&quot; can be used to print out the actual app-defined labels for the objects, instead of the class, where available.</LI>
<P>
	This variable defaults to false.</P>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2c.htm#IX_target Swat command">target</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_model Swat command">model</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_mouse Swat command">mouse</A>,
<A HREF="../../Tools/SwatRef/SR_17.htm#IX_keyboard Swat command">keyboard</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>.



<H1 CLASS="refHeading">
<A NAME="SR_e.htm_IX_Focus:finding with Swat">
 </A>
<A NAME="SR_e.htm_IX_focusobj Swat command">
 </A>
focusobj</H1>

<PRE CLASS="syntax">focusobj</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;focusobj&quot;</DT><DD>print model hierarchy from system object down</DD>
<DT>
&quot;pobj [focusobj]&quot;</DT><DD>
Do a pobject on the focus object (equivalent to &quot;pobj -f&quot;).</DD>
</DL>
<P>
Returns the object with the focus.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_e.htm#IX_focus Swat command">focus</A>,
<A HREF="../../Tools/SwatRef/SR_2c.htm#IX_target Swat command">target</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_model Swat command">model</A>,
<A HREF="../../Tools/SwatRef/SR_2c.htm#IX_targetobj Swat command">targetobj</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_modelobj Swat command">modelobj</A>.



<H1 CLASS="refHeading">
<A NAME="SR_e.htm_IX_fonts Swat command">
 </A>
fonts</H1>

<PRE CLASS="syntax">fonts [&lt;args&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;fonts&quot;</DT><DD>summarize general font usage</DD>
<DT>
&quot;fonts -u&quot;</DT><DD>list fonts currently in use</DD>
</DL>
<P>
Print various font info.</P>


<UL>
<LI>
The &lt;args&gt; argument may be any of the following:</LI>
<DL>
<DT>
<STRONG>
           -a</STRONG>
</DT><DD>list of fonts available</DD>
<DT>
<STRONG>
           -d</STRONG>
</DT><DD>list of font drivers available</DD>
<DT>
<STRONG>
           -u</STRONG>
</DT><DD>[&lt;ID&gt;] list of fonts currently in use. Optional font ID to match.</DD>
<DT>
<STRONG>
            -s</STRONG>
</DT><DD>summary of above information</DD>
</DL>
<P>
 If no argument is specified the default is to show the summary.</P>
<LI>
 When using other commands you probably need to pass them the handle in <CODE>
FIUE_dataHandle</CODE>
. When you don't have the font's handle ready, the best way is to use &quot;fonts -u&quot; to find the font at the right point size and then grab the handle from there.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1d.htm#IX_pfont Swat command">pfont</A>,
<A HREF="../../Tools/SwatRef/SR_1d.htm#IX_pfontinfo Swat command">pfontinfo</A>,
<A HREF="../../Tools/SwatRef/SR_23.htm#IX_pusage Swat command">pusage</A>,
<A HREF="../../Tools/SwatRef/SR_1d.htm#IX_pfontinfo Swat command">pfontinfo</A>.


<HR>
<A NAME="SR_f.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_f.htm_IX_fpstack Swat command">
 </A>
fpstack</H1>

<PRE CLASS="syntax">fpstack</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;fpstack&quot;</DT><DD>Prints out the hardware and software floating point stacks for the patient.</DD>
</DL>
<P>
Prints out the hardware and software floating point stacks for the patient. </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_f.htm#IX_fpu-state Swat command">fpu-state</A>.



<H1 CLASS="refHeading">
<A NAME="SR_f.htm_IX_fpu-state Swat command">
 </A>
fpu-state</H1>

<PRE CLASS="syntax">fpustate [&lt;mode&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;fpustate&quot;</DT><DD>Print out the state of the coprocessor.</DD>
<DT>
&quot;fpustate w&quot;</DT><DD>Dumps actual words of the numbers.</DD>
</DL>
<P>
Prints out the current state of the coprocessor, if any.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_f.htm#IX_fpstack Swat command">fpstack</A>.



<H1 CLASS="refHeading">
<A NAME="SR_f.htm_IX_Stack:examining">
 </A>
<A NAME="SR_f.htm_IX_frame Swat command:command reference">
 </A>
frame</H1>

<PRE CLASS="syntax">frame top
frame cur
frame get &lt;ss&gt; &lt;sp&gt; &lt;cs&gt; &lt;ip&gt;
frame next &lt;frame&gt;
frame prev &lt;frame&gt;
frame function [&lt;frame&gt;]
frame funcsym [&lt;frame&gt;]
frame scope [&lt;frame&gt;]
frame info [&lt;frame&gt;]
frame patient [&lt;frame&gt;]
frame register &lt;regName&gt; [&lt;frame&gt;]
frame set [&lt;frame&gt;]
frame setreg &lt;regName&gt; &lt;value&gt; [&lt;frame&gt;]
frame +&lt;number&gt;
frame -&lt;number&gt;
frame &lt;number&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var f [frame top]&quot;</DT><DD>
 Fetches the token for the frame at the top of the current thread's stack and stores it in the variable &quot;f&quot;</DD>
<DT>
 &quot;var f [frame next $f]&quot;</DT><DD>
 Fetches the token for the next frame up the stack (away from the top) from that whose token is in $f</DD>
<DT>
<A NAME="SR_f.htm_IX_Registers:value within a frame">
 </A>
 &quot;frame register ax $f&quot; </DT><DD>
Returns the value of the AX register in the given frame.</DD>
<DT>
 &quot;frame 1&quot; </DT><DD>Sets the current frame for the current thread to be the top-most one.</DD>
</DL>
<P>
This command provides access to the stack-decoding functions of swat. Most of the subcommands deal with frame tokens, but a few also handle frame numbers, for the convenience of the user.</P>

<UL>
<LI>
Subcommands may be abbreviated uniquely.</LI>
<LI>
Stack decoding works by a heuristic method, rather than relying on the presence of a created stack frame pointed to by BP in each function. Because of this, it can occasionally get confused. </LI>
<LI>
Frame tokens are valid only while the target machine is stopped and are invalidated when it is continued.</LI>
<LI>
Each frame records the address on the stack where each register was most-recently pushed (i.e. by the frame closest to it on the way toward the top of the stack). Register pushes are looked for only at the start of a function in what can be considered the function prologue.</LI>
<LI>
&quot;frame register&quot; and &quot;frame setreg&quot; allow you to get or set the value held in a register in the given frame. For &quot;setreg&quot;, &lt;value&gt; is a standard address expression, only the offset of which is used to set the register.</LI>
<LI>
&quot;frame register&quot; returns all registers but &quot;pc&quot; as a decimal number. &quot;pc&quot; is formatted as two hex numbers (each preceded by &quot;0x&quot;) separated by a colon.</LI>
<LI>
&quot;frame info&quot; prints out information on where the register values for &quot;frame register&quot; and &quot;frame setreg&quot; are coming from/going to for the given or currently-selected frame. Because of the speed that can be gained by only pushing registers when you absolutely have to, there are many functions in GEOS that do not push the registers they save at their start, so Swat does not notice that they are actually saved. It is good to make sure a register value is coming from a reliable source before deciding your program has a bug simply because the value returned by &quot;frame register&quot; is invalid.</LI>
<LI>
For any subcommand where the &lt;frame&gt; token is optional, the currently- selected frame will be used if you give no token.</LI>
<LI>
&quot;frame cur&quot; returns the token for the currently-selected stack frame.</LI>
<LI>
&quot;frame set&quot; is what sets the current frame, when set by a Tcl procedure.</LI>
<LI>
&quot;frame +&lt;number&gt;&quot; selects the frame &lt;number&gt; frames up the stack (away from the top) from the current frame. &quot;frame -&lt;number&gt;&quot; goes the other way.</LI>
<LI>
&quot;frame &lt;number&gt;&quot; selects the frame with the given number, where the top-most frame is considered frame number 1 and numbers count up from there.</LI>
<LI>
<A NAME="SR_f.htm_IX_Routines:current within frame">
 </A>
&quot;frame funcsym&quot; returns the symbol token for the function active in the given (or current) frame. If no known function is active, you get &quot;nil&quot;.</LI>
<LI>
&quot;frame scope&quot; returns the full name of the scope that is active in the given (or current) frame. This will be different from the function if, for example, one is in the middle of an &quot;if&quot; that contains variables that are local to it only.</LI>
<LI>
&quot;frame function&quot; returns the name of the function active in the given (or current) frame. If no known function is active, you get the CS:IP for the frame, formatted as two hex numbers separated by a colon.</LI>
<LI>
&quot;frame patient&quot; returns the token for the patient that owns the function in which the frame is executing.<A NAME="SR_f.htm_marker=833372">
 </A>
</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2.htm#IX_addr-parse Swat command">addr-parse</A>,
<A HREF="../../Tools/SwatRef/SR_2b.htm#IX_switch Swat command:command reference">switch</A>.



<H1 CLASS="refHeading">
<A NAME="SR_f.htm_IX_Display windows in Swat:displaying current Stack frame">
 </A>
<A NAME="SR_f.htm_IX_framewin Swat command">
 </A>
framewin</H1>

<PRE CLASS="syntax">framewin [del]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;framewin&quot;</DT><DD>
Creates a single-line window to display info about the current stack frame.</DD>
<DT>
&quot;framewin del&quot;</DT><DD>
Deletes the window created by a previous &quot;framewin&quot;.</DD>
</DL>
<P>
Creates a window in which the current stack frame is always displayed.</P>


<UL>
<LI>
Only one frame window can be active at a time.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_a.htm#IX_display Swat command">display</A>,
<A HREF="../../Tools/SwatRef/SR_25.htm#IX_regwin Swat command">regwin</A>,
<A HREF="../../Tools/SwatRef/SR_29.htm#IX_srcwin Swat command">srcwin</A>.



<H1 CLASS="refHeading">
<A NAME="SR_f.htm_IX_Threads:freezing">
 </A>
<A NAME="SR_f.htm_IX_freeze Swat command">
 </A>
freeze</H1>

<PRE CLASS="syntax">freeze [&lt;patient&gt;]
freeze :&lt;n&gt;
freeze &lt;patient&gt;:&lt;n&gt;
freeze &lt;id&gt; </PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;freeze&quot;</DT><DD>Freezes the current thread.</DD>
<DT>
&quot;freeze term&quot; </DT><DD>
Freezes the application thread for &quot;term&quot;</DD>
<DT>
&quot;freeze :1&quot; </DT><DD>Freezes thread #1 of the current patient</DD>
<DT>
&quot;freeze 16c0h&quot; </DT><DD>
Freezes the thread whose handle is 16c0h.</DD>
</DL>
<P>
Freezing a thread prevents a thread from running unless it's the only thread that's runnable in the entire system.</P>

<UL>
<LI>
A frozen thread is not dead in the water, as it will still run if nothing else is runnable. </LI>
<LI>
Freezing a thread is most useful when debugging multi-threaded applications where a bug appears to be caused by a timing problem or race condition between the two threads. Freezing one of the threads ensures a consistent timing relationship between the two threads and allows the bug to be reproduced much more easily. </LI>
<LI>
The freezing of a thread is accomplished by setting its base and current priorities to as high a number as possible (255) thereby making the thread the least-favored thread in the system. The previous priority can be restored using the &quot;thaw&quot; command.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2d.htm#IX_thaw Swat command">thaw</A>.



<H1 CLASS="refHeading">
<A NAME="SR_f.htm_IX_fullscreen">
 </A>
fullscreen</H1>

<PRE CLASS="syntax">fullscreen</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;fullscreen&quot;</DT>
<P>
Prints the full screen hierarchy from the system object down.</P>


</DL>
<HR>
<A NAME="SR_10.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_10.htm_IX_Routines:current routine">
 </A>
<A NAME="SR_10.htm_IX_func Swat command">
 </A>
func</H1>

<PRE CLASS="syntax">func [&lt;func name&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;func&quot;</DT><DD>return the current function.</DD>
<DT>
&quot;func ObjMessage&quot;</DT><DD>
set the frame to the first frame for ObjMessage.</DD>
</DL>
<P>
Get the current function or set the frame to the given function.</P>

<UL>
<LI>
The &lt;func name&gt; argument is the name of a function in the stack frame of the current patient. The frame is set to the first occurrence of the function from the top of the stack.</LI>
<LI>
 If no &lt;func name&gt; argument is given then `func' returns the current function.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_4.htm#IX_backtrace Swat command:command reference">backtrace</A>,
<A HREF="../../Tools/SwatRef/SR_2e.htm#IX_up Swat command">up</A>,
<A HREF="../../Tools/SwatRef/SR_a.htm#IX_down Swat command">down</A>,
<A HREF="../../Tools/SwatRef/SR_d.htm#IX_finish Swat command">finish</A>.



<H1 CLASS="refHeading">
<A NAME="SR_10.htm_IX_Objects:finding variable data">
 </A>
<A NAME="SR_10.htm_IX_fvardata Swat command">
 </A>
fvardata</H1>

<PRE CLASS="syntax">fvardata &lt;token&gt; [&lt;address&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;fvardata ATTR_VIS_TEXT_STYLE_ARRAY *ds:si&quot;</DT>
</DL>
<P>
Locates and returns the value list for the data stored under the given token in the vardata of the given object.</P>

<UL>
<LI>
If the data are found, returns a list {&lt;token&gt; &lt;data&gt;}, where &lt;data&gt; is a standard value list for the type of data associated with the specified token. </LI>
<LI>
Returns an empty list if the object has no vardata entry of the given type. </LI>
<LI>
If no &lt;address&gt; is given, the default is *ds:si.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_10.htm_IX_Files:displaying open files">
 </A>
<A NAME="SR_10.htm_IX_fwalk Swat command">
 </A>
fwalk</H1>

<PRE CLASS="syntax">fwalk [&lt;patient&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;fwalk&quot;</DT><DD>list all open files.</DD>
<DT>
&quot;fwalk geos&quot;</DT><DD>
list all open files owned by the GEOS patient.</DD>
</DL>
<P>
Print the list of files open anywhere in the system.</P>

<UL>
<LI>
The patient argument may be used to restrict the list to a particular patient. The patient may be specified either as the patient name or as the patient's handle.</LI>
<LI>
fwalk differs from <CODE>
sysfiles</CODE>
 and <CODE>
geosfiles</CODE>
 in that it deals primarily with GEOS data structures.</LI>
<LI>
The `Other' column shows if there is a VM handle bound to the file.</LI>
<LI>
The letters in the `Flags' column mean the following:</LI>
<DL>
<DT>
           <STRONG>
RW</STRONG>
</DT><DD>deny RW</DD>
<DT>
        <STRONG>
R</STRONG>
</DT><DD>deny R</DD>
<DT>
        <STRONG>
W</STRONG>
</DT><DD>deny W</DD>
<DT>
        <STRONG>
N</STRONG>
</DT><DD>deny none</DD>
<DT>
           <STRONG>
rw</STRONG>
</DT><DD>access RW</DD>
<DT>
        <STRONG>
r</STRONG>
</DT><DD>access R</DD>
<DT>
        <STRONG>
w</STRONG>
</DT><DD>access RW</DD>
<DT>
        <STRONG>
O</STRONG>
</DT><DD>override, used to override normal exclusion normally used by <CODE>
FileEnum()</CODE>
 to check out file headers.</DD>
<DT>
        <STRONG>
E</STRONG>
</DT><DD>exclusive, used to prevent override. This is used by <STRONG CLASS="fileName">
swap.geo</STRONG>
</DD>
</DL>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_d.htm#IX_fhandle Swat command">fhandle</A>,
<A HREF="../../Tools/SwatRef/SR_10.htm#IX_geosfiles Swat command">geosfiles</A>,
<A HREF="../../Tools/SwatRef/SR_2c.htm#IX_sysfiles Swat command">sysfiles</A>.



<H1 CLASS="refHeading">
<A NAME="SR_10.htm_IX_gc Swat command">
 </A>
gc</H1>

<PRE CLASS="syntax">gc [(off|register|&lt;extensive-heap-checking-flag&gt;]</PRE>
<P>
Implements a simple garbage collector to scavenge unreferenced symbols and types. If given an argument other than &quot;off&quot; or &quot;register,&quot; it turns on extensive heap checking, which slows things down enormously but ensures the heap is in good shape. The &quot;gc register&quot; command can be use to register a type created by &quot;type make&quot;as something that is being used for an extended period at the Tcl level, preventing the thing from being garbage-collected. </P>



<H1 CLASS="refHeading">
<A NAME="SR_10.htm_IX_Trees:generic, displaying with Swat">
 </A>
<A NAME="SR_10.htm_IX_Generic objects:displaying tree">
 </A>
<A NAME="SR_10.htm_IX_gentree Swat command:command reference">
 </A>
gentree</H1>

<PRE CLASS="syntax">gentree [&lt;address&gt;] [&lt;instance field&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;gentree&quot;</DT><DD>print the generic tree starting at *DS:SI</DD>
<DT>
&quot;gentree -i&quot;</DT><DD>print the generic tree under the mouse</DD>
<DT>
&quot;gentree [systemobj]&quot;</DT><DD>
print the generic tree starting at the system's root</DD>
<DT>
&quot;gentree @23 GI_states&quot;</DT><DD>
print the generic tree with generic states</DD>
<DT>
&quot;gentree *uiSystemObj&quot;</DT><DD>
start the generic tree at the root of the system</DD>
</DL>
<P>
Print a generic tree.</P>

<UL>
<LI>
The &lt;address&gt; argument is the address to an object in the generic tree. This defaults to *DS:SI. The `-i' flag for an implied grab may be used.</LI>
<LI>
The special object flags may be used to specify &lt;object&gt;.  For a list of these flags, see pobject.</LI>
<LI>
The &lt;instance field&gt; argument is the offset to any instance data within the GenInstance which should be printed out.</LI>
<LI>
The variable &quot;printNamesInObjTrees&quot; can be used to print out the actual app-defined labels for the objects, instead of the class, where available. This variable defaults to false.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_11.htm#IX_gup Swat command:command reference">gup</A>,
<A HREF="../../Tools/SwatRef/SR_2f.htm#IX_vistree Swat command">vistree</A>,
<A HREF="../../Tools/SwatRef/SR_15.htm#IX_impliedgrab Swat command">impliedgrab</A>,
<A HREF="../../Tools/SwatRef/SR_2c.htm#IX_systemobj Swat command">systemobj</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>.



<H1 CLASS="refHeading">
<A NAME="SR_10.htm_IX_geosfiles Swat command">
 </A>
<A NAME="SR_10.htm_IX_Files:listing with Swat">
 </A>
geosfiles</H1>

<PRE CLASS="syntax">geosfiles</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	&quot;geosfiles&quot;</P>
<P>
Print out all the files for which I/O is currently pending in GEOS.</P>

<UL>
<LI>
This looks at the same dos structure as sysfiles but this prints only those files also listed in GEOS' job file table.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2c.htm#IX_sysfiles Swat command">sysfiles</A>,
<A HREF="../../Tools/SwatRef/SR_27.htm#IX_sftwalk Swat command">sftwalk</A>,
<A HREF="../../Tools/SwatRef/SR_10.htm#IX_fwalk Swat command">fwalk</A>.



<H1 CLASS="refHeading">
<A NAME="SR_10.htm_IX_geos-release Swat command">
 </A>
geos-release</H1>
<P>
This variable contains the major number of the version of GEOS running on the target PC.</P>


<H1 CLASS="refHeading">
<A NAME="SR_10.htm_IX_Objects:monitoring with Swat">
 </A>
<A NAME="SR_10.htm_IX_geowatch Swat command">
 </A>
geowatch</H1>

<PRE CLASS="syntax">geowatch [&lt;object&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;geowatch *MyObj&quot; </DT><DD>
Display geometry calls that have reached the object MyObj</DD>
<DT>
&quot;geowatch&quot; </DT><DD>Display geometry calls that have reached *ds:si (asm) or oself (goc)</DD>
</DL>
<P>
This displays geometry calls that have reached a particular object. Only one object at a time can be watched in this way.</P>

<UL>
<LI>
Two conditional breakpoints are used by this function (see cbrk). The tokens for these breakpoints are returned. </LI>
<LI>
The special object flags may be used to specify <EM>
object</EM>
.  For a list of these flags, see pobject.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1b.htm#IX_objwatch Swat command">objwatch</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_mwatch Swat command">mwatch</A>,
<A HREF="../../Tools/Tcl/TTCL_f.htm#IX_cbrk Tcl structure:command reference">cbrk</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>.



<H1 CLASS="refHeading">
<A NAME="SR_10.htm_IX_Address history in Swat:get-address Swat command">
 </A>
<A NAME="SR_10.htm_IX_History:most recently accessed address">
 </A>
<A NAME="SR_10.htm_IX_get-address Swat command">
 </A>
get-address</H1>
<P>
Used by the various memory-access commands. Takes one argument, ADDR, being the address argument for the command. Typically, the command is declared as </P>
<PRE>[defcmd cmd {{addr nil}} ... ]</PRE>
<P>
allowing the address to be unspecified. This function will return the given address if it was, else it will return the last-accessed address (stored in the global <EM>
lastAddr</EM>
 variable as a 3-tuple from addr-parse) in the form of an address expression. If no address is recorded (<EM>
lastAddr</EM>
 is nil), the default-addr argument is used. If it is not specified then CS:IP will be used.</P>


<H1 CLASS="refHeading">
<A NAME="SR_10.htm_IX_Registers:flags register:getting flags with Swat">
 </A>
<A NAME="SR_10.htm_IX_Flags register:getting flags with Swat">
 </A>
<A NAME="SR_10.htm_IX_getcc Swat command">
 </A>
getcc</H1>

<PRE CLASS="syntax">getcc &lt;flag&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;getcc c&quot;</DT><DD>Get the carry flag.</DD>
</DL>
<P>
Get a flag from the target machine.</P>

<UL>
<LI>
The first argument is the first letter of the flag to get. The following is a list of the flags: </LI>
<DL>
<DT>
<STRONG>
                t</STRONG>
 </DT><DD>trap</DD>
<DT>
<STRONG>
               i</STRONG>
 </DT><DD>interrupt enable</DD>
<DT>
<STRONG>
          d</STRONG>
</DT><DD> direction</DD>
<DT>
<STRONG>
          o</STRONG>
</DT><DD> overflow</DD>
<DT>
<STRONG>
          s</STRONG>
</DT><DD> sign</DD>
<DT>
<STRONG>
          z</STRONG>
</DT><DD> zero</DD>
<DT>
<STRONG>
          a</STRONG>
</DT><DD> auxiliary carry</DD>
<DT>
<STRONG>
          p</STRONG>
</DT><DD> parity</DD>
<DT>
<STRONG>
          c</STRONG>
</DT><DD> carry </DD>
</DL>
<LI>
This command is handy to run with a breakpoint to stop if a flag is set.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_27.htm#IX_setcc Swat command">setcc</A>,
<A HREF="../../Tools/SwatRef/SR_6.htm#IX_clrcc Swat command">clrcc</A>,
<A HREF="../../Tools/SwatRef/SR_6.htm#IX_compcc Swat command">compcc</A>.


<HR>
<A NAME="SR_11.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_11.htm_IX_getenv Swat command">
 </A>
getenv</H1>

<PRE CLASS="syntax">getenv &lt;NAME&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;getenv PTTY&quot;	</DT><DD>
Fetches the value of the host machine's PTTY environment variable.</DD>
</DL>
<P>
Returns the value for a variable defined in Swat's environment.</P>


<P>
If the variable isn't defined, this returns the empty string.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_var Tcl command">var</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_string Tcl command">string</A>.



<H1 CLASS="refHeading">
<A NAME="SR_11.htm_IX_Key bindings in Swat">
 </A>
<A NAME="SR_11.htm_IX_get-key-binding Swat command">
 </A>
get-key-binding</H1>

<PRE CLASS="syntax">get-key-binding &lt;char&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;get-key-binding c&quot;</DT><DD>
Gets key binding for the character c.</DD>
<DT>
&quot;get-key-binding \045&quot;</DT><DD>
Gets key binding for the % key.</DD>
</DL>
<P>
Gets key binding for given key.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_3.htm#IX_alias Swat command:command reference">alias</A>,
<A HREF="../../Tools/SwatRef/SR_4.htm#IX_bind-key Swat command">bind-key</A>,
<A HREF="../../Tools/SwatRef/SR_2e.htm#IX_unbind-key Swat command">unbind-key</A>.



<H1 CLASS="refHeading">
<A NAME="SR_11.htm_IX_Formatting Swat output:integer values of expressions">
 </A>
<A NAME="SR_11.htm_IX_getvalue Swat command">
 </A>
getvalue</H1>

<PRE CLASS="syntax">getvalue &lt;expr&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;getvalue <CODE>
MSG_META_DETACH</CODE>
&quot;</DT><DD>
Returns the integer value of the symbol MSG_META_DETACH.</DD>
</DL>
<P>
This is a front-end to the &quot;addr-parse&quot; command that allows you to easily obtain the integer value of any expression. It's most useful for converting something the user might have given you to a decimal integer for further processing.</P>


<P>
If the expression you give does not evaluate to an address (whose offset will be returned) or an integer, the results of this function are undefined.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2.htm#IX_addr-parse Swat command">addr-parse</A>,
<A HREF="../../Tools/SwatRef/SR_2.htm#IX_addr-preprocess Swat command">addr-preprocess</A>.



<H1 CLASS="refHeading">
<A NAME="SR_11.htm_IX_Stepping through code:go Swat command">
 </A>
<A NAME="SR_11.htm_71276">
 </A>
<A NAME="SR_11.htm_IX_Breakpoints:single use">
 </A>
<A NAME="SR_11.htm_IX_go Swat command">
 </A>
go</H1>

<PRE CLASS="syntax">go [&lt;address expressions&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;go&quot;</DT><DD>&quot;go drawLeftLine&quot;</DD>
</DL>
<P>
Go until an address is reached.</P>

<UL>
<LI>
The &lt;address expressions&gt; argument is as many address expressions as desired for breakpoints. Execution is continued until a breakpoint is reached. These breakpoints are then removed when the machine stops and are only active for the current patient.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_break Tcl command">break</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_continue Tcl command">continue</A>,
<A HREF="../../Tools/SwatRef/SR_a.htm#IX_detach Swat command:command reference">detach</A>,
<A HREF="../../Tools/SwatRef/SR_24.htm#IX_quit Swat command:command reference">quit</A>.


<H1 CLASS="refHeading">
<A NAME="SR_11.htm_IX_gup Swat command:command reference">
 </A>
<A NAME="SR_11.htm_IX_Trees:displaying generic ancestors">
 </A>
<A NAME="SR_11.htm_IX_Generic objects:displaying ancestors">
 </A>
gup</H1>

<PRE CLASS="syntax">gup [&lt;address&gt;] [&lt;instance field&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;gup&quot;</DT><DD>print the generic object at *DS:SI and its ancestors</DD>
<DT>
 &quot;gup @23 GI_states&quot;</DT><DD>
print the states of object @23 and its ancestors</DD>
<DT>
&quot;gup -i&quot;</DT><DD>print the generic object under the mouse and the object's ancestors</DD>
</DL>
<P>
Print a list of the object and all of its generic ancestors.</P>

<UL>
<LI>
The address argument is the address to an object in the generic tree. This defaults to *DS:SI. The `-i' flag for an implied grab may be used.</LI>
<LI>
The special object flags may be used to specify &lt;object&gt;.  For a list of these flags, see pobject.</LI>
<LI>
The instance field argument is the offset to any instance data within the GenInstance which should be printed out.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_10.htm#IX_gentree Swat command:command reference">gentree</A>,
<A HREF="../../Tools/SwatRef/SR_2f.htm#IX_vup Swat command:command reference">vup</A>,
<A HREF="../../Tools/SwatRef/SR_2f.htm#IX_vistree Swat command">vistree</A>,
<A HREF="../../Tools/SwatRef/SR_15.htm#IX_impliedgrab Swat command">impliedgrab</A>.



<H1 CLASS="refHeading">
<A NAME="SR_11.htm_IX_handles Swat command">
 </A>
handles</H1>

<PRE CLASS="syntax">handles [&lt;flags&gt;] [&lt;patient&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	&quot;handles&quot;<BR>
&quot;handles -f&quot;<BR>
&quot;handles ui&quot;</P>
<P>
Print all handles in-use.</P>

<UL>
<LI>
The flags argument is a collection of flags, beginning with `-', from the following set:</LI>
<DL>
<DT>
<STRONG>
           s</STRONG>
</DT><DD>print summary only.</DD>
<DT>
<STRONG>
           e</DT><DD></STRONG>
events only.</DD>
<DT>
<STRONG>
           p</STRONG>
</DT><DD>don't print prevPtr and nextPtr.</DD>
<DT>
<STRONG>
           f</STRONG>
</DT><DD>fast print-out - this doesn't try to figure out the block type.</DD>
<DT>
<STRONG>
                r</STRONG>
 </DT><DD>reverse, i.e. starts at the end of the handle table.</DD>
<DT>
<STRONG>
               u</STRONG>
 </DT><DD>print only those handles that are in-use.</DD>
</DL>
<LI>
<A NAME="SR_11.htm_IX_Patients:displaying handles">
 </A>
The <EM>
patient</EM>
 argument is a patient whose blocks are to be selectively printed (either a name or a core-block's handle ID). The default is to print all the blocks on the heap.</LI>
<LI>
The following columns can appear in a listing:</LI>
<DL>
<DT>
HANDLE</DT><DD>The handle of the block</DD>
<DT>
ADDR</DT><DD>The segment address of the block</DD>
<DT>
SIZE</DT><DD>Size of the block in bytes</DD>
<DT>
PREV</DT><DD>The previous block handle (appears with the p flag)</DD>
<DT>
NEXT</DT><DD>The next block handle (appears with the p flag)</DD>
<DT>
FLAGS	The following letters appears in the FLAGS column:</DT><DD>
<STRONG>
s</STRONG>
   sharable,<BR>
<STRONG>
S</STRONG>
  swapable, <BR>
<STRONG>
D</STRONG>
  discardable, <BR>
<STRONG>
L</STRONG>
<A NAME="SR_11.htm_IX_Local memory:detecting heaps">
 </A>
  contains local memory heap, <BR>
<STRONG>
d</STRONG>
   discarded<BR>
            (by LMem module: discarded blocks don't appear here), <BR>
<STRONG>
a</STRONG>
   attached (notice given to swat whenever state changes)</DD>
<DT>
LOCK</DT><DD>Number of times the block is locked or n/a if FIXED.</DD>
<DT>
OWNER</DT><DD>The process which owns the block</DD>
<DT>
IDLE</DT><DD>The time since the block has been accessed in minutes:seconds</DD>
<DT>
OINFO</DT><DD>The <CODE>
otherInfo</CODE>
 field of the handle (block type dependent)</DD>
<DT>
TYPE</DT><DD>Type of the block, for example: R#1 (dgroup) resource number one</DD>
</DL>
<LI>
This only prints those handles in memory while `handles' prints all handles used.</LI>
<LI>
The handles may be printed with lhwalk and phandle.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_17.htm#IX_lhwalk Swat command:command reference">lhwalk</A>,
<A HREF="../../Tools/SwatRef/SR_1e.htm#IX_phandle Swat command">phandle</A>,
<A HREF="../../Tools/SwatRef/SR_13.htm#IX_hgwalk Swat command">hgwalk</A>.


<HR>
<A NAME="SR_12.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_12.htm_IX_Handles:displaying with Swat">
 </A>
<A NAME="SR_12.htm_IX_handsum Swat command">
 </A>
handsum</H1>

<PRE CLASS="syntax">handsum</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;handsum&quot; </DT><DD>Summarize the use to which the handle table is being put.</DD>
</DL>
<P>
This command analyzes the handle table and prints out a list of the number of handles being used by each geode, and for what purpose.</P>

<UL>
<LI>
The columns of the output are labeled somewhat obscurely, owing to horizontal-space constraints. The headings, and their meanings are:</LI>
<DL>
<DT>
 <STRONG>
Res</STRONG>
 </DT><DD>Resource handles (i.e. handles for data stored in the geode's executable)</DD>
<DT>
 <STRONG>
Mem</STRONG>
 </DT><DD>Non-resource memory handles</DD>
<DT>
 <STRONG>
File</STRONG>
 </DT><DD>Open files</DD>
<DT>
 <STRONG>
Thds</STRONG>
 </DT><DD>Threads</DD>
<DT>
 <STRONG>
Evs</STRONG>
 </DT><DD>Recorded events</DD>
<DT>
 <STRONG>
Qs</STRONG>
 </DT><DD>Event queues</DD>
<DT>
 <STRONG>
Sems</STRONG>
 </DT><DD>Semaphores</DD>
<DT>
 <STRONG>
EDat</STRONG>
 </DT><DD>Data for recorded events</DD>
<DT>
 <STRONG>
Tim</STRONG>
 </DT><DD>Timers</DD>
<DT>
 <STRONG>
SB</STRONG>
 </DT><DD>Saved blocks (handles tracking memory/resource handles whose contents will go to an application's state file)</DD>
<DT>
 <STRONG>
VMF</STRONG>
 </DT><DD>VM files</DD>
</DL>
<LI>
The &quot;handles&quot; command is good at printing out all the handles for a particular geode, but it's generally too verbose to use for the entire handle table. That's why this command exists. </LI>
<LI>
It's a good idea to issue the command &quot;dcache length 4096&quot; before executing this command, as it ensures the entire handle table will end up in Swat's data cache, for quick access if you want to use the &quot;handles&quot; command immediately afterward. </LI>
</UL>

<H1 CLASS="refHeading">
<A NAME="SR_12.htm_IX_hbrk Swat command">
 </A>
hbrk</H1>

<PRE CLASS="syntax"><A NAME="SR_12.htm_IX_Memory:monitoring with Swat"> </A><A NAME="IX_Heap:monitoring with Swat"> </A><A NAME="IX_Breakpoints:&quot;hardware breakpoints&quot;"> </A><A NAME="IX_hbrk Swat command"> </A>hbrk &lt;address&gt; (byte|word) (match|mismatch) &lt;value&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;hbrk scrollTab+10 byte match 0&quot;</DT><DD>
print message handlers until a zero is written at scrollTab+10.</DD>
<DT>
&quot;hbrk OLScrollButton+3 word mismatch 0x654f&quot;</DT><DD>
Break when the word at OLScrollButton+3 is destroyed.</DD>
</DL>
<P>
Break when a memory location changes.</P>

<UL>
<LI>
The &lt;address&gt; argument is the address to watch for a change.</LI>
<LI>
The (byte|word) argument indicates whether to watch a byte or a word for a change.</LI>
<LI>
The (match|mismatch) argument indicates whether to break if the value at the address matches or mismatches the value hbrk is called with.</LI>
<LI>
hbrk emulates a hardware breakpoint by checking at every message call to see if a location in memory has been written to. If so, swat breaks and tells between which two messages the write occurred. The information and the return stack will hopefully guide you to the offending line of code.</LI>
<LI>
The command creates two breakpoints. Remove these to get rid of the hardware breakpoint.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_f.htm#IX_brk Tcl structure:command reference">brk</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_mwatch Swat command">mwatch</A>,
<A HREF="../../Tools/SwatRef/SR_28.htm#IX_showcalls Swat command">showcalls</A>.



<H1 CLASS="refHeading">
<A NAME="SR_12.htm_IX_Heap:heapspace Swat command">
 </A>
<A NAME="SR_12.htm_IX_heapspace Swat command">
 </A>
heapspace</H1>

<PRE CLASS="syntax">heapspace &lt;geode&gt;
heapspace total 
heapspace syslib </PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;heapspace geomanager&quot; </DT><DD>
print out &quot;heapspace&quot; value for geomanager</DD>
<DT>
&quot;heapspace total&quot; </DT><DD>
print out maxTotalHeapSpace</DD>
<DT>
&quot;heapspace syslib&quot;</DT><DD>
print out space being used by system libraries.</DD>
</DL>
<P>
Prints out how much space the program requires on the heap. This value may then be used in a &quot;heapspace&quot; line of the program's .gp field. This command only determines present usage--to determine the most heapspace your geode will ever use requires that you make it allocate as much space as it ever will. This means pulling down all menus, opening all dialog boxes, and generally building out all UI gadgetry. The value this command prints is roughly the non-discardable heap usage by the app and any transient libraries that it depends on, plus an additional amount for thread activity.</P>
<P>
When using this command, you should run your application on the device it is to run on. One or more system libraries may be XIP (running from ROM) on the device, but run from RAM on your target PC's emulator. Thus, to get a more accurate picture of memory usage, run the application on the planned device.</P>


<HR>
<A NAME="SR_13.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_13.htm_IX_help Swat command:command reference">
 </A>
help</H1>

<PRE CLASS="syntax">help [&lt;command&gt;]</PRE>
<P>
This is the user-level access to the on-line help facilities for Swat. If given a topic (e.g. &quot;brk&quot;) as its argument, it will print all help strings defined for the given topic (there could be more than one if the same name is used for both a variable and a procedure, for instance). If invoked without arguments, it will enter a browsing mode, allowing the user to work his/her way up and down the documentation tree.</P>



<H1 CLASS="refHeading">
<A NAME="SR_13.htm_IX_help-fetch Swat command">
 </A>
help-fetch</H1>

<PRE CLASS="syntax">help-fetch &lt;topic-path&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	&quot;help-fetch top.patient&quot;</P>
<P>
Fetches the help string for a given topic path in the help tree.</P>


<P>
If there is more than one node with the given path in the help tree, only the string for the first node will be returned.</P>



<H1 CLASS="refHeading">
<A NAME="SR_13.htm_IX_help-fetch-level Swat command">
 </A>
help-fetch-level</H1>

<PRE CLASS="syntax">help-fetch-level</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;help-fetch-level top.prog.obscure&quot;</DT><DD>
Returns the topics within the &quot;top.prog.obscure&quot; level of the help tree.</DD>
</DL>
<P>
Returns a list of the topics available at a given level in the help tree.</P>

<P>
The result is a list of node names without leading path components.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_13.htm#IX_help-fetch Swat command">help-fetch</A>.



<H1 CLASS="refHeading">
<A NAME="SR_13.htm_IX_help-help Swat command">
 </A>
help-help</H1>

<PRE CLASS="syntax">help-help</PRE>
<P>
Provides help about using the help command (q.v.)</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_13.htm#IX_help Swat command:command reference">help</A>.



<H1 CLASS="refHeading">
<A NAME="SR_13.htm_IX_help-is-leaf Swat command">
 </A>
help-is-leaf</H1>

<PRE CLASS="syntax">help-is-leaf &lt;topic-path&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;help-is-leaf top.prog&quot;</DT><DD>
See if top.prog is a leaf node in the help tree (i.e. if it has no children).</DD>
<P>
Determines whether a given path refers to a help topic or a help category.</P>


</DL>
<P>
Returns one if the given path refers to a leaf node, zero if it is not.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_13.htm#IX_help-fetch Swat command">help-fetch</A>,
<A HREF="../../Tools/SwatRef/SR_13.htm#IX_help-fetch-level Swat command">help-fetch-level</A>.



<H1 CLASS="refHeading">
<A NAME="SR_13.htm_IX_help-minAspect Swat command">
 </A>
help-minAspect</H1>

<PRE CLASS="syntax">var help-minAspect [&lt;ratio-times-ten&gt;]</PRE>
<P>
If non-zero, contains the minimum aspect ratio to be maintained when displaying tables in the help browser. The ratio is expressed as the fraction</P>
<PRE>entries_per_column*10/number_of_columns</PRE>
<P>
E.g. a minimum ratio of 1.5 would be 15. (We multiply by ten because Swat doesn't support floating point numbers.)</P>



<H1 CLASS="refHeading">
<A NAME="SR_13.htm_IX_help-scan Swat command">
 </A>
help-scan</H1>

<PRE CLASS="syntax">help-scan &lt;pattern&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;help-scan break&quot;</DT><DD>
Looks for all nodes at any level of the help tree whose documentation includes the pattern &quot;break&quot;.</DD>
</DL>
<P>
Scans all nodes in the help tree for those whose documentation matches a given pattern.</P>

<UL>
<LI>
The result is a list of topic-paths.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_13.htm#IX_help-fetch Swat command">help-fetch</A>.



<H1 CLASS="refHeading">
<A NAME="SR_13.htm_IX_help-verbose Swat variable">
 </A>
help-verbose</H1>

<PRE CLASS="syntax">var help-verbose [0|1)]</PRE>
<P>
If non-zero, performs verbose prompting.</P>



<H1 CLASS="refHeading">
<A NAME="SR_13.htm_IX_Formatting Swat output:formatting numbers">
 </A>
<A NAME="SR_13.htm_IX_hex Swat command">
 </A>
hex</H1>

<PRE CLASS="syntax">hex &lt;number&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;hex 034&quot;</DT><DD>print hex equivalent of octal 34.</DD>
<DT>
&quot;hex 12&quot;</DT><DD>print hex equivalent of decimal 12.</DD>
</DL>
<P>
Print hexadecimal equivalent of a number.</P>


<H1 CLASS="refHeading">
<A NAME="SR_13.htm_IX_Memory:displaying usage with Swat">
 </A>
<A NAME="SR_13.htm_IX_Geodes:displaying">
 </A>
<A NAME="SR_13.htm_IX_hgwalk Swat command">
 </A>
hgwalk</H1>

<PRE CLASS="syntax">hgwalk</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;hgwalk&quot;</DT><DD>print statistics on all geodes</DD>
</DL>
<P>
Print out all geodes and their memory usage.</P>

<H1 CLASS="refHeading">
<A NAME="SR_13.htm_IX_History:history Swat command">
 </A>
<A NAME="SR_13.htm_IX_history Swat command">
 </A>
history</H1>

<PRE CLASS="syntax">history [&lt;args&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
 &quot;history 10&quot; 	</DT><DD>
Prints the last 10 commands entered via the &quot;history subst&quot; command.</DD>
<DT>
 &quot;history subst $line&quot;</DT><DD>
 Performs history substitution on the string in $line, enters the result in the history queue and returns the result.</DD>
<DT>
 &quot;var n [history cur]&quot; </DT><DD>
Stores the number of the next string to be entered via &quot;history subst&quot; in the variable n.</DD>
<DT>
 &quot;history set 50&quot; </DT><DD>
Limit the number of entries in the queue to 50.</DD>
<DT>
 &quot;history fetch 36&quot; </DT><DD>
Returns the string entered as command number 36 in the history queue.</DD>
</DL>
<P>
This command manipulates the history list. Options are:</P>
<DL>
<DT>
&lt;<STRONG>number</STRONG>&gt;</DT><DD>Prints the most-recent &lt;number&gt; commands</DD>
<DT>
<STRONG>set</STRONG> &lt;<STRONG>queue-size</STRONG>&gt;</DT><DD>
	Sets the number of commands saved</DD>
<DT>
<STRONG>subst</STRONG> &lt;<STRONG>str</STRONG>&gt;</DT><DD>
Performs history substitution on &lt;str&gt; and enters it into the history queue.</DD>
<DT>
<STRONG>cur</STRONG>
</DT><DD>Returns the current history number. If no argument is given, all saved commands are printed.</DD>
<DT>
<STRONG>fetch</STRONG> &lt;<STRONG>n</STRONG>&gt;</DT><DD>Returns the string entered as command number &lt;n&gt; in the history queue.</DD>
</DL>

<HR>
<A NAME="SR_14.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_14.htm_IX_hwalk Swat command:command reference">
 </A>
<A NAME="SR_14.htm_IX_Heap:examining">
 </A>
hwalk</H1>

<PRE CLASS="syntax">hwalk [&lt;flags&gt;] [&lt;patient&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;hwalk&quot;</DT><DD>display the heap</DD>
<DT>
&quot;hwalk -e&quot;</DT><DD>display the heap and perform error checking</DD>
<DT>
&quot;hwalk -r ui&quot;</DT><DD>
display the heap owned by the ui in reverse order</DD>
</DL>
<P>
Print the status of all blocks on the global heap.</P>

<UL>
<LI>
The &lt;flags&gt; argument is a collection of flags, beginning with `-', from the following set:</LI>
<DL>
<DT>
<STRONG>
r</STRONG>
</DT><DD>print heap in reverse order (decreasing order of addresses)</DD>
<DT>
<STRONG>
p</STRONG>
</DT><DD>print prevPtr and nextPtr as well.</DD>
<DT>
<STRONG>
e</STRONG>
</DT><DD>do error-checking on the heap.</DD>
<DT>
<STRONG>
l</STRONG>
</DT><DD>just print out locked blocks</DD>
<DT>
<STRONG>
f</STRONG>
</DT><DD>fast print-out--this doesn't try to figure out the block type</DD>
<DT>
<STRONG>
F</STRONG>
</DT><DD>print out only fixed (or pseudo-fixed) resources.</DD>
<DT>
<STRONG>
c</STRONG>
</DT><DD>Print out only code resources (discardable or fixed non-lmem non-dgroup resources).</DD>
<DT>
<STRONG>
s</STRONG>
 &lt;<STRONG>
num</STRONG>
&gt;</DT><DD>start at block &lt;num&gt;</DD>
</DL>
<LI>
The patient argument is a patient whose blocks are to be selectively printed (either a name or a core-block's handle ID). The default is to print all the blocks on the heap.</LI>
<LI>
The following columns can appear in a listing:</LI>
<DL>
<DT>
HANDLE</DT><DD>The handle of the block</DD>
<DT>
ADDR</DT><DD>The segment address of the block</DD>
<DT>
SIZE</DT><DD>Size of the block in bytes</DD>
<DT>
PREV</DT><DD>The previous block handle (appears with the p flag)</DD>
<DT>
NEXT</DT><DD>The next block handle (appears with the p flag)</DD>
<DT>
FLAGS	The following letters appears in the FLAGS column:</DT><DD>
<STRONG>
s</STRONG>
     sharable <BR>
<STRONG>
S</STRONG>
    swapable <BR>
<STRONG>
D</STRONG>
   discardable <BR>
<A NAME="SR_14.htm_IX_Local memory:detecting heaps">
 </A>
<STRONG>
L</STRONG>
    contains local memory heap <BR>
<STRONG>
d</STRONG>
    discarded <BR>
         (by LMem module: discarded blocks don't appear here) <BR>
<STRONG>
a</STRONG>
    attached (notice given to swat whenever state changes)</DD>
<DT>
LOCK</DT><DD>Number of times the block is locked or n/a if FIXED.</DD>
<DT>
OWNER</DT><DD>The process which owns the block</DD>
<DT>
IDLE</DT><DD>The time since the block has been accessed in minutes:seconds</DD>
<DT>
OINFO</DT><DD>The otherInfo field of the handle (block type dependent)</DD>
<DT>
TYPE	Type of the block, for example:</DT><DD>
R#1 (dgroup) Resource number one, named &quot;dgroup&quot;<BR>
Geode Internal control block for a geode <BR>
WINDOW, GSTATE, <BR>
   Internal structures of the given type<BR>
GSTRING, FONT_BLK, FONT OBJ(write:0) <BR>
   Object block run by thread write:0 <BR>
VM(3ef0h)... <BR>
   VM block from VM file 3ef0h</DD>
</DL>
<LI>
This only prints those handles in memory while `handles' prints all handles used.</LI>
<LI>
The handles may be printed with lhwalk and phandle.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_17.htm#IX_lhwalk Swat command:command reference">lhwalk</A>,
<A HREF="../../Tools/SwatRef/SR_1e.htm#IX_phandle Swat command">phandle</A>,
<A HREF="../../Tools/SwatRef/SR_11.htm#IX_handles Swat command">handles</A>,
<A HREF="../../Tools/SwatRef/SR_13.htm#IX_hgwalk Swat command">hgwalk</A>.



<H1 CLASS="refHeading">
<A NAME="SR_14.htm_IX_iacp Swat command">
 </A>
iacp</H1>

<P>iacp -ac <BR>
              prints all connections</PRE>
<P>
iacp -l <BR>
             prints all lists without connections</P>
<P>
iacp -d <BR>
             prints all open documents</P>
<P>
iacp &lt;obj&gt; <BR>
             prints all connections to which &lt;obj&gt; is party</P>



<H1 CLASS="refHeading">
<A NAME="SR_14.htm_IX_Breakpoints:setting interactively">
 </A>
<A NAME="SR_14.htm_IX_ibrk Swat command">
 </A>
ibrk</H1>
<P>
Set a breakpoint interactively. At each instruction, you have several options:</P>
<DL>
<DT>
<STRONG>
q </STRONG>
</DT><DD>Quit back to the command level.</DD>
<DT>
<STRONG>
 n</STRONG>
 </DT><DD>Go to next instruction (this also happens if you just hit return).</DD>
<DT>
<STRONG>
 p</STRONG>
 </DT><DD>Go to previous instruction.</DD>
<DT>
<STRONG>
 P</STRONG>
</DT><DD> Look for a different previous instruction.</DD>
<DT>
<STRONG>
 ^D</STRONG>
 </DT><DD>Go down a &quot;page&quot; of instructions. The size of the page is controlled by the global variable ibrkPageLen. It defaults to 10.</DD>
<DT>
<STRONG>
 ^U</STRONG>
 </DT><DD>Go up a &quot;page&quot; of instructions.</DD>
<DT>
<STRONG>
 b</STRONG>
 </DT><DD>Set an unconditional breakpoint at the current instruction and go back to command level.</DD>
<DT>
<STRONG>
 a</STRONG>
 </DT><DD>Like 'b', but the breakpoint is set for all patients.</DD>
<DT>
<STRONG>
 t</STRONG>
 </DT><DD>Like 'b', except the breakpoint is temporary and will be	 removed the next time the machine stops.</DD>
<DT>
<STRONG>
 B </STRONG>
</DT><DD>Like 'b', but can be followed by a command to execute when the breakpoint is hit.</DD>
<DT>
<STRONG>
 A</STRONG>
 </DT><DD>Like 'B', but for all patients.</DD>
<DT>
<STRONG>
 T</STRONG>
 </DT><DD>Like 'B', but breakpoint is temporary.</DD>


</DL>
<H1 CLASS="refHeading">
<A NAME="SR_14.htm_IX_ibrkPageLen Swat variable">
 </A>
ibrkPageLen</H1>

<PRE CLASS="syntax">var ibrkPageLen [&lt;number-of-lines&gt;]</PRE>
<P>
Number of instructions to skip when using the ^D and ^U commands of ibrk.</P>



<H1 CLASS="refHeading">
<A NAME="SR_14.htm_IX_Errors:continuing after, in Swat">
 </A>
<A NAME="SR_14.htm_IX_ignerr Swat command">
 </A>
ignerr</H1>

<PRE CLASS="syntax">ignerr</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;ignerr&quot; ignore error and continue</DT>
<DT>
&quot;ignerr MyFunc::done&quot; ignore error and continue at MyFunc::done.</DT>
<P>
Ignore a fatal error and continue.</P>

</DL>
<UL>
<LI>
The address argument is the address of where to continue execution. If not specified then CS:IP is taken from the frame. </LI>
<LI>
The stack is patched so that execution can continue in the frame above the fatal error handling routine.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_30.htm#IX_why Swat command:command reference">why</A>,
<A HREF="../../Tools/SwatRef/SR_4.htm#IX_backtrace Swat command:command reference">backtrace</A>.


<HR>
<A NAME="SR_15.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_15.htm_IX_Memory:examining with Swat">
 </A>
<A NAME="SR_15.htm_IX_imem Swat command:command reference">
 </A>
imem</H1>

<PRE CLASS="syntax">imem [&lt;address&gt;] [&lt;mode&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;imem&quot;</DT><DD>enter imem mode at DS:SI</DD>
<DT>
&quot;imem ds:di&quot;</DT><DD>
enter imem mode at DS:SI</DD>
</DL>
<P>
Examine memory and modify memory interactively.</P>

<UL>
<LI>
The address argument is the address to examine. If not specified, the address after the last examined memory location is used. If no address has been examined then DS:SI is used for the address.</LI>
<LI>
The mode argument determines how the memory is displayed and modified. Each of the four modes display the memory in various appropriate formats. The modes are:</LI>


</UL>
<UL>
<LI>
The default mode is swat's best guess of what type of object is at the address.</LI>
<LI>
imem lets you conveniently examine memory at different locations and assign it different values. imem displays the memory at the current address according to the mode. From there you can move to another memory address or you can assign the memory a value.</LI>
<LI>
You may choose from the following single-character commands:</LI>
<DL>
<DT>
<STRONG>
b</STRONG>
, <STRONG>
w</STRONG>
, <STRONG>
d</STRONG>
,<STRONG>
i</STRONG>
</DT><DD>Sets the mode to the given one and redisplays the data.</DD>
<DT>
<STRONG>
n</STRONG>
, <STRONG>
j</STRONG>
, &lt;<STRONG>
Return</STRONG>
&gt;</DT><DD>
Advances to the next data item. The memory address advances by the size of the mode.</DD>
<DT>
<STRONG>
p</STRONG>
, <STRONG>
k</STRONG>
</DT><DD>Returns to the preceding data item. The memory address decreases by the size of the mode. When displaying instructions, a heuristic is applied to locate the preceding instruction. If it chooses the wrong one, use the `P' command to make it search again.</DD>
<DT>
&lt;<STRONG>
space</STRONG>
&gt;</DT><DD>Clears the data display and allows you to enter a new value appropriate to the current display mode. The &quot;assign&quot; command is used to perform the assignment, so the same rules apply to it, with the exception of `- and &quot;-quoted strings. A string with `s around it (`hi mom') has its characters poked into memory starting at the current address. A string with &quot;s around it (&quot;swat.exe&quot;) likewise has its characters poked into memory, with the addition of a null byte at the end. This command is not valid in instruction mode.</DD>
<DT>
<STRONG>
q</STRONG>
</DT><DD>quit imem and return to command level. The last address accessed is recorded for use by the other memory-access commands.</DD>
<DT>
<STRONG>
^D</STRONG>
</DT><DD>Display a &quot;page&quot; of successive memory elements in the current mode.</DD>
<DT>
<STRONG>
^U</STRONG>
</DT><DD>Display a &quot;page&quot; of preceding memory elements in the current mode.</DD>
<DT>
<STRONG>
h</STRONG>
, <STRONG>
?</STRONG>
</DT><DD>This help list.</DD>
<DT>
 For ^D and ^U, the size of a &quot;page&quot; is kept in the global variable <CODE>
imemPageLen</CODE>
, which defaults to 10.</DT>
</DL>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_5.htm#IX_bytes Swat command:command reference">bytes</A>,
<A HREF="../../Tools/SwatRef/SR_30.htm#IX_words Swat command:command reference">words</A>,
<A HREF="../../Tools/SwatRef/SR_b.htm#IX_dwords Swat command:command reference">dwords</A>,
<A HREF="../../Tools/SwatRef/SR_4.htm#IX_assign Swat command:command reference">assign</A>.



<H1 CLASS="refHeading">
<A NAME="SR_15.htm_IX_imemPageLen Swat variable">
 </A>
imemPageLen</H1>

<PRE CLASS="syntax">var imemPageLen [&lt;numlines&gt;]</PRE>
<P>
Contains the number of elements to display when imem is given the ^D or ^U command.</P>



<H1 CLASS="refHeading">
<A NAME="SR_15.htm_IX_Mouse:object under, finding with Swat">
 </A>
<A NAME="SR_15.htm_IX_impliedgrab Swat command">
 </A>
impliedgrab</H1>

<PRE CLASS="syntax">impliedgrab</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;gentree [impliedgrab]&quot;</DT><DD>
print the generic tree under the mouse</DD>
</DL>
<P>
Print the address of the current implied grab, which is the screen object grabbing the mouse.</P>

<UL>
<LI>
This command is normally used with gentree to get the generic tree of an application by placing the mouse on application's window and issuing the command.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2c.htm#IX_systemobj Swat command">systemobj</A>,
<A HREF="../../Tools/SwatRef/SR_10.htm#IX_gentree Swat command:command reference">gentree</A>.



<H1 CLASS="refHeading">
<A NAME="SR_15.htm_IX_Windows:under mouse">
 </A>
impliedwin</H1>

<PRE CLASS="syntax">impliedwin</PRE>

<DL>
<DT>
&quot;wintree [impliedwin]&quot;</DT><DD>
print the window tree of the window under the mouse</DD>
</DL>
<P>
Print the address of the current implied window (the window under the mouse).</P>

<UL>
<LI>
Note that a window handle is returned.</LI>
<LI>
This command is normally used with wintree. One may also use the print command if they properly cast the handle.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_15.htm_IX_Interrupts:monitoring with Swat">
 </A>
<A NAME="SR_15.htm_IX_Interrupts">
 </A>
<A NAME="SR_15.htm_IX_int Swat command">
 </A>
int</H1>

<PRE CLASS="syntax">int [&lt;int level&gt; &lt;state&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;int&quot;</DT><DD>report the interrupt statuses</DD>
<DT>
<A NAME="SR_15.htm_IX_Keyboard:allowing interrupts">
 </A>
&quot;int 1:1 on&quot;</DT><DD>allow keyboard interrupt while in swat</DD>
</DL>
<P>
Set or print the state of the two interrupt controllers for when then machine is stopped in Swat.</P>

<UL>
<LI>
If no arguments are given, the current state is printed.</LI>
<LI>
The &lt;int level&gt; argument is specified by their names or their numbers with the form &lt;controller&gt;:&lt;number&gt;. &lt;controller&gt; is either 1 or 2, and &lt;number&gt; ranges from 0 to 7. The interrupts and their numbers are:</LI>
<DL>
<DT>
<STRONG>
Timer 1:0</STRONG>
<A NAME="SR_15.htm_IX_Timers:interrupt">
 </A>
</DT><DD>System timer. Probably dangerous to enable.</DD>
<DT>
<STRONG>
Keybd 1:1</STRONG>
</DT><DD>Keyboard input.</DD>
<DT>
<STRONG>
Slave 1:2</STRONG>
</DT><DD>This is how devices on controller 2 interrupt. Disabling this disables them all.</DD>
<DT>
<STRONG>
Com2 1:3</STRONG>
</DT><DD>This is the port usually used by Swat, so it can't be disabled.</DD>
<DT>
<STRONG>
Com1 1:4</STRONG>
</DT><DD>The other serial port -- usually the mouse.</DD>
<DT>
<STRONG>
LPT2 1:5</STRONG>
</DT><DD>The second parallel port</DD>
<DT>
<STRONG>
Floppy 1:6</STRONG>
</DT><DD>Floppy-disk drive</DD>
<DT>
<STRONG>
LPT1 1:7</STRONG>
</DT><DD>First parallel port</DD>
<DT>
<STRONG>
Clock 2:0</STRONG>
</DT><DD>Real-time clock</DD>
<DT>
<STRONG>
Net 2:1</STRONG>
</DT><DD>Network interfaces (?)</DD>
<DT>
<STRONG>
FPA 2:5</STRONG>
</DT><DD>Coprocessor</DD>
<DT>
<STRONG>
HardDisk 2:6</DT><DD>
</STRONG>
Hard-disk drive</DD>
</DL>
<LI>
The &lt;state&gt; argument is either on or off.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_15.htm_IX_intFormat Swat variable">
 </A>
intFormat</H1>

<PRE CLASS="syntax">var intFormat [&lt;format-string&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var intFormat %d&quot;</DT><DD>
Sets the default format for printing unsigned integers to decimal.</DD>
</DL>
<P>
$<EM>intFormat</EM>
 contains the string passed to the &quot;format&quot; command to print an integer.</P>


<P>
The default value is {%xh}, which prints the integer in hexadecimal, followed by an &quot;h&quot;.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_20.htm#IX_print Swat command:command reference">print</A>,
<A HREF="../../Tools/SwatRef/SR_5.htm#IX_byteAsChar Swat variable">byteAsChar</A>.


<HR>
<A NAME="SR_16.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_16.htm_IX_Interrupts:manipulating with Swat">
 </A>
<A NAME="SR_16.htm_IX_intr Swat command">
 </A>
intr</H1>
<P>
Catch, ignore, or deliver an interrupt on the target PC. First argument is the interrupt number. Optional second argument is &quot;catch&quot; to catch delivery of the interrupt, &quot;ignore&quot; to ignore the delivery, or &quot;send&quot; to send the interrupt (the machine will keep going once the interrupt has been handled). If no second argument is given, the interrupt is delivered.</P>


<H1 CLASS="refHeading">
<A NAME="SR_16.htm_IX_io Swat command">
 </A>
<A NAME="SR_16.htm_IX_I/O manipulating with Swat[;IO:monitoring with Swat]">
 </A>
io</H1>

<PRE CLASS="syntax">io [w] &lt;port&gt; [&lt;value&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;io 21h&quot;</DT><DD>Reads byte-sized I/O port 21h.</DD>
<DT>
&quot;io 20h 10&quot;</DT><DD>Writes decimal 10 to byte-sized I/O port 20h.</DD>
</DL>
<P>
Provides access to any I/O port on the PC.</P>

<UL>
<LI>
If you give the optional first argument &quot;w&quot; then Swat will perform a 16-bit I/O read or write, rather than the default 8-bit access. Be aware that most devices don't handle this too well. </LI>
<LI>
&lt;port&gt; must be a number (in any radix); it cannot be a register or other complex expression. </LI>
<LI>
If you don't give a &lt;value&gt;, you will be returned the contents of the I/O port (it will not be printed to the screen). </LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_16.htm_IX_Interrupts:manipulating with Swat">
 </A>
<A NAME="SR_16.htm_IX_irq Swat command">
 </A>
irq</H1>

<PRE CLASS="syntax">irq
irq (no|yes)
irq (set|clear)</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;irq&quot;</DT><DD>Returns non-zero if an interrupt is pending.</DD>
<DT>
&quot;irq no&quot;</DT><DD>Disable recognition and acting on a break request from the keyboard.</DD>
<DT>
&quot;irq set&quot;</DT><DD>Pretend the user typed Ctrl-C.</DD>
</DL>
<P>
Controls Swat's behavior with respect to interrupt requests from the keyboard.</P>

<UL>
<LI>
Swat maintains an interrupt-pending flag that is set when you type Ctrl+C (it can also be set or cleared by this command). It delays acting on the interrupt until the start of the next or the completion of the current Tcl command, whichever comes first. </LI>
<LI>
When given no arguments, it returns the current state of the interrupt-pending flag. This will only ever be non-zero if Swat is ignoring the flag (since the command wouldn't actually return if the flag were set and being paid attention to, as the interpreter would act on the flag to vault straight back to the command prompt). </LI>
<LI>
If given &quot;no&quot; or &quot;yes&quot; as an argument, it causes Swat to ignore or pay attention to the interrupt-pending flag, respectively. </LI>
<LI>
You can set or clear the flag by giving &quot;set&quot; or &quot;clear&quot; as an argument.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_16.htm_IX_Objects:testing class with Swat">
 </A>
<A NAME="SR_16.htm_IX_is-obj-in-class Swat command">
 </A>
is-obj-in-class</H1>

<PRE CLASS="syntax">is-obj-in-class &lt;obj-addr&gt; &lt;class-name&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;is-obj-in-class ^l4e10h:1eh GenPrimaryClass&quot; </DT><DD>
see if the object at ^l4e10h:1eh is in <CODE>
GenPrimaryClass</CODE>
.</DD>
</DL>
<P>
Returns whether a given object is in the specified class.</P>

<UL>
<LI>
Returns one if the object is in the specified class, zero otherwise. It will return one if the object's class is a subclass of the passed class.</LI>
<LI>
The special object flags may be used to specify &lt;object&gt;.  For a list of these flags, see pobject.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_22.htm#IX_psup Swat command">psup</A>.



<H1 CLASS="refHeading">
<A NAME="SR_16.htm_IX_istep Swat command:command reference">
 </A>
<A NAME="SR_16.htm_IX_Stepping through code:Asm">
 </A>
istep</H1>

<PRE CLASS="syntax">istep [&lt;default command&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;is&quot;</DT><DD>enter instruction step mode</DD>
<DT>
&quot;istep n&quot;</DT><DD>enter instruction step mode, &lt;ret&gt; does a next command</DD>
</DL>
<P>
Step through the execution of the current patient. This is THE command for stepping through assembly code.</P>

<UL>
<LI>
The default command argument determines what pressing the &lt;Return&gt; key does. By default, &lt;Return&gt; executes a step command. Any other command listed below may be substituted by passing the letter of the command.</LI>
<LI>
Istep steps through the patient instruction by instruction, printing where the ip is, what instruction will be executed, and what the instruction arguments contain or reference. Istep waits for the user to type a command which it performs and then prints out again where istep is executing.</LI>
<LI>
This is a list of <CODE>
istep</CODE>
 commands:</LI>
<DL>
<DT>
<STRONG>
q</STRONG>
, &lt;<STRONG>
Esc</STRONG>
&gt;, ` `</DT><DD>Stops istep and returns to command level.</DD>
<DT>
<STRONG>
b</STRONG>
</DT><DD>Toggles a breakpoint at the current location.</DD>
<DT>
<STRONG>
c</STRONG>
</DT><DD>Stops istep and continues execution.</DD>
<DT>
<STRONG>
n</STRONG>
</DT><DD>Continues to the next instruction, skipping procedure calls, repeated string instructions, and software interrupts. Using this procedure, istep only stops when the machine returns to the right context (i.e. the stack pointer and current thread are the same as they are when the &quot;n&quot; command was given). Routines which change the stack pointer should use &quot;N&quot; instead.</DD>
<DT>
<STRONG>
o</STRONG>
</DT><DD>Like &quot;n&quot; but steps over macros as well.</DD>
<DT>
<STRONG>
l</STRONG>
</DT><DD>Goes to the next library routine.</DD>
<DT>
<STRONG>
N</STRONG>
</DT><DD>Like `n', but stops whenever the breakpoint is hit, whether you're in the same frame or not.</DD>
<DT>
<STRONG>
O</STRONG>
</DT><DD>Like `N' but steps over macros as well.</DD>
<DT>
<STRONG>
m, M</STRONG>
</DT><DD>Goes to the next method called. Doesn't work when the message is not handled anywhere.</DD>
<DT>
<STRONG>
F</STRONG>
</DT><DD>Finishes the current message.</DD>
<DT>
<STRONG>
f</STRONG>
</DT><DD>Finishes out the current stack frame.</DD>
<DT>
<STRONG>
s</STRONG>
, &lt;<STRONG>
Return</STRONG>
&gt;</DT><DD>Steps one instruction.</DD>
<DT>
<STRONG>
A</DT><DD></STRONG>
Aborts the current stack frame.</DD>
<DT>
<STRONG>
S</STRONG>
</DT><DD>Skips the current instruction</DD>
<DT>
<STRONG>
B</DT><DD></STRONG>
Backs up an instruction (opposite of &quot;S&quot;).</DD>
<DT>
<STRONG>
J</STRONG>
</DT><DD>Jump on a conditional jump, even when &quot;Will not jump&quot; appears. This does not change the condition codes.</DD>
<DT>
<STRONG>
g</STRONG>
</DT><DD>Executes the `go' command with the rest of the line as arguments.</DD>
<DT>
<STRONG>
e</STRONG>
</DT><DD>Executes a Tcl command and returns to the prompt.</DD>
<DT>
<STRONG>
r</STRONG>
</DT><DD>Lists the registers (uses the regs command)</DD>
<DT>
<STRONG>
R</STRONG>
</DT><DD>References either the function to be called or the function currently executing.</DD>
<DT>
<STRONG>
h</STRONG>
, <STRONG>
?</STRONG>
</DT><DD>Displays a help message.</DD>
</DL>
<LI>
If the current patient isn't the actual current thread, <CODE>
istep</CODE>
 waits for the patient to wake up before single-stepping it.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_29.htm#IX_sstep Swat command">sstep</A>,
<A HREF="../../Tools/SwatRef/SR_17.htm#IX_listi Swat command:command reference">listi</A>.

<HR>
<A NAME="SR_17.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_17.htm_IX_keyboard Swat command">
 </A>
<A NAME="SR_17.htm_IX_Keyboard:displaying keyboard hierarchy with Swat">
 </A>
keyboard</H1>

<PRE CLASS="syntax">keyboard [&lt;object&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;keyboard&quot;</DT><DD>print keyboard hierarchy from system object down</DD>
<DT>
&quot;keyboard -i&quot; </DT><DD>print keyboard hierarchy from implied grab down</DD>
<DT>
&quot;keyboard ^l4e10h:20h&quot; </DT><DD>
print keyboard hierarchy from ^l4e10h:20h down.</DD>


</DL>
<P>
Prints the keyboard hierarchy below an object.</P>

<UL>
<LI>
If no object is specified, the system object is used. </P>
<LI>
The special object flags may be used to specify &lt;object&gt;.  For a list of these flags, see pobject.</LI>
<LI>
The variable &quot;printNamesInObjTrees&quot; can be used to print out the actual app-defined labels for the objects, instead of the class, where available. </LI>
<P>
	This variable defaults to false. </P>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2c.htm#IX_target Swat command">target</A>,
<A HREF="../../Tools/SwatRef/SR_e.htm#IX_focus Swat command">focus</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_mouse Swat command">mouse</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_model Swat command">model</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>.



<H1 CLASS="refHeading">
<A NAME="SR_17.htm_IX_Keyboard:finding keyboard grab with Swat">
 </A>
<A NAME="SR_17.htm_IX_keyboardobj Swat command">
 </A>
keyboardobj</H1>

<PRE CLASS="syntax">keyboardobj</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;keyboardobj&quot; 	</DT><DD>
return object with keyboard grab</DD>
<DT>
&quot;pobj [keyboardobj]&quot; </DT><DD>
do a <CODE>
pobject</CODE>
 on the object with the keyboard grab (equivalent  to &quot;pobj -kg&quot;.</DD>


</DL>
<P>
Returns the object with the keyboard grab.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2c.htm#IX_target Swat command">target</A>,
<A HREF="../../Tools/SwatRef/SR_e.htm#IX_focus Swat command">focus</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_mouse Swat command">mouse</A>,
<A HREF="../../Tools/SwatRef/SR_17.htm#IX_keyboard Swat command">keyboard</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_mouseobj Swat command">mouseobj</A>.



<H1 CLASS="refHeading">
<A NAME="SR_17.htm_IX_lastCommand Swat command">
 </A>
lastCommand</H1>

<PRE CLASS="syntax">$lastCommand</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var repeatCommand $lastCommand&quot;</DT><DD>
Set the current command as the command to execute next time.</DD>


</DL>
<P>
$lastCommand stores the text of the command currently being executed.</P>


<P>
This variable is set by top-level-read. Setting it yourself will have no effect, unless you call set-address or some similar routine that looks at it. </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_25.htm#IX_repeatCommand Swat variable">repeatCommand</A>.



<H1 CLASS="refHeading">
<A NAME="SR_17.htm_IX_Local memory:examaning with Swat">
 </A>
<A NAME="SR_17.htm_IX_lhwalk Swat command:command reference">
 </A>
lhwalk</H1>

<PRE CLASS="syntax">lhwalk [&lt;address&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;lhwalk 1581h&quot;</DT><DD>
list the lm heap at 1581h:0</DD>


</DL>
<P>
Prints out information about a local memory heap.</P>

<UL>
<LI>
The address argument is the address of the block to print. The default is the block pointed to by DS.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_14.htm#IX_hwalk Swat command:command reference">hwalk</A>,
<A HREF="../../Tools/SwatRef/SR_1b.htm#IX_objwalk Swat command">objwalk</A>.



<H1 CLASS="refHeading">
<A NAME="SR_17.htm_IX_link Swat command">
 </A>
link</H1>

<PRE CLASS="syntax">link &lt;library&gt; [&lt;patient&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;link motif&quot;</DT><DD>Makes the library &quot;motif&quot; a library of the current patient as far as Swat is concerned.</DD>


</DL>
<P>
Allows you to link a patient to act as an imported library of another patient, even though the other patient doesn't actually import the patient. This is useful only for symbol searches.</P>

<UL>
<LI>
sym-default is a much better way to have Swat locate symbols for libraries that are loaded by <CODE>
GeodeUseLibrary()</CODE>
. </LI>
<LI>
Cycles are not allowed. I.e. don't link your application as a library of the UI, as it won't work--or if it does, it will make Swat die. </LI>
<LI>
The link persists across detach/attach sequences so long as the &lt;patient&gt; isn't recompiled and downloaded. </LI>
<LI>
If you don't give &lt;patient&gt;, then the current patient will be the one made to import &lt;library&gt; </LI>
<LI>
Both &lt;library&gt; and &lt;patient&gt; are patient <EM>
names</EM>
, not tokens.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_13.htm#IX_help-fetch Swat command">help-fetch</A>.



<H1 CLASS="refHeading">
<A NAME="SR_17.htm_IX_listi Swat command:command reference">
 </A>
listi</H1>

<PRE CLASS="syntax">listi [&lt;address&gt;] [&lt;length&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;l&quot;</DT><DD>disassemble at the current point of execution</DD>
<DT>
&quot;listi geos::Dispatch&quot;</DT><DD>
disassemble at the kernel's dispatch routine</DD>
<DT>
&quot;listi DocClip:IsOut&quot;</DT><DD>
disassemble at the local label</DD>
<DT>
&quot;listi cs:ip 20&quot;</DT><DD>
disassemble 20 instructions from the current point of execution</DD>


</DL>
<P>
Disassemble at a memory address.</P>

<UL>
<LI>
The &lt;address&gt; argument is the address to examine. If not specified, the address after the last examined memory location is used. If no address has be examined then CS:IP is used for the address.</LI>
<LI>
The &lt;length&gt; argument is the number of instructions to list. It defaults to 16.</LI>
<LI>
Pressing &lt;Return&gt; after this command continues the list.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_16.htm#IX_istep Swat command:command reference">istep</A>,
<A HREF="../../Tools/SwatRef/SR_29.htm#IX_sstep Swat command">sstep</A>,
<A HREF="../../Tools/SwatRef/SR_28.htm#IX_skip Swat command">skip</A>.


<HR>
<A NAME="SR_18.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_18.htm_IX_Files:Loading Tcl files">
 </A>
<A NAME="SR_18.htm_IX_load Swat command:command reference">
 </A>
load</H1>

<PRE CLASS="syntax">load &lt;file&gt;</PRE>


<P>
Load a file of Tcl commands.</P>
<UL>
<LI>
If the file cannot be found as given, it is looked for in all the directories mentioned in the &quot;load-path&quot; variable. This variable is initialized from the SWATPATH environment variable, which is in the form &lt;dir1&gt;:&lt;dir2&gt;:...:&lt;dirN&gt;.</LI>
<LI>
The Swat library directory is appended to this path so you need not include it yourself. The file need not end in &quot;.tcl&quot;.</LI>
<LI>
When searching, <EM>
file</EM>
, <EM>
file</EM>
.tcl, and <EM>
file</EM>
.tlc are searched for. If <CODE>
load</CODE>
 finds a <EM>
file</EM>
.tlc file, that file will be used only if it is more recent than any corresponding <EM>
file</EM>
.tcl or <EM>
file</EM>
 file.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_18.htm_IX_Geodes:loading with Swat">
 </A>
<A NAME="SR_18.htm_IX_loadapp Swat command">
 </A>
loadapp</H1>
<P>
Load an application from swat. Single argument is the file name of the application to launch (application must reside in the appl subdirectory of the GEOS tree). </P>
<P>
The application is opened in normal application mode. Note that the application will not be loaded until you continue the machine, as the loading is accomplished by sending a message to the UI.</P>


<H1 CLASS="refHeading">
<A NAME="SR_18.htm_IX_Geodes:loading with Swat">
 </A>
<A NAME="SR_18.htm_IX_loadgeode Swat command">
 </A>
loadgeode</H1>
<P>
Load a geode from swat. Mandatory first argument is the name of the file to load (with path from top-level GEOS directory, using / instead of \ as the path separator). </P>
<P>
Second and third arguments are the data words to pass to the geode. The second argument is passed to the geode in cx, while the third argument is passed in dx.</P>
<P>
Both the second and third arguments are optional and default to 0. They likely are unnecessary.</P>


<H1 CLASS="refHeading">
<A NAME="SR_18.htm_IX_Routines:local variables">
 </A>
<A NAME="SR_18.htm_IX_Local variables:displaying with Swat">
 </A>
<A NAME="SR_18.htm_IX_locals Swat command">
 </A>
locals</H1>

<PRE CLASS="syntax">locals [&lt;func&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;locals&quot;</DT><DD>Print the values of all local variables and arguments for the current frame.</DD>
<DT>
&quot;locals WinOpen&quot;</DT><DD>
Print the names of all local variables for the given function. No values are printed.</DD>


</DL>
<P>
Allows you to quickly find the values or names of all the local variables of a function or stack frame.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_20.htm#IX_print Swat command:command reference">print</A>,
<A HREF="../../Tools/SwatRef/SR_f.htm#IX_frame Swat command:command reference">frame</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_info Tcl command">info</A>.



<H1 CLASS="refHeading">
<A NAME="SR_18.htm_IX_localwin Swat command">
 </A>
localwin</H1>

<PRE CLASS="syntax">localwin [&lt;numlines&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;localwin&quot; </DT><DD>Display local variables in a 10-line window</DD>
<DT>
 &quot;localwin 15&quot; </DT><DD>
Display local variables in a 15-line window</DD>
<DT>
 &quot;localwin off&quot; </DT><DD>
Turn off the local variable display</DD>


</DL>
<P>
Turn on or off the continuous display of local variables.</P>

<UL>
<LI>
Passing an optional numerical argument turns on display of that size. The default size is 10 lines. </LI>
<LI>
Only one local variable display may be active at a time.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_18.htm_IX_loop Swat command">
 </A>
loop</H1>
<P>
Simple integer loop procedure. Usage is:<BR>
 loop &lt;loop-variable&gt; &lt;start&gt;,&lt;end&gt; [step &lt;step&gt;] &lt;body&gt;</P>
<P>
&lt;start&gt;, &lt;end&gt;, and &lt;step&gt; are integers. &lt;body&gt; is a string for Tcl to evaluate. If no &lt;step&gt; is given, 1 or -1 (depending as &lt;start&gt; is less than or greater than &lt;end&gt;, respectively) is used. &lt;loop-variable&gt; is any legal Tcl variable name.</P>


<H1 CLASS="refHeading">
<A NAME="SR_18.htm_IX_map Swat command">
 </A>
map</H1>

<PRE CLASS="syntax">map &lt;var-list&gt; &lt;data-list&gt;+ &lt;body&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;map {i j} {a b} {c d} {list $i $j}&quot;</DT><DD>
Executes the command &quot;list $i $j&quot; with i and j assigned to successive elements of the lists {a b} and {c d}, respectively, merging the results into the list {{a c} {b d}}</DD>


</DL>
<P>
This applies a command string to the successive elements of one or more lists, binding each element in turn to a variable and evaluating the command string. The results of all the evaluations are merged into a result list.</P>

<UL>
<LI>
The number of variables given in &lt;var-list&gt; must match the number of &lt;data-list&gt; arguments you give.</LI>
<LI>
 All the &lt;data-list&gt; arguments must have the same number of elements.</LI>
<LI>
 You do not specify the result of the &lt;body&gt; with the &quot;return&quot; command. Rather, the result of &lt;body&gt; is the result of the last command executed within &lt;body&gt;.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_foreach Tcl command">foreach</A>,
<A HREF="../../Tools/SwatRef/SR_18.htm#IX_mapconcat Swat command">mapconcat</A>.



<H1 CLASS="refHeading">
<A NAME="SR_18.htm_IX_mapconcat Swat command">
 </A>
mapconcat</H1>

<PRE CLASS="syntax">mapconcat &lt;var-list&gt; &lt;data-list&gt;+ &lt;body&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;mapconcat {i j} {a b} {c d} {list $i $j}&quot;</DT><DD>
Executes the command &quot;list $i $j&quot; with i and j assigned to successive elements of the lists {a b} and {c d}, respectively, merging the results into a string.</DD>



</DL>
<H1 CLASS="refHeading">
<A NAME="SR_18.htm_IX_map-method Swat command">
 </A>
<A NAME="SR_18.htm_IX_Messages:decoding message values">
 </A>
map-method</H1>

<PRE CLASS="syntax">map-method &lt;number&gt; &lt;object&gt;
map-method &lt;number&gt; &lt;class-name&gt; [&lt;object&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;map-method ax ^lbx:si&quot; </DT><DD>
Prints the name of the message in ax, from the object at ^lbx:si's perspective.</DD>
<DT>
&quot;map-method 293 GenClass&quot; </DT><DD>
Prints the name of message number 293 from GenClass's perspective.</DD>


</DL>
<P>
Maps a message number to a human-readable message name, returning that name. This command is useful both for the user and for a Tcl procedure.</P>

<UL>
<LI>
When called from a Tcl procedure, the &lt;class-name&gt; argument should be the fullname of the class symbol (usually obtained with the obj-class function), and &lt;object&gt; should be the address of the object for which the mapping is to take place. If no &lt;object&gt; argument is provided, map-method will be unable to resolve messages defined by one of the object's superclasses that lies beyond a variant superclass. </LI>
<LI>
If no name can be found, the message number, in decimal, is returned. </LI>
<LI>
The result is simply returned, not echoed. You will need to echo the result yourself if you call this function from anywhere but the command line. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1a.htm#IX_obj-class Swat command">obj-class</A>.



<H1 CLASS="refHeading">
<A NAME="SR_18.htm_IX_Messages:monitoring with Swat">
 </A>
<A NAME="SR_18.htm_IX_mcount Swat command">
 </A>
mcount</H1>

<PRE CLASS="syntax">mcount [&lt;args&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;mcount&quot;</DT><DD>start the method count or print the count</DD>
<DT>
&quot;mcount reset&quot; </DT><DD>
restart the method count</DD>
<DT>
&quot;mcount stop&quot; </DT><DD>
stop the method count</DD>
<DT>
&quot;mcount MyAppRecalcSize&quot; </DT><DD>
count messages handled by MyAppRecalcSize</DD>


</DL>
<P>
Keep a count of the methods called.</P>


<P>
The args argument may be one of the following:</P>
<DL>
<DT>
 nothing </DT><DD>start the method count or print the current count</DD>
<DT>
'reset' </DT><DD>reset the count to zero</DD>
<DT>
'stop' </DT><DD>stop the method count and remove it's breakpoint</DD>
<DT>
 message handler 	</DT><DD>
start the method count for a particular method</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_19.htm#IX_mwatch Swat command">mwatch</A>,
<A HREF="../../Tools/SwatRef/SR_28.htm#IX_showcalls Swat command">showcalls</A>.


<HR>
<A NAME="SR_19.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_19.htm_IX_Memory:finding size with Swat">
 </A>
<A NAME="SR_19.htm_IX_memsize Swat command">
 </A>
memsize</H1>

<PRE CLASS="syntax">memsize [&lt;memory size&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;memsize&quot;</DT>
<DT>
&quot;memsize 512&quot;</DT>


</DL>
<P>
Change the amount of memory that GEOS thinks that it has.</P>

<UL>
<LI>
The &lt;memory size&gt; argument is the size to make the heap. If none is specified then the current memory size is returned.</LI>
<LI>
Memsize can only be run at startup, before the heap has been initialized. Use this right after an `att -s'.</LI>
<LI>
Memsize accounts for the size of the stub.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_19.htm_IX_methods Swat command">
 </A>
methods</H1>

<PRE CLASS="syntax">methods &lt;class&gt;
methods &lt;object&gt;
methods &lt;flags&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;methods -p&quot; </DT><DD>Print out methods defined for process</DD>
<DT>
&quot;methods ui::GenDocumentClass&quot;</DT><DD>
Print out GenDocumentClass methods</DD>
<DT>
&quot;methods 3ffch:072fh&quot;</DT><DD>
Print out methods for class at addr</DD>
<DT>
&quot;methods -a&quot; </DT><DD>Print methods of top class of app obj</DD>


</DL>
<P>
Prints out the method table for the class specified, or if an object is passed, for the overall class of the object. Useful for getting a list of candidate locations to breakpoint.</P>



<H1 CLASS="refHeading">
<A NAME="SR_19.htm_IX_Model:finding with Swat">
 </A>
<A NAME="SR_19.htm_IX_model Swat command">
 </A>
model</H1>

<PRE CLASS="syntax">model [&lt;object&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;model&quot;</DT><DD>print model hierarchy from system object down</DD>
<DT>
 &quot;model -i&quot; </DT><DD>print model hierarchy from implied grab down</DD>
<DT>
 &quot;model ^l4e10h:20h&quot; </DT><DD>
print model hierarchy from ^l4e10h:20h down.</DD>


</DL>
<P>
Prints the model hierarchy below an object.</P>

<UL>
<LI>
If no object is specified, the system object is used. </LI>
<LI>
The special object flags may be used to specify &lt;object&gt;.  For a list of these flags, see pobject.</LI>
<LI>
Remember that the object you start from may have the model exclusive within its part of the hierarchy, but still not have the exclusive because something in a different part of the tree has it. </LI>
<LI>
The variable &quot;printNamesInObjTrees&quot; can be used to print out the actual app-defined labels for the objects, instead of the class, where available. </LI>
<P>
	This variable defaults to false. </P>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2c.htm#IX_target Swat command">target</A>,
<A HREF="../../Tools/SwatRef/SR_e.htm#IX_focus Swat command">focus</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_mouse Swat command">mouse</A>,
<A HREF="../../Tools/SwatRef/SR_17.htm#IX_keyboard Swat command">keyboard</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>.



<H1 CLASS="refHeading">
<A NAME="SR_19.htm_IX_Model:finding with Swat">
 </A>
<A NAME="SR_19.htm_IX_modelobj Swat command">
 </A>
modelobj</H1>

<PRE CLASS="syntax">modelobj</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;modelobj&quot;</DT><DD>print model hierarchy from system object down</DD>
<DT>
&quot;pobj [modelobj]&quot;</DT><DD>
Do a <CODE>
pobject</CODE>
 on the object with the model grab (the equivalent of a &quot;pobj -m&quot;).</DD>


</DL>
<P>
Returns the object with the model grab.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2c.htm#IX_target Swat command">target</A>,
<A HREF="../../Tools/SwatRef/SR_e.htm#IX_focus Swat command">focus</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_model Swat command">model</A>,
<A HREF="../../Tools/SwatRef/SR_e.htm#IX_focusobj Swat command">focusobj</A>,
<A HREF="../../Tools/SwatRef/SR_2c.htm#IX_targetobj Swat command">targetobj</A>.



<H1 CLASS="refHeading">
<A NAME="SR_19.htm_IX_Mouse:printing mouse hierarchy">
 </A>
<A NAME="SR_19.htm_IX_mouse Swat command">
 </A>
mouse</H1>

<PRE CLASS="syntax">mouse [&lt;object&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;mouse&quot;</DT><DD>print mouse hierarchy from system object down</DD>
<DT>
&quot;mouse -i&quot; </DT><DD>print mouse hierarchy from implied grab down</DD>
<DT>
&quot;mouse ^l4e10h:20h&quot; </DT><DD>
print mouse hierarchy from ^l4e10h:20h down.</DD>


</DL>
<P>
Prints the mouse hierarchy below an object.</P>

<UL>
<LI>
If no object is specified, the system object is used. </LI>
<LI>
The special object flags may be used to specify &lt;object&gt;.  For a list of these flags, see pobject.</LI>
<LI>
The variable &quot;printNamesInObjTrees&quot; can be used to print out the actual app-defined labels for the objects, instead of the class, where available. </LI>
<P>
	This variable defaults to false. </P>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2c.htm#IX_target Swat command">target</A>,
<A HREF="../../Tools/SwatRef/SR_e.htm#IX_focus Swat command">focus</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_model Swat command">model</A>,
<A HREF="../../Tools/SwatRef/SR_17.htm#IX_keyboard Swat command">keyboard</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>.



<H1 CLASS="refHeading">
<A NAME="SR_19.htm_IX_Mouse:finding mouse grab with Swat">
 </A>
<A NAME="SR_19.htm_IX_mouseobj Swat command">
 </A>
mouseobj</H1>

<PRE CLASS="syntax">mouseobj</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;mouseobj&quot;</DT><DD>return object with mouse grab</DD>
<DT>
 &quot;pobj [mouseobj]&quot; </DT><DD>
do a pobject on the object with the mouse grab (equivalent to &quot;pobj -mg&quot;).</DD>


</DL>
<P>
Returns the object with the mouse grab.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2c.htm#IX_target Swat command">target</A>,
<A HREF="../../Tools/SwatRef/SR_e.htm#IX_focus Swat command">focus</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_mouse Swat command">mouse</A>,
<A HREF="../../Tools/SwatRef/SR_17.htm#IX_keyboard Swat command">keyboard</A>,
<A HREF="../../Tools/SwatRef/SR_17.htm#IX_keyboardobj Swat command">keyboardobj</A>.



<H1 CLASS="refHeading">
<A NAME="SR_19.htm_IX_Messages:monitoring with Swat">
 </A>
<A NAME="SR_19.htm_IX_mwatch Swat command">
 </A>
mwatch</H1>

<PRE CLASS="syntax">mwatch &lt;msg&gt;+
mwatch add &lt;msg&gt;+
mwatch list
mwatch clear</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;mwatch <CODE>
MSG_VIS_DRAW</CODE>
 MSG_METAQUIT&quot;</DT><DD>
watch these messages</DD>
<DT>
&quot;mwatch add <CODE>
MSG_META_START_SELECT</CODE>
&quot;</DT><DD>
watch this message also</DD>
<DT>
&quot;mwatch&quot;</DT><DD>clear all message watches</DD>


</DL>
<P>
Display all deliveries of a particular message.</P>

<UL>
<LI>
The <EM>
msg</EM>
 argument is which messages to watch. Those specified replace any messages watched before. If none are specified then any messages watched will be cleared.</LI>
<LI>
You may specify up to eight messages to be watched (fewer if you have other conditional breakpoints active). See cbrk for more information about conditional breakpoints.</LI>
<LI>
&quot;mwatch clear&quot; will clear all message watches. </LI>
<LI>
&quot;mwatch add&quot; will add the specified messages to the watch list. </LI>
<LI>
&quot;mwatch list&quot; will return a list of breakpoints that have been set by previous calls to mwatch.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1b.htm#IX_objwatch Swat command">objwatch</A>,
<A HREF="../../Tools/SwatRef/SR_1a.htm#IX_objbrk Swat command">objbrk</A>,
<A HREF="../../Tools/SwatRef/SR_1b.htm#IX_objmessagebrk Swat command">objmessagebrk</A>,
<A HREF="../../Tools/SwatRef/SR_22.htm#IX_procmessagebrk Swat command">procmessagebrk</A>.



<H1 CLASS="refHeading">
<A NAME="SR_19.htm_IX_Stepping through code:Assembly code">
 </A>
<A NAME="SR_19.htm_IX_next Swat command">
 </A>
next</H1>

<PRE CLASS="syntax">next</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;next&quot;</DT><DD>execute the next assembly instruction without entering it</DD>
<DT>
&quot;n&quot;</DT>


</DL>
<P>
Execute the patient by a single assembly instruction, skipping over any calls, repeated instructions, or software interrupts.</P>

<UL>
<LI>
<CODE>
next</CODE>
 does not protect against recursion, so when the breakpoint for the next instruction is hit, the frame of execution may be one lower.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2a.htm#IX_step Swat command">step</A>,
<A HREF="../../Tools/SwatRef/SR_16.htm#IX_istep Swat command:command reference">istep</A>.


<HR>
<A NAME="SR_1a.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_1a.htm_IX_noStructEnum Swat variable">
 </A>
<A NAME="SR_1a.htm_IX_Structures:formatting Swat output">
 </A>
noStructEnum</H1>

<PRE CLASS="syntax">var noStructEnum [(0|1)]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var noStructEnum 1&quot; </DT><DD>
Don't put &quot;struct&quot; or &quot;enum&quot; before the data type for variables that are structures or enumerated types.</DD>


</DL>
<P>
Structure fields that are structures or enumerated types normally have &quot;struct&quot; or &quot;enum&quot; as part of their type description. This usually just clutters up the display, however, so this variable shuts off this prepending.</P>


<P>
The default value of this variable is one.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_20.htm#IX_print Swat command:command reference">print</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1a.htm_IX_null Swat command">
 </A>
null</H1>

<PRE CLASS="syntax">null &lt;val&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;null $sym&quot;</DT><DD>Sees if the symbol token stored in $sym is the empty string or &quot;nil.&quot;</DD>


</DL>
<P>
Checks to see if a string is either empty or &quot;nil,&quot; special values returned by many commands when something isn't found or doesn't apply. Returns non-zero if &lt;val&gt; is either of these special values.</P>


<P>
The notion of &quot;nil&quot; as a value comes from lisp.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_index Tcl command">index</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_range Tcl command">range</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1a.htm_IX_Messages:monitoring with Swat">
 </A>
<A NAME="SR_1a.htm_IX_Objects:monitoring with Swat">
 </A>
<A NAME="SR_1a.htm_IX_objbrk Swat command">
 </A>
objbrk</H1>

<PRE CLASS="syntax">objbrk [&lt;obj address&gt;] [&lt;message&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;objbrk ds:si <CODE>
MSG_VIS_DRAW</CODE>
&quot;</DT><DD>
break when a <CODE>
MSG_VIS_DRAW</CODE>
 reaches the object</DD>
<DT>
&quot;objbrk -p&quot;</DT><DD>Break when any message is sent to the process object.</DD>


</DL>
<P>
Break when a particular message reaches a particular object.</P>

<UL>
<LI>
If you do not give a &lt;message&gt; argument after the &lt;obj&gt; argument, the machine will stop when any message is delivered to the object.</LI>
<LI>
&lt;obj&gt; is the address of the object to watch.</LI>
<LI>
The &lt;objbrk&gt; argument to &quot;objbrk del&quot; is the token/number returned when you set the breakpoint.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1b.htm#IX_objwatch Swat command">objwatch</A>,
<A HREF="../../Tools/SwatRef/SR_1b.htm#IX_objmessagebrk Swat command">objmessagebrk</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_mwatch Swat command">mwatch</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1a.htm_IX_obj-class Swat command">
 </A>
obj-class</H1>

<PRE CLASS="syntax">objclass &lt;obj-addr&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var cs [obj-class ^lbx:si]&quot; </DT><DD>
Store the symbol token for the class of the object ^lbx:si in the variable $cs.</DD>


</DL>
<P>
Figures out the class of an object, coping with unrelocated object blocks and the like.</P>

<UL>
<LI>
The value return is a symbol token, as one would pass to the &quot;symbol&quot; command. Using &quot;symbol name&quot; or &quot;symbol fullname&quot; you can obtain the actual class name. </LI>
<LI>
We decide whether to relocate the class pointer ourselves based on the LMF_RELOCATED bit in the <CODE>
LMBH_flags</CODE>
 field of the object block's header. There are times, e.g. during the call to <CODE>
MSG_META_RELOCATE</CODE>
 for an object, when this bit doesn't accurately reflect the state of the class pointer and we will return an error when we should not. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_f.htm#IX_symbol Tcl structure">symbol</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1a.htm_IX_Objects:monitoring with Swat">
 </A>
<A NAME="SR_1a.htm_IX_objcount Swat command">
 </A>
objcount</H1>

<PRE CLASS="syntax">objcount [-q] [-X] [-Y] [-b #] [-o #] [-p #]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;objcount&quot; </DT><DD>count all objects</DD>
<DT>
&quot;objcount -p welcome&quot; </DT><DD>
count all objects owned by welcome</DD>
<DT>
&quot;objcount -o *desktop::DiskDrives&quot; </DT><DD>
count this one object</DD>
<DT>
&quot;objcount -b 0x3270&quot; </DT><DD>
count all objects in this block.</DD>


</DL>
<P>
Count up instances of various objects on the heap.</P>

<UL>
<LI>
The first argument specifies the options:</LI>
<DL>
<DT>
            <STRONG>
q</STRONG>
 </DT><DD>quiet operation - no progress output (not applicable with X, Y)</DD>
<DT>
            <STRONG>
o #</STRONG>
 </DT><DD>check only object #</DD>
<DT>
           <STRONG>
 b #</STRONG>
 </DT><DD>check ONLY block #</DD>
<DT>
            <STRONG>
p #</STRONG>
 </DT><DD>check only blocks for patient #</DD>
<DT>
            <STRONG>
c # </STRONG>
</DT><DD>check only objects of class #</DD>
<DT>
           <STRONG>
 C #</STRONG>
 </DT><DD>check only objects of top-level class #</DD>
<DT>
            <STRONG>
X</STRONG>
 </DT><DD>show general verbose info</DD>
<DT>
            <STRONG>
Y</STRONG>
 </DT><DD>show search verbose info</DD>
</DL>
<LI>
Output fields:</LI>
<DL>
<DT>
          <STRONG>
direct</STRONG>
</DT><DD>number of direct instances of this class</DD>
<DT>
          <STRONG>
indirect</DT><DD>
</STRONG>
number if indirect instance of this class (i.e object's superclass is this class)</DD>
<DT>
          <STRONG>
size</STRONG>
</DT><DD>total size of instance data for this class (excludes instance data inherited from superclass)</DD>
</DL>
<LI>
Status output:</LI>
<DL>
<DT>
           <STRONG>
.</STRONG>
</DT><DD>processing heap block</DD>
<DT>
          <STRONG>
 ,</STRONG>
</DT><DD>processing matching object's top-level class</DD>
<DT>
           <STRONG>
;</STRONG>
</DT><DD>processing matching object's non-top-level class</DD>
</DL>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_14.htm#IX_hwalk Swat command:command reference">hwalk</A>,
<A HREF="../../Tools/SwatRef/SR_1b.htm#IX_objwalk Swat command">objwalk</A>,
<A HREF="../../Tools/SwatRef/SR_17.htm#IX_lhwalk Swat command:command reference">lhwalk</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1a.htm_IX_obj-foreach-class Swat command">
 </A>
obj-foreach-class</H1>

<PRE CLASS="syntax">obj-foreach-class &lt;function&gt; &lt;object&gt; [&lt;args&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;obj-foreach-class foo-callback ^lbx:si&quot; </DT><DD>
calls foo-callback with each class in turn to which the object ^lbx:si belongs.</DD>


</DL>
<P>
Processes all the classes to which an object belongs, calling a callback procedure for each class symbol in turn.</P>

<UL>
<LI>
&lt;function&gt; is called with the symbol for the current class as its first argument, &lt;object&gt; as its second, and the arguments that follow &lt;object&gt; as its third and subsequent arguments. </LI>
<LI>
&lt;function&gt; should return an empty string to continue up the class tree. </LI>
<LI>
obj-foreach-class returns whatever &lt;function&gt; returned, if it halted processing before the root of the class tree was reached. It returns the empty string if &lt;function&gt; never returned a non-empty result.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1a.htm#IX_obj-class Swat command">obj-class</A>.


<HR>
<A NAME="SR_1b.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_1b.htm_IX_Messages:monitoring with Swat">
 </A>
<A NAME="SR_1b.htm_IX_Objects:monitoring with Swat">
 </A>
<A NAME="SR_1b.htm_IX_objmessagebrk Swat command">
 </A>
objmessagebrk</H1>

<PRE CLASS="syntax">objmessagebrk [&lt;address&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;objmessagebrk MyObj&quot;</DT><DD>
break whenever a message is sent to MyObj</DD>
<DT>
&quot;objmessagebrk&quot;</DT><DD>
stop intercepting messages</DD>


</DL>
<P>
Break whenever a message is sent to a particular object via ObjMessage.</P>

<UL>
<LI>
The &lt;address&gt; argument is the address to an object to watch for messages being sent to it. If no argument is specified then the watching is stopped.</LI>
<LI>
This breaks whenever a message is sent (before they get on the message queue. This enables one to track identical messages to an object which can be removed.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1b.htm#IX_objwatch Swat command">objwatch</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_mwatch Swat command">mwatch</A>,
<A HREF="../../Tools/SwatRef/SR_22.htm#IX_procmessagebrk Swat command">procmessagebrk</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1b.htm_IX_Objects:examining with Swat">
 </A>
<A NAME="SR_1b.htm_IX_objwalk Swat command">
 </A>
objwalk</H1>

<PRE CLASS="syntax">objwalk [&lt;address&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	&quot;objwalk&quot;</P>


<P>
Prints out information about an object block.</P>

<UL>
<LI>
The &lt;address&gt; argument is the address of the block to print. The default is the block pointed at by DS.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_17.htm#IX_lhwalk Swat command:command reference">lhwalk</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1b.htm_IX_Objects:monitoring with Swat">
 </A>
<A NAME="SR_1b.htm_IX_objwatch Swat command">
 </A>
<A NAME="SR_1b.htm_IX_Messages:monitoring with Swat">
 </A>
objwatch</H1>

<PRE CLASS="syntax">objwatch [&lt;address&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;objwatch ds:si&quot;</DT><DD>
watch the messages which reach the object at DS:SI</DD>
<DT>
&quot;objwatch MyObject&quot;</DT><DD>
watch the messages which reach MyObject</DD>
<DT>
&quot;objwatch&quot;</DT><DD>
Watch the messages which reach the process object.</DD>


</DL>
<P>
Display message calls that have reached a particular object.</P>

<UL>
<LI>
The &lt;address&gt; argument is the address of the object to watch.</LI>
<LI>
This returns the token of the breakpoint being used to watch message deliveries to the object. Use the &quot;brk&quot; command to enable, disable, or turn off the watching of the object.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_f.htm#IX_brk Tcl structure:command reference">brk</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_mwatch Swat command">mwatch</A>,
<A HREF="../../Tools/SwatRef/SR_1b.htm#IX_objmessagebrk Swat command">objmessagebrk</A>,
<A HREF="../../Tools/SwatRef/SR_22.htm#IX_procmessagebrk Swat command">procmessagebrk</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1b.htm_IX_Messages:sending with Swat">
 </A>
<A NAME="SR_1b.htm_IX_omfq Swat command">
 </A>
omfq</H1>

<PRE CLASS="syntax">omfq &lt;message&gt; &lt;object&gt; &lt;args&gt;* </PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;omfq MSG_META_QUIT *HelloApp&quot;</DT><DD>
 Sends <CODE>
MSG_META_QUIT</CODE>
 to the *<CODE>
HelloApp</CODE>
 object.</DD>


</DL>
<P>
Forces a message for an object onto its event queue.</P>

<UL>
<LI>
This command calls ObjMessage, passing it <BR>
di=mask MF_FORCE_QUEUE. </LI>
<LI>
&lt;args&gt; is the set of additional parameters to pass to ObjMessage. It consists of &lt;variable/register&gt; &lt;value&gt; pairs, which are passed to the &quot;assign&quot; command. As a special case, if the variable is &quot;push&quot;, the value (a word) is pushed onto the stack and is popped when the message has been queued. </LI>
<LI>
The registers active before you issued this command are always restored, regardless of whether the call to <CODE>
ObjMessage </CODE>
completes successfully. This is in contrast to the &quot;call&quot; command, which leaves you where the machine stopped with the previous state lost. </LI>
<LI>
This command will only work when execution halts in the thread that is to receive
the message.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_5.htm#IX_call Swat command">call</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1b.htm_IX_pappcache">
 </A>
pappcache</H1>

<PRE CLASS="syntax">pappcache</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pappcache&quot; </DT><DD>Print out current state of the app-cache</DD>


</DL>
<P>
Prints out the current state of the system application cache, for systems operating in transparent launch mode.</P>


<P>
Specifically, this command prints out:</P>
<UL>
<LI>
Applications in the cache (First choice for detaching)</LI>
<LI>
Top full-screen App (Not detached except by another full screen app)</LI>
<LI>
Desk accessories (detached only as last resort)</LI>
<LI>
Application geodes in the process of detaching</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_1b.htm_IX_patch Swat command">
 </A>
patch</H1>

<PRE CLASS="syntax">patch [&lt;addr&gt;]
patch del &lt;addr&gt;*</PRE>


<P>
Patch assists in creating breakpoints that invisibly make small changes to code. This can help the programmer find several bugs without remaking and redownloading.</P>

<UL>
<LI>
If you give no &lt;addr&gt; when creating a patch, the patch will be placed at the most-recently accessed address, as set by the command that most-recently accessed memory (e.g. bytes, words, listi, imem, etc.)</LI>
<LI>
When creating a patch, you are prompted for its contents, each line of which comes from the following command set: </LI>
</UL>
<P CLASS="figCaption">
<A NAME="SR_1b.htm_Commands">
 </A>
<A NAME="SR_1b.htm_patch">
 </A>
<A NAME="SR_1b.htm_61881">
 </A>
Patch Command Set</P>
<TABLE BORDER="1">
<TR><TH>
Form</TH><TH>	Meaning</TH><TH>	Example</TH></TR>

<TR><TD>
&lt;reg&gt; = &lt;value&gt;	</TD><TD>assign value to reg</TD><TD>ax = bx		dl = 5</TD></TR>
<TR><TD>
<A NAME="SR_1b.htm_push">
 </A>
push &lt;reg&gt;|&lt;value&gt;</TD><TD>push value</TD><TD>push ax 	push 45</TD></TR>
<TR><TD>
<A NAME="SR_1b.htm_pop">
 </A>
pop &lt;reg&gt;|&lt;value&gt;</TD><TD>pop value</TD><TD>pop ax 	pop 45</TD></TR>
<TR><TD>
pop</TD><TD>pop nothing (sp=sp+2)</TD><TD>pop</TD></TR>
<TR><TD>
<A NAME="SR_1b.htm_jmp">
 </A>
jmp &lt;address&gt;</TD><TD>change ip</TD><TD>jmp UI_Attach+45</TD></TR>
<TR><TD>
<A NAME="SR_1b.htm_scall">
 </A>
scall &lt;address&gt; &lt;regs&gt;</TD><TD>call routine (save)</TD><TD>scall MemLock ax = 3</TD></TR>
<TR><TD>
<A NAME="SR_1b.htm_mcall">
 </A>
mcall&lt;address&gt; &lt;regs&gt;</TD><TD>call routine (modify)</TD><TD>mcall MemLock ax = 3</TD></TR>
<TR><TD>
<A NAME="SR_1b.htm_xchg">
 </A>
xchg &lt;reg&gt; &lt;reg&gt;</TD><TD>swap two registers</TD><TD>xchg ax bx</TD></TR>
<TR><TD>
<A NAME="SR_1b.htm_set">
 </A>
set &lt;flag&gt;</TD><TD>set condition flag</TD><TD>set CF		set ZF</TD></TR>
<TR><TD>
<A NAME="SR_1b.htm_reset">
 </A>
reset &lt;flag&gt;</TD><TD>reset condition flag</TD><TD>reset CF		reset ZF</TD></TR>
<TR><TD>
<A NAME="SR_1b.htm_if">
 </A>
if &lt;flag&gt;</TD><TD>if flag set then ...</TD><TD>if CF</TD></TR>
<TR><TD>
if !&lt;flag&gt;</TD><TD>if flag reset then ...</TD><TD>if !ZF</TD></TR>
<TR><TD>
if &lt;expr&gt;</TD><TD>if expr then ...</TD><TD>if foo == 4</TD></TR>
<TR><TD>
else</TD><TD></TD><TD></TD></TR>
<TR><TD>
endif</TD><TD></TD><TD></TD></TR>
<TR><TD>
<A NAME="SR_1b.htm_ret">
 </A>
ret</TD><TD>make function return</TD><TD>ret</TD></TR>
<TR><TD>
<A NAME="SR_1b.htm_$">
 </A>
$</TD><TD>terminate input</TD><TD></TD></TR>
<TR><TD>
<A NAME="SR_1b.htm_a">
 </A>
a</TD><TD>abort</TD><TD></TD></TR>
<TR><TD>
&lt;other&gt;</TD><TD>tcl command</TD><TD>echo $foo</TD></TR>
</TABLE>
<P CLASS="figCaption">
&lt;flag&gt; is taken from the set TF, IF, DF, OF, SF, ZF, PF, AF, CF and must be in upper-case.</P>
<P>
The &quot;scall&quot; command has no effect on the current registers (not even for purposes of return values), while the &quot;mcall&quot; command changes whatever registers the function called modifies. See the &quot;call&quot; documentation for the format of &lt;regs&gt;.</P>


<HR>
<A NAME="SR_1c.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_1c.htm_IX_patchin Swat command">
 </A>
patchin</H1>
<P>
Patchin undoes the work of patchout.</P>


<H1 CLASS="refHeading">
<A NAME="SR_1c.htm_IX_patchout Swat command">
 </A>
patchout</H1>
<P>
This command causes a RET to be placed at the start of a routine.</P>

<A NAME="SR_1c.htm_IX_patient-default Swat command">
 </A>
<H1 CLASS="refHeading">
patient-default</H1>

<PRE CLASS="syntax">patient-default [&lt;geode-name&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;patient-default hello2&quot;</DT><DD>
Makes &quot;hello2&quot; the default patient.</DD>
<DT>
&quot;patient-default&quot;</DT><DD>
Prints the names of the current default patient.</DD>


</DL>
<P>
Specifies the default patient. The <CODE>
send</CODE>
 and <CODE>
run</CODE>
 commands will use this as the default patient to operate on if none is passed to them.</P>



<H1 CLASS="refHeading">
<A NAME="SR_1c.htm_IX_Bitmaps:examining with Swat">
 </A>
<A NAME="SR_1c.htm_IX_pbitmap Swat command">
 </A>
pbitmap</H1>

<PRE CLASS="syntax">pbitmap &lt;address&gt;</PRE>


<P>
Print a bitmap graphically.</P>

<UL>
<LI>
The address argument is the address of the Bitmap or CBitmap structure.</LI>
<LI>
Color bitmaps are printed with a letter representing the color as well. The letters are index from the string (kbgcrvnAaBGCRVYW).</LI>
</UL>

<H1 CLASS="refHeading">
<A NAME="SR_1c.htm_IX_Local memory:examining chunk arrays with Swat">
 </A>
<A NAME="SR_1c.htm_IX_Chunk arrays:examining with Swat">
 </A>
<A NAME="SR_1c.htm_IX_pcarray Swat command">
 </A>
pcarray</H1>

<PRE CLASS="syntax">pcarray [-eth] [&lt;address&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pcarray&quot;</DT><DD>Print the chunk array at *DS:SI (header only)</DD>
<DT>
&quot;pcarray es:di&quot;</DT><DD>
Print the chunk array at ES:DI (header only)</DD>
<DT>
&quot;pcarray -e&quot;</DT><DD>Print the chunk array at *DS:SI and print the elements in the array</DD>
<DT>
&quot;pcarray -tMyStruct&quot;</DT><DD>
Print the chunk array at *DS:SI and print the elements where the elements are of type MyStruct</DD>
<DT>
&quot;pcarry -tMyStruct -TMyExtraStruct&quot;</DT><DD>
Like above, but data after MyStruct is printed as an array of MyExtraStruct structures.</DD>
<DT>
&quot;pcarray -e3&quot;</DT><DD>
Print the chunk array at *DS:SI and print the third element</DD>
<DT>
&quot;pcarray -hMyHeader&quot;</DT><DD>
Print the chunk array at *DS:SI (header only) where the header is of type MyHeader</DD>

</DL>
<P>
Print information about a chunk array.</P>

<UL>
<LI>
The flags argument can be any combination of the flags &quot;e&quot;, &quot;t&quot;, and &quot;h&quot;. The &quot;e&quot; flag prints all elements. If followed by a number (e.g. &quot;-e3&quot;), then only the third element will be printed.</LI>
<LI>
<A NAME="SR_1c.htm_IX_GStrings:printing elements stored in a chunk array">
 </A>
The `t' flag specifies the elements' type. It should be followed<BR>
 immediately by the element type. You can also use &quot;-tgstring&quot; if<BR>
 the elements are GString Elements.</LI>
<LI>
 The `h' flag specifies the header type. It should be followed immediately by the element type. </LI>
<LI>
 The `l' flag specifies how many elements to print. It can be used in conjunction with the `e' flag to print a range of element numbers. </LI>
<LI>
 The `H' flag suppresses printing of the header. </LI>
<LI>
 All flags are optional and may be combined.</LI>
<LI>
The address argument is the address of the chunk array. If not specified then *ds:si is used.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_1c.htm_IX_Bitmaps:examining with Swat">
 </A>
<A NAME="SR_1c.htm_IX_pcbitmap Swat command">
 </A>
pcbitmap</H1>

<PRE CLASS="syntax">pcbitmap &lt;address&gt; &lt;width&gt; &lt;height&gt; [&lt;no space flag&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pcbitmap *ds:si 64 64 t&quot;</DT><DD>
print the bitmap without spaces</DD>


</DL>
<P>
Print out a one-bit deep packbits-compacted bitmap.</P>

<UL>
<LI>
The &lt;address&gt; argument is the address to the bitmap data.</LI>
<LI>
The &lt;width&gt; argument is the width of the bitmap in pixels.</LI>
<LI>
The &lt;height&gt; argument is the height of the bitmap in pixels.</LI>
<LI>
The &lt;no space flag&gt; argument removes the space normally printed between the pixels. Anything (like &quot;t&quot;) will activate the flag.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pncbitmap Swat command">pncbitmap</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1c.htm_IX_Cells:printing cell data with Swat">
 </A>
<A NAME="SR_1c.htm_IX_pcelldata Swat command">
 </A>
pcelldata</H1>

<PRE CLASS="syntax">pcelldata [&lt;addr&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pcelldata *es:di&quot; </DT><DD>
Print cell data for cell at *es:di.</DD>


</DL>
<P>
Prints data for a spreadsheet data.</P>


<P>
If no address is given, *es:di is used.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_6.htm#IX_content Swat command">content</A>,
<A HREF="../../Tools/SwatRef/SR_1c.htm#IX_pcelldeps Swat command">pcelldeps</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1c.htm_IX_Cells:printing cell dependencies with Swat">
 </A>
<A NAME="SR_1c.htm_IX_pcelldeps Swat command">
 </A>
pcelldeps</H1>

<PRE CLASS="syntax">pcelldeps &lt;filehan&gt; [&lt;addr&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pcelldeps 4be0h *es:di&quot;	</DT><DD>
 print dependencies of cell in file 4be0h.</DD>


</DL>
<P>
Prints dependencies for a cell in the spreadsheet.</P>


<P>
If no address is given, *es:di is used.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_6.htm#IX_content Swat command">content</A>,
<A HREF="../../Tools/SwatRef/SR_1c.htm#IX_pcelldata Swat command">pcelldata</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1c.htm_IX_Objects:printing class">
 </A>
<A NAME="SR_1c.htm_IX_pclass Swat command">
 </A>
pclass</H1>

<PRE CLASS="syntax">pclass [&lt;address&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pclass&quot;</DT><DD>prints the class of *DS:SI</DD>
<DT>
&quot;pclass ^l4ac0h:001eh&quot;</DT><DD>
Print the class of the object at the given address.</DD>


</DL>
<P>
Print the object's class.</P>

<UL>
<LI>
The &lt;address&gt; argument is the address of the object to find the class of. This defaults to *DS:SI.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_1c.htm_IX_DBase:examining blocks with Swat">
 </A>
<A NAME="SR_1c.htm_IX_pdb Swat command">
 </A>
pdb</H1>
<P>
Produces useful information about a DBase block. For now, only information about the map block of the DBase file is produced. First arg H is the SIF_FILE or SIG_VM handle's ID. Second arg B is the VM block handle for which information is desired.</P>

<H1 CLASS="refHeading">
<A NAME="SR_1c.htm_dgroup:pdgroup Swat command">
 </A>
<A NAME="SR_1c.htm_IX_pdgroup Swat command">
 </A>
pdgroup</H1>
<P>

<PRE CLASS="syntax">pdgroup [&lt;flags&gt;] [&lt;patient&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG> </P>
<DL>
<DT>&quotpdgroup&quot</DT>
<DD>Prints out all dgroup variables of the current patient</DD>
<DT>&quotpdgroup -e *lock*&quot</DT>
<DD>Prints out all dgroup variables matching expression "*lock*" of the current patient</DD>
<DT>&quotpdgroup term&quot</DT>
<DD>Prints out all dgroup variables of the patient "term"</DD>
<DT>&quotpdgroup -e *lock* term&quot</DT>
<DD>Prints out all dgroup variables matching expression "*lock*" of the patient "term"</DD>
</DL>
<P>
Prints out the variables defined in dgroup.</P>

<UL>
<LI>Flags:</LI>
<DL>
<DT>-e &lt;expression&gt;</DT>
<DD>Only prints out the variables matching &lt;expression&gt;.
When -e flag is used, <EM>expression</EM> argument must be
supplied. The expression syntax is the same as the
one specified in 
&quot;<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_string Tcl command">string match</A>&quot;
command.</DD>
</DL>
</UL>

<P CLASS="refField"><STRONG>
See Also:</STRONG> 
<A HREF="../../Tools/SwatRef/SR_20.htm#IX_print Swat command:command reference">print</A>,
<A HREF="../../Tools/SwatRef/SR_22.htm#IX_pscope Swat command">pscope</A>.

</P>
<HR>
<A NAME="SR_1d.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_1d.htm_IX_Files:printing disk information with Swat">
 </A>
<A NAME="SR_1d.htm_IX_pdisk Swat command">
 </A>
pdisk</H1>

<PRE CLASS="syntax">pdisk &lt;disk-handle&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pdisk 00a2h&quot;</DT><DD>
Prints information about the disk whose handle is 00a2h.</DD>


</DL>
<P>
Prints out information about a registered disk, given its handle.</P>


<P>
The Flags column is a string of single-character flags with the following meanings:</P>
<DL>
<DT>
           <STRONG>
w</STRONG>
 </DT><DD>The disk is writable.</DD>
<DT>
           <STRONG>
V</STRONG>
 </DT><DD>The disk is always valid, i.e. it's not removable.</DD>
<DT>
           <STRONG>
S</STRONG>
 </DT><DD>The disk is stale. This is set if the drive for the disk has been deleted.</DD>
<DT>
           <STRONG>
u</STRONG>
 </DT><DD>The disk is unnamed, so the system has made up a name for it.</DD>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_a.htm#IX_diskwalk Swat command">diskwalk</A>,
<A HREF="../../Tools/SwatRef/SR_b.htm#IX_drivewalk Swat command">drivewalk</A>.

<H1 CLASS="refHeading">
<A NAME="SR_1d.htm_IX_pdrive">
 </A>
pdrive</H1>

<PRE CLASS="syntax">pdrive &lt;drive-handle&gt;
pdrive &lt;drive-name&gt;
pdrive &lt;drive-number&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pdrive si&quot;</DT><DD> Print a description of the drive whose handle is in SI</DD>
<DT>
&quot;pdrive al&quot;</DT><DD> Print a description of the drive whose number is in AL</DD>
<DT>
&quot;pdrive C&quot;</DT><DD>Print a description of drive C</DD>
</DL>
<P>
Provides the same information as &quot;drivewalk,&quot; but for a single drive, given the offset to its DriveStatusEntry structure in the FSInfoResource.</P>


<P>
This is intended for use by implementors of IFS drivers, as no one else is likely to ever see a drive handle.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_b.htm#IX_drivewalk Swat command">drivewalk</A>.


<H1 CLASS="refHeading">
<A NAME="SR_1d.htm_IX_pdw">
 </A>
pdw</H1>

<PRE CLASS="syntax">pdr &lt;register pair&gt;</PRE>

<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pdw dxax&quot;</DT>

<DT>
&quot;pdw dx.ax&quot;</DT>
<DT>
&quot;pdw dx:ax&quot;</DT><DD>Prints the dword value of register pair dx:ax</DD>
</DL>
<P>
Prints the dword value of a register pair.</P>


<P>
The first register is the high register while the second is 
the low register.</P>

<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_20.htm#IX_print Swat command:command reference">print</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1d.htm_IX_Structures:formatting enumerated type values with Swat">
 </A>
<A NAME="SR_1d.htm_IX_penum Swat command">
 </A>
penum</H1>

<PRE CLASS="syntax">penum &lt;type&gt; &lt;value&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
<A NAME="SR_1d.htm_IX_Errors:decoding FatalErrors values">
 </A>
&quot;penum FatalErrors 0&quot;</DT><DD>
print the first FatalErrors enumeration</DD>


</DL>
<P>
Print an enumeration constant given a numerical value.</P>

<UL>
<LI>
The &lt;type&gt; argument is the type of the enumeration.</LI>
<LI>
The &lt;value&gt; argument is the value of the enumeration in a numerical format.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_20.htm#IX_print Swat command:command reference">print</A>,
<A HREF="../../Tools/SwatRef/SR_20.htm#IX_precord Swat command">precord</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1d.htm_IX_Events:printing with Swat">
 </A>
<A NAME="SR_1d.htm_IX_pevent Swat command">
 </A>
pevent</H1>

<PRE CLASS="syntax">pevent &lt;handle&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pevent 39a0h&quot;</DT><DD>
Print event with handle.</DD>


</DL>
<P>
Print an event given its handle.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_c.htm#IX_elist Swat command">elist</A>,
<A HREF="../../Tools/SwatRef/SR_c.htm#IX_eqlist Swat command">eqlist</A>,
<A HREF="../../Tools/SwatRef/SR_c.htm#IX_eqfind Swat command">eqfind</A>,
<A HREF="../../Tools/SwatRef/SR_c.htm#IX_erfind Swat command">erfind</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1d.htm_IX_Registers:flags register:printing">
 </A>
<A NAME="SR_1d.htm_IX_Flags register:printing">
 </A>
<A NAME="SR_1d.htm_IX_pflags Swat command">
 </A>
pflags</H1>

<PRE CLASS="syntax">pflags</PRE>


<P>
Prints the current machine flags (carry, zero, etc.).</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_27.htm#IX_setcc Swat command">setcc</A>,
<A HREF="../../Tools/SwatRef/SR_10.htm#IX_getcc Swat command">getcc</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1d.htm_IX_Fonts:examining with Swat">
 </A>
<A NAME="SR_1d.htm_IX_pfont Swat command">
 </A>
pfont</H1>

<PRE CLASS="syntax">pfont [-c] [&lt;address&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pfont&quot;</DT><DD>print bitmaps of the characters of the font in BX.</DD>
<DT>
&quot;pfont -c ^h1fd0h&quot;</DT><DD>
list the characters in the font at ^h1fd0h.</DD>


</DL>
<P>
Print all the bitmaps of the characters in a font.</P>


<P>
&nbsp;</P>
<UL>
<LI>
The &quot;-c&quot; flag causes pfont to list which characters are in the font and any special status (i.e. NOT BUILT).</LI>
<LI>
The &lt;address&gt; argument is the address of the font. If none is specified then ^hbx is used.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_e.htm#IX_fonts Swat command">fonts</A>,
<A HREF="../../Tools/SwatRef/SR_23.htm#IX_pusage Swat command">pusage</A>,
<A HREF="../../Tools/SwatRef/SR_1d.htm#IX_pfontinfo Swat command">pfontinfo</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1d.htm_IX_Fonts:examining with Swat">
 </A>
<A NAME="SR_1d.htm_IX_pfontinfo Swat command">
 </A>
pfontinfo</H1>

<PRE CLASS="syntax">pfontinfo &lt;font ID&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	&quot;pfontinfo FID_BERKELEY&quot;</P>


<P>
Prints font header information for a font. Also lists all sizes built.</P>

<UL>
<LI>
The &lt;font ID&gt; argument must be supplied. If not known, use `fonts -u' to list all the fonts with their IDs.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_e.htm#IX_fonts Swat command">fonts</A>,
<A HREF="../../Tools/SwatRef/SR_1d.htm#IX_pfont Swat command">pfont</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1d.htm_IX_Objects:displaying generic instance data">
 </A>
<A NAME="SR_1d.htm_IX_Instance data:displaying GenClass">
 </A>
<A NAME="SR_1d.htm_IX_Generic objects:displaying instance data with Swat">
 </A>
<A NAME="SR_1d.htm_IX_pgen Swat command">
 </A>
pgen</H1>

<PRE CLASS="syntax">pgen &lt;element&gt; [&lt;object&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pgen GI_states @65&quot;</DT><DD>
print the states of object 65</DD>
<DT>
<A NAME="SR_1d.htm_IX_Monikers:displaying with Swat">
 </A>
&quot;pgen GI_visMoniker&quot;</DT><DD>
print the moniker of the object at *DS:SI</DD>
<DT>
&quot;pgen GI_states -i&quot;</DT><DD>
print the states of the object at the implied grab</DD>


</DL>
<P>
Print an element of the generic instance data.</P>

<UL>
<LI>
The &lt;element&gt; argument specifies which element in the object to print</LI>
<LI>
The &lt;object&gt; argument is the address to the object to print out. It defaults to *DS:SI and is optional. The `-i' flag for an implied grab may be used.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_10.htm#IX_gentree Swat command:command reference">gentree</A>,
<A HREF="../../Tools/SwatRef/SR_11.htm#IX_gup Swat command:command reference">gup</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_piv Swat command">piv</A>,
<A HREF="../../Tools/SwatRef/SR_23.htm#IX_pvis Swat command">pvis</A>.


<HR>
<A NAME="SR_1e.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_1e.htm_IX_GStrings:examining with Swat">
 </A>
<A NAME="SR_1e.htm_IX_pgs Swat command">
 </A>
pgs</H1>

<PRE CLASS="syntax">pgs &lt;address&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pgs&quot;</DT><DD>List the graphics string at DS:SI</DD>
<DT>
&quot;pgs ^hdi&quot;</DT><DD>Lift the graphics string whose handle is in DI, starting at the current position.</DD>
<DT>
&quot;pgs -s ^hdi&quot;</DT><DD>List the graphics string whose handle is in DI, starting at the beginning of the graphics string.</DD>
<DT>
&quot;pgs -l3 ^hdi&quot;	</DT><DD>
List three elements of the graphics string whose handle is in DI, starting at the current position.</DD>


</DL>
<P>
List the contents of a graphics string.</P>

<UL>
<LI>
The &lt;address&gt; argument is the address of a graphics string. If none is specified then DS:SI is used as a pointer to a graphics string.</LI>
<LI>
The passed address may also be the base of a gstate (e.g. &quot;^hdi&quot;). In this case, the gstring that is associated with the gstate will be printed.</LI>
<LI>
The -s option can be used to specify that the gstring should be listed from the beginning of the string. By default, gstrings will be listed starting at the current position.</LI>
<LI>
The -g option can be used to specify that the passed address is the address of a GrObj (GStringClass) object-- the gstring for that object will be listed.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1c.htm#IX_pbitmap Swat command">pbitmap</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1e.htm_IX_Handles:examining with Swat">
 </A>
<A NAME="SR_1e.htm_IX_phandle Swat command">
 </A>
phandle</H1>

<PRE CLASS="syntax">phandle &lt;handle ID&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;phandle 1a8ch&quot;</DT><DD>
print the handle 1a8ch</DD>


</DL>
<P>
Print out a handle.</P>

<UL>
<LI>
The &lt;handle ID&gt; argument is just the handle number. Make sure that the proper radix is used.</LI>
<LI>
The size is in paragraphs.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_14.htm#IX_hwalk Swat command:command reference">hwalk</A>,
<A HREF="../../Tools/SwatRef/SR_17.htm#IX_lhwalk Swat command:command reference">lhwalk</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1e.htm_IX_Virtual memory:printing huge arrays">
 </A>
<A NAME="SR_1e.htm_IX_Huge arrays:printing with Swat">
 </A>
<A NAME="SR_1e.htm_IX_pharray Swat command">
 </A>
pharray</H1>

<PRE CLASS="syntax">pharray [&lt;flags&gt;] [&lt;vmfile&gt; &lt;dirblk&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pharray&quot; </DT><DD>Print the huge array at ^vbx:di (header only)</DD>
<DT>
&quot;pharray dx cx&quot; </DT><DD>
Print the huge array at ^vdx:cx (header only)</DD>
<DT>
&quot;pharray -e&quot; </DT><DD>Print the huge array at ^vbx:di and print the elements in the array</DD>
<DT>
&quot;pharray -tMyStruct&quot; </DT><DD>
Print the huge array at ^vbx:di and print the elements where the elements are of type MyStruct</DD>
<DT>
&quot;pharray -e3&quot; </DT><DD>
Print the huge array at ^vbx:di and print the third element</DD>
<DT>
&quot;pharray -h&quot; </DT><DD>Print the header of the HugeArray at ^vbx:di, using the default header type (HugeArrayDirectory).</DD>
<DT>
&quot;pharray -hMyHeader&quot; </DT><DD>
Print the huge array at ^vbx:di (header only) where the header is of type MyHeader</DD>
<DT>
&quot;pharray -d&quot; </DT><DD>Print the directory elements of a HugeArray</DD>
<DT>
&quot;pharray -e5 -l8&quot; </DT><DD>
Print 8 HugeArray elements starting with number 5</DD>


</DL>
<P>
Print information about a huge array.</P>

<UL>
<LI>
The flags argument can be any combination of the flags `e', `t', and `h'. The `e' flag prints all elements. If followed by a number &quot;-e3&quot;, then only the third element is printed. </LI>
<P>
	The `t' flag specifies the elements' type. It should be followed immediately by the element type. You can also use &quot;gstring&quot;, in which case the elements will be interpreted as GString Elements. </P>
<P>
	The `h' flag specifies the header type. It should be followed immediately by the element type. If no options are specified, then &quot;-hHugeArrayDirectory&quot; is used. If any other options are specified, then the printing of the header is disabled. So, for example, if you want both the header and the third element, use &quot;-h -e3&quot;. </P>
<P>
	The `d' flag specifies that the HugeArray directory entries should be printed out. </P>
<P>
	The `l' flag specified how many elements to print.</P>
<P>
	The `s' flag requests that a summary table be printed.</P>
<P>
	All flags are optional and may be combined. </P>
<LI>
The address arguments are the VM file handle and the VM block handle for the directory block. If nothing is specified, then bx:di is used</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_1e.htm_IX_GEOS.INI file:examing with Swat">
 </A>
<A NAME="SR_1e.htm_IX_pini Swat command">
 </A>
pini</H1>

<PRE CLASS="syntax">pini [&lt;category&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pini Lights Out&quot; </DT><DD>
Print out the contents of the Lights Out category in each .ini file</DD>
<DT>
 &quot;pini&quot; </DT><DD>Print out each currently loaded .ini file.</DD>


</DL>
<P>
Provides you with the contents of the .ini files being used by the current GEOS session.</P>


<P>
&lt;category&gt; may contain spaces and other such fun things. In fact, if you attempt to quote the argument (e.g. &quot;pini {Lights Out}&quot;), this will not find the category.</P>


<HR>
<A NAME="SR_1f.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_1f.htm_IX_Objects:examining with Swat">
 </A>
<A NAME="SR_1f.htm_IX_pinst Swat command">
 </A>
<A NAME="SR_1f.htm_IX_Instance data:examining with Swat">
 </A>
pinst</H1>

<PRE CLASS="syntax">pinst [&lt;address&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pinst&quot;</DT><DD>print the last master level of instance data of the object at *DS:SI</DD>
<DT>
&quot;pinst *MyObject&quot;	</DT><DD>
print the last master level of instance data of MyObject.</DD>
<DT>
&quot;pinst -i&quot;</DT><DD>print the last master level of the windowed object at the mouse pointer.</DD>


</DL>
<P>
Print out all the instance data to the last level of the object.</P>

<UL>
<LI>
The &lt;address&gt; argument is the address of the object to examine. If not specified then pinst will use a default address. If you are debugging a C method, then the oself value will be used. Otherwise, *DS:SI is assumed to be an object.</LI>
<LI>
This command is useful for classes you've created and you are not interested in the data in the master levels which pobject would display.</LI>
<LI>
The following special values are accepted for &lt;address&gt;:</LI>
<DL>
<DT>
           <STRONG>
-a</STRONG>
</DT><DD>the current patient's application object</DD>
<DT>
           <STRONG>
-i</STRONG>
 </DT><DD>the current &quot;implied grab&quot;: the windowed object over which the mouse is currently located.</DD>
<DT>
           <STRONG>
-f</STRONG>
 </DT><DD>the leaf of the keyboard-focus hierarchy</DD>
<DT>
           <STRONG>
-t </STRONG>
</DT><DD>the leaf of the target hierarchy</DD>
<DT>
           <STRONG>
-m</STRONG>
 </DT><DD>the leaf of the model hierarchy</DD>
<DT>
           <STRONG>
-c</STRONG>
 </DT><DD>the content for the view over which the mouse is currently located</DD>
<DT>
           <STRONG>
-kg</STRONG>
 </DT><DD>the leaf of the keyboard-grab hierarchy</DD>
<DT>
           <STRONG>
-mg</STRONG>
</DT><DD> the leaf of the mouse-grab hierarchy</DD>
</DL>
<LI>
<CODE>
pinst</CODE>
 prints out the same information as &quot;pobj l&quot;.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_piv Swat command">piv</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1f.htm_IX_Instance data:examining with Swat">
 </A>
<A NAME="SR_1f.htm_IX_Objects:examining with Swat">
 </A>
<A NAME="SR_1f.htm_IX_piv Swat command">
 </A>
piv</H1>

<PRE CLASS="syntax">piv &lt;master&gt; &lt;iv&gt; [&lt;address&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;piv Vis VCNI_viewHeight&quot;</DT><DD>
print Vis.VCNI_viewHeight at *DS:SI</DD>


</DL>
<P>
This prints out the value of the instance variable specified.</P>

<UL>
<LI>
The &lt;master&gt; argument expects the name of a master level. The name may be found using <CODE>
pobject</CODE>
 to print the levels, and then using the name that appears after &quot;master part:&quot; and before the &quot;_offset&quot;.</LI>
<LI>
The &lt;iv&gt; argument expects the name of the instance variable to print.</LI>
<LI>
The &lt;address&gt; argument is the address of the object to examine. If not specified then *DS:SI assumed to be an object.</LI>
<LI>
This command is useful for when you know what instance variable you want to see but don't want to wade through a whole pobject command.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pinst Swat command">pinst</A>.


<P>
Prints a keyboard map in assembly-language format.</P>



<H1 CLASS="refHeading">
<A NAME="SR_1f.htm_IX_plines Swat command">
 </A>
plines</H1>

<PRE CLASS="syntax">plines &lt;start&gt; [&lt;obj-address&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;plines 12&quot;</DT><DD>Print lines starting at line 12.</DD>
<DT>
&quot;plines 12 ^l6340h:0020h&quot;</DT><DD>
Print lines starting at line 12 of object at given address.</DD>


</DL>
<P>
Print information about the lines in a text object.</P>


<P>
The printed line-starts are <EM>
not</EM>
 correct.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_23.htm#IX_ptext Swat command">ptext</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1f.htm_IX_Local memory:examining with Swat">
 </A>
<A NAME="SR_1f.htm_IX_plist Swat command">
 </A>
plist</H1>
<P>
Prints out a list of structures stored in an lmem chunk. It takes two arguments, the structure type that makes up the list, and the lmem handle of the chunk. e.g. plist FontsInUseEntry ds:di</P>


<H1 CLASS="refHeading">
<A NAME="SR_1f.htm_IX_Bitmaps:examining with Swat">
 </A>
<A NAME="SR_1f.htm_IX_pncbitmap Swat command">
 </A>
pncbitmap</H1>

<PRE CLASS="syntax">pncbitmap &lt;address&gt; &lt;width&gt; &lt;height&gt; [&lt;no space flag&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pncbitmap *ds:si 64 64 t&quot;</DT><DD>
print the bitmap without spaces</DD>


</DL>
<P>
Print out a one-bitdeep noncompacted bitmap.</P>

<UL>
<LI>
The &lt;address&gt; argument is the address to the bitmap data.</LI>
<LI>
The &lt;width&gt; argument is the width of the bitmap in pixels.</LI>
<LI>
The &lt;height&gt; argument is the height of the bitmap in pixels.</LI>
<LI>
The &lt;no space flag&gt; argument removes the space normally printed between the pixels. Anything (like `t') will activate the flag.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1c.htm#IX_pcbitmap Swat command">pcbitmap</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1f.htm_IX_Clipboard:printing transfer item with Swat">
 </A>
<A NAME="SR_1f.htm_IX_pnormal Swat command">
 </A>
pnormal</H1>

<PRE CLASS="syntax">pnormal [-v]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pnormal -v&quot;</DT><DD>
Print out verbose information about the current normal transfer item.</DD>


</DL>
<P>
Prints out information about the current &quot;normal&quot; transfer item on the clipboard.</P>


<P>
If you give the &quot;-v&quot; flag, this will print out the contents of the different transfer formats, rather than just an indication of their types. </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_20.htm#IX_pquick Swat command">pquick</A>,
<A HREF="../../Tools/SwatRef/SR_21.htm#IX_print-clipboard-item Swat command">print-clipboard-item</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1f.htm_IX_pobjarray Swat command">
 </A>
pobjarray</H1>

<PRE CLASS="syntax">pobjarray [&lt;address&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pobjarray&quot;</DT><DD>Print the array of ODs at *ds:si.</DD>


</DL>
<P>
Print out an array of objects.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1c.htm#IX_pbody Swat command">pbody</A>.



<H1 CLASS="refHeading">
<A NAME="SR_1f.htm_IX_pobject Swat command:command reference">
 </A>
<A NAME="SR_1f.htm_IX_Objects:examining with Swat">
 </A>
pobject</H1>

<PRE CLASS="syntax">pobject [&lt;address&gt;] [&lt;detail&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pobj&quot; </DT><DD>print the object at *ds:si from Gen down if Gen is one of its master levels; else, print all levels</DD>
<DT>
&quot;pobj *MyGenObject&quot; </DT><DD>
print MyGenObject from Gen down</DD>
<DT>
&quot;pobj Gen&quot; </DT><DD>print the Gen level for the object at *ds:si</DD>
<DT>
&quot;pobj last&quot;</DT><DD> print the last master level for the object at *ds:si</DD>
<DT>
&quot;pobj *MyObject&quot;</DT><DD>
 all print all levels of MyObject</DD>
<DT>
&quot;pobj -i sketch&quot; </DT><DD>
print the master level headings of the windowed object at the mouse pointer</DD>
<DT>
&quot;pobj *MyObject FI_foo&quot;</DT><DD>
 print the FI_foo instance variable for MyObject</DD>
<DT>
&quot;pobj HINT_FOO&quot; </DT><DD>
print the HINT_FOO variable data entry for the object at *ds:si</DD>
<DT>
&quot;pobj v&quot; </DT><DD>print the variable data for the object at *ds:si</DD>


</DL>
<P>
Print all or part of an object's instance and variable data.</P>

<UL>
<LI>
The &lt;address&gt; argument is the address of the object to examine. If not specified then oself is used, unless the current function is written in assembly, in which case *DS:SI . </LI>
<LI>
The following flag values are accepted in lieu of an address:</LI>
<DL>
<DT>
           <STRONG>
-a</STRONG>
</DT><DD>the current patient's application object</DD>
<DT>
           <STRONG>
-i</STRONG>
 </DT><DD>the current &quot;implied grab&quot;: the windowed object over which the mouse is currently located.</DD>
<DT>
           <STRONG>
-f</STRONG>
 </DT><DD>the leaf of the keyboard-focus hierarchy</DD>
<DT>
           <STRONG>
-t</STRONG>
 </DT><DD>the leaf of the target hierarchy</DD>
<DT>
           <STRONG>
-m</STRONG>
 </DT><DD>the leaf of the model hierarchy</DD>
<DT>
           <STRONG>
-c</STRONG>
 </DT><DD>the content for the view over which the mouse is currently located</DD>
<DT>
           <STRONG>
-kg</STRONG>
 </DT><DD>the leaf of the keyboard-grab hierarchy</DD>
<DT>
           <STRONG>
-mg</STRONG>
</DT><DD> the leaf of the mouse-grab hierarchy</DD>
</DL>
<LI>
The <EM>
detail</EM>
 argument specifies what information should be printed out about the object. If none is specified, all levels of the object from the Gen level down will be printed if Gen is one of the object's master levels; else, the whole object will be printed.</LI>
<LI>
The following values are accepted for <EM>
detail</EM>
:</LI>
<DL>
<DT>
           <STRONG>
all</STRONG>
 (or <STRONG>
a</STRONG>
) 	</DT><DD>
all master levels</DD>
<DT>
           <STRONG>
last</STRONG>
 (or <STRONG>
l</STRONG>
)	</DT><DD>
last master level only</DD>
<DT>
           <STRONG>
sketch</STRONG>
 (or <STRONG>
s</STRONG>
)</DT><DD>
master level headings only</DD>
<DT>
           <STRONG>
vardata</STRONG>
 (or <STRONG>
v</STRONG>
)</DT><DD>
vardata only</DD>
<DT>
           a master level name</DT>
<DT>
           an instance variable name</DT>
<DT>
           a variable data entry name </DT>
</DL>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pinst Swat command">pinst</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_piv Swat command">piv</A>,
<A HREF="../../Tools/SwatRef/SR_23.htm#IX_pvardata Swat command">pvardata</A>.


<HR>
<A NAME="SR_20.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_20.htm_IX_Monikers:examining with Swat">
 </A>
<A NAME="SR_20.htm_IX_Objects:examining with Swat">
 </A>
<A NAME="SR_20.htm_IX_pobjmon Swat command">
 </A>
pobjmon</H1>

<PRE CLASS="syntax">pobjmon [&lt;address&gt;] [&lt;text only&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pobjmon&quot;</DT><DD>print the VisMoniker from the gentree object at *DS:SI</DD>


</DL>
<UL>
<LI>
The &lt;address&gt; argument is the address of an object with a VisMoniker. If none is specified then *DS:SI is used.</LI>
<LI>
The &lt;text only&gt; argument returns a shortened description of the structure. To set it use something other than `0' for the second argument.</LI>
<LI>
The special object flags may be used to specify &lt;object&gt;.  For a list of these flags, see pobject.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_24.htm#IX_pvismon Swat command">pvismon</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>,
<A HREF="../../Tools/SwatRef/SR_2f.htm#IX_vistree Swat command">vistree</A>,
<A HREF="../../Tools/SwatRef/SR_11.htm#IX_gup Swat command:command reference">gup</A>,
<A HREF="../../Tools/SwatRef/SR_10.htm#IX_gentree Swat command:command reference">gentree</A>,
<A HREF="../../Tools/SwatRef/SR_15.htm#IX_impliedgrab Swat command">impliedgrab</A>,
<A HREF="../../Tools/SwatRef/SR_2c.htm#IX_systemobj Swat command">systemobj</A>.



<H1 CLASS="refHeading">
<A NAME="SR_20.htm_IX_pod Swat command">
 </A>
pod</H1>

<PRE CLASS="syntax">pod &lt;address&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pod ds:si&quot;</DT>


</DL>
<P>
Print in output descriptor format (^l&lt;handle&gt;:&lt;chunk&gt;) the address passed.</P>


<P>
The address argument is the address of an object.</P>



<H1 CLASS="refHeading">
<A NAME="SR_20.htm_IX_Paths (graphics):displaying with Swat">
 </A>
<A NAME="SR_20.htm_IX_ppath Swat command">
 </A>
ppath</H1>

<PRE CLASS="syntax">ppath (current|docClip|winClip) [&lt;gstate&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;ppath&quot; </DT><DD>print the current path of the GState in ^hdi</DD>
<DT>
 &quot;ppath docClip ^hgstate&quot;</DT><DD>
 print the document clip path of the GState with handle <EM>
gstate</EM>
.</DD>
<DT>
 &quot;ppath winClip ds&quot; </DT><DD>
print the window clip path of the GState in the DS register.</DD>


</DL>
<P>
Print the structure of a path.</P>


<P>
Unique abbreviations for the path to be printed are allowed.</P>


<A NAME="SR_20.htm_IX_pquick Swat command">
 </A>

<H1 CLASS="refHeading">
pquick</H1>

<PRE CLASS="syntax">pquick [-v]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pquick -v&quot;</DT><DD>Print out verbose information about the current quick transfer item.</DD>


</DL>
<P>
Prints out information about the current &quot;quick&quot; transfer item on the clipboard.</P>


<P>
If you give the &quot;-v&quot; flag, this will print out the contents of the different transfer formats, rather than just an indication of their types.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pnormal Swat command">pnormal</A>,
<A HREF="../../Tools/SwatRef/SR_21.htm#IX_print-clipboard-item Swat command">print-clipboard-item</A>.



<H1 CLASS="refHeading">
<A NAME="SR_20.htm_IX_ByteFlags:printing flag fields">
 </A>
<A NAME="SR_20.htm_IX_WordFlags:printing flag fields">
 </A>
<A NAME="SR_20.htm_IX_Flags:examining flags fields">
 </A>
<A NAME="SR_20.htm_IX_precord Swat command">
 </A>
precord</H1>

<PRE CLASS="syntax">precord &lt;type&gt; &lt;value&gt; [&lt;silent&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;precord GSControl c0h&quot;</DT><DD>
print the <CODE>
GSControl</CODE>
 record with the top two bits set</DD>


</DL>
<P>
Print a record using a certain value.</P>

<UL>
<LI>
The &lt;type&gt; argument is the type of the record.</LI>
<LI>
The &lt;value&gt; argument is the value of the record.</LI>
<LI>
The &lt;silent&gt; argument will suppress the text indicating the record type and value. This is done by passing a non zero value like `1'. This is useful when precord is used by other functions.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_20.htm#IX_print Swat command:command reference">print</A>,
<A HREF="../../Tools/SwatRef/SR_1d.htm#IX_penum Swat command">penum</A>.



<H1 CLASS="refHeading">
<A NAME="SR_20.htm_IX_Regions, graphics:examining with Swat">
 </A>
<A NAME="SR_20.htm_IX_Windows:clipping region">
 </A>
<A NAME="SR_20.htm_IX_preg Swat command">
 </A>
preg</H1>

<PRE CLASS="syntax">preg [-g] &lt;addr&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
 &quot;preg *es:W_appReg&quot; </DT><DD>
Prints the application-defined clipping region for the window pointed to by es.</DD>
<DT>
 &quot;preg -g ds:si&quot; </DT><DD>
Prints a &quot;graphical&quot; representation of the region beginning at ds:si</DD>


</DL>
<P>
Decodes a graphics GEOS region and prints it out, either numerically, or as a series of x's and spaces.</P>

<UL>
<LI>
This command can deal with parameterized regions. When printing a parameterized region with the -g flag, the region is printed as if it were unparameterized, with the offsets from the various PARAM constants used as the coordinates.</LI>
<LI>
If no address is given, this will use the last-accessed address (as the &quot;bytes&quot; and &quot;words&quot; commands do). It sets the last-accessed address, for other commands to use, to the first byte after the region definition.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_20.htm_IX_print Swat command:command reference">
 </A>
print</H1>

<PRE CLASS="syntax">print &lt;expression&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;print 56h&quot;</DT><DD>print the constant 56h in various formats</DD>
<DT>
&quot;print ax - 10&quot;</DT><DD>
print ax less 10 decimal</DD>
<DT>
&quot;print ^l31a0h:001eh&quot;</DT><DD>
print the absolute address of the pointer</DD>


</DL>
<P>
Print the value of an expression.</P>

<UL>
<LI>
The &lt;expression&gt; argument is usually an address that has a type or that is given a type by casting and may span multiple arguments. The contents of memory of the given type at that address is what's printed. If the expression has no type, its offset part is printed in both hex and decimal. This is used for printing registers, for example.</LI>
<LI>
The first argument may contain the following flags (which start with `-'):</LI>
<DL>
<DT>
<STRONG>
x</STRONG>
</DT><DD>integers (bytes, words, dwords if dwordIsPtr false) printed in hex</DD>
<DT>
<STRONG>
d</STRONG>
</DT><DD>integers printed in decimal</DD>
<DT>
<STRONG>
o</STRONG>
</DT><DD>integers printed in octal c bytes printed as characters (byte arrays printed as strings, byte variables/fields printed as character followed by integer equivalent)</DD>
<DT>
<STRONG>
C</STRONG>
</DT><DD>bytes treated as integers </DD>
<DT>
<STRONG>
a</STRONG>
 </DT><DD>align structure fields</DD>
<DT>
<STRONG>
A</STRONG>
</DT><DD>Don't align structure fields</DD>
<DT>
<STRONG>
p</STRONG>
</DT><DD>dwords are far pointers</DD>
<DT>
<STRONG>
P</STRONG>
</DT><DD>dwords aren't far pointers</DD>
<DT>
<STRONG>
r</STRONG>
 </DT><DD>parse regions</DD>
<DT>
<STRONG>
R</STRONG>
 </DT><DD>don't try to parse regions</DD>
</DL>
<LI>
 These flags operate on the following Tcl variables:</LI>
<DL>
<DT>
<STRONG>
intFormat</STRONG>
</DT><DD>A printf format string for integers.</DD>
<DT>
<STRONG>
bytesAsChar</STRONG>
	</DT><DD>
Treat bytes as characters if non-zero.</DD>
<DT>
<STRONG>
alignFields</STRONG>
	</DT><DD>
Align structure fields if non-zero.</DD>
<DT>
<STRONG>
dwordIsPtr</STRONG>
</DT><DD>DWords are far pointers if non-zero.</DD>
<DT>
<STRONG>
noStructEnum</DT><DD>
</STRONG>
If non-zero, doesn't print the &quot;struct&quot;, &quot;enum&quot; or &quot;record&quot; before the name of a structured/enumerated type -- just gives the type name.</DD>
<DT>
<STRONG>
printRegions</DT><DD>
</STRONG>
If non-zero, prints what a Region points to (bounds and so on).</DD>
<DT>
<STRONG>
condenseSpecial</DT><DD>
</STRONG>
If non-zero, condense special structures (Rectangles, OutputDescriptors, ObjectDescriptors, TMatrixes and all fixed-point numbers) to one line.</DD>
</DL>
<LI>
This does not print enumerations. Use penum for that.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_20.htm#IX_precord Swat command">precord</A>,
<A HREF="../../Tools/SwatRef/SR_1d.htm#IX_penum Swat command">penum</A>,
<A HREF="../../Tools/SwatRef/SR_1.htm#IX__print Swat command">_print</A>.


<HR>
<A NAME="SR_21.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_21.htm_IX_Spreadsheets:examining with Swat">
 </A>
<A NAME="SR_21.htm_IX_Cells:examining with Swat">
 </A>
<A NAME="SR_21.htm_IX_print-cell Swat command">
 </A>
print-cell</H1>

<PRE CLASS="syntax">print-cell [row column &lt;cfp ds:si&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;print-cell 1 1&quot;</DT><DD>
print the cell &lt;1,1&gt;</DD>
<DT>
&quot;print-cell 1 2 *ds:si&quot;</DT><DD>
print the cell &lt;1,2&gt; given *DS:SI</DD>


</DL>
<P>
Print information about a cell</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_22.htm#IX_print-row Swat command">print-row</A>,
<A HREF="../../Tools/SwatRef/SR_22.htm#IX_print-row-block Swat command">print-row-block</A>,
<A HREF="../../Tools/SwatRef/SR_21.htm#IX_print-cell-params Swat command">print-cell-params</A>,
<A HREF="../../Tools/SwatRef/SR_21.htm#IX_print-column-element Swat command">print-column-element</A>.



<H1 CLASS="refHeading">
<A NAME="SR_21.htm_IX_Cells:printing paramaters in Swat">
 </A>
<A NAME="SR_21.htm_IX_print-cell-params Swat command">
 </A>
print-cell-params</H1>

<PRE CLASS="syntax">print-cell-params [&lt;address&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;print-cell-params&quot; </DT><DD>
print the <CODE>
CellFunctionParameters</CODE>
 at ds:si.</DD>
<DT>
&quot;print-cell-params ds:bx&quot; </DT><DD>
print the <CODE>
CellFunctionParameters</CODE>
 at ds:bx.</DD>


</DL>
<P>
Print a <CODE>
CellFunctionParameters</CODE>
 block.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_22.htm#IX_print-row Swat command">print-row</A>,
<A HREF="../../Tools/SwatRef/SR_21.htm#IX_print-column-element Swat command">print-column-element</A>,
<A HREF="../../Tools/SwatRef/SR_22.htm#IX_print-row-block Swat command">print-row-block</A>,
<A HREF="../../Tools/SwatRef/SR_21.htm#IX_print-cell Swat command">print-cell</A>.



<H1 CLASS="refHeading">
<A NAME="SR_21.htm_IX_Clipboard:print-clipboard-item Swat command">
 </A>
<A NAME="SR_21.htm_IX_print-clipboard-item Swat command">
 </A>
print-clipboard-item</H1>

<PRE CLASS="syntax">print-clipboard-item [-v] &lt;vmfile&gt; &lt;vmblock&gt;
print-clipboard-item [-v] &lt;memhandle&gt;
print-clipboard-item [-v] &lt;addr&gt; </PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;print-clipboard-item bx&quot; </DT><DD>
Print out info about the transfer item whose memory handle is in the BX register.</DD>


</DL>
<P>
Prints out information about a transfer item.</P>

<UL>
<LI>
If you give the &quot;-v&quot; flag, this will print out the contents of the different transfer formats, rather than just an indication of their types. </LI>
<LI>
The -v flag will not work unless the transfer item is in a VM file.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pnormal Swat command">pnormal</A>,
<A HREF="../../Tools/SwatRef/SR_20.htm#IX_pquick Swat command">pquick</A>.



<H1 CLASS="refHeading">
<A NAME="SR_21.htm_IX_Cells:printing ColumnArrayElement structures in Swat">
 </A>
<A NAME="SR_21.htm_IX_print-column-element Swat command">
 </A>
print-column-element</H1>

<PRE CLASS="syntax">print-column-element [&lt;address&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;print-column-element&quot;</DT><DD>
Print the <CODE>
ColumnArrayElement</CODE>
 at ds:si.</DD>
<DT>
&quot;print-column-element ds:bx&quot; print the <CODE>
ColumnArrayElement</CODE>
 at ds:bx </DT>


</DL>
<P>
Print a single <CODE>
ColumnArrayElement</CODE>
 at a given address.</P>



<H1 CLASS="refHeading">
<A NAME="SR_21.htm_IX_DBase:printing group blocks in Swat">
 </A>
<A NAME="SR_21.htm_IX_print-db-group Swat command">
 </A>
print-db-group</H1>

<PRE CLASS="syntax">print-db-group file group</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;print-db-group ax bx&quot;</DT><DD>
print the group at bx/ax.</DD>


</DL>
<P>
Print information about a dbase group block.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_21.htm#IX_print-db-item Swat command">print-db-item</A>.



<H1 CLASS="refHeading">
<A NAME="SR_21.htm_IX_DBase:examining items with Swat">
 </A>
<A NAME="SR_21.htm_IX_print-db-item Swat command">
 </A>
print-db-item</H1>

<PRE CLASS="syntax">print-db-item file group item</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;print-db-item bx ax di&quot;</DT><DD>
print the item at bx/ax/di</DD>


</DL>
<P>
Print information about a single dbase item</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_21.htm#IX_print-db-group Swat command">print-db-group</A>.



<H1 CLASS="refHeading">
<A NAME="SR_21.htm_IX_Cells:printing dependency lists with Swat">
 </A>
<A NAME="SR_21.htm_IX_print-eval-dep-list Swat command">
 </A>
print-eval-dep-list</H1>

<PRE CLASS="syntax">print-eval-dep-list [&lt;addr&gt;] </PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;print-eval-dep-list es:0&quot;</DT><DD>
Print dependency list at ES:0.</DD>


</DL>
<P>
Prints a dependency list used for evaluation.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_6.htm#IX_content Swat command">content</A>,
<A HREF="../../Tools/SwatRef/SR_1c.htm#IX_pcelldeps Swat command">pcelldeps</A>.



<H1 CLASS="refHeading">
<A NAME="SR_21.htm_IX_printNamesInObjTrees Swat variable">
 </A>
printNamesInObjTrees</H1>

<PRE CLASS="syntax">var printNamesInObjTrees (0|1)</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var printNamesInObjTrees 1&quot;</DT><DD>
Sets &quot;gentree,&quot; &quot;vistree,&quot; etc. commands to print object names (where available).</DD>


</DL>
<P>
Determines whether object names are printed (where available) rather than class names when using the following commands: vistree, gentree, focus, target, model, mouse, keyboard.</P>


<P>
The default value for this variable is zero.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_10.htm#IX_gentree Swat command:command reference">gentree</A>,
<A HREF="../../Tools/SwatRef/SR_2f.htm#IX_vistree Swat command">vistree</A>,
<A HREF="../../Tools/SwatRef/SR_e.htm#IX_focus Swat command">focus</A>,
<A HREF="../../Tools/SwatRef/SR_2c.htm#IX_target Swat command">target</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_model Swat command">model</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_mouse Swat command">mouse</A>,
<A HREF="../../Tools/SwatRef/SR_17.htm#IX_keyboard Swat command">keyboard</A>.



<H1 CLASS="refHeading">
<A NAME="SR_21.htm_IX_print-obj-and-method Swat command">
 </A>
print-obj-and-method</H1>

<PRE CLASS="syntax">print-obj-and-method &lt;handle&gt; &lt;chunk&gt; &lt;message&gt; [&lt;cx&gt; [&lt;dx&gt; 
                                                   [&lt;bp&gt; [&lt;class&gt;]]]] </PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;print-obj-and-method [read-reg bx] [read-reg si]&quot;</DT><DD>
Prints a description of the object ^lbx:si with the value stored and a hex representation.</DD>
<DT>
&quot;print-obj-and-method $h $c $m [read-reg cx] [read-reg dx] [read-reg bp]&quot;</DT><DD>
Prints a description of the object ^l$h:$c and the name of the message whose number is in $c. This is followed by the three words of data in cx, dx, and bp.</DD>


</DL>
<P>
Prints a nicely formatted representation of an object, with option message, register data, label, hex address, &amp; carriage return. The class indication may also be overriden.</P>

<UL>
<LI>
You may specify anywhere from 0 to 5 arguments after the message number. These are interpreted as the value of the message, the registers CX, DX and BP, and the symbol token of the class to print, respectively. </LI>
<LI>
All arguments must be integers, as this is expected to be called by another procedure, not by the user, so the extra time required to call <CODE>
getvalue</CODE>
 would normally be wasted. (The user should call <CODE>
pobj</CODE>
, <CODE>
gup</CODE>
, or other such functions for this sort of print out.)</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_19.htm#IX_mwatch Swat command">mwatch</A>,
<A HREF="../../Tools/SwatRef/SR_18.htm#IX_map-method Swat command">map-method</A>,
<A HREF="../../Tools/SwatRef/SR_1b.htm#IX_objwatch Swat command">objwatch</A>.


<HR>
<A NAME="SR_22.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_22.htm_IX_Regions, graphics:printRegions Swat variable">
 </A>
<A NAME="SR_22.htm_IX_printRegions Swat variable">
 </A>
printRegions</H1>

<PRE CLASS="syntax">var printRegions [(0|1)]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var printRegions 1&quot;</DT><DD>
If a structure contains a pointer to a region, &quot;print&quot; will attempt to determine its bounding box.</DD>


</DL>
<P>
Controls whether &quot;print&quot; parses regions to find their bounding rectangle.</P>


<P>
The default value for this variable is one.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_20.htm#IX_print Swat command:command reference">print</A>,
<A HREF="../../Tools/SwatRef/SR_6.htm#IX_condenseSpecial Swat variable">condenseSpecial</A>.



<H1 CLASS="refHeading">
<A NAME="SR_22.htm_IX_Spreadsheets:examining with Swat">
 </A>
<A NAME="SR_22.htm_IX_print-row Swat command">
 </A>
print-row</H1>

<PRE CLASS="syntax">print-row [&lt;address *DS:SI&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;print-row&quot;</DT><DD>print the row at *DS:SI</DD>
<DT>
&quot;print-row ds:si&quot;</DT><DD>
print the row at DS:SI</DD>


</DL>
<P>
Print a single row in the cell file given a pointer to the row.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_21.htm#IX_print-column-element Swat command">print-column-element</A>,
<A HREF="../../Tools/SwatRef/SR_21.htm#IX_print-cell-params Swat command">print-cell-params</A>,
<A HREF="../../Tools/SwatRef/SR_22.htm#IX_print-row-block Swat command">print-row-block</A>,
<A HREF="../../Tools/SwatRef/SR_21.htm#IX_print-cell Swat command">print-cell</A>.



<H1 CLASS="refHeading">
<A NAME="SR_22.htm_IX_Cells:printing row blocks in Swat">
 </A>
<A NAME="SR_22.htm_IX_print-row-block Swat command">
 </A>
print-row-block</H1>

<PRE CLASS="syntax">print-row-block [&lt;address ds&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;print-row-block&quot; </DT><DD>
print the row-block at DS:0</DD>
<DT>
&quot;print-row-block es&quot; </DT><DD>
print the row-block at ES:0 </DD>


</DL>
<P>
Print a row-block.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_22.htm#IX_print-row Swat command">print-row</A>,
<A HREF="../../Tools/SwatRef/SR_21.htm#IX_print-cell-params Swat command">print-cell-params</A>,
<A HREF="../../Tools/SwatRef/SR_21.htm#IX_print-column-element Swat command">print-column-element</A>,
<A HREF="../../Tools/SwatRef/SR_21.htm#IX_print-cell Swat command">print-cell</A>.



<H1 CLASS="refHeading">
<A NAME="SR_22.htm_IX_printStop Swat command">
 </A>
printStop</H1>

<P>
This variable controls how the current machine state is printed each time the machine comes to a complete stop. Possible values:</P>
<DL>
<DT>
<STRONG>
asm</STRONG>
 </DT><DD>Print the current assembly-language instruction, complete with the values for the instruction operands.</DD>
<DT>
 <STRONG>
src</STRONG>
 </DT><DD>Print the current source line, if it's available. If the source line is not available, the current assembly-language instruction is displayed as above.</DD>
<DT>
 <STRONG>
why</STRONG>
 </DT><DD>Print only the reason for the stopping, not the current machine state. &quot;asm&quot; and &quot;src&quot; modes also print this.</DD>
<DT>
 <STRONG>
nil</STRONG>
 </DT><DD>Don't print anything. </DD>



</DL>
<H1 CLASS="refHeading">
<A NAME="SR_22.htm_IX_Objects:monitoring process object">
 </A>
<A NAME="SR_22.htm_IX_Messages:monitoring with Swat">
 </A>
<A NAME="SR_22.htm_IX_procmessagebrk Swat command">
 </A>
procmessagebrk</H1>

<PRE CLASS="syntax">procmessagebrk [&lt;handle&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;procmessagebrk MyObj&quot;</DT><DD>
break whenever a message is sent to MyObj</DD>
<DT>
&quot;procmessagebrk&quot;</DT><DD>
stop intercepting messages</DD>


</DL>
<P>
Break whenever a message is <EM>
sent</EM>
 to a particular process via ObjMessage.</P>

<UL>
<LI>
The &lt;handle&gt; argument is the handle to a process to watch for messages being sent to it. If no argument is specified then the watching is stopped. The process' handle may be found by typing &quot;ps -p&quot;. The process's handle is the number before the process's name.</LI>
<LI>
This command breaks whenever a message is sent (before they get on the message queue. This enables one to track identical messages to a process which can be removed.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1b.htm#IX_objwatch Swat command">objwatch</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_mwatch Swat command">mwatch</A>,
<A HREF="../../Tools/SwatRef/SR_1b.htm#IX_objmessagebrk Swat command">objmessagebrk</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>.



<H1 CLASS="refHeading">
<A NAME="SR_22.htm_IX_Handles:displaying information with Swat">
 </A>
<A NAME="SR_22.htm_IX_Patients:displaying status with Swat">
 </A>
<A NAME="SR_22.htm_IX_Threads:displaying status with Swat">
 </A>
<A NAME="SR_22.htm_IX_ps Swat command">
 </A>
ps</H1>

<PRE CLASS="syntax">ps [&lt;flags&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;ps -t&quot;</DT><DD>list all threads in GEOS.</DD>


</DL>
<P>
Print out GEOS' system status.</P>


<P>
The flags argument may be one of the following:</P>
<DL>
<DT>
<STRONG>
-t</STRONG>
</DT><DD>Prints out info on all threads. May be followed by a list of patients whose threads are to be displayed.</DD>
<DT>
<STRONG>
-p</STRONG>
</DT><DD>Prints out info on all patients. May be followed by a list of patients to be displayed.</DD>
<DT>
<STRONG>
-h</STRONG>
</DT><DD>Prints out info on all handles. May be followed by a list of patients whose handles are to be displayed.</DD>
<DT>
 The default is `-p'.</DT>
</DL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2b.htm#IX_switch Swat command:command reference">switch</A>,
<A HREF="../../Tools/SwatRef/SR_2c.htm#IX_sym-default Swat command:command reference">sym-default</A>.



<H1 CLASS="refHeading">
<A NAME="SR_22.htm_IX_pscope Swat command">
 </A>
pscope</H1>

<PRE CLASS="syntax">pscope [&lt;scope-name&gt; [&lt;sym-class&gt;]]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pscope WinOpen&quot;    </DT><DD>
Prints out all the local labels, variables, and arguments within the <CODE>
WinOpen()</CODE>
 procedure</DD>


</DL>
<P>
This prints out all the symbols contained in a particular scope.</P>

<UL>
<LI>
This can be useful when you want to know just the fields in a structure, and not the fields within those fields, or if you know the segment in which a variable lies, but not its name. Admittedly, this could be overkill.</LI>
<LI>
<EM>
sym-class</EM>
 can be a list of symbol classes to restrict the output. For example, &quot;pscope Filemisc proc&quot; will print out all the procedures within the Filemisc resource.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_30.htm#IX_whatis Swat command">whatis</A>,
<A HREF="../../Tools/SwatRef/SR_18.htm#IX_locals Swat command">locals</A>.



<H1 CLASS="refHeading">
<A NAME="SR_22.htm_IX_Structures:displaying size in Swat">
 </A>
<A NAME="SR_22.htm_IX_psize Swat command">
 </A>
psize</H1>

<PRE CLASS="syntax">psize &lt;structure&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	&quot;psize FontsInUseEntry&quot;</P>


<P>
Print the size of the passed structure.</P>



<H1 CLASS="refHeading">
<A NAME="SR_22.htm_IX_Cells:printing spreadheets in Swat">
 </A>
<A NAME="SR_22.htm_IX_Spreadsheets:printing in Swat">
 </A>
<A NAME="SR_22.htm_IX_pssheet Swat command">
 </A>
pssheet</H1>

<PRE CLASS="syntax">pssheet [-isSfrcvd] &lt;address&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pssheet -s ^l3ce0h:001eh&quot;</DT><DD>
print style attributes.</DD>
<DT>
&quot;pssheet -f -i 94e5h:0057h&quot;</DT><DD>
print file info from instance data.</DD>


</DL>
<P>
Prints out information about a spreadsheet object.</P>


<P>
&nbsp;</P>
<UL>
<LI>
If you are in the middle of debugging a spreadsheet routine and have a pointer to the Spreadsheet instance, the &quot;-i&quot; flag can be used to specify the object using that pointer. </LI>
<LI>
 If you simply have the OD of the spreadsheet object, use that. </LI>
<LI>
Alternatively, you can do:</LI>
</UL>
<PRE> pssheet &lt;flags&gt; [targetobj]</PRE>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_6.htm#IX_content Swat command">content</A>,
<A HREF="../../Tools/SwatRef/SR_2c.htm#IX_targetobj Swat command">targetobj</A>.



<H1 CLASS="refHeading">
<A NAME="SR_22.htm_IX_Objects:printing class hierarchy in Swat">
 </A>
<A NAME="SR_22.htm_IX_psup Swat command">
 </A>
psup</H1>

<PRE CLASS="syntax">psup [&lt;object&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;psup&quot;</DT><DD>print superclasses of object at *ds:si.</DD>
<DT>
&quot;psup -i&quot; </DT><DD>print superclasses of object under mouse.</DD>
<DT>
&quot;psup ^l4e10h:20h&quot; </DT><DD>
print superclasses of object at ^l4e10h:20h.</DD>


</DL>
<P>
Prints superclasses of an object.</P>


<P>
If no object is specified, *ds:si is used.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_16.htm#IX_is-obj-in-class Swat command">is-obj-in-class</A>.


<HR>
<A NAME="SR_23.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_23.htm_IX_Text:displaying text objects with Swat">
 </A>
<A NAME="SR_23.htm_IX_Objects:displaying text objects with Swat">
 </A>
<A NAME="SR_23.htm_IX_ptext Swat command">
 </A>
ptext</H1>

<PRE CLASS="syntax">ptext [&lt;options&gt;] &lt;addr&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;ptext&quot;</DT><DD>Prints the text in the object for the method being executed in the current stack frame.</DD>


</DL>
<P>
Prints out the text and related structures for a text object</P>


<P>
The flag may be one or more of the following:</P>
<DL>
<DT>
-<STRONG>
c</STRONG>
</DT><DD>Print out the char attr structures.</DD>
<DT>
-<STRONG>
e</STRONG>
</DT><DD>Print out elements in addition to runs.</DD>
<DT>
-<STRONG>
f</STRONG>
&lt;<STRONG>
field</STRONG>
&gt;</DT><DD>Print out given field of each element (default is Meta part).</DD>
<DT>
-<STRONG>
g</STRONG>
 </DT><DD>Print out graphics structures.</DD>
<DT>
-<STRONG>
l</STRONG>
 </DT><DD>Print out line and field structures.</DD>
<DT>
-<STRONG>
p</STRONG>
</DT><DD>Print out para attr structures.</DD>
<DT>
-<STRONG>
r</STRONG>
 </DT><DD>Print out region attr structures.</DD>
<DT>
-<STRONG>
s</STRONG>
 </DT><DD>Print out style structures.</DD>
<DT>
-<STRONG>
t</STRONG>
 </DT><DD>Print out type structures.</DD>
<DT>
-<STRONG>
E</STRONG>
</DT><DD>Limit printout to just the elements of whatever arrays are requeste. Do not attempt to print out associated text.</DD>
<DT>
-<STRONG>
N</STRONG>
</DT><DD>Print out associated names.</DD>
<DT>
-<STRONG>
R </STRONG>
</DT><DD>Print out full region descriptions.</DD>
</DL>

<H1 CLASS="refHeading">
<A NAME="SR_23.htm_IX_Threads:examining with Swat">
 </A>
<A NAME="SR_23.htm_IX_pthread Swat command">
 </A>
pthread</H1>

<PRE CLASS="syntax">pthread &lt;id&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pthread 16c0h&quot;</DT><DD>
Prints information about the thread whose handle is 16c0h.</DD>


</DL>
<P>
Provides various useful pieces of information about a particular thread including its current priority and its current registers.</P>


<P>
&lt;id&gt; is the thread's handle ID, as obtained with the &quot;ps -t&quot; or &quot;threadstat&quot; command.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2d.htm#IX_threadstat Swat command">threadstat</A>.



<H1 CLASS="refHeading">
<A NAME="SR_23.htm_IX_Timers:printing with Swat">
 </A>
<A NAME="SR_23.htm_IX_ptimer Swat command">
 </A>
ptimer</H1>

<PRE CLASS="syntax">ptimer &lt;handle&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;ptimer bx&quot;</DT><DD>Print out information about the timer whose handle is in the BX register.</DD>


</DL>
<P>
Prints out information about a timer registered with the system: when it will fire, what it will do when it fires, etc.</P>


<P>
&lt;handle&gt; may be a variable, register, or constant.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2e.htm#IX_twalk Swat command">twalk</A>,
<A HREF="../../Tools/SwatRef/SR_1e.htm#IX_phandle Swat command">phandle</A>.



<H1 CLASS="refHeading">
<A NAME="SR_23.htm_IX_ptrans Swat command">
 </A>
ptrans</H1>

<PRE CLASS="syntax">ptrans [&lt;flags&gt;] [&lt;address&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;ptrans&quot; </DT><DD>print the normal transform for the object at *ds:si.</DD>
<DT>
 &quot;ptrans -s&quot; </DT><DD>print the sprite transform for the GrObj object at *ds:si. </DD>
<DT>
 &quot;ptrans ^lbx:cx&quot; </DT><DD>
print the normal transform for the object whose OD is ^lbx:cx.</DD>


</DL>
<P>
Prints the <CODE>
ObjectTransform</CODE>
 data structure as specified.</P>

<UL>
<LI>
The -s flag can be used to print the &quot;sprite&quot; transform (the &quot;sprite&quot; is the shape's outline which is drawn to give feedback to the user when said user is moving/rotating/etc. the GrObj).</LI>
<LI>
&lt;address&gt; defaults to *ds:si </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>.



<H1 CLASS="refHeading">
<A NAME="SR_23.htm_IX_Regions, graphics:printing in Swat">
 </A>
<A NAME="SR_23.htm_IX_ptreg Swat command">
 </A>
ptreg</H1>

<PRE CLASS="syntax">ptreg &lt;start&gt; [&lt;obj-addr&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;ptreg 12&quot; </DT><DD>Print lines for region 12</DD>
<DT>
&quot;ptreg 12 ^lcx:dx&quot; </DT><DD>
Print lines for region 12 of object ^lcx:dx </DD>


</DL>
<P>
Print information about the lines in a region.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_23.htm#IX_ptext Swat command">ptext</A>.



<H1 CLASS="refHeading">
<A NAME="SR_23.htm_IX_Fonts:monitoring with Swat">
 </A>
<A NAME="SR_23.htm_IX_pusage Swat command">
 </A>
pusage</H1>

<PRE CLASS="syntax">pusage [&lt;address&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pusage&quot;</DT><DD>print the usage of characters in the font</DD>


</DL>
<P>
List the characters in a font and when they were last used.</P>

<UL>
<LI>
The &lt;address&gt; argument is the address of a font. If none is given then ^hbx is used.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_e.htm#IX_fonts Swat command">fonts</A>,
<A HREF="../../Tools/SwatRef/SR_1d.htm#IX_pfont Swat command">pfont</A>,
<A HREF="../../Tools/SwatRef/SR_1d.htm#IX_pfontinfo Swat command">pfontinfo</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_plist Swat command">plist</A>.



<H1 CLASS="refHeading">
<A NAME="SR_23.htm_IX_Objects:displaying variable data with Swat">
 </A>
<A NAME="SR_23.htm_IX_pvardata Swat command">
 </A>
pvardata</H1>

<PRE CLASS="syntax">pvardata [&lt;entry&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pvardata ds:si&quot;</DT><DD>
 Prints vardata of object at *ds:si</DD>
<DT>
&quot;pvardata -i&quot;</DT><DD>
 Prints vardata of object with implied grab.</DD>

</DL>

<UL>
<LI>
The address argument is the address of an object with variable data. The default is *ds:si.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_23.htm_IX_Objects:displaying variable data with Swat">
 </A>
<A NAME="SR_23.htm_IX_pvardentry Swat command">
 </A>
pvardentry</H1>

<PRE CLASS="syntax">pvardentry &lt;address&gt; &lt;object&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pvardentry ds:bx *ds:si&quot;</DT>


</DL>
<UL>
<LI>
The address argument is the address of a variable data entry in an object's variable data storage area. The default is ds:bx. </LI>
<LI>
The &lt;object&gt; argument is required to determine the name of the tag for the entry, as well as the type of data stored with it.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_23.htm_IX_Visual objects:displaying instance data">
 </A>
<A NAME="SR_23.htm_IX_Instance data:displaying VisClass">
 </A>
<A NAME="SR_23.htm_IX_pvis Swat command">
 </A>
pvis</H1>

<PRE CLASS="syntax">pvis &lt;element&gt; [&lt;object&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pvis VI_bounds @65&quot;</DT><DD>
print the bounds of object 65</DD>
<DT>
&quot;pvis VI_optFlags&quot;</DT><DD>
print the flags of the object at *DS:SI</DD>
<DT>
&quot;pvis VI_attrs -i&quot;</DT><DD>
print the attributes of the object at the implied grab</DD>


</DL>
<P>
Print an element of the visual instance data.</P>

<UL>
<LI>
The &lt;element&gt; argument specifies which element in the object to print</LI>
<LI>
The &lt;object&gt; argument is the address to the object to print out. It defaults to *DS:SI and is optional. The `-i' flag for an implied grab may be used.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2f.htm#IX_vistree Swat command">vistree</A>,
<A HREF="../../Tools/SwatRef/SR_2f.htm#IX_vup Swat command:command reference">vup</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_piv Swat command">piv</A>,
<A HREF="../../Tools/SwatRef/SR_1d.htm#IX_pgen Swat command">pgen</A>.


<HR>
<A NAME="SR_24.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_24.htm_IX_Text:displaying text monikers with Swat">
 </A>
<A NAME="SR_24.htm_IX_Monikers:examining with Swat">
 </A>
<A NAME="SR_24.htm_IX_pvismon Swat command">
 </A>
pvismon</H1>

<PRE CLASS="syntax">pvismon [&lt;address&gt;] [&lt;text only&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pvismon&quot;</DT><DD>print the moniker at *DS:SI</DD>
<DT>
&quot;pvismon -i 1&quot; </DT><DD>
print a short description of the implied grab object.</DD>


</DL>
<P>
Print a visual moniker structure at an absolute address.</P>

<UL>
<LI>
The &lt;address&gt; argument is the address to an object in the visual tree. This defaults to *DS:SI. The `-i' flag for an implied grab may be used.</LI>
<LI>
The &lt;text only&gt; argument returns a shortened description of the structure. Pass a non-zero value to turn on this flag.</LI>
<LI>
The special object flags may be used to specify &lt;object&gt;.  For a list of these flags, see pobject.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_20.htm#IX_pobjmon Swat command">pobjmon</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>,
<A HREF="../../Tools/SwatRef/SR_2f.htm#IX_vistree Swat command">vistree</A>,
<A HREF="../../Tools/SwatRef/SR_11.htm#IX_gup Swat command:command reference">gup</A>,
<A HREF="../../Tools/SwatRef/SR_10.htm#IX_gentree Swat command:command reference">gentree</A>,
<A HREF="../../Tools/SwatRef/SR_15.htm#IX_impliedgrab Swat command">impliedgrab</A>,
<A HREF="../../Tools/SwatRef/SR_2c.htm#IX_systemobj Swat command">systemobj</A>.



<H1 CLASS="refHeading">
<A NAME="SR_24.htm_IX_Virtual memory:examining with Swat">
 </A>
<A NAME="SR_24.htm_IX_pvmb Swat command">
 </A>
pvmb</H1>

<P>
Prints out the VMBlockHandle for a VM block given the file handle <EM>
H</EM>
 and the VM block handle <EM>
B</EM>
.</P>



<H1 CLASS="refHeading">
<A NAME="SR_24.htm_IX_Virtual memory:examining with Swat">
 </A>
<A NAME="SR_24.htm_IX_pvmt Swat command">
 </A>
pvmt</H1>

<PRE CLASS="syntax">pvmt [-p] [-a] [-s] [-c] (&lt;handle&gt; | &lt;segment&gt;)</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pvmt bx&quot; </DT><DD>Print out all used blocks for the open VM file whose file handle is in BX.</DD>
<DT>
&quot;pvmt -as ds&quot; </DT><DD>
Print out all blocks for the open VM file the segment of whose header block is in DS.</DD>


</DL>
<P>
Prints out a map of the VM block handles for a VM file.</P>

<UL>
<LI>
The -p flag will only print out blocks that have the Preserve flag set. Useful for examining object blocks in GeoCalc files, for example. </LI>
<LI>
The -a flag causes pvmt to print out all block handles, not just those that have been allocated. The other two types of block handles are &quot;assigned&quot; (meaning they're available for use, but currently are tracking unused space in the file) and &quot;unassigned&quot; (they're available for use). </LI>
<LI>
The -s indicates the final argument is a segment, not a file handle. This is used only if you're inside the VM subsystem of the kernel. </LI>
<LI>
The -c flag requests a count of the different types of blocks at the end of the printout.</LI>
<LI>
The blocks are printed in a table with the following columns:</LI>
<DL>
<DT>
<STRONG>
han</STRONG>
 </DT><DD>VM block handle (in hex)</DD>
<DT>
<STRONG>
flags</STRONG>
 	D if the block is dirty, </DT><DD>
C if the block is clean, <BR>
- if the block is non-resident, <BR>
L if the block is LMem, <BR>
B if the block has a backup, <BR>
P if the preserve handle bit is set for the block, <BR>
! if the block is locked</DD>
<DT>
<STRONG>
memhan</STRONG>
 </DT><DD>Associated memory handle. Followed by &quot;(d)&quot; if the memory for the block was discarded but the handle retained. Followed by (s) if the memory has been swapped out.</DD>
<DT>
<STRONG>
block type</STRONG>
 </DT><DD>The type of block:</DD>
<DL>
<DT>
             VMBT_USED a normal in-use block,</DT>
<DT>
             VMBT_DUP an in-use block that has been backed up or allocated since the last call to <CODE>
VMSave()</CODE>
</DT>
<DT>
             VMBT_BACKUP a place-holder to keep track of the previous version of a VMBT_DUP block. The uid is the VM block handle to which the file space used to belong.</DT>
<DT>
             VMBT_ZOMBIE a block that has been freed since the last <CODE>
VMSave()</CODE>
. The handle is preserved in case of a <CODE>
VMRevert()</CODE>
 (a VMBT_BACKUP block retains the file space).</DT>
</DL>
<DT>
<STRONG>
uid</STRONG>
 </DT><DD>The &quot;used ID&quot; bound to the block.</DD>
<DT>
<STRONG>
size</STRONG>
 </DT><DD>Number of bytes allocated for the block in the file.</DD>
<DT>
<STRONG>
pos</STRONG>
 </DT><DD>The position of those bytes in the file.</DD>
</DL>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1e.htm#IX_pgs Swat command">pgs</A>.



<H1 CLASS="refHeading">
<A NAME="SR_24.htm_IX_Objects:printing visual bounds with Swat">
 </A>
<A NAME="SR_24.htm_IX_pvsize Swat command">
 </A>
pvsize</H1>

<PRE CLASS="syntax">pvsize [&lt;object&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;pvsize&quot; </DT><DD>print the dimensions of the visual object at *ds:si.</DD>


</DL>
<P>
Print out the dimensions of a visual object.</P>

<UL>
<LI>
The object argument is the address to the object to print out. It defaults to *ds:si and is optional. The `-i' flag for an implied grab may be used.</LI>
<LI>
The special object flags may be used to specify &lt;object&gt;.  For a list of these flags, see pobject.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_24.htm_IX_Files:printing current directory in Swat">
 </A>
<A NAME="SR_24.htm_IX_pwd Swat command">
 </A>
pwd</H1>

<PRE CLASS="syntax">pwd</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	&quot;pwd&quot;</P>


<P>
Prints the current working directory for the current thread.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_a.htm#IX_dirs Swat command">dirs</A>,
<A HREF="../../Tools/SwatRef/SR_2a.htm#IX_stdpaths Swat command">stdpaths</A>.



<H1 CLASS="refHeading">
<A NAME="SR_24.htm_IX_quit Swat command:command reference">
 </A>
quit</H1>

<PRE CLASS="syntax">quit [&lt;options&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;quit cont&quot;</DT><DD>continue GEOS and quit swat</DD>
<DT>
&quot;quit det&quot;</DT><DD>detach from the PC and quit swat.</DD>


</DL>
<P>
Stop the debugger and exit.</P>

<UL>
<LI>
The &lt;option&gt; argument may be one of the following: <BR>
<CODE>
continue</CODE>
: continue GEOS and exit swat; <BR>
<CODE>
leave</CODE>
: keep GEOS stopped and exit swat.</LI>
<LI>
 Anything else causes swat to detach and exit.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_a.htm#IX_detach Swat command:command reference">detach</A>.



<H1 CLASS="refHeading">
<A NAME="SR_24.htm_IX_read-char Swat command">
 </A>
read-char</H1>

<PRE CLASS="syntax">read-char [&lt;echo&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;read-char 0&quot;</DT><DD>
Read a single character from the user and don't echo it.</DD>


</DL>
<P>
Reads a character from the user.</P>


<P>
If &lt;echo&gt; is non-zero or absent, the character typed will be echoed.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_24.htm#IX_read-line Swat command">read-line</A>.



<H1 CLASS="refHeading">
<A NAME="SR_24.htm_IX_read-line Swat command">
 </A>
read-line</H1>

<PRE CLASS="syntax">read-line [&lt;isTcl&gt; [&lt;initial input&gt; [&lt;special chars&gt;]]]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;read-line&quot;</DT><DD>reads a single line of text.</DD>
<DT>
&quot;read-line 1&quot;</DT><DD>reads a Tcl command.</DD>
<DT>
&quot;read-line 1 {go}&quot;</DT><DD>
reads a Tcl command that starts with &quot;go &quot;</DD>
<DT>
&quot;read-line 1 {} {\e\4}&quot;</DT><DD>
reads a Tcl command, considering escape and control-d cause for immediate return, regardless of whether braces and brackets are balanced</DD>


</DL>
<P>
Reads a single line of input from the user. If optional argument is non-zero, the line is interpreted as a Tcl command and will not be returned until all braces/brackets are balanced. The final newline is stripped. Optional second argument is input to be placed in the buffer first. This input must also be on-screen following the prompt, else it will be lost.</P>

<UL>
<LI>
If &lt;isTcl&gt; is non-zero, the input may span multiple lines, as read-line will not return until all braces and brackets are properly balanced, according to the rules of Tcl. This behavior may be overridden by the &lt;special chars&gt; argument.</LI>
<LI>
If &lt;initial input&gt; is given and non-empty, it is taken to be the initial contents of the input line and may be edited by the user just as if s/he had typed it in. The string is not automatically displayed; that is up to the caller.</LI>
<LI>
&lt;special chars&gt; is an optional string of characters that will cause this routine to return immediately. The character that caused the immediate return is left as the last character of the string returned. You may use standard backslash escapes to specify the characters. This will return even if the user is entering a multi-line Tcl command whose braces and brackets are not yet balanced.</LI>
<LI>
The user's input is returned as a single string with the final newline stripped off.</LI>
</UL>

<HR>
<A NAME="SR_25.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_25.htm_IX_Registers:accessing with Swat">
 </A>
<A NAME="SR_25.htm_IX_read-reg Swat command">
 </A>
read-reg</H1>

<PRE CLASS="syntax">read-reg &lt;register&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;read-reg ax&quot;</DT><DD>
return the value of AX</DD>
<DT>
&quot;read-reg CC&quot;</DT><DD>
return the value of the conditional flags</DD>


</DL>
<P>
Return the value of a register in decimal.</P>

<UL>
<LI>
The &lt;register&gt; argument is the two letter name of a register in either upper or lower case.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_f.htm#IX_frame Swat command:command reference">frame</A>,
<A HREF="../../Tools/SwatRef/SR_4.htm#IX_assign Swat command:command reference">assign</A>,
<A HREF="../../Tools/SwatRef/SR_27.htm#IX_setcc Swat command">setcc</A>,
<A HREF="../../Tools/SwatRef/SR_6.htm#IX_clrcc Swat command">clrcc</A>.



<H1 CLASS="refHeading">
<A NAME="SR_25.htm_IX_Registers:displaying with Swat">
 </A>
<A NAME="SR_25.htm_IX_regs Swat command">
 </A>
regs</H1>

<PRE CLASS="syntax">regs</PRE>


<P>
Print the current registers, flags, and instruction.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_4.htm#IX_assign Swat command:command reference">assign</A>,
<A HREF="../../Tools/SwatRef/SR_27.htm#IX_setcc Swat command">setcc</A>,
<A HREF="../../Tools/SwatRef/SR_6.htm#IX_clrcc Swat command">clrcc</A>,
<A HREF="../../Tools/SwatRef/SR_25.htm#IX_read-reg Swat command">read-reg</A>.



<H1 CLASS="refHeading">
<A NAME="SR_25.htm_IX_Registers:monitoring with Swat">
 </A>
<A NAME="SR_25.htm_IX_Display windows in Swat:displaying registers">
 </A>
<A NAME="SR_25.htm_IX_Registers:displaying with Swat">
 </A>
<A NAME="SR_25.htm_IX_regwin Swat command">
 </A>
regwin</H1>

<PRE CLASS="syntax">regwin [off]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	&quot;regwin&quot;<BR>
&quot;regwin off&quot;</P>


<P>
Turn the continuous display of registers on or off.</P>

<UL>
<LI>
If you give the optional argument &quot;off&quot;, you will turn off any active register display.</LI>
<LI>
If you give no argument, the display will be turned on.</LI>
<LI>
Only one register display may be active at a time.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_a.htm#IX_display Swat command">display</A>.



<H1 CLASS="refHeading">
<A NAME="SR_25.htm_IX_repeatCommand Swat variable">
 </A>
repeatCommand</H1>

<PRE CLASS="syntax">var repeatCommand &lt;string&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var repeatCommand [list foo nil]&quot; </DT><DD>
Execute the command &quot;foo nil&quot; if the user just hits &lt;Enter&gt; at the next command prompt.</DD>


</DL>
<P>
This variable holds the command Swat should execute if the user enters an empty command. It is used by all the memory-referencing commands to display the next chunk of memory, and can be used for other purposes as well.</P>

<UL>
<LI>
<EM>
repeatCommand</EM>
 is emptied just before <CODE>
top-level-read</CODE>
 returns the command the interpreter should execute and must be reset by the repeated command if it wishes to continue to be executed when the user just hits &lt;Enter&gt;. </LI>
<LI>
The text of the current command is stored in <EM>
lastCommand</EM>
, should you wish to use it when setting up <EM>
repeatCommand</EM>
. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2c.htm#IX_target Swat command">target</A>,
<A HREF="../../Tools/SwatRef/SR_e.htm#IX_focus Swat command">focus</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_mouse Swat command">mouse</A>,
<A HREF="../../Tools/SwatRef/SR_17.htm#IX_keyboard Swat command">keyboard</A>.



<H1 CLASS="refHeading">
<A NAME="SR_25.htm_IX_require Swat command">
 </A>
require</H1>

<PRE CLASS="syntax">require &lt;name&gt; [&lt;file&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;require fmtval print&quot;</DT><DD>
Ensure the procedure &quot;fmtval&quot; is defined, loading the file &quot;print.tcl&quot; if it is not.</DD>


</DL>
<P>
This ensures that a particular function, not normally invoked by the user but present in some file in the system library, is actually loaded.</P>


<P>
If no &lt;file&gt; is given, a file with the same name (possibly suffixed &quot;.tcl&quot;) as the function is assumed.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_4.htm#IX_autoload Swat command:command reference">autoload</A>.



<H1 CLASS="refHeading">
resize</H1>

<PRE CLASS="syntax">resize &lt;window&gt; &lt;numLines&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;resize varwin 5&quot;   </DT><DD>
Resizes the varwin to 5 lines.</DD>
<DT>
&quot;resize va 5&quot; </DT><DD>Resizes the varwin to 5 lines.</DD>


</DL>
<P>
Resizes the source window or a varwin or localwin.</P>

<UL>
<LI>
The <EM>
window</EM>
 argument is the name of the window to be resized, or a unique abbreviation of that name. Possible names are: &quot;varwin&quot;, &quot;localwin&quot;, &quot;view&quot;, &quot;doc&quot;, and &quot;srcwin&quot;; the last three all refer to the source window. </LI>
<LI>
The <EM>
numLines</EM>
 argument is the desired window size. </LI>
<LI>
This command will not resize a flagwin, regwin, or framewin, as the optimal size of those windows does not vary.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_25.htm_IX_restore-state Swat command">
 </A>
restore-state</H1>

<PRE CLASS="syntax">restore-state</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;restore-state&quot;</DT><DD>
Set all registers for the current thread to the values saved by the most recent save-state.</DD>


</DL>
<P>
Pops all the registers for a thread from the internal state stack.</P>

<UL>
<LI>
This is the companion to the &quot;save-state&quot; command.</LI>
<LI>
All the thread's registers are affected by this command.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_26.htm#IX_save-state Swat command">save-state</A>.


<HR>
<A NAME="SR_26.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_26.htm_IX_ret Swat command">
 </A>
ret</H1>

<PRE CLASS="syntax">ret [&lt;function name&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	&quot;ret&quot;<BR>
&quot;ret ObjMessage&quot;</P>


<P>
Return from a function and stop.</P>
<UL>
<LI>
The &lt;function name&gt; argument is the name of a function in the patient's stack after which swat should stop. If none is specified then Swat returns from the current function.</LI>
<LI>
The function returned from is the first frame from the top of the stack which calls the function (like the &quot;finish&quot; command).</LI>
<LI>
This command does not force a return. The machine continues until it reaches the frame above the function.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_d.htm#IX_finish Swat command">finish</A>,
<A HREF="../../Tools/SwatRef/SR_4.htm#IX_backtrace Swat command:command reference">backtrace</A>.



<H1 CLASS="refHeading">
<A NAME="SR_26.htm_IX_return-to-top-level Swat command">
 </A>
return-to-top-level</H1>

<PRE CLASS="syntax">return-to-top-level</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;return-to-top-level&quot;</DT><DD>
Returns to the top-level interpreter.</DD>


</DL>
<P>
Forces execution to return to the top-level interpreter loop, unwinding intermediate calls (protected commands still have their protected clauses executed, but nothing else is).</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2d.htm#IX_top-level Swat command">top-level</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_protect Tcl command">protect</A>.



<H1 CLASS="refHeading">
<A NAME="SR_26.htm_IX_rs Swat command">
 </A>
rs</H1>

<PRE CLASS="syntax">rs</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;rs&quot;</DT><DD>restart GEOS without attaching</DD>

</DL>
<P>
Restart GEOS without attaching.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_4.htm#IX_att Swat command:command reference">att</A>,
<A HREF="../../Tools/SwatRef/SR_4.htm#IX_attach Swat command:command reference">attach</A>.



<H1 CLASS="refHeading">
<A NAME="SR_26.htm_IX_run Swat command">
 </A>
run</H1>

<PRE CLASS="syntax">run [&lt;patient-name&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;run uki&quot;</DT><DD>
Run the application with patient name &quot;uki&quot;.</DD>
<DT>
&quot;run -e uki&quot;</DT><DD>		run EC Uki</DD>
<DT>
&quot;run -n uki&quot;</DT><DD>		run non-EC Uki</DD>
<DT>
&quot;run -p games\ukiec.geo	&quot;</DT><DD>
run games\ukiec.geo</DD>
<DT>
&quot;run&quot;</DT><DD>		run the default patient, as specified by the patient-default command.</DD>


</DL>
<P>
&quot;Runs&quot; an application by loading it via a call to <CODE>
UserLoadApplication()</CODE>
 and stopping when the app reaches the GenProcess handler for <CODE>
MSG_META_ATTACH</CODE>
. Return patient created, if any (In the examples shown, this would be &quot;uki&quot;).</P>

<UL>
<LI>
May be used even if stopped inside the loader, in which case GEOS will be allowed to continue starting up,  and the specified app run after GEOS is Idle. </LI>
<LI>
If the machine stops for any other reason other than the call's completion, you are left wherever the machine stopped.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1c.htm#IX_patient-default Swat command">patient-default</A>,
<A HREF="../../Tools/SwatRef/SR_27.htm#IX_send Swat command:reference">send</A>,
<A HREF="../../Tools/SwatRef/SR_29.htm#IX_spawn Swat command">spawn</A>,
<A HREF="../../Tools/SwatRef/SR_2b.htm#IX_switch Swat command:command reference">switch</A>.



<H1 CLASS="refHeading">
<A NAME="SR_26.htm_IX_Text:monitoring line ripple activity with Swat">
 </A>
<A NAME="SR_26.htm_IX_rwatch Swat command">
 </A>
rwatch</H1>

<PRE CLASS="syntax">rwatch [(on|off)]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;rwatch on&quot; </DT><DD>Watch text-recalculation as it happens</DD>
<DT>
 &quot;rwatch off&quot; </DT><DD>Turn output off</DD>
<DT>
 &quot;rwatch&quot; </DT><DD>See what the status is</DD>

</DL>
<P>
Displays information about text recalculation. Specifically designed for tracking bugs in the rippling code.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_23.htm#IX_ptext Swat command">ptext</A>.



<H1 CLASS="refHeading">
<A NAME="SR_26.htm_IX_Dumping Swat output">
 </A>
<A NAME="SR_26.htm_IX_save Swat command">
 </A>
save</H1>

<PRE CLASS="syntax">save (&lt;#lines&gt;|&lt;filename&gt;)</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;save 500&quot;</DT><DD>Save the last 500 lines that scroll off the screen.</DD>
<DT>
&quot;save /dumps/puffball&quot;</DT><DD>
Save the contents of the entire scroll buffer to the file &quot;puffball&quot;.</DD>


</DL>
<P>
Controls the scrollback buffer Swat maintains for its main command window.</P>

<UL>
<LI>
If the argument is numeric, it sets the number of lines to save (the default is 1,000). </LI>
<LI>
If the argument is anything else, it's taken to be the name of a file in which the current buffer contents (including the command window) should be saved. If the &lt;filename&gt; is relative, it is taken relative to the directory in which the executable for the patient to which the current stack frame's function belongs is located. If the file already exists, it is overwritten.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_26.htm_IX_save-state Swat command">
 </A>
save-state</H1>

<PRE CLASS="syntax">save-state</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;save-state&quot;</DT><DD>
Push the current register state onto the thread's state stack.</DD>


</DL>
<P>
Records the state of the current thread (all its registers) for later restoration by &quot;restore-state&quot;.</P>

<UL>
<LI>
Swat maintains an internal state stack for each thread it knows, so calling this has no effect on the target PC. </LI>
<LI>
This won't save any memory contents, just the state of the thread's registers.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_25.htm#IX_restore-state Swat command">restore-state</A>,
<A HREF="../../Tools/SwatRef/SR_a.htm#IX_discard-state Swat command">discard-state</A>.



<H1 CLASS="refHeading">
<A NAME="SR_26.htm_IX_sbwalk Swat command">
 </A>
sbwalk</H1>

<PRE CLASS="syntax">sbwalk [&lt;patient&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;sbwalk&quot;</DT><DD>list the saved blocks of the current patient.</DD>
<DT>
&quot;sbwalk geos&quot;</DT><DD>
list the saved blocks of the GEOS patient.</DD>


</DL>
<P>
List all the saved blocks in a patient.</P>

<UL>
<LI>
The &lt;patient&gt; argument is any GEOS patient. If none is specified then the current patient is used.</LI>
</UL>


<HR>
<A NAME="SR_27.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_27.htm_IX_scope Swat command">
 </A>
scope</H1>

<PRE CLASS="syntax">scope [&lt;scope-name&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;scope&quot;</DT><DD>Returns the name of the current auxiliary scope.</DD>


</DL>
<P>
This changes the auxiliary scope in which Swat looks first when trying to resolve a symbol name in an address expression.</P>

<UL>
<LI>
This command isn't usually typed by users, but it is the reason you can reference local labels after you've listed a function unrelated to the current one. </LI>
<LI>
You most likely want to use the set-address Tcl procedure, rather than this command. </LI>
<LI>
If &lt;scope-name&gt; is &quot;..&quot;, the auxiliary scope will change to be the lexical parent of the current scope. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_27.htm#IX_set-address Swat command">set-address</A>,
<A HREF="../../Tools/SwatRef/SR_2.htm#IX_addr-parse Swat command">addr-parse</A>,
<A HREF="../../Tools/SwatRef/SR_30.htm#IX_whatis Swat command">whatis</A>.



<H1 CLASS="refHeading">
<A NAME="SR_27.htm_IX_Windows:accessing topmost with Swat">
 </A>
<A NAME="SR_27.htm_IX_screenwin Swat command">
 </A>
screenwin</H1>

<PRE CLASS="syntax">screenwin</PRE>


<P>
Print the address of the current top-most screen window.</P>



<H1 CLASS="refHeading">
<A NAME="SR_27.htm_IX_send Swat command:reference">
 </A>
send</H1>

<PRE CLASS="syntax">send [-enpr] &lt;geode-name&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;send icon&quot;	</DT><DD>
send EC Icon Editor if running in EC mode; send non-EC Icon Editor if running in non-EC mode.</DD>
<DT>
&quot;send -r icon&quot;</DT><DD>
send appropriate icon editor, then run it. (See documentation for &quot;run&quot; above.)</DD>
<DT>
&quot;send -e icon&quot;</DT><DD>
send EC Icon editor.</DD>
<DT>
&quot;send -n icon&quot;</DT><DD>
send non-EC Icon Editor</DD>
<DT>
&quot;send -p c:/pcgeos/appl/icon/icon.geo&quot;</DT><DD>
send c:/pcgeos/appl/icon/icon.geo</DD>
<DT>
&quot;send&quot;</DT><DD>send the default patient (as set by the <CODE>
patient-default</CODE>
 command).</DD>


</DL>
<P>
Send a geode from the host to target machine.</P>



<H1 CLASS="refHeading">
<A NAME="SR_27.htm_IX_send-file">
 </A>
send-file</H1>

<PRE CLASS="syntax">send-file &lt;file&gt; &lt;targfilename&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;send-file /pcgeos/appl/sdk/mess1/mess1.geo WORLD/soundapp.geo&quot;</DT><DD>
Send the <STRONG CLASS="fileName">
mess1.geo</STRONG>
 file on the host machine to the WORLD directory of the host machine, where it will be called <STRONG CLASS="fileName">
soundapp.geo</STRONG>
.</DD>


</DL>
<P>
Sends a file from the host machine to the target.</P>



<H1 CLASS="refHeading">
<A NAME="SR_27.htm_IX_set-address Swat command">
 </A>
set-address</H1>
<P>
Set the last-accessed address recorded for memory-access commands. Single argument is an address expression to be used by the next memory-access command (except via &lt;return&gt;).</P>


<H1 CLASS="refHeading">
<A NAME="SR_27.htm_IX_Registers:flags register:setting flags with Swat">
 </A>
<A NAME="SR_27.htm_IX_Flags register:setting flags with Swat">
 </A>
<A NAME="SR_27.htm_IX_setcc Swat command">
 </A>
setcc</H1>

<PRE CLASS="syntax">setcc &lt;flag&gt; [&lt;value&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;setcc c&quot;</DT><DD>set the carry flag</DD>
<DT>
&quot;setcc z 0&quot;</DT><DD>clear the zero flag</DD>


</DL>
<P>
Set a flag in the computer.</P>

<UL>
<LI>
The first argument is the first letter of the flag to set. The following is a list of the flags:</LI>
<DL>
<DT>
<STRONG>
          t</STRONG>
</DT><DD>trap</DD>
<DT>
<STRONG>
          i</STRONG>
</DT><DD>interrupt enable</DD>
<DT>
<STRONG>
          d</STRONG>
</DT><DD>direction</DD>
<DT>
<STRONG>
          o</STRONG>
</DT><DD>overflow</DD>
<DT>
<STRONG>
          s</STRONG>
</DT><DD>sign</DD>
<DT>
<STRONG>
          z</STRONG>
</DT><DD>zero</DD>
<DT>
<STRONG>
          a</STRONG>
</DT><DD>auxiliary carry</DD>
<DT>
<STRONG>
          p</STRONG>
</DT><DD>parity</DD>
<DT>
<STRONG>
          c</STRONG>
</DT><DD>carry</DD>
</DL>
<LI>
The second argument is the value to assign the flag. It defaults to one but may be zero to clear the flag.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_6.htm#IX_clrcc Swat command">clrcc</A>,
<A HREF="../../Tools/SwatRef/SR_6.htm#IX_compcc Swat command">compcc</A>.



<H1 CLASS="refHeading">
<A NAME="SR_27.htm_IX_Interrupts:masking with Swat">
 </A>
<A NAME="SR_27.htm_IX_set-masks Swat command">
 </A>
set-masks</H1>

<PRE CLASS="syntax">set-masks &lt;mask1&gt; &lt;mask2&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;set-masks 0xff 0xff&quot;</DT><DD>
Allow no hardware interrupts to be handled while the machine is stopped.</DD>


</DL>
<P>
Sets the interrupt masks used while the Swat stub is active. Users should use the &quot;int&quot; command.</P>

<UL>
<LI>
&lt;mask1&gt; is the mask for the first interrupt controller, with a 1 bit indicating the interrupt should be held until the stub returns the machine to GEOS. &lt;mask2&gt; is the mask for the second interrupt controller. </LI>
<LI>
These masks are active only while the machine is executing in the stub, which usually means only while the machine is stopped.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_15.htm#IX_int Swat command">int</A>.



<H1 CLASS="refHeading">
<A NAME="SR_27.htm_IX_set-repeat Swat command">
 </A>
set-repeat</H1>
<P>
Sets the command to be repeated using a template string and the lastCommand variable. The variables $0...$n substitute the fields 0...n from the lastCommand variable. The final result is placed in repeatCommand which will be executed should the user type Enter.</P>


<H1 CLASS="refHeading">
<A NAME="SR_27.htm_IX_set-startup-ec Swat command">
 </A>
set-startup-ec</H1>

<PRE CLASS="syntax">set-startup-ec [&lt;args&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;set-startup-ec +vm&quot;</DT><DD>
 turn on VM error checking when starting up</DD>
<DT>
&quot;set-startup-ec none&quot;</DT><DD>
 turn off all ec code when starting up</DD>


</DL>
<P>
Executes the &quot;ec&quot; command upon startup, to allow one to override the default error checking flags.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_b.htm#IX_ec Swat command">ec</A>.



<H1 CLASS="refHeading">
<A NAME="SR_27.htm_IX_Files:listing with Swat">
 </A>
<A NAME="SR_27.htm_IX_sftwalk Swat command">
 </A>
sftwalk</H1>

<PRE CLASS="syntax">sftwalk</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	&quot;sftwalk&quot;</P>


<P>
Print the system file table out by blocks.</P>

<UL>
<LI>
This is different than <CODE>
sysfiles</CODE>
 in that it shows less details of the files and instead shows where the SFT blocks are and what files are in them.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2c.htm#IX_sysfiles Swat command">sysfiles</A>,
<A HREF="../../Tools/SwatRef/SR_10.htm#IX_geosfiles Swat command">geosfiles</A>,
<A HREF="../../Tools/SwatRef/SR_10.htm#IX_fwalk Swat command">fwalk</A>.


<HR>
<A NAME="SR_28.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_28.htm_IX_Messages:monitoring with Swat">
 </A>
<A NAME="SR_28.htm_IX_showcalls Swat command">
 </A>
showcalls</H1>

<PRE CLASS="syntax">showcalls [&lt;flags&gt;] [&lt;args&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;showcalls -o&quot;</DT><DD>
show all calls using ObjMessage and ObjCall*</DD>
<DT>
&quot;showcalls -ml&quot;</DT><DD>
show all calls changing global and local memory</DD>
<DT>
&quot;showcalls&quot;</DT><DD>stop showing any calls</DD>


</DL>
<P>
Display calls to various parts of GEOS.</P>


<P>
&nbsp;</P>
<UL>
<LI>
The &lt;flags&gt; argument determines the types of calls displayed. Multiple flags must all be specified in the first argument such as &quot;showcalls -vl&quot;. If no flags are passed then showcalls stops watching. The flags may be any of the following:</LI>
<DL>
<DT>
<STRONG>
-p</STRONG>
</DT><DD>Modify all other flags to work for the current patient only</DD>
<DT>
<STRONG>
-a</STRONG>
</DT><DD>Show calls associated with attaching, detaching, state-saving, restoring from state</DD>
<DT>
<STRONG>
-b</STRONG>
</DT><DD>Monitors builds of Vis objects</DD>
<DT>
<STRONG>
-d</STRONG>
</DT><DD>Show dispatching of threads</DD>
<DT>
<STRONG>
-e</STRONG>
</DT><DD>Show FOCUS, TARGET, MODAL . exclusive grabs &amp; releases</DD>
<DT>
<STRONG>
-f</STRONG>
</DT><DD>Show certain file operations</DD>
<DT>
<STRONG>
-g</STRONG>
</DT><DD>Show geometry manager resizing things (all sizes in hex)</DD>
<DT>
<STRONG>
-h</STRONG>
</DT><DD>Show all hierarchical exclusive grabs and releases (associated with focus, target, and model).</DD>
<DT>
<STRONG>
-i</STRONG>
  </DT><DD>Show call far calls made to movable routines.</DD>
<DT>
<STRONG>
-l</STRONG>
</DT><DD><A NAME="SR_28.htm_IX_Local memory:monitoring with Swat">
 </A>
Show local memory create, destroy, relocate</DD>
<DT>
<STRONG>
-m</STRONG>
</DT><DD>Show global memory alloc, free, realloc</DD>
<DT>
<STRONG>
-o</STRONG>
</DT><DD><A NAME="SR_28.htm_IX_Messages:monitoring with Swat">
 </A>
Show <CODE>
ObjMessage()</CODE>
 and <CODE>
ObjCall</CODE>
...<CODE>
()</CODE>
</DD>
<DT>
<STRONG>
-s</STRONG>
</DT><DD>Monitors shutdown: <CODE>
MSG_DETACH</CODE>
, <CODE>
DETACH_COMPLETE</CODE>
, <CODE>
ACK</CODE>
, <CODE>
DETACH_ABORT</CODE>
</DD>
<DT>
<STRONG>
-t</STRONG>
 </DT><DD>Show clipboard activity</DD>
<DT>
<STRONG>
-v</STRONG>
</DT><DD>Show video driver calls</DD>
<DT>
<STRONG>
-w</STRONG>
</DT><DD><A NAME="SR_28.htm_IX_Windows:monitoring with Swat">
 </A>
Show <CODE>
WinOpen()</CODE>
, <CODE>
WinClose()</CODE>
, <CODE>
WinMoveResize()</CODE>
, <CODE>
WinChangePriority()</CODE>
.</DD>
<DT>
<STRONG>
-F</STRONG>
</DT><DD>Show file-change notifications produced by the system.</DD>
<DT>
<STRONG>
-G</STRONG>
</DT><DD>Show <CODE>
GrCreateState()</CODE>
 and <CODE>
GrDestroyGState()</CODE>
.</DD>
<DT>
<STRONG>
-H</STRONG>
</DT><DD>Show heap space allocation (using .gp heapspace values, not actual allocation values)</DD>
<DT>
<STRONG>
-I </STRONG>
</DT><DD>Show invalidation mechanism at work.</DD>
<DT>
<STRONG>
-L</STRONG>
</DT><DD>Show library loading calls</DD>
<DT>
<STRONG>
-N</STRONG>
</DT><DD>Show navigation calls (between fields, and between windows)</DD>
<DT>
<STRONG>
-S</STRONG>
</DT><DD>Show stack borrowing activity.</DD>
<DT>
<STRONG>
-T</STRONG>
 </DT><DD>Show text-object related information.</DD>
<DT>
<STRONG>
-V</STRONG>
</DT><DD>Show loading and unloading of resources to and from statefiles during shutdown.</DD>
</DL>
<LI>
The&lt;args&gt; argument is used to pass values for some of options.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_19.htm#IX_mwatch Swat command">mwatch</A>,
<A HREF="../../Tools/SwatRef/SR_1b.htm#IX_objwatch Swat command">objwatch</A>.



<H1 CLASS="refHeading">
<A NAME="SR_28.htm_IX_showMethodNames Swat command">
 </A>
showMethodNames</H1>

<PRE CLASS="syntax">var showMethodNames</PRE>


<P>
If this variable is non-zero, Swat prints out the names of the method in the AX register when unassembling a message call.</P>



<H1 CLASS="refHeading">
<A NAME="SR_28.htm_IX_Stepping through code:Assembly code">
 </A>
<A NAME="SR_28.htm_IX_skip Swat command">
 </A>
skip</H1>

<PRE CLASS="syntax">skip [&lt;number of instructions&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;skip&quot;</DT><DD>skip the current instruction</DD>
<DT>
&quot;skip 6&quot;</DT><DD>skip the next six instructions</DD>


</DL>
<P>
Skip one or more instructions.</P>

<UL>
<LI>
The &lt;number of instructions&gt; argument defaults to one if not specified.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_16.htm#IX_istep Swat command:command reference">istep</A>,
<A HREF="../../Tools/SwatRef/SR_29.htm#IX_sstep Swat command">sstep</A>,
<A HREF="../../Tools/SwatRef/SR_1b.htm#IX_patch Swat command">patch</A>.



<H1 CLASS="refHeading">
<A NAME="SR_28.htm_IX_sleep Swat command">
 </A>
sleep</H1>

<PRE CLASS="syntax">sleep &lt;seconds&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;sleep 5&quot;</DT><DD>Pauses Swat for 5 seconds.</DD>


</DL>
<P>
This pauses Tcl execution for the given number of seconds, or until the user types Ctrl-C.</P>

<UL>
<LI>
Messages from the PC continue to be processed, so a FULLSTOP event will be dispatched if the PC stops, but this command won't return until the given length of time has elapsed. </LI>
<LI>
&lt;seconds&gt; is a real number, so &quot;1.5&quot; is a valid argument. </LI>
<LI>
Returns non-zero if it slept for the entire time, or 0 if the sleep was interrupted by the user.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_28.htm_IX_Source code:listing with Swat">
 </A>
<A NAME="SR_28.htm_IX_slist Swat command">
 </A>
slist</H1>

<PRE CLASS="syntax">slist [&lt;args&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;slist&quot;</DT><DD>list the current point of execution</DD>
<DT>
&quot;slist foo.asm::15&quot;</DT><DD>
list foo.asm at line 15</DD>
<DT>
&quot;slist foo.asm::15,45&quot;</DT><DD>
list foo.asm from lines 15 to 45</DD>


</DL>
<P>
List source file lines in swat.</P>

<UL>
<LI>
The args argument can be any of the following:</LI>
<DL>
<DT>
&lt;address&gt;</DT><DD>Lists the 10 lines around the given address</DD>
<DT>
&lt;line&gt;</DT><DD>Lists the given line in the current file</DD>
<DT>
&lt;file&gt;::&lt;line&gt;</DT><DD>
Lists the line in the given file</DD>
<DT>
&lt;line1&gt;,&lt;line2&gt;</DT><DD>
Lists the lines between line1 and line2, inclusive, in the current file</DD>
<DT>
&lt;file&gt;::&lt;line1&gt;,&lt;line2&gt;</DT><DD>
Lists the range from &lt;file&gt;</DD>
</DL>
<LI>
 The default is to list the source lines around CS:IP.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_17.htm#IX_listi Swat command:command reference">listi</A>,
<A HREF="../../Tools/SwatRef/SR_16.htm#IX_istep Swat command:command reference">istep</A>,
<A HREF="../../Tools/SwatRef/SR_25.htm#IX_regs Swat command">regs</A>.


<HR>
<A NAME="SR_29.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_29.htm_IX_smatch Swat command">
 </A>
smatch</H1>

<P>
Look for symbols of a given class by pattern. First argument &lt;pattern&gt; is the pattern for which to search (it's a standard Swat pattern using shell wildcard characters). Optional second argument &lt;class&gt; is the class of symbol for which to search and is given directly to the &quot;symbol match&quot; command. Defaults to &quot;any&quot;.</P>



<H1 CLASS="refHeading">
<A NAME="SR_29.htm_IX_sort Swat command">
 </A>
sort</H1>

<PRE CLASS="syntax">sort [-r] [-n] [-u] &lt;list&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;sort -n $ids&quot;</DT><DD>
Sorts the list in $ids into ascending numeric order.</DD>


</DL>
<P>
This sorts a list into ascending or descending order, lexicographically or numerically.</P>

<UL>
<LI>
If &quot;-r&quot; is given, the sort will be in descending order. </LI>
<LI>
If &quot;-u&quot; is given, duplicate elements will be eliminated. </LI>
<LI>
If &quot;-n&quot; is given, the elements are taken to be numbers (with the usual radix specifiers possible) and are sorted accordingly. </LI>
<LI>
The sorted list is returned.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_18.htm#IX_map Swat command">map</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_foreach Tcl command">foreach</A>,
<A HREF="../../Tools/SwatRef/SR_18.htm#IX_mapconcat Swat command">mapconcat</A>.



<H1 CLASS="refHeading">
<A NAME="SR_29.htm_IX_Threads:monitoring with Swat">
 </A>
<A NAME="SR_29.htm_IX_spawn Swat command">
 </A>
spawn</H1>

<PRE CLASS="syntax">spawn &lt;processName&gt; [&lt;addr&gt;]</PRE>


<P>
Set a temporary breakpoint in a not-yet-existent process/thread, waiting for a new one to be created. First argument is the permanent name of the process to watch for. Second argument is an address expression specifying where to place the breakpoint. If no second argument is present, the machine will be stopped and Swat will return to the command level when the new thread is spawned by GEOS.</P>

<UL>
<LI>
This can also be used to catch the spawning of a new thread.</LI>
<LI>
If the machine stops before the breakpoint can be set, you'll have to do this again.</LI>
</UL>

<H1 CLASS="refHeading">
<A NAME="SR_29.htm_IX_Display windows in Swat:displaying source code">
 </A>
<A NAME="SR_29.htm_IX_Source code:displaying with Swat">
 </A>
<A NAME="SR_29.htm_IX_srcwin Swat command">
 </A>
srcwin</H1>

<PRE CLASS="syntax">srcwin &lt;numLines&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;srcwin 6&quot;</DT><DD>Show 6 lines of source context around CS:IP</DD>
<DT>
&quot;srcwin 0&quot;</DT><DD>Show no source lines, i.e. turn the display off.</DD>


</DL>
<P>
Set the number of lines of source code to be displayed when the target machine stops.</P>

<UL>
<LI>
Only one source display may be active at a time.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_a.htm#IX_display Swat command">display</A>,
<A HREF="../../Tools/SwatRef/SR_25.htm#IX_regwin Swat command">regwin</A>.



<H1 CLASS="refHeading">
<A NAME="SR_29.htm_IX_Stepping through code:C code">
 </A>
<A NAME="SR_29.htm_IX_sstep Swat command">
 </A>
sstep</H1>

<PRE CLASS="syntax">sstep [&lt;default command&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;ss&quot;</DT><DD>enter source step mode</DD>
<DT>
&quot;sstep n&quot;</DT><DD>enter source step mode, &lt;ret&gt; does a next command</DD>


</DL>
<P>
Step through the execution of the current patient by source lines. This is THE command for stepping through high-level (e.g., C) code.</P>
<UL>
<LI>
The &lt;default&gt; command argument determines what pressing the &lt;Return&gt; key does. By default, &lt;Return&gt; executes a step command. Any other command listed below may be substituted by passing the letter of the command.</LI>
<LI>
Sstep steps through the patient line by line, printing where the instruction pointer is and what line is to be executed Sstep waits for the user to type a command which it performs and then prints out again where sstep is executing.</LI>
<LI>
This is a list of sstep commands:</LI>
<DL>
<DT>
<STRONG>
q</STRONG>
, &lt;<STRONG>
Esc</STRONG>
&gt;,` `</DT><DD>Stops sstep and returns to command level.</DD>
<DT>
<STRONG>
b</STRONG>
</DT><DD>Toggles a breakpoint at the current location.</DD>
<DT>
<STRONG>
c</STRONG>
</DT><DD>Stops sstep and continues execution.</DD>
<DT>
<STRONG>
n</STRONG>
</DT><DD>Continues to the next source line, skipping procedure calls, repeated string instructions, and software interrupts. Only stops when the machine returns to the right context (i.e. the stack pointer and current thread are the same as they are when the `n' command was given).</DD>
<DT>
<STRONG>
l</STRONG>
</DT><DD>Goes to the next library routine.</DD>
<DT>
<STRONG>
N</STRONG>
</DT><DD>Like n, but stops whenever the breakpoint is hit, whether you're in the same frame or not.</DD>
<DT>
<STRONG>
M</STRONG>
</DT><DD><A NAME="SR_29.htm_IX_Methods:stopping in with Swat">
 </A>
Goes to the next message called. Doesn't work when the message is not handled anywhere.</DD>
<DT>
<STRONG>
f</STRONG>
</DT><DD>Finishes out the current stack frame.</DD>
<DT>
<STRONG>
s</STRONG>
, &lt;<STRONG>
Ret</STRONG>
&gt;</DT><DD>Steps one source line</DD>
<DT>
<STRONG>
S</STRONG>
</DT><DD>Skips the current instruction</DD>
<DT>
<STRONG>
J</STRONG>
</DT><DD>Jump on a conditional jump, even when &quot;Will not jump&quot; appears. This does not change the condition codes.</DD>
<DT>
<STRONG>
g</STRONG>
</DT><DD>Executes the `go' command with the rest of the line as arguments.</DD>
<DT>
<STRONG>
e</STRONG>
</DT><DD>Executes a Tcl command and returns to the prompt.</DD>
<DT>
<STRONG>
R</STRONG>
</DT><DD>References either the function to be called or the function currently executing.</DD>
<DT>
<STRONG>
h</STRONG>
, <STRONG>
?</STRONG>
</DT><DD>A help message.</DD>
</DL>
<LI>
Emacs will load in the correct file executing and following the lines where sstep is executing if its server is started and if ewatch is on in swat. If ewatch is off emacs will not be updated.</LI>
<LI>
If the current patient isn't the actual current thread, sstep waits for the patient to wake up before single-stepping it.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_16.htm#IX_istep Swat command:command reference">istep</A>,
<A HREF="../../Tools/SwatRef/SR_17.htm#IX_listi Swat command:command reference">listi</A>.


<HR>
<A NAME="SR_2a.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_2a.htm_IX_Standard paths:examining with Swat">
 </A>
<A NAME="SR_2a.htm_IX_Files:examining standard paths with Swat">
 </A>
<A NAME="SR_2a.htm_IX_stdpaths Swat command">
 </A>
stdpaths</H1>

<PRE CLASS="syntax">stdpaths</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	&quot;stdpaths&quot;</P>


<P>
Print out all paths set for standard directories</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_24.htm#IX_pwd Swat command">pwd</A>,
<A HREF="../../Tools/SwatRef/SR_a.htm#IX_dirs Swat command">dirs</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2a.htm_IX_Stepping through code:Assembly code">
 </A>
<A NAME="SR_2a.htm_IX_step Swat command">
 </A>
step</H1>

<PRE CLASS="syntax">step</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;step&quot;</DT><DD>execute the next instruction</DD>
<DT>
&quot;s&quot;</DT>


</DL>
<P>
Execute the patient by a single machine instruction.</P>

<UL>
<LI>
If waitForPatient is non-zero, step waits for the machine to stop again.</LI>
<LI>
This doesn't do any of the checks for special conditions (XchgTopStack, software interrupts, etc.) performed by the `s' command in istep.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_16.htm#IX_istep Swat command:command reference">istep</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_next Swat command">next</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2a.htm_IX_step-patient Swat command">
 </A>
<A NAME="SR_2a.htm_IX_Stepping through code:assembly code">
 </A>
step-patient</H1>

<PRE CLASS="syntax">step-patient </PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;step-patient&quot;</DT><DD>
Execute a single instruction on the target PC.</DD>


</DL>
<P>
Causes the PC to execute a single instruction, returning only when the instruction has been executed.</P>

<UL>
<LI>
Unlike the continue-patient command, this command will not return until the machine has stopped again.</LI>
<LI>
No other thread will be allowed to run, as timer interrupts will be turned off while the instruction is being executed.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_13.htm#IX_help-fetch Swat command">help-fetch</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2a.htm_IX_step-until Swat command">
 </A>
step-until</H1>

<PRE CLASS="syntax">step-until expression [byte|word]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;step-until ax=0&quot;</DT><DD>
Single-step until ax is zero.</DD>
<DT>
&quot;step-until ds:20h!=0 byte&quot; </DT><DD>
Single-step until byte at ds:20h is non-zero</DD>
<DT>
&quot;step-until ds:20h!=0 word&quot;</DT><DD>
Single-step until word at ds:20h is non-zero</DD>
<DT>
&quot;step-until c=0&quot;</DT><DD>
Single-step until the carry is clear</DD>
<DT>
&quot;step-until ax!=ax&quot;</DT><DD>
Step forever</DD>
</DL>
<P>
This command causes Swat to step until a condition is met.</P>

<P>
Useful for tracking memory or register trashing bugs.</P>

<H1 CLASS="refHeading">
<A NAME="SR_2a.htm_IX_Breakpoints:setting">
 </A>
<A NAME="SR_2a.htm_IX_stop Swat command">
 </A>
stop</H1>

<PRE CLASS="syntax">stop in &lt;class&gt;::&lt;message&gt; [if &lt;expr&gt;]
stop in &lt;procedure&gt; [if &lt;expr&gt;]
stop in &lt;address-history-token&gt; [if &lt;expr&gt;]
stop at [&lt;file&gt;:]&lt;line&gt; [if &lt;expr&gt;]
stop &lt;address&gt; [if &lt;expr&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	&quot;stop in main&quot;<BR>
&quot;stop in @3&quot;<BR>
&quot;stop at /staff/pcgeos/Loader/main.asm:36 if { joe_local ==22}&quot;<BR>
&quot;stop at 25&quot;<BR>
&quot;stop MemAlloc+3 if {ax==3}&quot;</P>


<P>
Specify a place and condition at which the machine should stop executing. This command is intended primarily for setting breakpoints when debugging a geode created in C or another high-level language, but may also be used when debugging assembly-language geodes.</P>

<UL>
<LI>
&quot;stop in&quot; will set a breakpoint at the beginning of a procedure, immediately after the procedure's stack frame has been set up.</LI>
<LI>
&quot;stop at&quot; will set a breakpoint at the first instruction of the given source line. If no &lt;file&gt; is specified, the source file for the current stack frame is used.</LI>
<LI>
If a condition is specified, by means of an &quot;if &lt;expr&gt;&quot; clause, you should enclose the expression in {}'s to prevent any nested commands, such as a &quot;value fetch&quot; command, from being evaluated until the break-point is hit.</LI>
<LI>
For convenience, &quot;stop in&quot; also allows address-history tokens. This is useful when used in conjunction with the &quot;methods&quot; command.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_f.htm#IX_brk Tcl structure:command reference">brk</A>,
<A HREF="../../Tools/SwatRef/SR_14.htm#IX_ibrk Swat command">ibrk</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2a.htm_IX_stop-catch Swat command">
 </A>
stop-catch</H1>

<PRE CLASS="syntax">stop-catch &lt;body&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;stop-catch {go ProcCallModuleRoutine}&quot;</DT><DD>
Let machine run until it reaches <CODE>
ProcCallModuleRoutine()</CODE>
, but do not issue a FULLSTOP event when it gets there.</DD>


</DL>
<P>
Allows a string of commands to execute without a FULLSTOP event being generated while they execute.</P>


<P>
A number of things happen when a FULLSTOP event is dispatched, including notifying the user where the machine stopped. This is inappropriate in something like &quot;istep&quot; or &quot;cycles&quot; that is single-stepping the machine, for example.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_f.htm#IX_event Tcl structure">event</A>,
<A HREF="../../Tools/SwatRef/SR_7.htm#IX_continue-patient Swat command">continue-patient</A>,
<A HREF="../../Tools/SwatRef/SR_2a.htm#IX_step-patient Swat command">step-patient</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2a.htm_IX_stop-patient Swat command">
 </A>
stop-patient</H1>

<PRE CLASS="syntax">stop-patient</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;stop-patient&quot;</DT><DD>
Stops the target PC.</DD>


</DL>
<P>
Stops the target PC, in case you continued it and didn't wait for it to stop on its own.</P>


<P>
This is different from the &quot;stop&quot; subcommand of the &quot;patient&quot; command.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_7.htm#IX_continue-patient Swat command">continue-patient</A>.


<HR>
<A NAME="SR_2b.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_2b.htm_IX_Files:manipulating host machine files with Swat">
 </A>
<A NAME="SR_2b.htm_IX_stream Swat command">
 </A>
stream</H1>

<PRE CLASS="syntax">stream open &lt;file&gt; (r|w|a|r+|w+)
stream read (line|list|char) &lt;stream&gt;
stream print &lt;list&gt; &lt;stream&gt;
stream write &lt;string&gt; &lt;stream&gt;
stream rewind &lt;stream&gt;
stream seek (&lt;posn&gt;|+&lt;incr&gt;|-&lt;decr&gt;|end) &lt;stream&gt;
stream state &lt;stream&gt;
stream eof &lt;stream&gt;
stream close &lt;stream&gt;
stream flush &lt;stream&gt;
stream watch &lt;stream&gt; &lt;what&gt; &lt;procName&gt;
stream ignore &lt;stream&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var s [stream open kmap.def w]&quot; </DT><DD>
Open the file &quot;kmap.def&quot; for writing, creating it if it wasn't there before, and truncating any existing file.</DD>
<DT>
 &quot;stream write $line $s&quot; </DT><DD>
Write the string in $line to the open stream.</DD>


</DL>
<P>
This allows you to read, write, create, and otherwise manipulate files on the host machine from Swat.</P>

<UL>
<LI>
Subcommands may be abbreviated uniquely. </LI>
<LI>
Streams are a precious resource, so you should be sure to always close them when you are done. This means stream access should usually be performed under the wings of a &quot;protect&quot; command so the stream gets closed even if the user types Ctrl+C. </LI>
<LI>
Swat's current directory changes as you change stack frames, with the directory always being the one that holds the executable file for the patient to which the function in the current frame belongs. If the &lt;file&gt; given to &quot;stream open&quot; isn't absolute, it will be affected by this. </LI>
<LI>
The global variable file-init-dir contains the absolute path of the directory in which Swat was started. It can be quite useful when forming the &lt;file&gt; argument to &quot;stream open&quot;.</LI>
<LI>
The second argument to &quot;stream open&quot; is the access mode of the file. The meanings of the 5 possible values are:</LI>
<DL>
<DT>
           <STRONG>
r</STRONG>
 </DT><DD>read-only access. The &lt;file&gt; must already exist.</DD>
<DT>
          <STRONG>
 w</STRONG>
</DT><DD> write-only access. If &lt;file&gt; doesn't already exist, it will be created. If it does exist, it will be truncated.</DD>
<DT>
           <STRONG>
a</STRONG>
 </DT><DD>append mode. The file is opened for writing only. If &lt;file&gt; doesn't already exist, it will be created. If it does exist, writing will commence at its end.</DD>
<DT>
           <STRONG>
r+</STRONG>
 </DT><DD>read/write. The &lt;file&gt; must already exist. A single read/write position is maintained, and it starts out at the start of the file. </DD>
<DT>
          <STRONG>
w+</STRONG>
 </DT><DD>read/write. If &lt;file&gt; doesn't already exist, it will be created. If it does exist, it will be truncated. A single read/write position is maintained, and it starts out at the start of the file.</DD>
</DL>
<LI>
&quot;stream read&quot; can read data from the stream in one of three formats:</LI>
<DL>
<DT>
           <STRONG>
line</STRONG>
 </DT><DD>Returns all the characters from the current position up to the first newline or the end of the file, whichever comes first. The newline, if seen, is placed at the end of the string as \n. Any other non-printable characters or backslashes are similarly escaped.</DD>
<DT>
            <STRONG>
list</STRONG>
 </DT><DD>Reads a single list from the stream, following all the usual rules of Tcl list construction. If the character at the current read position is a left brace, this will read to the matching right brace, bringing in newlines and other whitespace. If there is whitespace at the initial read position, it is skipped. Standard Tcl comments before the start of the list are also skipped over (so if the first non-whitespace character encountered is #, the characters up to the following newline or end-of-file will also be skipped).</DD>
<DT>
            <STRONG>
char</STRONG>
 </DT><DD>This reads a single character from the stream. If the character isn't printable ASCII, it will be returned as one of the regular Tcl backslash escapes.</DD>
</DL>
<P>
	 If there's nothing left to read, you will get an empty string back.</P>
<LI>
&quot;stream write&quot; writes the string exactly as given, without interpreting backslash escapes. If you want to include a newline or something of the sort in the string, you'll need to use the &quot;format&quot; command to generate the string, or place the whole thing in braces and have the newlines in there literally. </LI>
<LI>
While the syntax for &quot;stream print&quot; is the same as for &quot;stream write&quot;, there is a subtle difference between the two. &quot;stream write&quot; will write the string as it's given, while &quot;stream print&quot; is intended to write out data to be read back in by &quot;stream read list&quot;. Thus the command</LI>
<PRE> stream write {foo biff} $s</PRE>
<P>
	 would write the string &quot;foo biff&quot; to the stream. In contrast,</P>
<PRE> stream print {foo biff} $s</PRE>
<P>
	 would write &quot;{foo biff}&quot; followed by a newline.</P>
<LI>
To ensure that all data you have written has made it to disk, use the &quot;stream flush&quot; command. Nothing is returned. </LI>
<LI>
 &quot;stream rewind&quot; repositions the read/write position at the start of the stream. &quot;stream seek&quot; gives you finer control over the position. You can set the stream to an absolute position (obtained from a previous call to &quot;stream seek&quot;) by passing the byte number as a decimal number. You can also move forward or backward in the file a relative amount by specifying the number of bytes to move, preceded by a &quot;+&quot;, for forward, or a &quot;-&quot;, for backward. Finally, you can position the pointer at the end of the file by specifying a position of &quot;end&quot;. </LI>
<LI>
&quot;stream seek&quot; returns the new read/write position, so a call of &quot;stream seek +0 $s&quot; will get you the current position without changing anything. If the seek couldn't be performed, -1 is returned. </LI>
<LI>
&quot;stream state&quot; returns one of three strings: &quot;error&quot;, if there's been some error accessing the file, &quot;eof&quot; if the read/write position is at the end of the file, or &quot;ok&quot; if everything's fine. &quot;stream eof&quot; is a shortcut for figuring if you've reached the end of the file. </LI>
<LI>
&quot;stream close&quot; shuts down the stream. The stream token should never be used again. </LI>
<LI>
&quot;stream watch&quot; and &quot;stream ignore&quot; are valid only on UNIX and only make sense if the stream is open to a device or a socket. &quot;stream watch&quot; causes the procedure &lt;procName&gt; to be called whenever the stream is ready for the access indicated by &lt;what&gt;, which is a list of conditions chosen from the following set:</LI>
<DL>
<DT>
           <STRONG>
read</STRONG>
</DT><DD> the stream has data that may be read.</DD>
<DT>
            <STRONG>
write</STRONG>
 </DT><DD>the stream has room for data to be written to it.</DD>
</DL>
<P>
	 When the stream is ready, the procedure is called:</P>
<PRE> &lt;procName&gt; &lt;stream&gt; &lt;what&gt;</PRE>
<P>
	 where &lt;what&gt; is the list of operations for which the stream is ready.</P>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_protect Tcl command">protect</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_source Tcl command">source</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_file Tcl command">file</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2b.htm_IX_Patients:switching">
 </A>
<A NAME="SR_2b.htm_IX_Threads:switching">
 </A>
<A NAME="SR_2b.htm_IX_switch Swat command:command reference">
 </A>
switch</H1>

<PRE CLASS="syntax">switch &lt;thread-id&gt;
switch [&lt;patient&gt;] [:&lt;thread-num&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;switch 3730h&quot;</DT><DD>
Switches swat's current thread to be the one whose handle ID is 3730h.</DD>
<DT>
 &quot;switch :1&quot;</DT><DD> Switches Swat's current thread to be thread number 1 for the current patient.</DD>
<DT>
 &quot;switch parallel:2&quot; </DT><DD>
Switches Swat's current thread to be thread number 2 for the patient &quot;parallel&quot;</DD>
<DT>
 &quot;switch write&quot; </DT><DD>
Switches Swat's current thread to be thread number 0 (the process thread) for the patient &quot;write&quot;</DD>
<DT>
 &quot;switch&quot;</DT><DD> Switches Swat's current thread to be the current thread on the PC.</DD>


</DL>
<P>
Switches between applications/threads.</P>

<UL>
<LI>
Takes a single argument of the form &lt;patient&gt;:&lt;thread-num&gt; or &lt;threadID&gt;. With the first form, :&lt;thread-num&gt; is optional -- if the patient has threads, the first thread is selected. To switch to another thread of the same patient, give just :&lt;thread-num&gt;. You can also switch to a patient/thread by specifying the thread handle ID. NOTE: The switch doesn't happen on the PC--just inside swat.</LI>
<LI>
If you don't give an argument, it switches to the actual current thread in the PC.</LI>
</UL>


<HR>
<A NAME="SR_2c.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_2c.htm_IX_symbolCompletion Swat variable">
 </A>
symbolCompletion</H1>

<PRE CLASS="syntax">var symbolCompletion [(0|1)]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var symbolCompletion 1&quot; </DT><DD>
Enable symbol completion in the top-level command reader.</DD>


</DL>
<P>
This variable controls whether you can ask Swat to complete a symbol for you while you're typing a command. Completion is currently very slow and resource-intensive, so you probably don't want to enable it.</P>

<UL>
<LI>
Even when symbolCompletion is 0, file-name, variable-name, and command- name completion are always enabled, using the keys described below. </LI>
<LI>
When completion is enabled, three keys cause the interpreter to take the text immediately before the cursor and look for all symbols that begin with those characters. The keys are:</LI>
<DL>
<DT>
<STRONG>
 Ctrl+D</STRONG>
 </DT><DD>Produces a list of all possible matches to the prefix.</DD>
<DT>
 <STRONG>
Escape</STRONG>
 </DT><DD>Completes the command as best possible. If the characters typed so far could be the prefix for more than one command, Swat will fill in as many characters as possible.</DD>
<DT>
<STRONG>
 Ctrl+]</STRONG>
 </DT><DD>Cycles through the list of possible symbols, in alphabetical order.</DD>
</DL>
</UL>

<H1 CLASS="refHeading">
<A NAME="SR_2c.htm_IX_sym-default Swat command:command reference">
 </A>
sym-default</H1>

<PRE CLASS="syntax">sym-default [&lt;name&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;sym-default motif&quot;</DT><DD>
Make swat look for any unknown symbols in the patient named &quot;motif&quot; once all other usual places have been searched.</DD>


</DL>
<P>
Specifies an additional place to search for symbols when all the usual places have been searched to no avail.</P>

<UL>
<LI>
The named patient need not have been loaded yet when you execute this command.</LI>
<LI>
A typical use of this is to make whatever program you're working on be the sym-default in your .swat file so you don't need to worry about whether it's the current one, or reachable from the current one, when the machine stops and you want to examine the patient's state.</LI>
<LI>
If you don't give a name, you'll be returned the name of the current sym-default.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_2c.htm_IX_Files:listing with Swat">
 </A>
<A NAME="SR_2c.htm_IX_sysfiles Swat command">
 </A>
<A NAME="SR_2c.htm_IX_Files:DOS files">
 </A>
sysfiles</H1>

<PRE CLASS="syntax">sysfiles</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG></P>
<DL>
<DT>&quot;sysfiles&quot;</DT>

<DD>
Print out all open files from dos's system file table.</DD>
</DL>

<P>
Normally SFT entries that aren't in-use aren't printed. If you give the optional argument &quot;all&quot;, however, all SFT entries, including those that aren't in-use, will be printed.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_10.htm#IX_geosfiles Swat command">geosfiles</A>,
<A HREF="../../Tools/SwatRef/SR_27.htm#IX_sftwalk Swat command">sftwalk</A>,
<A HREF="../../Tools/SwatRef/SR_10.htm#IX_fwalk Swat command">fwalk</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2c.htm_IX_Trees:generic:accessing top of, with Swat">
 </A>
<A NAME="SR_2c.htm_IX_systemobj Swat command">
 </A>
systemobj</H1>

<PRE CLASS="syntax">systemobj</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;gentree [systemobj]&quot;</DT><DD>
print the generic tree starting at the system's root</DD>
<DT>
&quot;pobject [systemobj]&quot;</DT><DD>
print the system object</DD>


</DL>
<P>
Prints out the address of the uiSystemObj, which is the top level of the generic tree.</P>

<UL>
<LI>
This command is normally used with gentree as shown above to print out the whole generic tree starting from the top.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_10.htm#IX_gentree Swat command:command reference">gentree</A>,
<A HREF="../../Tools/SwatRef/SR_15.htm#IX_impliedgrab Swat command">impliedgrab</A>.

<H1 CLASS="refHeading">
<A NAME="SR_2c.htm_IX_Target:accessing hierarchy with Swat">
 </A>
<A NAME="SR_2c.htm_IX_target Swat command">
 </A>
target</H1>

<PRE CLASS="syntax">target [&lt;object&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;target&quot; </DT><DD>print target hierarchy from the system object down</DD>
<DT>
 &quot;target -i&quot; </DT><DD>print target hierarchy from implied grab down</DD>
<DT>
 &quot;target ^l4e10h:20h&quot; </DT><DD>
print target hierarchy from ^l4e10h:20h down</DD>
<DT>
 &quot;target [content]&quot; </DT><DD>
print target hierarchy from content under mouse.</DD>


</DL>
<P>
Prints the target hierarchy below an object.</P>

<UL>
<LI>
If no argument is specified, the system object is used. </LI>
<LI>
The special object flags may be used to specify &lt;object&gt;.  For a list of these flags, see pobject.</LI>
<LI>
Remember that the object you start from may have the target within its part of the hierarchy, but still not have the target because something in a different part of the tree has it. </LI>
<LI>
The variable &quot;printNamesInObjTrees&quot; can be used to print out the actual app-defined labels for the objects, instead of the class, where available. </LI>
<P>
	This variable defaults to false. </P>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_e.htm#IX_focus Swat command">focus</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_model Swat command">model</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_mouse Swat command">mouse</A>,
<A HREF="../../Tools/SwatRef/SR_17.htm#IX_keyboard Swat command">keyboard</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2c.htm_IX_targetobj Swat command">
 </A>
targetobj</H1>

<PRE CLASS="syntax">targetobj</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;targetobj&quot; </DT><DD>return object with target</DD>
<DT>
&quot;pobj [targetobj]&quot; </DT><DD>
do a pobject on the target object (equivalent to &quot;pobj -t&quot;).</DD>


</DL>
<P>
Returns the object with the target.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2c.htm#IX_target Swat command">target</A>,
<A HREF="../../Tools/SwatRef/SR_e.htm#IX_focus Swat command">focus</A>,
<A HREF="../../Tools/SwatRef/SR_e.htm#IX_focusobj Swat command">focusobj</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_modelobj Swat command">modelobj</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2c.htm_IX_Optimization:tally breakpoints">
 </A>
<A NAME="SR_2c.htm_IX_Breakpoints:tally breakpoints">
 </A>
<A NAME="SR_2c.htm_IX_tbrk Swat command">
 </A>
tbrk</H1>

<PRE CLASS="syntax">tbrk &lt;addr&gt; &lt;condition&gt;*
tbrk del &lt;tbrk&gt;+
tbrk list
tbrk cond &lt;tbrk&gt; &lt;condition&gt;*
tbrk count &lt;tbrk&gt;
tbrk reset &lt;tbrk&gt;
tbrk address &lt;tbrk&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
 &quot;tbrk ObjCallMethodTable&quot; </DT><DD>
Count the number of times ObjCallMethodTable() is called.</DD>
<DT>
&quot;tbrk count 2&quot; </DT><DD>
Find the number of times tally breakpoint number 2 was hit.</DD>
<DT>
 &quot;tbrk reset 2&quot; </DT><DD>
Reset the counter for tbrk number 2 to 0.</DD>
<DT>
&quot;tbrk list&quot; </DT><DD>Print a list of the set tally breakpoints and their current counts.</DD>


</DL>
<P>
This command manipulates breakpoints that tally the number of times they are hit without stopping execution of the machine--the breakpoint is noted and the machine is immediately continued. Such a breakpoint allows for real-time performance analysis, which is nice.</P>

<UL>
<LI>
If you specify one or more &lt;condition&gt; arguments when setting the tally breakpoint, only those stops that meet the conditions will be counted. </LI>
<LI>
The <EM>
condition</EM>
 argument is exactly as defined by the &quot;brk&quot; command, q.v..</LI>
<LI>
When you've set a tally breakpoint, you will be returned a token of the form &quot;tbrk&lt;n&gt;&quot;, where &lt;n&gt; is some number. You use this token, or just the &lt;n&gt;, if you're not a program, wherever &lt;tbrk&gt; appears in the Usage description, above. </LI>
<LI>
There are a limited number of tally breakpoints supported by the stub. You'll know when you've set too many.</LI>
<LI>
&quot;tbrk address&quot; returns the address at which the tbrk was set, as a symbolic address expression.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_f.htm#IX_brk Tcl structure:command reference">brk</A>,
<A HREF="../../Tools/Tcl/TTCL_f.htm#IX_cbrk Tcl structure:command reference">cbrk</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2c.htm_IX_tcl-debug Swat command">
 </A>
tcl-debug</H1>

<PRE CLASS="syntax">tcl-debug top 
tcl-debug next &lt;tcl-frame&gt;
tcl-debug prev &lt;tcl-frame&gt;
tcl-debug args &lt;tcl-frame&gt;
tcl-debug getf &lt;tcl-frame&gt;
tcl-debug setf &lt;tcl-frame&gt; &lt;flags&gt;
tcl-debug eval &lt;tcl-frame&gt; &lt;expr&gt;
tcl-debug complete &lt;tcl-frame&gt;
tcl-debug next-call </PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var f [tcl-debug top]&quot;</DT><DD>
Sets $f to be the frame at which the debugger was entered.</DD>
<DT>
&quot;var f [tcl-debug next $f]&quot; </DT><DD>
Retrieves the next frame down (away from the top) the Tcl call stack from $f.</DD>


</DL>
<P>
This provides access to the internals of the Tcl interpreter for the Tcl debugger (which is written in Tcl, not C). It will not function except after the debugger has been entered.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_9.htm#IX_debug Swat command">debug</A>.


<HR>
<A NAME="SR_2d.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_2d.htm_IX_text-fixup Swat command">
 </A>
text-fixup</H1>

<OL>
<LI>
Run geos under swat, run swat on the development system </LI>
<LI>
Run GeoWrite </LI>
<LI>
Open the GeoWrite file that needs fixing </LI>
<LI>
Set the breakpoint in swat:</LI>
<PRE> patch text::CalculateRegions
 =&gt; text-fixup</PRE>
<P>
	 This will set a breakpoint at the right spot </P>
<LI>
Turn on the error-checking code in swat:</LI>
<PRE> ec +text </PRE>
<LI>
Enter a &lt;space&gt; into the document. This forces recalculation which will cause <CODE>
CalculateRegions()</CODE>
 to be called which will cause text-fixup to be called. </LI>
<P>
If it worked, this code should patch together the file. If it's not, you'll get a FatalError right now.</P>
<LI>
Turn off the ec code and disable the fixup breakpoint.</LI>
<PRE> ec none</PRE>
<PRE> dis &lt;breakpoint number&gt;</PRE>
<PRE> continue </PRE>
<LI>
Delete the space and save the file. </LI>
</OL>
<P>
To do another file, you can just enable the breakpoint once the new file is open and turn on the ec code.</P>


<P>
Helps fix up trashed GeoWrite documents.</P>



<H1 CLASS="refHeading">
<A NAME="SR_2d.htm_IX_Threads:thawing">
 </A>
<A NAME="SR_2d.htm_IX_thaw Swat command">
 </A>
thaw</H1>

<PRE CLASS="syntax">thaw [&lt;patient&gt;]
thaw :&lt;n&gt;
thaw &lt;patient&gt;:&lt;n&gt;
thaw &lt;id&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;thaw&quot;</DT><DD>Thaw the current thread.</DD>
<DT>
&quot;thaw term&quot; </DT><DD>Allows the application thread for &quot;term&quot; to run normally</DD>
<DT>
 &quot;thaw :1&quot; </DT><DD>Allows thread #1 of the current patient to run normally </DD>
<DT>
&quot;thaw 16c0h&quot; </DT><DD>Allows the thread whose handle is 16c0h to run normally.</DD>


</DL>
<P>
Thawing a thread restores its priority to what it was before the thread was frozen.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_f.htm#IX_freeze Swat command">freeze</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2d.htm_IX_Threads:displaying name in Swat">
 </A>
<A NAME="SR_2d.htm_IX_threadname Swat command">
 </A>
threadname</H1>

<PRE CLASS="syntax">threadname &lt;id&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;threadname 21c0h&quot;	</DT><DD>
Returns the name of the thread whose handle id is 21c0h.</DD>


</DL>
<P>
Given a thread handle, produces the name of the thread, in the form &lt;patient&gt;:&lt;n&gt;</P>


<P>
If the handle is not one of those swat knows to be for a thread, this returns the string &quot;unknown.&quot;</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_f.htm#IX_thread Tcl structure">thread</A>,
<A HREF="../../Tools/Tcl/TTCL_f.htm#IX_patient Tcl structure">patient</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2d.htm_IX_Threads:displaying with Swat">
 </A>
<A NAME="SR_2d.htm_IX_threadstat Swat command">
 </A>
threadstat</H1>

<PRE CLASS="syntax">threadstat</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;threadstat&quot; </DT>


</DL>
<P>
Provides information about all threads and various thread queues and synchronization points in the system.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_22.htm#IX_ps Swat command">ps</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2d.htm_IX_Timing with Swat">
 </A>
<A NAME="SR_2d.htm_IX_Breakpoints:timing breakpoints">
 </A>
<A NAME="SR_2d.htm_IX_timebrk Swat command">
 </A>
timebrk</H1>

<PRE CLASS="syntax">timebrk &lt;start-addr&gt; &lt;end-addr&gt;+
 timebrk del &lt;timebrk&gt;+
 timebrk list
 timebrk time &lt;timebrk&gt;
 timebrk reset &lt;timebrk&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;timebrk LoadResourceData -f&quot; </DT><DD>
Calculate the time required to process a call to <CODE>
LoadResourceData()</CODE>
.</DD>
<DT>
 &quot;timebrk time 2&quot; </DT><DD>
Find the amount of time accumulated for timing breakpoint number 2.</DD>
<DT>
 &quot;timebrk reset 2&quot; </DT><DD>
Reset the counter for timebrk number two to zero.</DD>
<DT>
 &quot;timebrk list&quot; </DT><DD>
Print a list of the set timing breakpoints and their current counts and time. </DD>


</DL>
<P>
This command manipulates breakpoints that calculate the amount of time executing between their starting point and a specified ending point. The breakpoints also record the number of times their start is hit, so you can figure the average amount of time per hit.</P>

<UL>
<LI>
You can specify a place at which timing should end either as an address or as &quot;-f&quot;. If you use &quot;-f&quot;, timing will continue until the finish of the routine at whose start you've placed the breakpoint. Such a breakpoint may only be set at the start of a routine, as the stub hasn't the wherewithal to determine what the return address is at an arbitrary point within the function. </LI>
<LI>
You may specify more than one ending point. Timing will stop when execution reaches any of those points. </LI>
<LI>
When you've set a timing breakpoint, you will be returned a token of the form &quot;timebrk&lt;n&gt;&quot;, where &lt;n&gt; is some number. You use this token, or just the &lt;n&gt;, if you're not a program, wherever &lt;timebrk&gt; appears in the Usage description, above. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_f.htm#IX_brk Tcl structure:command reference">brk</A>,
<A HREF="../../Tools/Tcl/TTCL_f.htm#IX_cbrk Tcl structure:command reference">cbrk</A>,
<A HREF="../../Tools/SwatRef/SR_2c.htm#IX_tbrk Swat command">tbrk</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2d.htm_IX_timingProcessor Swat variable">
 </A>
timingProcessor</H1>

<PRE CLASS="syntax">var timingProcessor [i86|i88|i286|V20]</PRE>


<P>
The processor for which to generate cycle counts.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_7.htm#IX_cycles Swat command">cycles</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2d.htm_IX_Memory:monitoring with Swat">
 </A>
<A NAME="SR_2d.htm_IX_tmem Swat command">
 </A>
tmem</H1>

<PRE CLASS="syntax">tmem</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;tmem&quot;</DT><DD>turn on memory tracing.</DD>


</DL>
<P>
Trace memory usage.</P>


<P>
The tmem command catches calls to DebugMemory, printing out the parameters passed (move, free, realloc, discard, swapout, swapin, modify).</P>



<H1 CLASS="refHeading">
<A NAME="SR_2d.htm_IX_top-level Swat command">
 </A>
top-level</H1>

<PRE CLASS="syntax">top-level</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;top-level&quot;</DT><DD>Begin reading and interpreting Tcl commands in a nested interpreter.</DD>


</DL>
<P>
This is the top-most read-eval-print loop of the Swat Tcl interpreter.</P>


<P>
This command will only return if the user issues the &quot;break&quot; command. Otherwise it loops infinitely, reading and executing and printing the results of Tcl commands. </P>

<H1 CLASS="refHeading">
<A NAME="SR_2d.htm_IX_Text:monitoring undo activity with Swat">
 </A>
<A NAME="SR_2d.htm_IX_tundocalls Swat command">
 </A>
tundocalls</H1>

<PRE CLASS="syntax">tundocalls [-acPCrR]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;tundocalls -a&quot; Print out all text undo calls</DT>
<DT>
&quot;tundocalls -r&quot; Print run undo calls</DT>
<DT>
&quot;tundocalls -R&quot; Print replace undo calls</DT>
<DT>
&quot;tundocalls -c&quot; Print info when undo information is created</DT>
<DT>
&quot;tundocalls -cP&quot; Print info about para attributes only</DT>
<DT>
&quot;tundocalls -cC&quot; Print info about char attributes only</DT>
<DT>
&quot;tundocalls&quot;</DT>


</DL>
<P>
Prints out information about each undo call made to the text object.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_23.htm#IX_ptext Swat command">ptext</A>,
<A HREF="../../Tools/SwatRef/SR_28.htm#IX_showcalls Swat command">showcalls</A>.


<HR>
<A NAME="SR_2e.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_2e.htm_IX_Timers:displaying with Swat">
 </A>
<A NAME="SR_2e.htm_IX_twalk Swat command">
 </A>
twalk</H1>

<PRE CLASS="syntax">twalk</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;twalk&quot;</DT><DD>print all the timers in the system.</DD>
<DT>
&quot;twalk -o ui&quot; </DT><DD>print all the timers in the system for the ui thread.</DD>
<DT>
 &quot;twalk -a&quot; </DT><DD>print all the timers with the &quot;real&quot; data for the time for time remaining rather than maintaining a total.</DD>


</DL>
<P>
List all the timers in GEOS.</P>



<H1 CLASS="refHeading">
<A NAME="SR_2e.htm_IX_unalias Swat command">
 </A>
unalias</H1>

<PRE CLASS="syntax">unalias &lt;name&gt;+</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;unalias p&quot;</DT><DD>Removes &quot;p&quot; as an alias for print.</DD>


</DL>
<P>
This removes an alias.</P>

<UL>
<LI>
In fact, this actually can be used to delete any command at all, including Tcl procedures and Swat built-in commands. Once they're gone, however, there's no way to get them back.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_3.htm#IX_alias Swat command:command reference">alias</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2e.htm_IX_unassemble Swat command">
 </A>
unassemble</H1>

<PRE CLASS="syntax">unassemble [&lt;addr&gt; [&lt;decode-args&gt;]]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;unassemble cs:ip 1&quot; </DT><DD>
Disassemble the instruction at CS:IP and return a string that shows the values of the arguments involved.</DD>


</DL>
<P>
This decodes data as machine instructions and returns them to you to display as you like. It is not usually typed from the command line.</P>

<UL>
<LI>
The return value is always a four-element list:</LI>
<PRE> {&lt;symbolic-addr&gt; &lt;instruction&gt; &lt;size&gt; &lt;args&gt;}</PRE>
<P>
	 where &lt;symbolic-addr&gt; is the address expressed as an offset from some named symbol, &lt;instruction&gt; is the decoded instruction (without any leading whitespace), &lt;size&gt; is the size of the instruction (in bytes) and &lt;args&gt; is a string displaying the values of the instruction operands, if &lt;decode-args&gt; was given and non-zero (it is the empty string if &lt;decode-args&gt; is missing or 0). </P>
<LI>
If &lt;addr&gt; is missing or &quot;nil&quot;, the instruction at the current frame's CS:IP is returned.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_17.htm#IX_listi Swat command:command reference">listi</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2e.htm_IX_Key bindings in Swat:removing">
 </A>
<A NAME="SR_2e.htm_IX_unbind-key Swat command">
 </A>
unbind-key</H1>

<PRE CLASS="syntax">unbind-key &lt;ascii_value&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;unbind-key \321&quot;</DT><DD>
Unbinds scroll-down key on host machine.</DD>


</DL>
<P>
Unbinds the passed ASCII value.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_3.htm#IX_alias Swat command:command reference">alias</A>,
<A HREF="../../Tools/SwatRef/SR_4.htm#IX_bind-key Swat command">bind-key</A>,
<A HREF="../../Tools/SwatRef/SR_11.htm#IX_get-key-binding Swat command">get-key-binding</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2e.htm_IX_undebug Swat command">
 </A>
undebug</H1>

<PRE CLASS="syntax">undebug &lt;proc-name&gt;+</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;undebug fooproc&quot;</DT><DD>
Cease halting execution each time &quot;fooproc&quot; is executing.</DD>


</DL>
<P>
Removes a Tcl breakpoint set by a previous &quot;debug&quot; command.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_9.htm#IX_debug Swat command">debug</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2e.htm_IX_Stack:changing frames">
 </A>
<A NAME="SR_2e.htm_IX_up Swat command">
 </A>
up</H1>

<PRE CLASS="syntax">up [&lt;frame offset&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;up&quot;</DT><DD>move the frame one frame up the stack</DD>
<DT>
&quot;up 4&quot;</DT><DD>move the frame four frames up the stack</DD>


</DL>
<P>
Move the frame up the stack.</P>

<UL>
<LI>
The &lt;frame offset&gt; argument is the number of frame to move up the stack. If none is specified then the current frame is moved up one frame.</LI>
<LI>
This command may be repeated by pressing &lt;Return&gt;.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_4.htm#IX_backtrace Swat command:command reference">backtrace</A>,
<A HREF="../../Tools/SwatRef/SR_a.htm#IX_down Swat command">down</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2e.htm_IX_value Swat command">
 </A>
value</H1>

<PRE CLASS="syntax">value fetch &lt;addr&gt; [&lt;type&gt;]
value store &lt;addr&gt; &lt;value&gt; [&lt;type&gt;]
value hfetch &lt;num&gt;
value hstore &lt;addr-list&gt;
value hset &lt;number-saved&gt;
value log &lt;addr&gt; &lt;stream&gt; [&lt;type&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;value fetch ds:si [type word]&quot; </DT><DD>
Fetch a word from ds:si</DD>
<DT>
&quot;value store ds:si 0 [type word]&quot; </DT><DD>
Store 0 to the word at ds:si</DD>
<DT>
&quot;value hfetch 36&quot; </DT><DD>
Fetch the 36th address list stored in the value history.</DD>
<DT>
&quot;value hstore $a&quot; </DT><DD>
Store the address list in $a into the value history.</DD>
<DT>
&quot;value hset 50&quot;</DT><DD>
Keep track of up to 50 address lists in the value history. </DD>
<DT>
&quot;value log ds:si $s [type word]&quot;</DT><DD>
Fetch a word from ds:si and dump the binary data to stream $s. </DD>


</DL>
<P>
This command allows you to fetch and alter values in the target PC. It is also the maintainer of the value history, which you normally access via @&lt;number&gt; terms in address expressions.</P>

<UL>
<LI>
&quot;value fetch&quot; returns a value list that contains the data at the given address. If the address has an implied data type (it involves a named variable or a structure field), then you do not need to give the &lt;type&gt; argument. </LI>
<P>
	All integers and enumerated types are returned in decimal. 32-bit pointers are returned as a single decimal integer whose high 16 bits are the high 16 bits (segment or handle) of the pointer. 16-bit pointers are likewise returned as a single decimal integer. </P>
<P>
	Characters are returned as characters, with non-printable characters converted to the appropriate backslash escapes (for example, newline is returned as \n). </P>
<P>
	Arrays are returned as a list of value lists, one element per element of the array. </P>
<P>
	Structures, unions and records are returned as a list of elements, each of which is a 3-element list: {&lt;field-name&gt; &lt;type&gt; &lt;value&gt;} &lt;field-name&gt; is the name of the field, &lt;type&gt; is the type token for the type of data stored in the field, and &lt;value&gt; is the value list for the data in the field, appropriate to its data type. </P>
<LI>
You will note that the description of value lists is recursive. For example, if a structure has a field that is an array, the &lt;value&gt; element in the list that describes that particular field will be itself a list whose elements are the elements of the array. If that array were an array of structures, each element of that list would again be a list of {&lt;field-name&gt; &lt;type&gt; &lt;value&gt;} lists. </LI>
<LI>
The &quot;field&quot; command is very useful when you want to extract the value for a structure field from a value list.</LI>
<LI>
As for &quot;value fetch&quot;, you do not need to give the &lt;type&gt; argument to</LI>
<LI>
 &quot;value store&quot; if the &lt;addr&gt; has an implied data type. The &lt;value&gt; argument is a value list appropriate to the type of data being stored, as described above. </LI>
<LI>
&quot;value hstore&quot; returns the number assigned to the stored address list. These numbers always increase, starting from 1. </LI>
<LI>
If no address list is stored for a given number, &quot;value hfetch&quot; will generate an error. </LI>
<LI>
&quot;value hset&quot; controls the maximum number of address lists the value history will hold. The value history is a FIFO queue; if it holds 50 entries, and the 51st entry is added to it, the 1st entry will be thrown out.</LI>

<LI>
&quot;value log&quot; has the same functionality as value fetch except that data fetched from the PC are dumped into the stream as raw binary data.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2.htm#IX_addr-parse Swat command">addr-parse</A>,
<A HREF="../../Tools/SwatRef/SR_4.htm#IX_assign Swat command:command reference">assign</A>,
<A HREF="../../Tools/SwatRef/SR_d.htm#IX_field Swat command">field</A>.


<HR>
<A NAME="SR_2f.htm"></A>



<H1 CLASS="refHeading">
<A NAME="SR_2f.htm_IX_Display windows in Swat:displaying variable">
 </A>
<A NAME="SR_2f.htm_IX_varwin Swat command">
 </A>
varwin</H1>

<PRE CLASS="syntax">varwin &lt;num-lines&gt; &lt;var-name&gt; </PRE>



<H1 CLASS="refHeading">
<A NAME="SR_2f.htm_IX_Source code:viewing with Swat">
 </A>
<A NAME="SR_2f.htm_IX_view Swat command">
 </A>
view</H1>

<PRE CLASS="syntax">view [&lt;args&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;view foo.goc&quot;</DT><DD>
Bring up <STRONG CLASS="fileName">
foo.goc</STRONG>
 in the source window.</DD>


</DL>
<P>
View a file in Swat.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2f.htm#IX_view-default Swat command">view-default</A>,
<A HREF="../../Tools/SwatRef/SR_29.htm#IX_srcwin Swat command">srcwin</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2f.htm_IX_view-default Swat command">
 </A>
view-default</H1>

<PRE CLASS="syntax">view-default [patient]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;view-default spool&quot;</DT><DD>
 sets the default view to the spool patient.</DD>
<DT>
&quot;view-default&quot;</DT><DD>
 turns off the view default.</DD>


</DL>
<P>
If the view-default is set the view command will automatically look for source files from that patient. If it's not set then the view command will look for files from the current patient.</P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2f.htm#IX_view Swat command">view</A>,
<A HREF="../../Tools/SwatRef/SR_29.htm#IX_srcwin Swat command">srcwin</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2f.htm_IX_vistree Swat command">
 </A>
<A NAME="SR_2f.htm_IX_Trees:displaying visual, with Swat">
 </A>
<A NAME="SR_2f.htm_IX_Visual objects:displaying tree with Swat">
 </A>
vistree</H1>

<PRE CLASS="syntax">vistree [&lt;address&gt;] [&lt;instance field&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;vistree&quot;</DT><DD>print the visual tree starting at *DS:SI</DD>
<DT>
&quot;vistree -i&quot;</DT><DD>print the visual tree under the mouse</DD>
<DT>
&quot;vistree @23 VI_optFlags&quot;</DT><DD>
print the visual tree with opt flags</DD>
<DT>
&quot;vistree *uiSystemObj&quot;</DT><DD>
starts the visual tree at the root of the system.</DD>


</DL>
<P>
Print out a visual tree.</P>

<UL>
<LI>
The &lt;address&gt; argument is the address to an object in the generic tree. This defaults to *DS:SI. The `-i' flag for an implied grab may be used.</LI>
<LI>
The special object flags may be used to specify &lt;object&gt;.  For a list of these flags, see pobject.</LI>
<LI>
The &lt;instance field&gt; argument is the offset to any instance data within the VisInstance which should be printed out.</LI>
<LI>
The variable &quot;printNamesInObjTrees&quot; can be used to print out the actual app-defined labels for the objects, instead of the class, where available. This variable defaults to false.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2f.htm#IX_vup Swat command:command reference">vup</A>,
<A HREF="../../Tools/SwatRef/SR_10.htm#IX_gentree Swat command:command reference">gentree</A>,
<A HREF="../../Tools/SwatRef/SR_15.htm#IX_impliedgrab Swat command">impliedgrab</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2f.htm_IX_Visual objects:displaying ancestors with Swat">
 </A>
<A NAME="SR_2f.htm_IX_vup Swat command:command reference">
 </A>
<A NAME="SR_2f.htm_IX_Trees:displaying visual ancestors with Swat">
 </A>
vup</H1>

<PRE CLASS="syntax">vup [&lt;address&gt;] [&lt;instance field&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;vup&quot;</DT><DD>print the visual object at *DS:SI and its ancestors</DD>
<DT>
&quot;vup @23 VI_optFlags&quot;</DT><DD>
print the states of object @23 and its ancestors</DD>
<DT>
 &quot;vup -i&quot;</DT><DD> print the visual object under the mouse and the object's ancestors</DD>


</DL>
<P>
Print a list of the object and all of its visual ancestors.</P>

<UL>
<LI>
The &lt;address&gt; argument is the address to an object in the visual tree. This defaults to *DS:SI. The `-i' flag for an implied grab may be used.</LI>
<LI>
The special object flags may be used to specify &lt;object&gt;.  For a list of these flags, see pobject.</LI>
<LI>
The &lt;instance field&gt; argument is the offset to any instance data within the GenInstance which should be printed out.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2f.htm#IX_vistree Swat command">vistree</A>,
<A HREF="../../Tools/SwatRef/SR_11.htm#IX_gup Swat command:command reference">gup</A>,
<A HREF="../../Tools/SwatRef/SR_10.htm#IX_gentree Swat command:command reference">gentree</A>,
<A HREF="../../Tools/SwatRef/SR_15.htm#IX_impliedgrab Swat command">impliedgrab</A>,
<A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2f.htm_IX_wait Swat command">
 </A>
wait</H1>

<PRE CLASS="syntax">wait</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;wait&quot;</DT><DD>Wait for the target PC to halt.</DD>


</DL>
<P>
This is used after the machine has been continued with &quot;continue-patient&quot; to wait for the machine to stop again. Its use is usually hidden by calling &quot;cont&quot; or &quot;next&quot;.</P>

<UL>
<LI>
This returns 0 if the patient halted naturally (because it hit a breakpoint), and 1 if it was interrupted (by the user typing Ctrl+C to Swat). </LI>
<LI>
Most procedures won't need to use this function.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_f.htm#IX_brk Tcl structure:command reference">brk</A>,
<A HREF="../../Tools/SwatRef/SR_14.htm#IX_ibrk Swat command">ibrk</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2f.htm_IX_waitForPatient Swat command">
 </A>
waitForPatient</H1>

<PRE CLASS="syntax">var waitForPatient [(1|0)]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;var waitForPatient 0&quot;</DT><DD>
Tells Swat to return to the command prompt after continuing the machine.</DD>


</DL>
<P>
Determines whether the command-level patient-continuation commands (step, next, and cont, for example) will wait for the machine to stop before returning.</P>

<UL>
<LI>
The effect of this is to return to the command prompt immediately after having issued the command. This allows you to periodically examine the state of the machine without actually halting it. </LI>
<LI>
The output when the machine does stop (e.g. when it hits a breakpoint) can be somewhat confusing. Furthermore, this isn't fully tested, so it should probably be set to 0 only in somewhat odd circumstances.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2a.htm#IX_step Swat command">step</A>,
<A HREF="../../Tools/SwatRef/SR_19.htm#IX_next Swat command">next</A>,
<A HREF="../../Tools/SwatRef/SR_6.htm#IX_cont Swat command:command reference">cont</A>,
<A HREF="../../Tools/SwatRef/SR_15.htm#IX_int Swat command">int</A>.



<H1 CLASS="refHeading">
<A NAME="SR_2f.htm_IX_Threads:waking up with Swat">
 </A>
<A NAME="SR_2f.htm_IX_wakeup Swat command">
 </A>
<A NAME="SR_2f.htm_IX_Patients:waking up with Swat">
 </A>
wakeup</H1>
<P>
Wait for a given patient/thread to wake up. WHO is of the same form as the argument to the &quot;switch&quot; command, (&quot;help switch&quot; to find out more). Leaves you stopped in the kernel in the desired thread's context unless something else causes the machine to stop before the patient/thread wakes up. WHO defaults to the current thread.</P>


<H1 CLASS="refHeading">
<A NAME="SR_2f.htm_IX_Patients:waking up with Swat">
 </A>
<A NAME="SR_2f.htm_IX_Threads:waking up with Swat">
 </A>
<A NAME="SR_2f.htm_IX_wakeup-thread Swat command">
 </A>
wakeup-thread</H1>
<P>
Subroutine to actually wake up a thread. Argument WHO is as for the &quot;switch&quot;command. Returns non-zero if the wakeup was successful and zero if the machine stopped for some other reason.</P>

<HR>
<A NAME="SR_30.htm"></A>




<H1 CLASS="refHeading">
<A NAME="SR_30.htm_IX_Display windows in Swat:clearing">
 </A>
<A NAME="SR_30.htm_IX_wclear Swat command">
 </A>
wclear</H1>

<PRE CLASS="syntax">wclear</PRE>


<P>
Clears the current window.</P>



<H1 CLASS="refHeading">
<A NAME="SR_30.htm_IX_Display windows in Swat:creating">
 </A>
<A NAME="SR_30.htm_IX_wcreate Swat command">
 </A>
wcreate</H1>

<PRE CLASS="syntax">wcreate &lt;height&gt;</PRE>


<P>
Create a window of the given height and return a token for it. The window is placed just above the command window, if there's room. If there aren't that many lines free on the screen, an error is returned.</P>



<H1 CLASS="refHeading">
<A NAME="SR_30.htm_IX_Display windows in Swat:destroying">
 </A>
<A NAME="SR_30.htm_IX_wdelete Swat command">
 </A>
wdelete</H1>

<PRE CLASS="syntax">wdelete &lt;window&gt;</PRE>


<P>
Delete the given window. All windows below it move up and the command window enlarges.</P>



<H1 CLASS="refHeading">
<A NAME="SR_30.htm_IX_whatat Swat command">
 </A>
whatat</H1>

<PRE CLASS="syntax">whatat [&lt;address&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;whatat&quot;</DT><DD>name of variable at *DS:SI</DD>
<DT>
&quot;whatat ^l2ef0h:002ah&quot;</DT><DD>
name of variable at the specified address</DD>


</DL>
<P>
Print the name of the variable at the address.</P>

<UL>
<LI>
The &lt;address&gt; argument specifies where to find a variable name for. The address defaults to *DS:SI.</LI>
<LI>
If no appropriate variable is found for the address, `*nil*' is returned.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_1f.htm#IX_pobject Swat command:command reference">pobject</A>,
<A HREF="../../Tools/SwatRef/SR_14.htm#IX_hwalk Swat command:command reference">hwalk</A>,
<A HREF="../../Tools/SwatRef/SR_17.htm#IX_lhwalk Swat command:command reference">lhwalk</A>.



<H1 CLASS="refHeading">
<A NAME="SR_30.htm_IX_Structures:examining with Swat">
 </A>
<A NAME="SR_30.htm_IX_whatis Swat command">
 </A>
whatis</H1>

<PRE CLASS="syntax">whatis (&lt;symbol&gt;|&lt;addr&gt;)</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	&quot;whatis WinColorFlags&quot;</P>


<P>
This produces a human-readable description of a symbol, giving whatever information is pertinent to its type.</P>

<UL>
<LI>
For type symbols (e.g. structures and enumerated types), the description of the type is fully displayed, so if a structure has a field with an enumerated type, all the members of the enumerated type will be printed as well. Also all fields of nested structures will be printed. If this level of detail isn't what you need, use the &quot;pscope&quot; command instead.</LI>
<LI>
It's not clear why you'd need the ability to find the type of an address-expression, since those types always come from some symbol or other, but if you want to type more, you certainly may.</LI>
</UL>



<H1 CLASS="refHeading">
<A NAME="SR_30.htm_IX_why Swat command:command reference">
 </A>
why</H1>

<PRE CLASS="syntax">why</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	&quot;why&quot;</P>


<P>
Print a description of why the system crashed.</P>

<UL>
<LI>
This must be run from within the frame of the FatalError function. Sometimes GEOS is not quite there. In this case, step an instruction <A NAME="SR_30.htm_IX_Errors:determining cause of crash">
 </A>
<A NAME="SR_30.htm_IX_Errors:decoding FatalErrors values">
 </A>
or two and then try the &quot;why&quot; command again.</LI>
<LI>
This simply looks up the enumerated constant for the error code in AX in the &quot;FatalErrors&quot; enumerated type defined by the geode that called FatalError. For example, if a function in the kernel called FatalError, AX would be looked up in geos::FatalErrors, while if a function in your application called FatalError, this function would look it up in the FatalErrors type defined by your application. Each application defines this enumerated type by virtue of having included <STRONG CLASS="fileName">
ec.def </STRONG>
or<STRONG CLASS="fileName">
 ec.goh</STRONG>
.</LI>
<LI>
For certain fatal errors, additional information is provided by invoking the command &lt;patient&gt;::&lt;error code name&gt;, if it exists.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_25.htm#IX_regs Swat command">regs</A>,
<A HREF="../../Tools/SwatRef/SR_4.htm#IX_backtrace Swat command:command reference">backtrace</A>,
<A HREF="../../Tools/SwatRef/SR_c.htm#IX_explain Swat command">explain</A>.



<H1 CLASS="refHeading">
<A NAME="SR_30.htm_IX_Windows:displaying,tree with Swat">
 </A>
<A NAME="SR_30.htm_IX_Trees:Displaying window, with Swat">
 </A>
<A NAME="SR_30.htm_IX_wintree Swat command">
 </A>
wintree</H1>

<PRE CLASS="syntax">wintree &lt;window handle&gt; [&lt;data field&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;wintree ^hd060h&quot;</DT><DD>
print a window tree starting at the handle d060h</DD>


</DL>
<P>
Print a window tree starting with the root specified.</P>

<UL>
<LI>
The &lt;window address&gt; argument is the address to a window.</LI>
<LI>
The &lt;data field&gt; argument is the offset to any instance data within a window (like W_ptrFlags).</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_2f.htm#IX_vistree Swat command">vistree</A>,
<A HREF="../../Tools/SwatRef/SR_10.htm#IX_gentree Swat command:command reference">gentree</A>.



<H1 CLASS="refHeading">
<A NAME="SR_30.htm_IX_Formatting Swat output:inverse type">
 </A>
<A NAME="SR_30.htm_IX_winverse Swat command">
 </A>
winverse</H1>

<PRE CLASS="syntax">winverse</PRE>


<P>
Sets the inverse-mode of the current window (whether newly-echoed characters are displayed in inverse video) on or off, depending on its argument (1 is on).</P>



<H1 CLASS="refHeading">
<A NAME="SR_30.htm_IX_Formatting Swat output:moving cursor">
 </A>
<A NAME="SR_30.htm_IX_wmove Swat command">
 </A>
wmove</H1>

<PRE CLASS="syntax">wmove [(+|-)] &lt;x-coord&gt; [(+|-)] &lt;y-coord&gt;</PRE>


<P>
Moves the cursor for the current window. Takes two arguments: the new<EM>
 x </EM>
position and the new<EM>
 y</EM>
 position. These positions may be absolute or relative (absolute positions begin with + or -). If you attempt to move outside the current window, an error is generated. This command returns the new cursor position as {<EM>
x y</EM>
}.</P>



<H1 CLASS="refHeading">
<A NAME="SR_30.htm_IX_words Swat command:command reference">
 </A>
<A NAME="SR_30.htm_IX_Memory:examining with Swat">
 </A>
words</H1>

<PRE CLASS="syntax">words [&lt;address&gt;] [&lt;length&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;words&quot;</DT><DD>lists 8 words at DS:SI</DD>
<DT>
&quot;words ds:di 16&quot;</DT><DD>
lists 16 words starting at DS:DI</DD>


</DL>
<P>
Examine memory as a dump of words.</P>

<UL>
<LI>
The &lt;address&gt; argument is the address to examine. If not specified, the address after the last examined memory location is used. If no address has been examined then DS:SI is used for the address.</LI>
<LI>
The &lt;length&gt; argument is the number of bytes to examine. It defaults to 8.</LI>
<LI>
Pressing &lt;Return&gt; after this command continues the list.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/SwatRef/SR_5.htm#IX_bytes Swat command:command reference">bytes</A>,
<A HREF="../../Tools/SwatRef/SR_b.htm#IX_dwords Swat command:command reference">dwords</A>,
<A HREF="../../Tools/SwatRef/SR_15.htm#IX_imem Swat command:command reference">imem</A>,
<A HREF="../../Tools/SwatRef/SR_4.htm#IX_assign Swat command:command reference">assign</A>.



<H1 CLASS="refHeading">
<A NAME="SR_30.htm_IX_Display windows in Swat:wpop Swat command">
 </A>
<A NAME="SR_30.htm_IX_wpop Swat command">
 </A>
wpop</H1>

<PRE CLASS="syntax">wpop</PRE>


<P>
Revert the current window to its previously pushed value.</P>



<H1 CLASS="refHeading">
<A NAME="SR_30.htm_IX_Display windows in Swat:wpush Swat command">
 </A>
<A NAME="SR_30.htm_IX_wpush Swat command">
 </A>
wpush</H1>

<PRE CLASS="syntax">wpush &lt;window&gt;</PRE>


<P>
Switch to a new window, saving the old current-window. Use <CODE>
wpop</CODE>
 to go back to the previous window. All I/O goes through the current window.</P>



<H1 CLASS="refHeading">
<A NAME="SR_30.htm_IX_Display windows in Swat:redisplaying">
 </A>
<A NAME="SR_30.htm_IX_wrefresh Swat command">
 </A>
wrefresh</H1>

<PRE CLASS="syntax">wrefresh</PRE>


<P>
Synchronizes the current window with the screen. This need only be performed if you don't echo a newline, as echoing a newline refreshes the current window.</P>



<H1 CLASS="refHeading">
<A NAME="SR_30.htm_IX_wtop Swat command">
 </A>
wtop</H1>

<PRE CLASS="syntax">wtop &lt;flag&gt;</PRE>


<P>
Sets where windows go. If argument is non-zero, windows go at the top of the screen and work down. Else windows go at the bottom of the screen and work up</P>

<HR>
This document is a single-page version of a <A HREF="index.htm">a multi-page document</A>, suitable for easy printing.
</BODY>
</HTML>
