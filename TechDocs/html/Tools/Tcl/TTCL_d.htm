<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: TTCL_d.htm,v 1.1 97/06/27 16:02:06 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE> Built-in Commands</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">


<H1 CLASS="subsectionTitle">
<A HREF="index.htm">Tool Command Language</A>: 5.2 <A HREF="TTCL_b.htm">Commands</A>: 
Built-in Commands</H1>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="TTCL_b.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="TTCL_c.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">5.1 Notation</A> 
<!-- to next --> | <A HREF="TTCL_e.htm"><IMG SRC="../../docImages/nextUp.gif" BORDER="0" ALT="Next: ">6 Coding</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
<P>
The built-in Tcl commands are as follows:</P>

<H2 CLASS="refHeading">
<A NAME="IX_bc Tcl command">
 </A>
bc</H2>
<PRE CLASS="syntax">bc list &lt;proc&gt;
bc disasm &lt;proc&gt;
bc compile &lt;proc&gt;
bc fcompile &lt;file&gt; [&lt;nohelp&gt;]
bc fload &lt;file&gt;
bc fdisasm &lt;file&gt;
bc debug [1|0]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;bc compile poof&quot;    </DT><DD>
Compiles the body of the procedure &quot;poof&quot; and replaces the existing procedure with its compiled form.</DD>
<DT>
&quot;bc fcomp bptutils.tcl&quot; </DT><DD>
Creates the file &quot;bptutils.tlc&quot; that contains a stream of compiled Tcl that will do exactly what sourcing bptutils.tcl does, except the resulting procedures will be compiled Tcl, not interpreted Tcl.</DD>
<DT>
&quot;bc fload bptutils.tlc&quot; </DT><DD>
Loads a file containing a stream of compiled Tcl code.</DD>
</DL>
<P>
The &quot;bc&quot; command allows you to create and examine compiled Tcl code. Compiled Tcl is not nearly as readable or changeable as interpreted Tcl code, but it's 30-50% faster.</P>

<P>
The &quot;list&quot; subcommand doesn't work. </P>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_source Tcl command">source</A>.



<H2 CLASS="refHeading">
<A NAME="IX_break Tcl command">
 </A>
break</H2>
<PRE CLASS="syntax">break</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;break&quot;</DT><DD>Break out of the current loop.</DD>
</DL>
<P>
Breaks out of the current loop or the current nested interpreter.</P>

<UL>
<LI>
Only the closest-enclosing loop can be exited via this command. </LI>
<LI>
This command may be invoked only inside the body of a loop command such as <CODE>
for</CODE>
 or <CODE>
foreach</CODE>
. It returns a TCL_BREAK code to signal the innermost containing loop command to return immediately.</LI>
<LI>
If you've entered a nested interpreter, e.g. by calling a function in the patient, use this to exit the interpreter and restore the registers to what they were before you made the call.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_continue Tcl command">continue</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_for Tcl command">for</A>.



<H2 CLASS="refHeading">
<A NAME="IX_case Tcl command">
 </A>
case</H2>
<PRE CLASS="syntax">case &lt;string&gt; [in] [&lt;pat&gt; &lt;body&gt;]+</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;[case $c in</DT>
<DT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{[0-9]} {</DT>
<DT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# do something with digit</DT>
<DT>
&nbsp;&nbsp;&nbsp;}</DT>
<DT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default {</DT>
<DT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# do something with non-digit</DT>
<DT>
&nbsp;&nbsp;&nbsp;}</DT>
<DT>
&nbsp;&nbsp;]&quot; </DT><DD>
Do one of two things depending on whether the character in $c is a digit.</DD>
</DL>
<P>
Perform one of a set of actions based on whether a string matches one or more patterns.</P>

<UL>
<LI>
Compares each of the &lt;<EM>pattern</EM>&gt; arguments to the given &lt;<EM>string</EM>&gt;, executing &lt;<EM>body</EM>&gt; following the first &lt;<EM>pattern</EM>&gt; to match. &lt;<EM>pattern</EM>&gt; uses shell wildcard characters as for the string match command, but may also contain alternatives, which are separated by a vertical bar, thus allowing a &lt;<EM>body</EM>&gt; to be executed under one of several circumstances. In addition, if one &lt;<EM>pattern</EM>&gt; (or element thereof) is the string default, the associated &lt;<EM>body</EM>&gt; will be executed if none of the other patterns matches. For example, the following:</LI>
<PRE>[case $test in
 a|b {return 1}
 {default|[DE]a*} {return 0}
 ?c {return -1}]</PRE>
<P>
	will return 1 if variable <CODE>
test</CODE>
 contains <CODE>
a</CODE>
 or <CODE>
b</CODE>
, -1 if it contains a two-letter string whose second letter is <CODE>
c</CODE>
, and 0 in all other cases, including the ones where <CODE>
test</CODE>
's first two letters are either <CODE>
Da</CODE>
 or <CODE>
Ea</CODE>
.</P>
<LI>
Each &lt;pat&gt; argument is a list of patterns of the form described for the &quot;string match&quot; command. </LI>
<LI>
Each &lt;pat&gt; argument must be accompanied by a &lt;body&gt; to execute. </LI>
<LI>
If a &lt;pat&gt; contains the special pattern &quot;default,&quot; the associated &lt;body&gt; will be executed if no other pattern matches. The difference between &quot;default&quot; and &quot;*&quot; is a pattern of &quot;*&quot; causes the &lt;body&gt; to be executed regardless of the patterns in the remaining &lt;pat&gt; arguments, while &quot;default&quot; postpones the decision until all the remaining patterns have been checked.</LI>
<LI>
You can give the literal &quot;in&quot; argument if you wish to enhance the readability of your code.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_string Tcl command">string</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_if Tcl command">if</A>.



<H2 CLASS="refHeading">
<A NAME="IX_catch Tcl command">
 </A>
catch</H2>
<PRE CLASS="syntax">catch &lt;command&gt; [&lt;varName&gt;]</PRE>
<P>
Executes a command, retaining control even if the command generates an error (which would otherwise cause execution to unwind completely).</P>
<UL>
<LI>
The <CODE>
catch</CODE>
 command may be used to prevent errors from aborting command interpretation. <CODE>
catch</CODE>
 calls the Tcl interpreter recursively to execute &lt;<EM>command</EM>&gt;, and always returns a TCL_OK code, regardless of any errors that might occur while executing &lt;<EM>command</EM>&gt;. The return value from <CODE>
catch</CODE>
 is a decimal string giving the code returned by the Tcl interpreter after executing &lt;<EM>command</EM>&gt;. This will be zero (TCL_OK) if there were no errors in command; otherwise it will have a non-zero value corresponding to one of the exceptional return codes. If the &lt;<EM>varName</EM>&gt; argument is given, then it gives the name of a variable; <CODE>
catch</CODE>
 will set the value of the variable to the string returned from command (either a result or an error message).</LI>
<LI>
This returns an integer that indicates how &lt;command&gt; completed:</LI>
<DL>
<DT>
            <STRONG>
0</STRONG>
</DT><DD>Completed successfully; $&lt;varName&gt; contains the result of the command.</DD>
<DT>
           <STRONG>
 1</STRONG>
</DT><DD>Generated an error; $&lt;varName&gt; contains the error message.</DD>
<DT>
           <STRONG>
 2</STRONG>
 </DT><DD>Executed &quot;return&quot;; $&lt;varName&gt; contains the argument passed to &quot;return.&quot;</DD>
<DT>
            <STRONG>
3</STRONG>
 </DT><DD>Executed &quot;break&quot;; $&lt;varName&gt; is empty.</DD>
<DT>
            <STRONG>
4</STRONG>
 </DT><DD>Executed &quot;continue&quot;; $&lt;varName&gt; is empty.</DD>
</DL>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_protect Tcl command">protect</A>.



<H2 CLASS="refHeading">
<A NAME="IX_concat Tcl command">
 </A>
<A NAME="IX_Lists in Swat:concat Tcl command">
 </A>
concat</H2>
<PRE CLASS="syntax">
concat &lt;arg1&gt;+</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;concat $list1 $list2&quot; </DT><DD>
Merges the lists in $list1 and $list2 into a single list whose elements are the elements of the two lists.</DD>
</DL>
<P>
Concatenates multiple list arguments into a single list.</P>
<UL>
<LI>
This command treats each argument as a list and concatenates them into a single list. It permits any number of arguments. For example, the command</LI>
<PRE>concat a b {c d e} {f {g h}}</PRE>
<P>
	will return <CODE>
a b c d e f {g h}</CODE>
 as its result.</P>
<LI>
There is a sometimes-subtle difference between this in the &quot;list&quot; command: Given two lists, &quot;concat&quot; will form a list whose n elements are the combined elements of the two component lists, while &quot;list&quot; will form a list whose 2 elements are the two lists. For example,</LI>
<PRE> concat a b {c d e} {f {g h}}</PRE>
<P>
	 yields the list </P>
<PRE>a b c d e f {g h}</PRE>
<P>
	but</P>
<PRE>list a b {c d e} {f {g h}}</PRE>
<P>
	yields</P>
<PRE>a b {c d e} {f {g h}}</PRE>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_list Tcl command">list</A>.

<H2 CLASS="refHeading">
<A NAME="IX_continue Tcl command">
 </A>
continue</H2>
<PRE CLASS="syntax">
continue</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;continue&quot;</DT><DD>Return to the top of the enclosing loop.</DD>
</DL>
<P>
Skips the rest of the commands in the current loop iteration, continuing at the top of the loop.</P>
<UL>
<LI>
Only the closest-enclosing loop can be continued via this command. </LI>
<LI>
The &lt;next&gt; clause of the &quot;for&quot; command is not part of the current iteration, i.e. it will be executed even if you execute this command.</LI>
<LI>
This command may be invoked only inside the body of a loop command such as <CODE>
for</CODE>
 or <CODE>
foreach</CODE>
. It returns a TCL_CONTINUE code to signal the innermost containing loop command to skip the remainder of the loop's body but continue with the next iteration of the loop. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_break Tcl command">break</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_for Tcl command">for</A>.

<H2 CLASS="refHeading">
<A NAME="IX_defsubr Tcl command">
 </A>
defsubr</H2>
<PRE CLASS="syntax">
defsubr &lt;name&gt; &lt;args&gt; &lt;body&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;defsubr poof {arg1 args} {return [list $arg1 $args]}&quot;</DT><DD>
Defines a procedure poof that takes 1 or more arguments and merges them into a list of two elements.</DD>
</DL>
<P>
This is the same as the &quot;proc&quot; command, except the new procedure's name may not be abbreviated when it is invoked.</P>
<UL>
<LI>Refer to the documentation for <CODE>
proc</CODE>
 for more information. </LI>
</UL>

<H2 CLASS="refHeading">
<A NAME="IX_error Tcl command">
 </A>
error</H2>
<PRE CLASS="syntax">
error &lt;message&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;error {invalid argument}&quot; </DT><DD>
Generates an error, giving the not-so-helpful message &quot;invalid argument&quot; to the caller's caller.</DD>
</DL>
<UL>
<LI>
Unless one of the procedures in the call stack has executed a &quot;catch&quot; command, all procedures on the stack will be terminated with &lt;message&gt; (and an indication of an error) being the result of the final one so terminated. </LI>
<LI>
Any commands protected by the &quot;protect&quot; command will be executed.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_return Tcl command">return</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_catch Tcl command">catch</A>.

<H2 CLASS="refHeading">
<A NAME="IX_eval Tcl command">
 </A>
eval</H2>
<PRE CLASS="syntax">
eval &lt;body&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;eval $mangled_command&quot; </DT><DD>
Evaluate the command contained in $mangled_command and return its result.</DD>
</DL>
<P>
Evaluates the passed string as a command and returns the result of that evaluation.</P>
<UL>
<LI>
<CODE>
eval</CODE>
 takes one argument, which is a Tcl command (or collection of Tcl commands separated by newlines in the usual way). <CODE>
eval</CODE>
 evaluates &lt;<EM>body</EM>&gt; by passing it to the Tcl interpreter recursively, and returns the result of the last command. If an error occurs inside &lt;<EM>body</EM>&gt; then <CODE>
eval</CODE>
 returns that error. </LI>
<LI>
This command is useful when one needs to cobble together a command from arguments or what have you. For example, if one of your arguments is a list of arguments to pass to another command, the only way to accomplish that is to say something like &quot;eval [concat random-command $args]&quot;, which will form a list whose first element is the command to be executed, and whose remaining elements are the arguments for the command. &quot;eval&quot; will then execute that list properly.</LI>
<LI>
If the executed command generates an error, &quot;eval&quot; will propagate that error just like any other command.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_concat Tcl command">concat</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_list Tcl command">list</A>.


<H2 CLASS="refHeading">
<A NAME="IX_expr Tcl command">
 </A>
expr</H2>
<PRE CLASS="syntax">
expr &lt;expression&gt; [float]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;expr 36*25&quot; </DT><DD>Multiplies 36 by 25 and returns the result.</DD>
<DT>
 &quot;expr $i/6 float&quot; </DT><DD>
Divides the number in $i by 6 using floating- point arithmetic; the result is a real number.</DD>
<DT>
&quot;expr 7.2*10 float&quot;</DT><DD>
Multiplies 7.2 by 10. Note that though the answer (72) is an integer, we need to pass the &quot;float&quot; keyword to make sure that the expression is interpreted correctly.</DD>
</DL>
<P>
Evaluates an arithmetic expression and returns its value.</P>
<UL>
<LI>
Most C operators are supported with the standard operator precedence. </LI>
<LI>
If you use a Tcl variable in the expression, the variable may only contain a number; it may not contain an expression. </LI>
<LI>
The result of any Tcl command, in square brackets (&quot;[ ]&quot;) must be a number; it may not be an expression. </LI>
<LI>
All the C and Esp radix specifiers are allowed. </LI>
<LI>
Bitwise and boolean operators (!, &amp;, ^, |, &amp;&amp;, ||, &gt;&gt;, &lt;&lt;, ~) are not permitted when the expression is being evaluated using floating-point arithmetic.</LI>
</UL>



<H2 CLASS="refHeading">
<A NAME="IX_file Tcl command">
 </A>
file</H2>
<PRE CLASS="syntax">
file dirname &lt;name&gt;
file exists &lt;name&gt;
file extension &lt;name&gt;
file isdirectory &lt;name&gt;
file isfile &lt;name&gt;
file readable &lt;name&gt;
file rootname &lt;name&gt;
file tail &lt;name&gt;
file writable &lt;name&gt;
file match &lt;pattern&gt;
file newer &lt;name1&gt; &lt;name2&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;file match /pcgeos/tcl/*.tcl&quot; </DT><DD>
Looks for all files/directories in /pcgeos/tcl whose name ends with &quot;.tcl&quot;.</DD>
<DT>
 &quot;file isdir $path&quot; </DT><DD>
See if the path stored in $path refers to a directory.</DD>
<DT>
 &quot;file tail $path&quot; </DT><DD>
Return the final component of the path stored in $path</DD>
</DL>
<P>
Performs various checks and manipulations of file and directory names.</P>
<UL>
<LI>
The forward slash is the path separator for this command.</LI>
<LI>
The predicate subcommands (executable, exists, isdirectory, isfile, owned, readable, and writable) all return 1 if the path meets the requirements, or 0 if it doesn't. </LI>
<LI>
&quot;file match&quot; takes a <EM>
pattern</EM>
 made from the same components as are described for &quot;string match&quot;. It is <EM>
not</EM>
 the same as the standard DOS wildcarding, where `.' serves to separate the root pattern from the extension pattern. For this command &quot;*.*&quot; would match only files that actually have an extension. </LI>
<LI>
&quot;file dirname&quot; returns the directory portion of <EM>
name</EM>
. If <EM>
name</EM>
 has no directory portion, this returns &quot;.&quot; </LI>
<LI>
&quot;file rootname&quot; returns all leading directory components of <EM>
name</EM>
, plus the text before its extension, without the &quot;.&quot; that separates the name from the extension. </LI>
<LI>
&quot;file tail&quot; returns all of the characters in <EM>
name</EM>
 after the final forward slash, or <EM>
name</EM>
 if it contains no forward slashes.</LI>
<LI>
&quot;file newer&quot; returns 1 if <EM>
name1</EM>
 was modified after <EM>
name2</EM>
. It returns 0 otherwise.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_string Tcl command">string</A>.



<H2 CLASS="refHeading">
<A NAME="IX_for Tcl command">
 </A>
for</H2>
<PRE CLASS="syntax">
for &lt;start&gt; &lt;test&gt; &lt;next&gt; &lt;body&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;for {var i 0} {$i &lt; 10} {var i [expr $i+1]} {echo $i}&quot;</DT><DD>
 Prints the numbers from 0 to 9.</DD>
</DL>
<P>
This is Tcl's main looping construct. It functions similarly to the &quot;for&quot; in C.</P>
<UL>
<LI>
&lt;start&gt; is a Tcl command string (which may involve multiple commands over multiple lines, if desired) that is executed once at the very start of the loop. It is always executed. If it returns an error, or contains a &quot;break&quot; command, no part of the loop will execute. </LI>
<LI>
&lt;test&gt; is an arithmetic expression that is passed to the &quot;expr&quot; command. If the result is non-zero, the &lt;body&gt; is executed. </LI>
<LI>
&lt;next&gt; is a Tcl command string (which may involve multiple commands over multiple lines, if desired) that is executed at the end of each iteration before &lt;test&gt; is evaluated again. If it returns an error, or contains a &quot;break&quot; command, no part of the loop will execute. </LI>
<LI>
You can exit the loop prematurely by executing the &quot;break&quot; command in any of the three Tcl command strings (&lt;start&gt;, &lt;next&gt;, or &lt;body&gt;). </LI>
<LI>
So long as there's no error, &quot;for&quot; always returns the empty string as its result.</LI>
<LI>
If a <CODE>
continue</CODE>
 command is invoked within &lt;<EM>body</EM>&gt; then any remaining commands in the current execution of &lt;<EM>body</EM>&gt; are skipped; processing continues by invoking the Tcl interpreter on &lt;<EM>next</EM>&gt;, then evaluating &lt;<EM>test</EM>&gt;, and so on. If a <CODE>
break</CODE>
 command is invoked within &lt;<EM>body</EM>&gt;, then the <CODE>
for</CODE>
 command will return immediately. The operation of <CODE>
break</CODE>
 and <CODE>
continue</CODE>
 are similar to the corresponding statements in C. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_foreach Tcl command">foreach</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_break Tcl command">break</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_continue Tcl command">continue</A>.



<H2 CLASS="refHeading">
<A NAME="IX_foreach Tcl command">
 </A>
foreach</H2>
<PRE CLASS="syntax">
foreach &lt;varname&gt; &lt;list&gt; &lt;body&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;foreach el $list {echo poof = $el}&quot; </DT><DD>
Prints each element of the list $list preceded by the profound words &quot;poof = &quot;</DD>
</DL>
<P>
This is a looping construct to easily iterate over all the elements of a list.</P>
<UL>
<LI>
&lt;body&gt; is evaluated once for each element in &lt;list&gt;. Before each evaluation, the next element is placed in the variable &lt;varName&gt;. </LI>
<LI>
You can exit the loop prematurely by executing the &quot;break&quot; command. </LI>
<LI>
As long as there's no error, &quot;foreach&quot; always returns the empty string.</LI>
<LI>
The <CODE>
break</CODE>
 and <CODE>
continue</CODE>
 statements may be invoked inside &lt;<EM>body</EM>&gt;, with the same effect as in the <CODE>
for</CODE>
 command.</LI>
</UL>

<H2 CLASS="refHeading">
<A NAME="IX_format Tcl command">
 </A>
format</H2>
<PRE CLASS="syntax">format &lt;formatString&gt; [&lt;arg&gt; ]*</PRE>
<P>
<A NAME="IX_format Tcl command">
 </A>
This command generates a formatted string in the same way as the C <CODE>
sprintf</CODE>
 procedure (it uses <CODE>
sprintf</CODE>
 in its implementation). &lt;<EM>formatString</EM>&gt; indicates how to format the result, using<EM> %</EM> fields as in <CODE>
sprintf</CODE>
, and the additional arguments, if any, provide values to be substituted into the result. All of the <CODE>
sprintf</CODE>
 options are valid; see the <CODE>
sprintf</CODE>
 procedure in a C manual for more details. Each &lt;<EM>arg</EM>&gt; must match the expected type from the <EM>%</EM> field in &lt;<EM>formatString</EM>&gt;; the <CODE>
format</CODE>
 command converts each argument to the correct type (floating, integer, etc.) before passing it to <CODE>
sprintf</CODE>
 for formatting. The only unusual conversion is for<EM> %c</EM>; in this case the argument must be a decimal string, which will then be converted to the corresponding ASCII character value. <CODE>
format</CODE>
 does backslash substitution on its &lt;<EM>formatString</EM>&gt; argument, so backslash sequences in &lt;<EM>formatString</EM>&gt; will be handled correctly even if the argument is in braces. The return value from <CODE>
format</CODE>
 is the formatted string.</P>


<H2 CLASS="refHeading">
<A NAME="IX_global Tcl command">
 </A>
global</H2>
<PRE CLASS="syntax">
global &lt;varname&gt;+</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;global attached&quot; </DT><DD>
When next the &quot;attached&quot; variable is fetched or set, get it from the global scope, not the local one.</DD>
</DL>
<P>
Declares the given variables to be from the global scope.</P>
<UL>
<LI>
For the duration of the procedure in which this command is executed (but not in any procedure it invokes), the global variable of the given name will be used when the variable is fetched or set. </LI>
<LI>
If no global variable of the given name exists, the setting of that variable will define it in the global scope.</LI>
<LI>
This command is ignored unless a Tcl procedure is being interpreted. If so, then it declares the given &lt;<EM>varname</EM>&gt;'s to be global variables rather than local ones. For the duration of the current procedure (and only while executing in the current procedure), any reference to any of the &lt;<EM>varname</EM>&gt; values will be bound to a global variable instead of a local one.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_var Tcl command">var</A>.



<H2 CLASS="refHeading">
<A NAME="IX_if Tcl command">
 </A>
if</H2>
<PRE CLASS="syntax">
if &lt;test&gt; [then] &lt;trueBody&gt; <BR>
             (elif &lt;test&gt; [(then)] &lt;trueBody&gt;)* <BR>
             [[else] &lt;falseBody&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;if {$v &gt; 3} {echo yes} {echo no}&quot; </DT><DD>
Prints &quot;yes&quot; if $v is greater than 3, else it prints &quot;no&quot;.</DD>
<DT>
&quot;if {$v &gt; 3} then {echo yes} else {echo no}&quot; </DT><DD>
Ditto.</DD>
<DT>
&quot;if {$v &gt; 3} then {echo yes} elif {$v == 3} {echo maybe} else {echo no}&quot;</DT>
</DL>
<P>
This is Tcl's conditional, as you'd expect from its name.</P>
<UL>
<LI>
The &quot;then&quot; and &quot;else&quot; keywords are optional, intended to delineate the different sections of the command and make the whole easier to read. </LI>
<LI>
The &quot;elif&quot; keyword is <EM>
mandatory</EM>
 if you want to perform additional tests. </LI>
<LI>
The &lt;expr&gt; arguments are normal Tcl expressions. If the result is non-zero, the appropriate &lt;truebody&gt; is executed. If none of the &lt;expr&gt; arguments evaluates non-zero, &lt;falsebody&gt; is executed. </LI>
<LI>
If a &lt;truebody&gt; is empty and the test evaluated non-zero, &quot;if&quot; will return the result of the test. Otherwise &quot;if&quot; returns the result from last command executed in whichever &lt;truebody&gt; or &lt;falsebody&gt; argument was finally executed. It returns an empty string if no &lt;expr&gt; evaluated non-zero and no &lt;falsebody&gt; was given.</LI>
<LI>
The <CODE>
if</CODE>
 command evaluates &lt;<EM>test</EM>&gt; as an expression in the same way that <CODE>
expr</CODE>
 evaluates its argument. If the result is non-zero then &lt;<EM>trueBody</EM>&gt; is called by passing it to the Tcl interpreter. Otherwise &lt;<EM>falseBody</EM>&gt; is executed by passing it to the Tcl interpreter. &lt;<EM>falseBody</EM>&gt; is also optional; if it isn't specified then the command does nothing if &lt;<EM>test</EM>&gt; evaluates to zero. The return value from <CODE>
if</CODE>
 is the value of the last command executed in &lt;<EM>trueBody</EM>&gt; or &lt;<EM>falseBody</EM>&gt; or the empty string if &lt;<EM>test</EM>&gt; evaluates to zero and &lt;<EM>falseBody</EM>&gt; isn't specified. Alternative test conditions can be added by adding &lt;<EM>elif</EM>&gt; arguments. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_expr Tcl command">expr</A>.



<H2 CLASS="refHeading">
<A NAME="IX_index Tcl command">
 </A>
index</H2>
<PRE CLASS="syntax">
index &lt;value&gt; &lt;index&gt; [chars]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;index {a b c} 1&quot; 	</DT><DD>
Extracts &quot;b&quot; from the list.</DD>
<DT>
&quot;index {hi mom} 3 char&quot; </DT><DD>
Extracts &quot;m&quot; from the string.</DD>
</DL>
<P>
&quot;index&quot; is used to retrieve a single element or character from a list or string.</P>
<UL>
<LI>
Elements and characters are numbered from 0. </LI>
<LI>
If you request an element or character from beyond the end of the &lt;list&gt; or &lt;string&gt;, you'll receive an empty list or string as a result.</LI>
<LI>
If the &lt;<EM>chars</EM>&gt; keyword isn't specified, then <CODE>
index</CODE>
 treats &lt;<EM>value</EM>&gt; as a list and returns the &lt;<EM>index</EM>&gt;'th field from it. In extracting the field, <CODE>
index</CODE>
 observes the same rules concerning braces and backslashes as the Tcl command interpreter; however, variable substitution and command substitution do not occur. If the &lt;<EM>chars</EM>&gt; keyword is specified (or any abbreviation of it), then &lt;<EM>value</EM>&gt; is treated as a string and the command returns the &lt;<EM>index</EM>&gt;'th character from it (or the empty string if there aren't at least &lt;<EM>index</EM>&gt;+1 characters in the string).
</LI>
</UL>

<H2 CLASS="refHeading">
<A NAME="IX_info Tcl command">
 </A>
info</H2>
<PRE CLASS="syntax">
info args &lt;procname&gt; [&lt;pattern&gt;]
info arglist &lt;procname&gt;
info body &lt;procname&gt;
info cmdcount
info commands [&lt;pattern&gt;]
info default &lt;procname&gt; &lt;arg&gt; &lt;varname&gt;
info globals [&lt;pattern&gt;]
info locals [&lt;pattern&gt;]
info procs [&lt;pattern&gt;]
info vars [&lt;pattern&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;info args fmtval&quot;</DT><DD> Retrieves the names of the arguments for the &quot;fmtval&quot; command so you know in what order to pass things.</DD>
<DT>
&quot;info body print-frame&quot;</DT><DD> Retrieves the string that is the body of the &quot;print-frame&quot; Tcl procedure.</DD>
<DT>
&quot;info commands <EM>
reg</EM>
&quot; </DT><DD>Retrieves a list of commands whose names contain the string &quot;reg&quot;.</DD>
</DL>
<P>
This command provides information about a number of data structures maintained by the Tcl interpreter.</P>
<UL>
<LI>
All the &lt;pattern&gt; arguments are standard wildcard patterns as are used for the &quot;string match&quot; and &quot;case&quot; commands. See &quot;string&quot; for a description of these patterns. </LI>
<LI>
&quot;info args&quot; returns the complete list of arguments for a Tcl procedure, or only those matching the &lt;pattern&gt;, if one is given. The arguments are returned in the order in which they must be passed to the procedure. </LI>
<LI>
&quot;info arglist&quot; returns the complete list of arguments, and their default values, for a Tcl procedure. </LI>
<LI>
&quot;info body&quot; returns the command string that is the body of the given Tcl procedure. </LI>
<LI>
&quot;info cmdcount&quot; returns the total number of commands the Tcl interpreter has executed in its lifetime.</LI>
<LI>
&quot;info commands&quot; returns the list of all known commands, either built-in or as Tcl procedures, known to the interpreter. You may also specify a pattern to restrict the commands to those whose names match the pattern. </LI>
<LI>
&quot;info default&quot; returns non-zero if the argument named &lt;arg&gt; for the given Tcl procedure has a default value. If it does, that default value is stored in the variable whose name is &lt;varname&gt;. </LI>
<LI>
&quot;info globals&quot; returns the list of all global variables accessible within the current variable scope (i.e. only those that have been declared global with the &quot;global&quot; command, unless you issue this command from the command-line, which is at the global scope), or those that match the given pattern. </LI>
<LI>
&quot;info locals&quot; returns the list of all local variables, or those that match the given pattern.</LI>
<LI>
&quot;info procs&quot; returns the list of all known Tcl procedures, or those that match the given pattern. </LI>
<LI>
&quot;info vars&quot; returns the list of all known Tcl variables in the current scope, either local or global. You may also give a pattern to restrict the list to only those that match.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_proc Tcl command">proc</A>,
<A HREF="../../Tools/SwatRef/SR_9.htm#IX_defcmd Swat command">defcmd</A>,
<A HREF="../../Tools/SwatRef/SR_9.htm#IX_defcommand Swat command">defcommand</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_defsubr Tcl command">defsubr</A>.



<H2 CLASS="refHeading">
<A NAME="IX_Strings in Swat:computing length">
 </A>
<A NAME="IX_Lists in Swat:length Tcl command">
 </A>
<A NAME="IX_length Tcl command">
 </A>
length</H2>
<PRE CLASS="syntax">
length &lt;value&gt; [&lt;chars&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;length $args&quot; </DT><DD>
Returns the number of elements in the list $args</DD>
<DT>
&quot;length $str char&quot; </DT><DD>
Returns the number of characters in the string $str</DD>
</DL>
<P>
Determines the number of characters in a string, or elements in a list.</P>
<UL>
<LI>
If (<EM>chars</EM>) isn't specified, <CODE>
length</CODE>
 treats &lt;<EM>value</EM>&gt; as a list and returns the number of elements in the list. If &lt;<EM>chars</EM>&gt; is specified (or any abbreviation of it), then <CODE>
length</CODE>
 treats &lt;<EM>value</EM>&gt; as a string and returns the number of characters in it (not including the terminating null character).</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_index Tcl command">index</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_range Tcl command">range</A>.



<H2 CLASS="refHeading">
<A NAME="IX_Lists in Swat:list Tcl command">
 </A>
<A NAME="IX_list Tcl command">
 </A>
list</H2>
<PRE CLASS="syntax">
list &lt;arg&gt;+</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;list a b {c d e} {f {g h}}&quot; </DT><DD>
Returns the list &quot;a b {c d e} {f {g h}}&quot;</DD>
</DL>
<P>
Joins any number of arguments into a single list, applying quoting braces and backslashes as necessary to form a valid Tcl list.</P>
<UL>
<LI>
If you use the &quot;index&quot; command on the result, the 0th element will be the first argument that was passed, the 1st element will be the second argument that was passed, etc. </LI>
<LI>
The difference between &quot;list&quot; and &quot;concat&quot; is subtle. Given the above arguments, &quot;concat&quot; would return &quot;a b c d e f {g h}&quot;.</LI>
<LI>
This command returns a list comprised of all the &lt;<EM>args</EM>&gt;. It also adds braces and backslashes as necessary, so that the <CODE>
index</CODE>
 command may be used on the result to re-extract the original arguments, and also so that <CODE>
eval</CODE>
 may be used to execute the resulting list, with &lt;<EM>arg1</EM>&gt; comprising the command's name and the other &lt;<EM>args&gt;</EM> comprising its arguments. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_concat Tcl command">concat</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_index Tcl command">index</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_range Tcl command">range</A>.



<H2 CLASS="refHeading">
<A NAME="IX_Tcl:defining procedures">
 </A>
<A NAME="IX_proc Tcl command">
 </A>
proc</H2>
<PRE CLASS="syntax">
proc &lt;name&gt; &lt;args&gt; &lt;body&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;proc poof {{arg1 one} args} {return [list $arg1 $args]}&quot;</DT><DD>
 Defines a procedure poof that takes 0 or more arguments and merges them into a list of two elements. If no argument is given, the result will be the list {one {}}</DD>
</DL>
<P>
Defines a new Tcl procedure that can be invoked by typing a unique abbreviation of the procedure name.</P>
<UL>
<LI>
Any existing procedure or built-in command with the same name is overridden. </LI>
<LI>
&lt;name&gt; is the name of the new procedure and can consist of pretty much any character (even a space or tab, if you enclose the argument in braces). </LI>
<LI>
&lt;args&gt; is the (possibly empty) list of formal parameters the procedure accepts. Each element of the list can be either the name of local variable, to which the corresponding actual parameter is assigned before the first command of the procedure is executed, or a two-element list, the first element of which is the local variable name, as above, and the second element of which is the value to assign the variable if no actual parameter is given. </LI>
<LI>
If the final formal parameter is named &quot;args&quot;, the remaining actual parameters from that position on are cobbled into a list and assigned to the local variable $args. This allows a procedure to receive a variable number of arguments (even 0, in which case $args will be the empty list). </LI>
<LI>
If the only formal parameter is &quot;noeval&quot;, all the actual parameters are merged into a list and assigned to $noeval. Moreover, neither command- nor variable-substitution is performed on the actual parameters. </LI>
<LI>
The return value for the procedure is specified by executing the &quot;return&quot; command within the procedure. If no &quot;return&quot; command is executed, the return value for the procedure is the empty string.</LI>
<LI>
Whenever the new command is invoked, the contents of &lt;<EM>body</EM>&gt; will be executed by the Tcl interpreter. &lt;<EM>args</EM>&gt; specifies the formal arguments to the procedure. It consists of a list, possibly empty, each of whose elements specifies one argument. Braces and backslashes may be used in the usual way to specify complex default values.</LI>
<LI>
When &lt;<EM>name</EM>&gt; (or a unique abbreviation of same) is invoked, a local variable will be created for each of the formal arguments to the procedure; its value will be the value of corresponding argument in the invoking command or the argument's default value. Arguments with default values need not be specified in a procedure invocation. However, there must be enough actual arguments for all the formal arguments that don't have defaults, and there must not be any extra actual arguments (unless the &quot;args&quot; keyword was used). </LI>
<LI>
When &lt;<EM>body</EM>&gt; is being executed, variable names normally refer to local variables, which are created automatically when referenced and deleted when the procedure returns. One local variable is automatically created for each of the procedure's arguments. Global variables can only be accessed by invoking the <CODE>
global</CODE>
 command.</LI>
<LI>
The <CODE>
proc</CODE>
 command itself returns the null string. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_defsubr Tcl command">defsubr</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_return Tcl command">return</A>.



<H2 CLASS="refHeading">
<A NAME="IX_protect Tcl command">
 </A>
protect</H2>
<PRE CLASS="syntax">
protect &lt;body&gt; &lt;cleanup&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;protect {</DT>
<DT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var s [stream open $file w]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# do stuff with the stream<BR>
&nbsp;}&nbsp;{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch {stream close $s}<BR>
<BR>
&nbsp;}&quot; </DT><DD>
Perform some random operations on a file making sure the stream gets closed, even if the user types control-C.</DD>
</DL>
<P>
Allows one to ensure that clean-up for a sequence of commands will always happen, even if the user types control-C to interrupt the command.</P>
<UL>
<LI>
Since the interrupt can come at any time during the &lt;body&gt;, the &lt;cleanup&gt; command string should not rely on any particular variables being set. Hence the &quot;catch&quot; command used in the &lt;cleanup&gt; clause of the example. </LI>
<LI>
The &lt;cleanup&gt; clause will also be executed if any command in the &lt;body&gt; generates an error. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_catch Tcl command">catch</A>.



<H2 CLASS="refHeading">
<A NAME="IX_range Tcl command">
 </A>
<A NAME="IX_Lists in Swat:range Tcl command">
 </A>
range</H2>
<PRE CLASS="syntax">
range &lt;value&gt; &lt;first&gt; &lt;last&gt; [chars] </PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;range {a b c} 1 end&quot; </DT><DD>
Returns {b c} (element 1 to the end)</DD>
<DT>
&quot;range {hi mom} 3 end chars&quot; </DT><DD>
Returns &quot;mom&quot;</DD>
</DL>
<P>
Extracts a range of characters from a string, or elements from a list.</P>
<UL>
<LI>
If you give an ending index that is greater than the number of elements in the list (characters in the string), it will be adjusted to be the index of the last element (character). </LI>
<LI>
If you give a starting index that is greater than the number of elements in the list (characters in the string), the result will be the empty list (string). </LI>
<LI>
You can give &lt;end&gt; as &quot;end&quot; (without the quotation marks, of course) to indicate the extraction should go to the end of the list (string). </LI>
<LI>
The range is inclusive, so &quot;range {a b c} 0 0&quot; returns &quot;a&quot;. </LI>
<LI>
Neither index may be less than 0 or &quot;range&quot; will generate an error.</LI>
<LI>
 Return a range of fields or characters from value.   If the <EM>chars</EM> keyword, or any abbreviation of it, is specified, then <CODE>
range</CODE>
 treats &lt;value&gt; as a character string and returns characters &lt;<EM>first</EM>&gt; through &lt;<EM>last</EM>&gt; of it, inclusive. If &lt;<EM>last</EM>&gt; is less than &lt;<EM>first</EM>&gt; then an empty string is returned. Note: <CODE>
range value </CODE>
<EM CLASS="CodeArgsAsTyped">first first</EM> does not always produce the same results as<CODE>
 index value </CODE>
<EM CLASS="CodeArgsAsTyped">first</EM>
(although it often does for simple fields that are not enclosed in braces); it does, however, produce exactly the same results as <CODE>
list [index value first]</CODE>
.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_index Tcl command">index</A>.



<H2 CLASS="refHeading">
<A NAME="IX_return Tcl command">
 </A>
return</H2>
<PRE CLASS="syntax">
return [&lt;value&gt;]</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;return $val&quot; 		</DT><DD>
Returns the string in $val as the value for the current Tcl procedure.</DD>
</DL>
<P>
Causes an immediate return from the current Tcl procedure, with or without a value.</P>
<UL>
<LI>
Every Tcl procedure returns a string for a value. If the procedure was called via command substitution (having been placed between square brackets as the argument to another command), the return value takes the place of the command invocation. </LI>
<LI>
Execution of the current procedure terminates immediately, though any &lt;cleanup&gt; clause for a containing &quot;protect&quot; command will still be executed. </LI>
<LI>
If no &quot;return&quot; command is invoked within a Tcl procedure, the procedure returns the empty string by default.</LI>
<LI>
This command may be invoked only when a procedure call is in progress. It causes the current procedure to return immediately. If &lt;<EM>value</EM>&gt; is specified, it will be the return value from the procedure. Otherwise the current procedure will return the empty string.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_error Tcl command">error</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_proc Tcl command">proc</A>,
<A HREF="../../Tools/Tcl/TTCL_d.htm#IX_defsubr Tcl command">defsubr</A>,
<A HREF="../../Tools/SwatRef/SR_9.htm#IX_defcommand Swat command">defcommand</A>,
<A HREF="../../Tools/SwatRef/SR_9.htm#IX_defcmd Swat command">defcmd</A>.



<H2 CLASS="refHeading">
<A NAME="IX_scan Tcl command">
 </A>
scan</H2>
<PRE CLASS="syntax">
scan &lt;string&gt; &lt;format&gt; [&lt;varname1&gt; ]*</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;scan $input {my name is %s} name&quot; </DT><DD>
Trims the leading string &quot;my name is &quot; from the string in $input and stores the rest of the string within the variable $name</DD>
</DL>
<P>
&quot;scan&quot; parses fields from an input string, given the string and a format string that defines the various types of fields. The fields are assigned to variables within the caller's scope.</P>
<UL>
<LI>
The &lt;format&gt; string consists of literal text, which must be matched explicitly, and field definitions. The &lt;varName&gt; arguments are names of variables to which each successive field value is assigned. </LI>
<LI>
A single whitespace character (space or tab) will match any number of whitespace characters in the input string. Fields are specified as for the standard C library routine &quot;sscanf&quot;:</LI>
<DL>
<DT>
           <STRONG>
 %c</STRONG>
 </DT><DD>A single character. The field value stored is the decimal number of the ASCII code for the character scanned. So if the character were a space, the variable would receive the string &quot;32&quot;.</DD>
<DT>
             <STRONG>
%d</STRONG>
 </DT><DD>A signed decimal integer is parsed and stored. </DD>
<DT>
             <STRONG>
%o</STRONG>
 </DT><DD>An octal integer is parsed and stored, as a decimal number.</DD>
<DT>
             <STRONG>
%x</STRONG>
 </DT><DD>A hexadecimal integer is parsed and stored, as a decimal number.</DD>
<DT>
              <STRONG>
%i</STRONG>
 </DT><DD>A signed integer, following the standard C radix-specification standard, is parsed and stored as a decimal number.</DD>
<DT>
              <STRONG>
%f</STRONG>
 </DT><DD>A floating-point number is parsed as a &quot;float&quot; and stored without exponent, unless the exponent is less than -4.</DD>
<DT>
              <STRONG>
%s</STRONG>
 </DT><DD>A whitespace-terminated string is parsed and stored.</DD>
<DT>
              <STRONG>
%[&lt;char-class&gt;]</STRONG>
	</DT><DD>
 A string consisting only of the characters in the given character class (see &quot;string match&quot; for details on character classes) is parsed and stored. The normal leading-whitespace skipping is suppressed.</DD>
<DT>
             <STRONG>
%%</STRONG>
 </DT><DD>Matches a single percent sign in the input. </DD>
</DL>
<LI>
If the % of a field specifier is followed by an *, the field is parsed as usual, consuming characters from the string, but the result is not stored anywhere and you should not specify a variable to receive the value. </LI>
<LI>
The maximum length of a field may be specified by giving a decimal number between the % and the field-type character. So &quot;%10s&quot; will extract out a string of at most 10 characters. </LI>
<LI>
There is a limit of 5 fields. </LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_format Tcl command">format</A>.



<H2 CLASS="refHeading">
<A NAME="IX_source Tcl command">
 </A>
source</H2>
<PRE CLASS="syntax">
source &lt;fileName&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;source coolness&quot; </DT><DD>
Evaluates all commands within the file &quot;coolness.tcl&quot; in the current directory.</DD>
</DL>
<P>
Reads and evaluates commands from a file.</P>
<UL>
<LI>
If &lt;file&gt; has no extension and doesn't exist, &quot;source&quot; will append &quot;.tcl&quot; to the end and try and read that file.</LI>
<LI>
The return value of <CODE>
source</CODE>
 is the return value of the last command executed from the file. If an error occurs in executing the contents of the file, then the <CODE>
source</CODE>
 command will return that error.</LI>
</UL>

<H2 CLASS="refHeading">
<A NAME="IX_string Tcl command">
 </A>
string</H2>
<PRE CLASS="syntax">
string compare&lt;string1&gt; &lt;string2&gt; [no_case]
string first&lt;substring&gt; &lt;string&gt; [no_case]
string last&lt;substring&gt; &lt;string&gt; [no_case]
string match&lt;string&gt; &lt;pattern&gt;
string subst &lt;string&gt; &lt;search&gt; &lt;replace&gt; [global] </PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;if {[string c [index $args 1] all] == 0}&quot; </DT><DD>
Do something if the 2nd element of the list in $args is the string &quot;all&quot;.</DD>
<DT>
&quot;while {[string m [index $args 0] -*]}&quot; </DT><DD>
Loop while the first element of the list in $args begins with a hyphen.</DD>
</DL>
<P>
Examine strings in various ways.</P>
<UL>
<LI>
&quot;string subst&quot; searches &lt;string&gt; for occurrences of &lt;search&gt; and replaces them with &lt;replace&gt;. If 5th argument is given as &quot;global&quot; (it may be abbreviated), then all (non-overlapping) occurrences of &lt;search&gt; will be replaced. If 5th argument is absent, only the first occurrence will be replaced. </LI>
<LI>
&quot;string compare&quot; compares the two strings character-by-character. It returns -1, 0, or 1 depending on whether &lt;string1&gt; is lexicographically less than, equal to, or greater than &lt;string2&gt;. If the no_case parameter is passed than it does a case insensitive compare. </LI>
<LI>
&quot;string first&quot; searches &lt;string&gt; for the given &lt;substring&gt;. If it finds it, it returns the index of the first character in the first such match. If &lt;substring&gt; isn't part of &lt;string&gt;, it returns -1. If the no_case parameter is passed it does the search ignoring case. </LI>
<LI>
&quot;string last&quot; is much like &quot;string first&quot;, except it returns the index of the first character of the last match for the &lt;substring&gt; within &lt;string&gt;. If there is no match, it returns -1. </LI>
<LI>
&quot;string match&quot; compares &lt;string&gt; against &lt;pattern&gt; and returns 1 if the two match, or 0 if they do not. For the strings to match, their contents must be identical, except that the following special sequences may appear in &lt;pattern&gt; with the following results:</LI>
<DL>
<DT>
           * </DT><DD>Matches any sequence of characters, including none.</DD>
<DT>
            ? </DT><DD>Matches any single character</DD>
<DT>
           [&lt;char-class&gt;] </DT><DD>
Matches a single character within the given set. The elements of the set are specified as single characters, or as ranges of the form &lt;start&gt;-&lt;end&gt;. Thus [0-9x] matches a single character that is a numeric digit or the letter x.</DD>
<DT>
           [^&lt;char-class&gt;] </DT><DD>
Matches a single character <EM>
not</EM>
 within the given set.</DD>
<DT>
           \* </DT><DD>Matches an asterisk.</DD>
<DT>
           \? </DT><DD>Matches a question mark.</DD>
<DT>
           \[ </DT><DD>Matches an open-bracket.</DD>
</DL>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_case Tcl command">case</A>.



<H2 CLASS="refHeading">
<A NAME="IX_uplevel Tcl command">
 </A>
uplevel</H2>
<PRE CLASS="syntax">
uplevel &lt;level&gt; &lt;body&gt;<BR>
uplevel &lt;function&gt; &lt;body&gt;</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;uplevel print-frame {var found1}&quot;</DT><DD>
Sets $found to 1 within the variables belonging to the nearest invocation of print-frame on the call stack.</DD>
<DT>
&quot;uplevel 0 {var foo-table}&quot; </DT><DD>
Retrieves the value of the global variable foo-table.</DD>
<DT>
&quot;uplevel 1 {var found 1}&quot; </DT><DD>
Sets $found to 1 within the scope of the procedure that called the one executing the &quot;uplevel&quot; command.</DD>
</DL>
<P>
Provides access to the variables of another procedure for fairly specialized purposes.</P>
<UL>
<LI>
&lt;level&gt; is a signed integer with the following meaning:</LI>
<DL>
<DT>
 &gt; 0 </DT><DD>Indicates the number of scopes to go up. For example, if you say &quot;uplevel 1 {var foo 36}&quot;, you would modify (or create) the variable &quot;foo&quot; in your caller's scope.</DD>
<DT>
 &lt;= 0 </DT><DD>Indicates the number of scopes to go down from the global one. &quot;uplevel 0 &lt;body&gt;&quot; will execute &lt;body&gt; in the top-most scope, which means that no local variables are involved, and any variables created by the commands in &lt;body&gt; persist as global variables.</DD>
</DL>
<LI>
&lt;function&gt; is the name of a function known to be somewhere on the call stack. If the named function isn't on the call stack anywhere, &quot;uplevel&quot; generates an error. </LI>
<LI>
&lt;body&gt; may be spread over multiple arguments, allowing the command to be executed to use variables local to the current procedure as arguments without having to use the &quot;list&quot; command to form the &lt;body&gt;.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_global Tcl command">global</A>.



<H2 CLASS="refHeading">
<A NAME="IX_var Tcl command">
 </A>
var</H2>
<PRE CLASS="syntax">
var &lt;varname&gt;
var (&lt;name&gt; &lt;value&gt;)+</PRE>
<P CLASS="refField"><STRONG>
Examples:</STRONG>	</P>
<DL>
<DT>
&quot;echo [var poof]&quot; </DT><DD>
Prints the value stored in the variable &quot;poof&quot;</DD>
<DT>
&quot;var a b c d&quot; </DT><DD>Assigns the string &quot;b&quot; to the variable &quot;a&quot;, and the string &quot;d&quot; to the variable &quot;c&quot;.</DD>
<DT>
&quot;var yes $no no $yes&quot; </DT><DD>
Exchanges the values of the &quot;yes&quot; and &quot;no&quot; variables </DD>
</DL>
<P>
This is the means by which variables are defined in Tcl. Less often, it is also used to retrieve the value of a variable (usually that's done via variable substitution).</P>
<UL>
<LI>
If you give only one argument, the value of that variable will be returned. If the variable has never been given a value, the variable will be created and assigned the empty string, then the empty string will be returned. </LI>
<LI>
You can set the value of a variable by giving the value as the second argument, after the variable name. No value is returned by the &quot;var&quot; command in this case. </LI>
<LI>
You can assign values to multiple variables &quot;in parallel&quot; by giving successive name/value pairs. </LI>
<LI>
If invoked in a procedure on a variable that has not been declared global (using the &quot;global&quot; command), this applies to the local variable of the given name, even if it has no value yet.</LI>
</UL>
<P CLASS="refField"><STRONG>
See Also:</STRONG> <A HREF="../../Tools/Tcl/TTCL_d.htm#IX_global Tcl command">global</A>.


<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="TTCL_b.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="TTCL_c.htm"><IMG SRC="../../docImages/prev.gif" BORDER="0" ALT="Prev: ">5.1 Notation</A> 
<!-- to next --> | <A HREF="TTCL_e.htm"><IMG SRC="../../docImages/nextUp.gif" BORDER="0" ALT="Next: ">6 Coding</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
