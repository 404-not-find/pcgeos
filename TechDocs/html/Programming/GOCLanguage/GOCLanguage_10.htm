<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>

<!-- $Id: GOCLanguage_10.htm,v 1.2 97/09/05 13:43:45 lawrence Exp $ -->
<META NAME="copyright" CONTENT="Copyright 1997 GEOWORKS">
<!-- <META NAME="description" CONTENT=""> -->
<!-- <META NAME="keywords" CONTENT=""> -->
<LINK REL="STYLESHEET" HREF="../../docHelpers/style.css">
<LINK REV="MADE" HREF="mailto:doc-feedback@geoworks.com">

<TITLE> Defining a New Class or Subclass</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">


<H1 CLASS="subsectionTitle">
<A HREF="index.htm">GEOS Programming</A>: 4.1 <A HREF="GOCLanguage_f.htm">Using Classes and Objects</A>: 
<A NAME="18289">
 </A>
Defining a New Class or Subclass</H1>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="GOCLanguage_f.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="GOCLanguage_f.htm"><IMG SRC="../../docImages/prevUp.gif" BORDER="0" ALT="Prev: ">4 Using Classes and Objects</A> 
<!-- to next --> | <A HREF="GOCLanguage_11.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">4.2 Non-relocatable Data</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
<PRE>@class, @classdecl, @endc, @default, @uses</PRE>
<P>
<A NAME="IX_@endc[;endc]">
 </A>
<A NAME="IX_@class[;class]">
 </A>
You can create new classes in GEOS by using the Goc keywords <CODE>
@class</CODE>
 and <CODE>
@endc</CODE>
. These frame the class definition as shown in <A HREF="GOCLanguage_10.htm#73551"> Defining Classes</A>
; the <CODE>
@endc</CODE>
 keyword takes no parameters, but <CODE>
@class</CODE>
 takes the following parameters:</P>
<PRE>@class    &lt;cname&gt;, &lt;super&gt; [, master [, variant]];</PRE>
<DL>
<DT>
<STRONG>
cname</STRONG>
</DT><DD>This is the name of the new class.</DD>
<DT>
<STRONG>
super</STRONG>
</DT><DD>This is the class name of the superclass.</DD>
<DT>
<STRONG>
master</STRONG>
</DT><DD><A NAME="IX_Master classes:class flag">
 </A>
<A NAME="IX_master (class flag)">
 </A>
When included, this word makes the new class a master class.</DD>
<DT>
<STRONG>
variant</STRONG>
</DT><DD><A NAME="IX_Variant classes:class flag">
 </A>
<A NAME="IX_variant (class flag)">
 </A>
When included, this word makes the new class a variant class. All variant classes must also be declared master classes.</DD>
</DL>
<P>
<A NAME="IX_@classdecl[;classdecl]">
 </A>
Every class must have a class structure (<CODE>
ClassStruct</CODE>
) in memory. This is created and filled automatically by Goc and the kernel; however, you must use the <CODE>
@classdecl</CODE>
 keyword to make sure the structure gets built. Only one <CODE>
@classdecl</CODE>
 statement may be used for each class, however--Goc will give an error if the class is declared twice. This is also shown in <A HREF="GOCLanguage_10.htm#73551"> Defining Classes</A>
, and its parameters are as follows:</P>
<PRE>@classdecl    &lt;cname&gt; [, &lt;cflags&gt;];</PRE>
<DL>
<DT>
<STRONG>
cname</STRONG>
</DT><DD>This is the name of the class being declared.</DD>
<DT>
<STRONG>
cflags</STRONG>
</DT><DD>These are optional flags, described below.</DD>
</DL>
<P>
The optional flags that can be used with a class declaration determine how objects of the class get shut down (see <A HREF="GOCLanguage_d.htm#11068"> Class_flags</A>
). The flags you can use with <CODE>
@classdecl</CODE>
 are</P>
<DL>
<DT>
<CODE>
neverSaved</CODE>
<A NAME="IX_neverSaved (class flag)">
 </A>
</DT><DD>This flag indicates that objects of this class will neither be written to a state file nor be loaded in from a resource. This flag should only be used for classes whose objects will only be created at run-time (not declared in the <STRONG CLASS="fileName">
.goc</STRONG>
 file) and for process classes.</DD>
<DT>
<CODE>
discardOnSave</DT><DD>
</CODE>
<A NAME="IX_discardOnSave (class flag)">
 </A>
This flag applies only to master classes. Objects of this class will never be saved to a state file and must be re-initialized each time they are loaded. If you want an object simply to revert to its default configuration each time it is loaded, use the flag <CODE>
ignoreDirty</CODE>
 instead in the object's declaration (see <CODE>
@object</CODE>
, in <A HREF="GOCLanguage_13.htm#72656"> Declaring an Object</A>
).</DD>
</DL>
<P>
In addition, any variant class can have a default superclass. The variant is resolved at compile-time to have the default superclass as its superclass. To set a default superclass for a variant class, add a line with the following structure in the class definition:</P>
<PRE>@default &lt;varRoot&gt; = &lt;super&gt;;</PRE>
<DL>
<DT>
<STRONG>
varRoot</STRONG>
</DT><DD>The name of the variant class with &quot;Class&quot; removed. (For example, GenClass would be specified as &quot;Gen.&quot;)</DD>
<DT>
<STRONG>
super</STRONG>
</DT><DD>The name of the superclass to set as the default.</DD>
</DL>
<P>
<A NAME="IX_@uses[;uses]">
 </A>
Sometimes a variant class will know that it will be the subclass of a specific class, though it doesn't know (at compile time) just how that ancestry will be traced. You can use the <CODE>
@uses</CODE>
 directive to let the compiler know this; that way, the variant class can define handlers for the &quot;used&quot; class. For example, if you know that variant class <CODE>
MyVariantClass</CODE>
 will always be resolved as a descendant of <CODE>
MyAncestorClass</CODE>
, you can put the directive
<IMG SRC="GOCLanguage_10_usesSidebar.gif">

</P>
<PRE>@uses MyAncestorClass;</PRE>
<P>
in the definition of <CODE>
MyVariantClass</CODE>
. The general format is</P>
<PRE>@uses &lt;class&gt;;</PRE>
<DL>
<DT>
<STRONG>
class</STRONG>
</DT><DD>The class which will always be an ancestor to this class.</DD>
</DL>
<P CLASS="figTitle">
Code Display 5-6 <A NAME="73551">
 </A>
Defining Classes</P>
<PRE>/* The @class keyword defines a new class or subclass. @endc ends the class
 * definition, and @classdecl must be put somewhere in the code to make sure Glue
 * will link the class structure into the compiled geode.*/</PRE>
<PRE>@class	MyNewClass, VisClass;
    /* Message declarations would go here. See @message.
     * Instance data field declarations would go here. See @instance
     * 						and @vardata. */
@endc
@classdecl MyNewClass, neverSaved;</PRE>
<PRE>@class	MyTriggerClass, GenTriggerClass;
    /* New messages for this subclass are defined here. */
    /* New instance data fields for this subclass are defined here. */
@endc
@classdecl MyTriggerClass;</PRE>
<PRE>/* When defining a variant class (which must also be a master class), you can
 * set a superclass for the variant at compile-time using @default. */</PRE>
<PRE>@class	MyNewVariantClass, MetaClass, master, variant;
    @default		MyNewVariant = VisClass;
@endc	MyNewVariantClass
@classdecl MyNewVariantClass;</PRE>

<H2 CLASS="HeadingC">
<A NAME="26398">
 </A>
Defining New Messages for a Class</H2>
<PRE>@message, @stack, @reserveMessages, @exportMessages, @importMessage, @alias, @prototype</PRE>
<P>
As discussed in <A HREF="GOCLanguage_e.htm#57260"> The GEOS Message System</A>
, messages are simply 16-bit numbers allocated as an enumerated type. When a new class is defined, a constant is automatically created representing the first message number for the class. This constant is then used as the first number in the enumeration of messages.</P>
<P>
<A NAME="IX_Messages:ranges">
 </A>
The constant is built off the class' superclass. <CODE>
MetaClass</CODE>
 has the first 16384 messages reserved for its use. Each master level gets 8192, and the first master class of a level gets 2048 of these. All other classes are allocated 512 message spots. Thus, a master class subclassed directly off <CODE>
MetaClass</CODE>
 would have 2048 messages beginning with number #16384 (since the numbering is zero-based). A subclass of this would have 512 messages beginning with number #18432.</P>
<P>
This numbering scheme ensures that no two classes at different levels in the class hierarchy will have the same message number. Specifically, a class will never have the same message number as one of its sub- or superclasses.</P>
<P>
New messages must be defined in the class definition between the <CODE>
@class</CODE>
 and <CODE>
@endc</CODE>
 keywords (see above). They are defined much like normal function calls and follow the normal C calling conventions (see <A HREF="GOCLanguage_10.htm#43720"> Defining Messages</A>
 for examples). If your class uses messages from its superclass, you do <EM>
not</EM>
 have to declare these messages in your class definition--they are inherited automatically. This is true even if you are subclassing the method to alter its functionality.</P>
<P>
<A NAME="IX_@message[;message]">
 </A>
To define a new message, use the <CODE>
@message</CODE>
 keyword. This keyword takes the following parameters:</P>
<PRE>@message   &lt;retType&gt; &lt;mname&gt;(&lt;param&gt;*);</PRE>
<DL>
<DT>
<STRONG>
retType</STRONG>
</DT><DD>This is the data type of the return value of the message. It can be any standard C or GEOS data type (excluding structures), or a pointer to a structure. If this message has multiple return values, you must do as in C function calls and pass pointers to buffers for the return information.</DD>
<DT>
<STRONG>
mname</STRONG>
</DT><DD>This is the name of the message. By convention, it will be <CODE>
MSG_</CODE>
 followed by a shortened version of the name of the class and then some useful name (e.g., <CODE>
MSG_META_INITIALIZE</CODE>
).</DD>
<DT>
<STRONG>
param</STRONG>
</DT><DD>This represents one or more parameters. Messages may have no parameters, one parameter, or several parameters. Parameter definition is essentially the same as definition of function parameters; see <A HREF="GOCLanguage_10.htm#43720"> Defining Messages</A>
 for examples. </DD>
</DL>
<P>
	NOTE: When defining a function with no parameters, it is best to declare it with &quot;void&quot; between the parentheses. This will make sure Goc gives an error if the function is called with arguments.</P>

<H3 CLASS="HeadingD">
Messages for Use with Assembly Code</H3>
<P>
<A NAME="IX_@stack[;stack]">
 </A>
 The <CODE>
@stack</CODE>
 keyword indicates that parameters are passed on the stack; it is important to note that because of calling conventions, parameters passed on the stack must be listed in the message definition <EM>
in reverse order</EM>
 from the way the handler pops them from the stack. This keyword is used only when the message may be handled by an assembly language method; its format is shown below:</P>
<PRE>@message &lt;retType&gt; &lt;mname&gt;(@stack &lt;param&gt;*);</PRE>
<P>
All the parameters shown in the formats are the same as in the normal <CODE>
@message</CODE>
 format.</P>
<P CLASS="figTitle">
Code Display 5-7 <A NAME="43720">
 </A>
Defining Messages</P>
<PRE>	/* Each message is defined for a class within the class definition. */
@class	MyTriggerClass, GenTriggerClass;
	/* All the new messages MyTriggerClass can handle are defined here. */
@message void MSG_MYTRIG_SET_COLOR(colors colorIndex);
@message optr MSG_MYTRIG_RETURN_OPTR( void );
@message void MSG_MYTRIG_COLLECT_PARAMS(byte bParam, word wParam, char * string);
	/* Instance data fields would be defined here. */</PRE>
<PRE>@endc
@classdecl MyTriggerClass;</PRE>


<H3 CLASS="HeadingD">
Exporting, Importing, and Reserving Message Ranges</H3>
<P>
<A NAME="IX_Messages:importing">
 </A>
<A NAME="IX_Messages:exporting">
 </A>
As discussed above, message numbers are assigned based on the class' location in the class tree. No message number will ever conflict with messages defined in the class' superclasses. However, the assignment scheme opens up the possibility that classes on the same level in the class tree could have conflicting message numbers, as shown below.
<IMG SRC="GOCLanguage_10_messageNumbers.gif">

</P>
<P>
Normally, this is not a problem. If subclasses are to receive the same message and handle it differently, the message can typically be defined in the superclass and simply be intercepted by the subclasses. Sometimes, however, different subclasses will need to have different definitions for the same messages. For example, a class supplied by a library may be used by several applications; if the applications each create a subclass, these subclasses can import particular messages that will be the same for all the subclasses in all the applications.</P>
<P>
Goc therefore allows a class to export a range of message numbers which subclasses can import and create specific definitions for. This allows you greater control over what aspects of the class you can define.</P>
<P>
<A NAME="IX_@importMessage[;importMessage]">
 </A>
<A NAME="IX_@exportMessages[;exportMessages]">
 </A>
To export a range of messages, use the <CODE>
@exportMessages</CODE>
 keyword. This will set aside several message numbers which can then be imported by subclasses using the <CODE>
@importMessage</CODE>
 keyword.<A NAME="IX_Messages:reserving ranges">
 </A>
</P>
<P>
<A NAME="IX_@reserveMessages[;reserveMessages]">
 </A>
Another potential problem is upgrading your program from release to release. If you create classes that may grow in the future, you may want to reserve a number of message spots to ensure that those spots can be filled in later. Nothing is done with the spots; they are simply place holders for future upgrades. You can use the <CODE>
@reserveMessages</CODE>
 keyword to reserve a range of any size. The parameters of these three keywords are shown below:</P>
<PRE>@reserveMessages    &lt;num&gt;;
@exportMessages     &lt;expName&gt;, &lt;num&gt;;
@importMessage	      &lt;expName&gt;, &lt;messageDef&gt;;</PRE>
<DL>
<DT>
<STRONG>
num</STRONG>
</DT><DD>This is the number of messages in the exported range.</DD>
<DT>
<STRONG>
expName</STRONG>
</DT><DD>This is the name of the exported range. This is used when importing messages to ensure that the proper numbers are used.</DD>
<DT>
<STRONG>
messageDef</DT><DD>
</STRONG>
This is a standard message definition line, the same as would be found with the <CODE>
@message</CODE>
 keyword (though <CODE>
@message</CODE>
 is left out).</DD>
</DL>
<P>
Note that you do not <EM>
need</EM>
 to reserve messages for upgrades; any class can always have messages tacked on to the end of its class definition. If you want to group the messages logically, however, you should reserve ranges where you expect additions to be made.</P>


<H3 CLASS="HeadingD">
Aliasing Messages</H3>
<P>
<A NAME="IX_@alias[;alias]">
 </A>
The <CODE>
@alias</CODE>
 keyword allows a single message to have more than one pass/return format.<A NAME="IX_@prototype[;prototype]">
 </A>
 The <CODE>
@prototype</CODE>
 keyword allows quick, clean, and convenient repetition of a single format for many different messages; it also allows a class to create a prototype so users of a message can have their own messages with the same format.</P>
<P>
<CODE>
@alias</CODE>
 is used when a single method takes conditional parameters. For example, a method may take a word value in a certain case and a dword value in another (dependent upon a passed flag). Each condition must be accounted for in its own message format. Rather than create a message and a method for each case, you can create a single assembly-language method for all the different pass/return formats; then, you can use <CODE>
@alias</CODE>
 to make several messages refer to the same method, each using a different format.</P>
<PRE>@alias(&lt;protoMsg&gt;) &lt;msgDef&gt;;</PRE>
<DL>
<DT>
<STRONG>
protoMsg</STRONG>
</DT><DD>The name of the original message. The new message may have different pass/return values but will invoke the same method code and will have the same message number.</DD>
<DT>
<STRONG>
msgDef</STRONG>
</DT><DD>The new message definition. It follows the same format as messages defined with the <CODE>
@message</CODE>
 keyword (with <CODE>
@message</CODE>
 left off).</DD>
</DL>
<P>
In addition, if you have a single pass/return format for many messages, you can use the <CODE>
@prototype</CODE>
 keyword as coding shorthand. For example, if an object has ten messages that all take two parameters and return a single value, you can set up the format with the <CODE>
@prototype</CODE>
 keyword and then use a simpler format for definition of your messages. An example is shown in <A HREF="GOCLanguage_10.htm#26009"> Aliasing Messages</A>
, and the parameters of this keyword are shown below.</P>
<PRE>@prototype &lt;msgDef&gt;;</PRE>
<DL>
<DT>
<STRONG>
msgDef</STRONG>
</DT><DD>This is the standard message definition. For the message name, use something like &quot;<CODE>
MY_PROTOTYPE</CODE>
&quot; that you can insert later into the definitions of your real messages. All other parts of the message definition are the same as would be declared with <CODE>
@message</CODE>
 (with <CODE>
@message</CODE>
 left off).</DD>
</DL>
<P CLASS="figTitle">
Code Display 5-8 <A NAME="26009">
 </A>
Aliasing Messages</P>
<PRE>	/* MyClass in this example uses both prototype and aliased messages. */
@class MyClass, MetaClass;
	/* The following is a normal message declaration. The register that this
	 * parameter uses is specified because the handler (method) is written in
	 * assembly language. */
@message void MSG_MESSAGE_WITH_WORD(byte flag = cl, word value = dx);</PRE>
<PRE>	/* The following message invokes the same method as the alias above.
	 * It has the same message number but passes a different sized parameter
	 * in different registers. */
@alias(MSG_MESSAGE_WITH_WORD) void MSG_MESSAGE_WITH_DWORD(byte flag = cl,
							dword value = dx:bp);</PRE>
<PRE>	/* The following message is not used. Its pass and return values can
	 * be used elsewhere, however, to ensure that all handlers of this message
	 * type are given the same format. */
@prototype int MSG_MYCLASS_PROTO(int a, int b);</PRE>
<PRE>	/* The following have the same return values and parameters
	 * as the prototype above. */
@message(MSG_MYCLASS_PROTO) MSG_MY_CLASS_ADD;
@message(MSG_MYCLASS_PROTO) MSG_MY_CLASS_SUBTRACT;
@message(MSG_MYCLASS_PROTO) MSG_MY_CLASS_MULTIPLY;</PRE>
<PRE>@endc
@classdecl MyClass;</PRE>



<H2 CLASS="HeadingC">
<A NAME="87922">
 </A>
Defining Instance Data Fields</H2>
<PRE>@instance, @composite, @link, @visMoniker, @kbdAccelerator</PRE>
<P>
<A NAME="IX_@instance[;instance]">
 </A>
<A NAME="IX_Instance data:Goc syntax">
 </A>
Instance data fields are all defined with the <CODE>
@instance</CODE>
 keyword. Other keywords may be included in the <CODE>
@instance</CODE>
 declaration for special types of data. All instance data definitions must appear between the class' <CODE>
@class</CODE>
 and <CODE>
@endc</CODE>
 keywords (see above under class definition).</P>
<P>
The <CODE>
@instance</CODE>
 keyword is used to define normal instance data. If you have data that must be added or removed dynamically (such as hints), use the <CODE>
@vardata</CODE>
 keyword, described in <A HREF="GOCLanguage_10.htm#54822"> Defining and Working With Variable Data Fields</A>
. Also, if you have data that requires relocation (such as pointers to fixed data) when the object is loaded, use the <CODE>
@reloc</CODE>
 keyword.</P>
<P>
The format of the <CODE>
@instance</CODE>
 keyword is as follows:</P>
<PRE>@instance    &lt;insType&gt;    &lt;iname&gt; = &lt;default&gt;;</PRE>
<DL>
<DT>
<STRONG>
insType</STRONG>
</DT><DD>A standard C or GEOS data or structure type representing the data type of the instance field.</DD>
<DT>
<STRONG>
iname</STRONG>
</DT><DD>The name of the instance field.</DD>
<DT>
<STRONG>
default</STRONG>
</DT><DD>The default value of the instance field if it is not filled in when an object of this class is instantiated. The value must, of course, be appropriate for the data type.</DD>
</DL>
<P>
Goc has several special types of instance data fields that you can declare along with <CODE>
@instance</CODE>
 to make object definition easier. The format for using one of the special types is shown below (with examples in <A HREF="GOCLanguage_10.htm#99888"> Declaring Instance Data Fields</A>
). Each of the types is also described below.</P>
<PRE>@instance    &lt;specType&gt; &lt;iname&gt;;</PRE>
<DL>
<DT>
<STRONG>
specType</STRONG>
</DT><DD>This is the keyword (one of those shown in the list below) that defines the special type of this field.</DD>
<DT>
<STRONG>
iname</STRONG>
</DT><DD>This is the name of the instance field.</DD>
</DL>
<P>
The special types are given here:</P>
<DL>
<DT>
<CODE>
@composite</CODE>
<A NAME="IX_@composite[;composite]">
 </A>
</DT><DD>This field is used when objects of the class being defined are allowed to have children. The <CODE>
@composite</CODE>
 field will actually contain an optr to the first child object in an object tree. Since most objects in object trees are subclassed from <CODE>
VisClass</CODE>
 or <CODE>
GenClass</CODE>
, you will most likely never use the <CODE>
@composite</CODE>
 keyword. Both <CODE>
VisCompClass</CODE>
 and <CODE>
GenClass</CODE>
 have <CODE>
@composite</CODE>
 fields predefined. The <CODE>
@composite</CODE>
 type has a special format, shown below:</DD>
<PRE>@instance  @composite &lt;iname&gt; = &lt;linkName&gt;;</PRE>
<DT>
</DT><DD>where <CODE>
iname</CODE>
 is the name of the instance field and <CODE>
linkName</CODE>
 is the name of the field designated as <CODE>
@link</CODE>
 (below). Note that there must be a <CODE>
@link</CODE>
 field in every class that has a <CODE>
@composite</CODE>
 field. See <A HREF="GOCLanguage_15.htm#95668"> Managing Object Trees</A>
 for more information on object trees and the composite and link fields.</DD>
<DT>
<CODE>
@link</CODE>
<A NAME="IX_@link[;link]">
 </A>
</DT><DD>This field is used by objects that can be children in an object tree. Where the <CODE>
@composite</CODE>
 field points to the first child, the <CODE>
@link</CODE>
 field points to the next sibling. If there is no next sibling, this field will point back to the parent object. Since most objects in object trees are subclassed from <CODE>
VisClass</CODE>
 or <CODE>
GenClass</CODE>
, you will most likely never use the <CODE>
@link</CODE>
 keyword. Both <CODE>
VisClass</CODE>
 and <CODE>
GenClass</CODE>
 have <CODE>
@link</CODE>
 fields predefined.</DD>
<DT>
<CODE>
@visMoniker</DT><DD>
</CODE>
<A NAME="IX_Chunks:declaring with @visMoniker">
 </A>
This field is designated as holding a pointer to a visual moniker chunk for the object. It is used in <CODE>
GenClass</CODE>
--see <A HREF="../../SysObjects/Gen/index.htm">the GenClass chapter</A>for information on the <CODE>
GI_visMoniker</CODE>
 field. The moniker or moniker list must be in the same resource as the generic object using that moniker since only the chunk's handle is stored. A moniker list can store full object pointers to its monikers, so monikers referenced by a list need not be in the same resource as that list; thus if an object's moniker is specified via a list, then while the list must be in the same resource as the object, the monikers themselves need not be.</DD>
<DT>
<CODE>
@kbdAccelerator</DT><DD>
</CODE>
This field contains a character sequence that, when typed by the user, causes the object to execute its default operation. For example, a keyboard accelerator could invoke a trigger implemented as a menu item. It is used in <CODE>
GenClass</CODE>
 only.</DD>
</DL>
<P CLASS="figTitle">
Code Display 5-9 <A NAME="99888">
 </A>
Declaring Instance Data Fields</P>
<PRE>/* GenClass is a good example of many of the different types of fields. */</PRE>
<PRE>@class	GenClass, VisClass, master, variant;</PRE>
<PRE>	/* The GenClass messages are defined here. */</PRE>
<PRE>    @instance @link GI_link;
    @instance @composite GI_comp = GI_link;
    @instance @visMoniker GI_visMoniker;
    @instance @kbdAccelerator GI_kbdAccelerator;
    @instance byte GI_attrs = 0;
    @instance byte GI_states = (GS_USABLE|GS_ENABLED);</PRE>
<PRE>	/* Hints and other variable data fields are defined with @vardata. */</PRE>
<PRE>@endc</PRE>


<H2 CLASS="HeadingC">
New Defaults for Subclassed Instance Data Fields</H2>
<PRE>@default</PRE>
<P>
Recall that when defining an instance data field you can set up a default value for that field. When creating a subclass, you may wish to specify that the subclass should have a different default value for a given field than the superclass does. Use the <CODE>
@default</CODE>
 keyword to do this:</P>
<PRE>@default &lt;iname&gt; = &lt;default&gt;;</PRE>
<DL>
<DT>
<STRONG>
iname</STRONG>
</DT><DD>The name of the instance field.</DD>
<DT>
<STRONG>
default</STRONG>
</DT><DD>The new default value of the instance field if it is not filled in when an object of this class is instantiated. The value must, of course, be appropriate for the data type. You may use <CODE>
@default</CODE>
 as part of this value; this @default will be treated as the value of the superclass. (If this seems confusing, try looking at the example.)</DD>
</DL>
<P>
For example, a subclass of GenInteraction could set GIV_DIALOG as its default value for the GenInteraction instance field <CODE>
GII_visibility</CODE>
:</P>
<PRE>@default GII_visibility = GIV_DIALOG;</PRE>
<P>
A generic class might want to have the same value for its <CODE>
GI_states</CODE>
 field as its superclass, except with the GS_USABLE flag turned off:</P>
<PRE>@default GI_states = @default &amp; ~GS_USABLE;</PRE>


<H2 CLASS="HeadingC">
<A NAME="54822">
 </A>
Defining and Working With Variable Data Fields</H2>
<PRE>@vardata, @vardataAlias, ObjVarAddData(), ObjVarDeleteData(), ObjVarDeleteDataAt(), ObjVarScanData(), ObjVarFindData(), ObjVarDerefData(), ObjVarDeleteDataRange(), ObjVarCopyDataRange(), MSG_META_ADD_VAR_DATA, MSG_META_DELETE_VAR_DATA, MSG_META_INITIALIZE_VAR_DATA, MSG_META_GET_VAR_DATA</PRE>
<P>
<A NAME="IX_Variable data:Goc syntax">
 </A>
Most classes will have well-defined instance data fields; each object in the class will have the same data structures, and all the instance chunks will look relatively similar and will be the same size.</P>
<P>
Many classes, however, will also use &quot;variable data,&quot; or instance fields that may be added or removed dynamically. This allows objects within the same class to have more or less instance data than other objects in the class. One example of variable data is the use of hints in generic UI objects. Because each object in a given class may or may not have hints, the objects can actually have different instance sizes. Variable data instance fields are defined with the use of the <CODE>
@vardata</CODE>
 keyword.</P>
<P>
Using variable data, however, is somewhat more complex than using standard instance data. You must use special kernel routines or messages to get a pointer to the data; then you can use the pointer to access the field.</P>
<P>
Variable data is stored together at the end of the instance chunk in &quot;data entries.&quot; Each entry consists of a primary word and optional extra data. The primary word represents a data type defined by the keyword <CODE>
@vardata</CODE>
. This type is created automatically by Goc when the <CODE>
@vardata</CODE>
 keyword is used.
<IMG SRC="GOCLanguage_10_messageNumbers.gif">

</P>
<P>
Each data entry is associated with a master class level and is considered part of the instance data for that master level (despite being stored at the end of the instance chunk). Thus, when a master part of an object is destroyed, the variable data entries associated with that master class will also be destroyed. For example, when a UI object is set not usable (taken off the screen), its Vis master part is removed from the instance chunk; any variable data entries associated with <CODE>
VisClass</CODE>
 will also be destroyed.</P>
<P>
Variable data may also be tagged for saving to the state file. That is, you can set up individual data entries to be saved to a state file and to be reinstated when the object is loaded from the state file. For more information about state saving, see <A HREF="GOCLanguage_15.htm#73804"> Saving Object State</A>
.</P>
<P>
Variable data may be defined in an object's declaration in your <STRONG CLASS="fileName">
.goc</STRONG>
 file or may be added and removed during execution. This gives the potential for using variable data as temporary storage in an object's instance chunk; however, temporary data used in this manner should be kept small to avoid slowing down the system--constantly resizing instance chunks to add and remove vardata fields makes more work for the memory manager.</P>
<P>
<A NAME="IX_@vardata[;vardata]">
 </A>
To define a variable data type in a given class, use the <CODE>
@vardata</CODE>
 keyword as follows (an example is given in <A HREF="GOCLanguage_10.htm#61839"> Defining Variable Data</A>
):</P>
<PRE>@vardata    &lt;type&gt; &lt;vname&gt;;</PRE>
<DL>
<DT>
<STRONG>
type</STRONG>
</DT><DD>This is the data type of any extra data associated with the variable data. It must be a standard C or GEOS data type. If the type <CODE>
void</CODE>
 is specified, no extra data will be added to the data entry when it is created. (An instance data field may be declared as an array, just as in standard C.)</DD>
<DT>
<STRONG>
vname</STRONG>
</DT><DD>This is the name of the variable data type. This name is used whenever referring to the vardata entry. Note that no two variable data types should have the same name, even if they're in different classes. Doing so will cause a compilation error. It's a good practice to put the class name within the data type name.</DD>
</DL>
<P CLASS="figTitle">
Code Display 5-10 Examples of Instance Data Declarations</P>
<PRE>/* These are some data fields for MyDataClass.
 */</PRE>
<PRE>    @instance		ChunkHandle		MDI_aChunk;
    @instance		HelloInfoFlags		MDI_flags;
    @instance		byte		MDI_lotsOfNumbers[32];</PRE>
<P>
<A NAME="IX_@vardataAlias[;vardataAlias]">
 </A>
Some vardata types may have varying amounts of extra data. For example, one type may have either a word or a dword of extra data. To allow this, you can set up an alias with the new type attached using the keyword <CODE>
@vardataAlias</CODE>
:</P>
<PRE>@vardataAlias  (&lt;origName&gt;) &lt;newType&gt; &lt;newName&gt;;</PRE>
<DL>
<DT>
<STRONG>
origName</STRONG>
</DT><DD>This is the name of the original variable data field already defined with <CODE>
@vardata</CODE>
.</DD>
<DT>
<STRONG>
newType</STRONG>
</DT><DD>This is the data type of the new variable data field, a standard C or GEOS data type.</DD>
<DT>
<STRONG>
newName</STRONG>
</DT><DD>This is the name of the new variable data field. In essence, the original and new fields will have the same data type word but will have different extra data size.</DD>
</DL>
<P>
<A NAME="IX_VarDataFlags">
 </A>
As noted earlier, the data type field in the data entry has two flags associated with it. These flags are each one bit:</P>
<DL>
<DT>
VDF_EXTRA_DATA</DT><DD>
<A NAME="IX_VDF_EXTRA_DATA">
 </A>
This flag indicates that this data type carries extra data.</DD>
<DT>
VDF_SAVE_TO_STATE</DT><DD>
<A NAME="IX_VDF_SAVE_TO_STATE">
 </A>
This flag indicates that this particular data entry should be saved along with all the other object's instance data when the state is saved. It should likewise be restored when the object is restored from the state file. Unless set <CODE>
off</CODE>
 explicitly, this flag will be set for every data type defined in a <STRONG CLASS="fileName">
.goc</STRONG>
 or <STRONG CLASS="fileName">
.goh</STRONG>
 file.</DD>
</DL>
<P>
The bitmask VDF_TYPE is a bitwise OR of VDF_EXTRA_DATA and VDF_SAVE_TO_STATE. You can use it to mask out all but those bits.</P>
<P CLASS="figTitle">
Code Display 5-11 <A NAME="61839">
 </A>
Defining Variable Data</P>
<PRE>/* Hints are defined with the @vardata command, as is shown in GenClass. Only a
 * small portion of the hints for GenClass are shown here. Those with structures
 * or data types (not &quot;void&quot;) have extra data fields associated with them. */</PRE>
<PRE>@class GenClass, VisClass, master, variant;
	/* Messages are defined here. */
	/* Followed by instance data defined with @instance. */
    @vardata void HINT_CENTER_MONIKER;
    @vardata SpecSizeSpec HINT_CUSTOM_CHILD_SPACING;
    @vardata char[] ATTR_GEN_INIT_FILE_KEY;</PRE>
<PRE>	/* Relocatable instance fields (see the next section) are defined with
	 * @reloc. This field contains an object pointer that must be resolved
	 * when the GenClass object is loaded. */
    @instance @link GI_link;
	@reloc GI_link, optr;
    @vardata DestinationClassArgs ATTR_GEN_DESTINATION_CLASS;
	@reloc ATTR_GEN_DESTINATION_CLASS, 0, optr;
@endc</PRE>
<P>
The kernel provides a number of routines an object may use to add, remove, and change its own vardata entries. Note that all these routines must be called from within the object containing the variable data entries; since variable data is instance data, it is against OOP doctrine for one object to alter another object's variable data directly.</P>
<P>
Instead, <CODE>
MetaClass</CODE>
 provides vardata messages that can be sent by one object to another to add, remove, change, or retrieve vardata entries of another object. The kernel routines and <CODE>
MetaClass</CODE>
 messages are outlined below:</P>
<UL>
<LI>
<CODE>
ObjVarAddData()<BR>
</CODE>
<A NAME="IX_ObjVarAddData()">
 </A>
This routine adds an new entry for the passed data type or replaces the extra data associated with a particular data type entry.</LI>
<LI>
<CODE>
ObjVarDeleteData()<BR>
</CODE>
<A NAME="IX_ObjVarDeleteData()">
 </A>
This routine deletes the entry for a particular data type when passed the data type.</LI>
<LI>
<CODE>
ObjVarDeleteDataAt()<BR>
</CODE>
<A NAME="IX_ObjVarDeleteDataAt()">
 </A>
This routine deletes a particular data entry when passed the entry's pointer as returned by <CODE>
ObjVarAddData()</CODE>
, <CODE>
ObjVarFindData()</CODE>
, or <CODE>
ObjVarDerefData()</CODE>
.</LI>
<LI>
<CODE>
ObjVarScanData()<BR>
</CODE>
<A NAME="IX_ObjVarScanData()">
 </A>
This routine causes the kernel to scan all data entries in an object's variable data and call any &quot;handler routines&quot; listed for them. This process is described below.</LI>
<LI>
<CODE>
ObjVarFindData()<BR>
</CODE>
<A NAME="IX_ObjVarFindData()">
 </A>
This routine searches for and returns (if possible) a pointer to a data entry of the passed data type.</LI>
<LI>
<CODE>
ObjVarDerefData()<BR>
</CODE>
<A NAME="IX_ObjVarDerefData()">
 </A>
This routine returns a pointer to a data entry when passed the object's optr and the data type. If the entry does not exist, this routine will call on the object to create and initialize the entry. Such variable data then behaves much like instance data. The object containing the vardata is responsible for creating the entry and then initializing it upon receipt of a <CODE>
MSG_META_INITIALIZE_VAR_DATA</CODE>
, described below.</LI>
<LI>
<CODE>
ObjVarDeleteDataRange()<BR>
</CODE>
<A NAME="IX_ObjVarDeleteDataRange()">
 </A>
This routine deletes all data entries with types in the passed range.</LI>
<LI>
<CODE>
ObjVarCopyDataRange()<BR>
</CODE>
<A NAME="IX_ObjVarCopyDataRange()">
 </A>
This routine copies all data entries within the passed range from one object's instance chunk to another`s. If any entries are copied, the destination object will be marked dirty for saving. This routine must be called by the destination object; it is bad policy for one object to alter another object's instance data. This routine is primarily for copying hints from one UI object to another and is not commonly used by applications.</LI>
</UL>
<P>
The four messages (in <CODE>
MetaClass</CODE>
) that can be used to add, delete, and alter variable data entries remotely are listed below. Classes will never need to intercept and subclass these messages because the proper functionality is implemented in <CODE>
MetaClass</CODE>
.</P>
<DL>
<DT>
<CODE>
MSG_META_ADD_VAR_DATA</DT><DD>
</CODE>
<A NAME="IX_MSG_META_ADD_VAR_DATA">
 </A>
Adds a new vardata type to the recipient object. If the type already exists, the passed type replaces the old one.</DD>
<DT>
<CODE>
MSG_META_DELETE_VAR_DATA</DT><DD>
</CODE>
<A NAME="IX_MSG_META_DELETE_VAR_DATA">
 </A>
Deletes a vardata type from the recipient's instance data. If the type does not exist, nothing is done.</DD>
<DT>
<CODE>
MSG_META_INITIALIZE_VAR_DATA</DT><DD>
</CODE>
<A NAME="IX_MSG_META_INITIALIZE_VAR_DATA">
 </A>
Used when something is trying to access an object's vardata field remotely but the field has not yet been added to the object or initialized. The object must create and/or initialize the vardata field at this point.</DD>
<DT>
<CODE>
MSG_META_GET_VAR_DATA</DT><DD>
</CODE>
<A NAME="IX_MSG_META_GET_VAR_DATA">
 </A>
Returns the extra data set for the passed data type.</DD>
</DL>
<P>
In addition to supporting variable data structures, GEOS allows you to set up &quot;handlers&quot; for different variable data types. Handlers are routines that process a given data entry; for example, each generic UI object stores a number of hints. Specific UI classes, when attached to the generic object, have a specific routine to handle each hint supported. Some specific UIs do nothing with certain hints; these specific UIs do not have handlers for those hints.</P>
<P>
<A NAME="IX_VarDataCHandler tables">
 </A>
Handlers are associated with data types through the use of a <CODE>
VarDataCHandler</CODE>
 table. This is a table that you set up in your <STRONG CLASS="fileName">
.goc</STRONG>
 file that contains pairings of routine names with <CODE>
@vardata</CODE>
 field names. An example of the <CODE>
VarDataCHandler</CODE>
 table is shown in <A HREF="GOCLanguage_10.htm#98877"> Variable Data Handlers</A>
.</P>
<P>
A handler is simply a normal C routine or function and is defined as such. The handler should be declared as an <CODE>
_pascal</CODE>
 routine.The table pairs the handler with the <CODE>
@vardata</CODE>
 data type, and when <CODE>
ObjVarScanData()</CODE>
 is called, all handlers for all data types are called in order. This is true for the object's class and all its superclasses since variable data is inherited just as normal instance data is. The handler can do almost anything appropriate with the exception of destroying the object or adding or deleting variable data from the object.</P>
<P CLASS="figTitle">
Code Display 5-12 <A NAME="98877">
 </A>
Variable Data Handlers</P>
<PRE>	/* This example is taken from the C VarData sample application. */</PRE>
<PRE>/* This is a VarDataCHandler. It is called by the ObjVarScanData() routine when
 * the data type corresponding to this routine in the VarDataCHandlerTable
 * is encountered. The parameters indicated are passed.
 *
 * This particular handler is actually used for several different data types
 * (see VarDataCHandlerTable below). The data type can be distinguished by
 * the `dataType' parameter. 
 *
 * NOTE: VarDataInteractionHintHandler, like any handler used in a 
 * VarDataCHandler structure, must be declared _pascal. */</PRE>
<PRE>void _pascal VarDataInteractionHintHandler(MemHandle mh, ChunkHandle chnk, 
		void *data, word dataType, HandlerData *handlerData) {</PRE>
<PRE>    if (dataType == HINT_ORIENT_CHILDREN_HORIZONTALLY) {
	handlerData-&gt;HD_flags.has_horiz = 1;
    } else if (dataType == HINT_ORIENT_CHILDREN_VERTICALLY) {
	handlerData-&gt;HD_flags.has_vert = 1;
    } else if (dataType == HINT_ALLOW_CHILDREN_TO_WRAP) {
	handlerData-&gt;HD_flags.has_allow_wrap = 1;
    } else if ((dataType == HINT_WRAP_AFTER_CHILD_COUNT) &amp;&amp;
		(((WrapAfterChildCountData *) data)-&gt;WACCE_childCount == 2)) {
	handlerData-&gt;HD_flags.has_wrap_after = 1;
    }
}</PRE>
<PRE>/* This is the VarDataCHandler Table. It consists of data type/VarDataCHandler
 * pairs. The VarDataCHandlers are far routines. */</PRE>
<PRE>static VarDataCHandler varDataInteractionHandlerTable[] = {
    {HINT_ORIENT_CHILDREN_HORIZONTALLY, VarDataInteractionHintHandler},
    {HINT_ORIENT_CHILDREN_VERTICALLY, VarDataInteractionHintHandler},
    {HINT_ALLOW_CHILDREN_TO_WRAP, VarDataInteractionHintHandler},
    {HINT_WRAP_AFTER_CHILD_COUNT, VarDataInteractionHintHandler}
};</PRE>


<H2 CLASS="HeadingC">
Defining Relocatable Data</H2>
<PRE>@reloc</PRE>
<P>
<A NAME="IX_Relocatable data:goc syntax">
 </A>
Some objects and classes may have instance data fields that must be resolved when the object is loaded and linked at run-time. For example, if the object contains an optr to another object, that optr must be updated when the object is loaded and resolved since the global memory handle can't be known at compile-time.</P>
<P>
<A NAME="IX_@reloc[;reloc]">
 </A>
For some special instance fields, this happens automatically. For example, the <CODE>
@composite</CODE>
 and <CODE>
@link</CODE>
 fields as well as optrs are automatically resolved. However, if you add your own instance fields requiring relocation, you will have to set them up with the <CODE>
@reloc</CODE>
 keyword. This is true for both static and variable data.</P>
<P>
This keyword uses two formats. The first listed here is for normal, static instance data, and the second is used with variable data.</P>
<PRE><A NAME="52446"> </A>@reloc    &lt;iname&gt;, [(&lt;count&gt;, &lt;struct&gt;)] &lt;ptrType&gt;;</PRE>
<DL>
<DT>
<STRONG>
iname</STRONG>
</DT><DD>This is the name of the relocatable instance field.</DD>
<DT>
<STRONG>
count</STRONG>
</DT><DD>If the instance variable is an array of relocatable data or structures containing relocatable fields, this is the number of elements in the array.</DD>
<DT>
<STRONG>
struct</STRONG>
</DT><DD>If the relocatable data is an array of structures, this represents the name of the field within each structure that requires relocation.</DD>
<DT>
<STRONG>
ptrType</STRONG>
</DT><DD>This is the type of relocatable data contained in the field. It may be one of <CODE>
optr</CODE>
, <CODE>
ptr</CODE>
, or <CODE>
handle</CODE>
.</DD>
<PRE>@reloc &lt;vname&gt;, &lt;fn&gt;, [(&lt;count&gt;, &lt;struct&gt;)] ptrType;</PRE>
<DT>
<STRONG>
vname</STRONG>
</DT><DD>This is the name of the variable data type.</DD>
<DT>
<STRONG>
fn</STRONG>
</DT><DD>This is the name of the field within the variable data's extra data. If there is no extra data with this data type, put a zero rather than a name.</DD>
<DT>
<STRONG>
count</STRONG>
</DT><DD>If the instance variable is an array of relocatable data or structures containing relocatable fields, this is the number of elements in the array.</DD>
<DT>
<STRONG>
struct</STRONG>
</DT><DD>If the relocatable data is an array of structures, this represents the name of the field within each structure that requires relocation.</DD>
<DT>
<STRONG>
ptrType</STRONG>
</DT><DD>This is the type of relocatable data contained in the field. It may be one of <CODE>
optr</CODE>
, <CODE>
ptr</CODE>
, or <CODE>
handle</CODE>
.</DD>

</DL>
<HR>
<!-- This blob is a bunch of standard links: up, back, index, etc. -->
<!-- up to top -->|&nbsp;<A HREF="../../index.htm"><IMG SRC="../../docImages/upTop.gif" ALT="Up: " BORDER="0">GEOS SDK TechDocs</A>
<!-- up to parent -->| <A HREF="GOCLanguage_f.htm"><IMG SRC="../../docImages/up.gif" ALT="Up" BORDER="0"></A>
<!-- down to first child --> 
<!-- to previous --> | <A HREF="GOCLanguage_f.htm"><IMG SRC="../../docImages/prevUp.gif" BORDER="0" ALT="Prev: ">4 Using Classes and Objects</A> 
<!-- to next --> | <A HREF="GOCLanguage_11.htm"><IMG SRC="../../docImages/next.gif" BORDER="0" ALT="Next: ">4.2 Non-relocatable Data</A> 
<HR>
<!-- That blob was a bunch of standard links: up, back, index, etc. -->
</BODY>
</HTML>
