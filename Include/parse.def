COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) GeoWorks 1990 -- All Rights Reserved

PROJECT:	PC GEOS
MODULE:		
FILE:		parse.def

AUTHOR:		John Wedgwood, Jan 16, 1991

	
REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	jcw	 1/16/91	Initial revision


DESCRIPTION:
	Definitions of the parse library.
	
	For information on the parse library see the README file in
	/staff/pcgeos/Library/Parse. It contains a description of the
	functionality provided by the parse library.
		

	$Id: parse.def,v 1.1 97/04/04 14:23:24 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

SetDef  __PARSE

StartLibrary	parse

;
; There are two different types of tokens... The scanner returns tokens
; to the parser. These tokens represent what is found in the input stream.
; The parser has its own set of tokens which are stored into the parsed
; result.
;

;
; The scanner returns tokens to the parser. There are a limited number
; of things that the scanner returns. They are enumerated here.
;
; There are a set of tokens which the parser and scanner have in common
; It is important that they are at the start of both lists.
;
ScannerTokenType	etype	byte, 0, 1
SCANNER_TOKEN_NUMBER			enum	ScannerTokenType
SCANNER_TOKEN_STRING			enum	ScannerTokenType
SCANNER_TOKEN_CELL			enum	ScannerTokenType
SCANNER_TOKEN_END_OF_EXPRESSION		enum	ScannerTokenType
SCANNER_TOKEN_OPEN_PAREN		enum	ScannerTokenType
SCANNER_TOKEN_CLOSE_PAREN		enum	ScannerTokenType
SCANNER_TOKEN_IDENTIFIER		enum	ScannerTokenType
	;
	; All the items above are in common with the ParserTokenType list.
	; You can add or delete items below this point without changing
	; the other table.
	;
SCANNER_TOKEN_OPERATOR			 enum	ScannerTokenType
SCANNER_TOKEN_LIST_SEPARATOR		 enum	ScannerTokenType

;
; Each token which is returned by the scanner has data associated with it.
;
ScannerTokenNumberData	struct
    STND_value	FloatNum		; 8 byte constant
ScannerTokenNumberData	ends

ScannerTokenStringData	struct
    STSD_start		word		; Offset to start of string
    STSD_length		word		; Length of the string
ScannerTokenStringData	ends

;
; Cell references can be absolute, relative, or mixed.
; There is code in the scanner that assumes that these flags can be
; initialized to 0 (all flags cleared). If you add flags, attempt to
; make them initializable to 0.
;
CellRowColumn	record
    CRC_ABSOLUTE:1		; Set if the reference is absolute
    CRC_VALUE:15		; The value of the row/column
CellRowColumn	end

CellReference	struct
    CR_row	CellRowColumn <>
    CR_column	CellRowColumn <>
CellReference	ends

CellRange	struct
    CR_start	CellReference <>
    CR_end	CellReference <>
CellRange	ends

ScannerTokenCellData	struct
    STCD_cellRef	CellReference <>
ScannerTokenCellData	ends

;
; Operators have unique identifiers. There is a table in parseVariables.asm
; which depends on the order of definition of these operators.
; (opFormatTable).
;
; There are tables which depend on the order in which the operators are
; defined:
;	parseEval.asm		operatorHandlers
;	parseDepend.asm		opArgCountTable
;	parseVariables.asm	opFormatTable
;				opPrecedenceTable
;
OperatorType	etype	byte, 0, 1
OP_RANGE_SEPARATOR			enum OperatorType

OP_NEGATION				enum OperatorType
OP_PERCENT				enum OperatorType

OP_EXPONENTIATION			enum OperatorType
OP_MULTIPLICATION			enum OperatorType
OP_DIVISION				enum OperatorType
OP_MODULO				enum OperatorType
OP_ADDITION				enum OperatorType
OP_SUBTRACTION				enum OperatorType

OP_EQUAL				enum OperatorType
OP_NOT_EQUAL				enum OperatorType
OP_LESS_THAN				enum OperatorType
OP_GREATER_THAN				enum OperatorType
OP_LESS_THAN_OR_EQUAL			enum OperatorType
OP_GREATER_THAN_OR_EQUAL		enum OperatorType

; **** Add new operators here ****

OP_STRING_CONCAT			enum OperatorType
OP_RANGE_INTERSECTION			enum OperatorType

; The following are graphic versions of existing operators.  For example,
; OP_NOT_EQUAL_GRAPHIC is the same as OP_NOT_EQUAL, but shows up on screen
; as an equals sign with a line through it.
OP_NOT_EQUAL_GRAPHIC			enum OperatorType
OP_DIVISION_GRAPHIC			enum OperatorType
OP_LESS_THAN_OR_EQUAL_GRAPHIC		enum OperatorType
OP_GREATER_THAN_OR_EQUAL_GRAPHIC	enum OperatorType

;
; The following are included here because it's convenient. They represent
; an as yet undecided operator. The scanner has seen it and recognized it.
; The parser will decide which operator it is.
;
; The problem is that a single lexical token can correspond to two different
; operations, depending on the context:
; Percent Operator:
;	9%	<- Divides the value to the left by 100
; Modulo Operator:
;	9%2	<- Performs the operation "9 MOD 2"
; Negation Operator:
;	-5	<- Negates the value to the right
; Subtraction Operator:
;	3-5	<- Performs the operation "3 MINUS 5"
;
; Since the scanner has no idea what is coming next in the input stream it
; can only return that the operator is undecided.
;
; These operators should always be the last in the list since none of the
; tables depend on them.
;
OP_PERCENT_MODULO			enum OperatorType
OP_SUBTRACTION_NEGATION			enum OperatorType

;**** Don't add operators here ****
;**** Add them ahead of PERCENT_MODULO and SUBTRACTION_NEGATION ****

ScannerTokenOperatorData	struct
    STOD_operatorID	OperatorType	; Identifier for this operator
ScannerTokenOperatorData	ends

ScannerTokenIdentifierData	struct
    STID_start	word		; The offset to the start of the identifier
ScannerTokenIdentifierData	ends

;
; A single structure that is a union of all of the above is needed to
; construct a single Token-Data structure.
;
ScannerTokenData	union
    STD_number		ScannerTokenNumberData
    STD_string		ScannerTokenStringData
    STD_cell		ScannerTokenCellData
    STD_identifier	ScannerTokenIdentifierData
    STD_operator	ScannerTokenOperatorData
ScannerTokenData	end

;
; Here's the actual scanner token structure...
;
ScannerToken	struct
    ST_type	ScannerTokenType	; The type of the token
    ST_data	ScannerTokenData	; The data associated with the token
ScannerToken	ends

;*****************************************************************************

;
; The parser takes in a stream of ScannerTokens, makes sure it conforms to
; grammar, and produces a parsed result which is a stream or parser tokens
; and arguments.
;
; There are tables which depend on the order of definition of these tokens.
;
; There is a table in parseVariable.asm which defines the sizes of the
; data associated with each token type.
;
; There is a table in parseFormat.asm which lists handlers for the formatting
; of each of the different types.
;
; There is a table in parseEval.asm which lists handlers for evaluating
; each of the different types.
;
ParserTokenType		etype	byte, 0, 1
PARSER_TOKEN_NUMBER			enum	ParserTokenType
PARSER_TOKEN_STRING			enum	ParserTokenType
PARSER_TOKEN_CELL			enum	ParserTokenType
PARSER_TOKEN_END_OF_EXPRESSION		enum	ParserTokenType
PARSER_TOKEN_OPEN_PAREN			enum	ParserTokenType
PARSER_TOKEN_CLOSE_PAREN		enum	ParserTokenType
PARSER_TOKEN_NAME			enum	ParserTokenType
	;
	; All the items above are in common with the ScannerTokenType list.
	; You can add or delete items below this point without changing
	; the other table.
	;
PARSER_TOKEN_FUNCTION			enum	ParserTokenType
PARSER_TOKEN_CLOSE_FUNCTION		enum	ParserTokenType
PARSER_TOKEN_ARG_END			enum	ParserTokenType
PARSER_TOKEN_OPERATOR			enum	ParserTokenType

;
; There are structures for each of these parser tokens.  All of the
; parser tokens are a fixed size, except for strings, whose lengths
; are stored as the first word.
;
ParserTokenNumberData	struct
    PTND_value	FloatNum <>
ParserTokenNumberData	ends

ParserTokenStringData	struct
    PTSD_length		word		; Length of the string
    PTSD_string		label	char	; string starts here
ParserTokenStringData	ends

ParserTokenCellData	struct
    PTCD_cellRef	CellReference <>
ParserTokenCellData	ends

ParserTokenFunctionData	struct
    PTFD_functionID	word		; Identifier for the function
ParserTokenFunctionData	ends

ParserTokenOperatorData	struct
    PTOD_operatorID	OperatorType	; The operator ID.
ParserTokenOperatorData	ends

ParserTokenNameData	struct
    PTND_name		word		; The token describing the name
ParserTokenNameData	ends

ParserTokenData		union
    PTD_number		ParserTokenNumberData
    PTD_string		ParserTokenStringData
    PTD_name		ParserTokenNameData
    PTD_cell		ParserTokenCellData
    PTD_function	ParserTokenFunctionData
    PTD_operator	ParserTokenOperatorData
ParserTokenData		end

ParserToken	struct
    PT_type	ParserTokenType		; Type of the data
    PT_data	ParserTokenData		; The data itself
ParserToken	ends

;
; The parser maintains some flags which are defined below.
;
ParserFlags	record
    ;
    ; These are initialized by the parser. They are initialized to zero.
    ;
    PF_HAS_LOOKAHEAD:1		; The next token to get is the look-ahead token
    PF_CONTAINS_DISPLAY_FUNC:1	; Set: This expression contains a function
				;      which should be evaluated when the
				;      result of the expression is displayed.
    PF_OPERATORS:1		; Set: Allow operators
    PF_NUMBERS:1		; Set: Allow numbers
    PF_CELLS:1			; Set: Allow cell references
    PF_FUNCTIONS:1		; Set: Allow functions
    PF_NAMES:1			; Set: Allow names
    PF_NEW_NAMES:1		; Set: Allow new names (app only)
ParserFlags	end

;
; A list of the errors that the parser, scanner, and evaluator can generate.
;
; There is a list of error message, one for each error, in parseStrings.ui
; Make sure that the list is updated if you change this list.
;
ParserScannerEvaluatorError	etype	byte, 0, 1
	;
	; Scanner errors
	;
PSEE_BAD_NUMBER			enum	ParserScannerEvaluatorError
PSEE_BAD_CELL_REFERENCE		enum	ParserScannerEvaluatorError
PSEE_NO_CLOSE_QUOTE		enum	ParserScannerEvaluatorError
PSEE_COLUMN_TOO_LARGE		enum	ParserScannerEvaluatorError
PSEE_ROW_TOO_LARGE		enum	ParserScannerEvaluatorError
PSEE_ILLEGAL_TOKEN		enum	ParserScannerEvaluatorError
	;
	; Parser errors
	;
PSEE_GENERAL			enum	ParserScannerEvaluatorError
PSEE_TOO_MANY_TOKENS		enum	ParserScannerEvaluatorError
PSEE_EXPECTED_OPEN_PAREN	enum	ParserScannerEvaluatorError
PSEE_EXPECTED_CLOSE_PAREN	enum	ParserScannerEvaluatorError
PSEE_BAD_EXPRESSION		enum	ParserScannerEvaluatorError
PSEE_EXPECTED_END_OF_EXPRESSION	enum	ParserScannerEvaluatorError
PSEE_MISSING_CLOSE_PAREN	enum	ParserScannerEvaluatorError
PSEE_UNKNOWN_IDENTIFIER		enum	ParserScannerEvaluatorError
PSEE_NOT_ENOUGH_NAME_SPACE	enum	ParserScannerEvaluatorError
	;
	; Serious evaluator errors
	;
PSEE_OUT_OF_STACK_SPACE		enum	ParserScannerEvaluatorError
PSEE_NESTING_TOO_DEEP		enum	ParserScannerEvaluatorError
	;
	; Evaluator errors that are returned as the result of formulas.
	; These are returned on the argument stack.
	;
PSEE_ROW_OUT_OF_RANGE		enum	ParserScannerEvaluatorError
PSEE_COLUMN_OUT_OF_RANGE	enum	ParserScannerEvaluatorError
PSEE_FUNCTION_NO_LONGER_EXISTS	enum	ParserScannerEvaluatorError
PSEE_BAD_ARG_COUNT		enum	ParserScannerEvaluatorError
PSEE_WRONG_TYPE			enum	ParserScannerEvaluatorError
PSEE_DIVIDE_BY_ZERO		enum	ParserScannerEvaluatorError
PSEE_UNDEFINED_NAME		enum	ParserScannerEvaluatorError
PSEE_CIRCULAR_REF		enum	ParserScannerEvaluatorError
PSEE_CIRCULAR_DEP		enum	ParserScannerEvaluatorError
PSEE_CIRC_NAME_REF		enum	ParserScannerEvaluatorError
PSEE_NUMBER_OUT_OF_RANGE	enum	ParserScannerEvaluatorError
PSEE_GEN_ERR			enum	ParserScannerEvaluatorError
PSEE_NA				enum	ParserScannerEvaluatorError
	;
	; Dependency errors
	;
PSEE_TOO_MANY_DEPENDENCIES	enum	ParserScannerEvaluatorError
	;
	; Applications can define errors too, they start here.
	;
PSEE_FIRST_APPLICATION_ERROR	enum	ParserScannerEvaluatorError, 0xc0
	;
	; !!! NOTE !!!
	; These PSEE_ errors map directly to the floating point errors
	; Any change in the float library errors require corresponding
	; changes here.
	;
PSEE_FLOAT_POS_INFINITY		enum	ParserScannerEvaluatorError, 250
PSEE_FLOAT_NEG_INFINITY		enum	ParserScannerEvaluatorError
PSEE_FLOAT_GEN_ERR		enum	ParserScannerEvaluatorError

;
; There is some basic information that is useful to many of the callbacks.
; It should always be placed at the base of the parameter structures.
;
CommonParameters	struct
    CP_row		word		; Current row
    CP_column		word		; Current column
    CP_maxRow		word		; Largest legal row value
    CP_maxColumn	word		; Largest legal column value
    CP_callback		dword		; One general purpose callback
    CP_cellParams	dword		; Pointer to the cell parameters
CommonParameters	ends

;
; The reason for the callback is always passed to the application in al.
;
; Where al is returned as an error code, the application can destroy ah.
; The application cannot destroy anything else.
;
; No argument will ever be passed in ah.
;
; Applications can depend on the order of definition for these entries.
;
CallbackType	etype byte, 0, 1
CT_FUNCTION_TO_TOKEN		enum	CallbackType
	;
	; Description:
	;	Convert a function name to a function id token.
	; Pass:
	;	ss:bp	= Pointer to ParserParameters
	;	ds:si	= Pointer to the text of the identifier
	;	cx	= Length of the identifier
	; Return:
	;	carry set if the text is a function name
	;	di	= The Function-ID for the identifier
	;
CT_NAME_TO_TOKEN		enum	CallbackType
	;
	; Description:
	;	Convert a name to a name id token.
	; Pass:
	;	ss:bp	= Pointer to ParserParameters
	;	ds:si	= Pointer to the text of the identifier
	;	cx	= Length of the identifier
	; Return:
	;	cx	= Token for the name
	;	Carry set on error
	;	al	= Error code
	;
CT_CHECK_NAME_EXISTS		enum	CallbackType
	;
	; Description:
	;	Check to see if a name already exists
	; Pass:
	;	ss:bp	= Pointer to ParserParameters
	;	ds:si	= Pointer to the text of the name
	;	cx	= Length of the name
	; Return:
	;	carry set if the name does exist
	;	carry clear otherwise
	;
CT_CHECK_NAME_SPACE		enum	CallbackType
	;
	; Description:
	;	Signal the need to allocate a certain number of names.
	;	This is used to avoid the problem of getting part way through
	;	allocating names for an expression and then finding we don't
	;	have any more space for names.
	; Pass:
	;	ss:bp	= Pointer to ParserParameters
	;	cx	= # of names we want to allocate
	; Return:
	;	Carry set on error
	;	al	= Error code
	;
CT_EVAL_FUNCTION		enum	CallbackType
	;
	; Description:
	;	Evaluate a function with parameters.
	; Pass:
	;	ss:bp	= Pointer to EvalParameters
	;	cx	= # of arguments
	;	si	= Function ID
	;	es:di	= Operator stack
	;	es:bx	= Argument stack
	; Return:
	;	carry set on error
	;	al	= Error code
	;
CT_LOCK_NAME			enum	CallbackType
	;
	; Description:
	;	Lock a name definition.
	; Pass:
	;	ss:bp	= Pointer to ParserParameters
	;	cx	= Name token
	; Return:
	;	carry set on error
	;	al	= Error code
	;	ds:si	= Pointer to the definition
	;
CT_UNLOCK			enum	CallbackType
	;
	; Description:
	;	Unlock a name/function definition.
	; Pass:
	;	ss:bp	= Pointer to ParserParameters
	;	ds	= Segment address of the data to unlock
	;
CT_FORMAT_FUNCTION		enum	CallbackType
	;
	; Description:
	;	Format a function name into a buffer.
	; Pass:
	;	ss:bp	= Pointer to ParserParameters
	;	es:di	= Place to store the text
	;	cx	= Function token
	;	dx	= Maximum number of characters that can be written
	; Return:
	;	es:di	= Pointer past the inserted text
	;	dx	= # of characters that were written
	;
CT_FORMAT_NAME			enum	CallbackType
	;
	; Description:
	;	Format a name into a buffer.
	; Pass:
	;	ss:bp	= Pointer to ParserParameters
	;	es:di	= Place to store the text
	;	cx	= Name token
	;	dx	= Maximum number of characters that can be written
	; Return:
	;	ss:bp	= Pointer to ParserParameters
	;	es:di	= Pointer past the inserted text
	;	dx	= # of characters that were written
	;
CT_CREATE_CELL			enum	CallbackType
	;
	; Description:
	;	Create a new empty cell. Used by the dependency code to
	;	create a cell to add dependencies to.
	; Pass:
	;	ss:bp	= Pointer to ParserParameters
	;	dx	= Row of the cell to create
	;	cx	= Column of the cell to create
	; Return:
	;	carry set on error
	;	al	= Error code
	;
CT_EMPTY_CELL			enum	CallbackType
	;
	; Description:
	;	Remove a cell if it's appropriate. This is called when a cell
	;	has its last dependency removed.
	; Pass:
	;	ss:bp	= Pointer to ParserParameters
	;	dx	= Row of the cell that now has no dependencies
	;	cx	= Column of the cell that now has no dependencies
	; Return:
	;	carry set on error
	;	al	= Error code
	;
CT_NAME_TO_CELL			enum	CallbackType
	;
	; Description:
	;	Convert a name to a cell so we can add a dependency to it.
	; Pass:
	;	ss:bp	= Pointer to ParserParameters
	;	cx	= Name token
	; Return:
	;	dx	= Row of the cell containing the names dependencies
	;	cx	= Column of the cell containing the names dependencies
	;
CT_FUNCTION_TO_CELL		enum	CallbackType
	;
	; Description:
	;	Convert a function to a cell so we can add a dependencies to
	;	it.
	; Pass:
	;	ss:bp	= Pointer to ParserParameters
	;	cx	= Function-ID
	; Return:
	;	dx	= Row of the cell containing the functions dependencies
	;		= 0 if no dependency is required
	;	cx	= Column of the cell containing the functions
	;			dependencies.
	;
CT_DEREF_CELL		enum	CallbackType
	;
	; Description:
	;	Get the contents of a cell. The callback is responsible for
	;	popping the cell reference off the stack.
	; Pass:
	;	es:bx	= Pointer to the argument stack
	;	es:di	= Pointer to operator/function stack
	;	ss:bp	= Pointer to EvalParameters
	;	dx	= Row of the cell to dereference
	;	cx	= Column of the cell to dereference
	; Return:
	;	es:bx	= New pointer to the argument stack
	;	carry set on error
	;	   al	= Error code
	;
CT_SPECIAL_FUNCTION	enum	CallbackType
	;
	; Description:
	;	Get the value of one of the special functions.
	; Pass:
	;	es:bx	= Pointer to the argument stack
	;	es:di	= Pointer to operator/function stack
	;	ss:bp	= Pointer to EvalParameters
	;	cx	= Special function
	; Return:
	;	es:bx	= New pointer to the argument stack
	;	carry set on error
	;	   al	= Error code
	;
SpecialFunction	etype	word, 0, 2
SF_FILENAME		enum	SpecialFunction
SF_PAGE			enum	SpecialFunction
SF_PAGES		enum	SpecialFunction

;
; The parser allocates the following structure on the stack.
;
ParserParameters	struct
    ;
    ; Applications should initialize these fields before calling ParseString
    ;
    PP_common		CommonParameters <>
	;
	; Possible callbacks:
	;    CT_FUNCTION_TO_TOKEN
	;    CT_NAME_TO_TOKEN
	;
    PP_parserBufferSize	word			; Size of the buffer
    ;
    ; Fields below this point are initialized by ParseString
    ;
    PP_flags		ParserFlags		; Parsing flags
SBCS<    PP_textPtr	fptr.char		; Ptr to text		>
DBCS<    PP_textPtr	fptr.wchar		; Ptr to text		>
    PP_currentToken	ScannerToken		; Current token
    PP_lookAheadToken	ScannerToken		; Look ahead token

    PP_error		ParserScannerEvaluatorError
    PP_tokenStart	word			; Offset to start of token
    PP_tokenEnd		word			; Offset to end of token
ParserParameters	ends

; The CParserReturnStruct is the assembly version of the CParserReturnStruct.
; It's used for returning error values in the parser's C stubs.
CParserReturnStruct struc
    PRS_errorCode	byte
    PRS_textOffsetStart	word
    PRS_textOffsetEnd	word
    PRS_lastTokenPtr	fptr
CParserReturnStruct ends	

DerefFlags	record
	DF_DONT_POP_ARGUMENT:1		; Set = don't pop arg from arg stack
DerefFlags	end

; C Callback structures:
;	The callback structure (way below) has the CallbackType as the
;	first byte, then any passed values, then a set of variables
;	that are filled with return values from the following
;	structures.
;
;	See parse.h for details on these structures.

CT_FTT_CallbackStruct	struc	; Structure for CT_FUNCTION_TO_TOKEN 
    FTT_text		fptr
    FTT_length 	    	word
    FTT_isFunctionName 	byte
    FTT_funcID    	word
CT_FTT_CallbackStruct	ends

CT_NTT_CallbackStruct	struc	; Structure for CT_NAME_TO_TOKEN	
    NTT_text		fptr
    NTT_length    	word
    NTT_nameID    	word
    NTT_errorOccurred 	byte
    NTT_error    	byte
CT_NTT_CallbackStruct	ends

CT_CNE_CallbackStruct	struc	; Structure for CT_CHECK_NAME_EXISTS	
    CNE_text		fptr
    CNE_length       	word
    CNE_nameExists	byte
CT_CNE_CallbackStruct	ends

CT_CNS_CallbackStruct	struc	; Structure for CT_CHECK_NAME_SPACE	
    CNS_numToAllocate	word
    CNS_enoughSpace	byte
    CNS_errorOccurred 	byte
    CNS_error    	byte
CT_CNS_CallbackStruct	ends

CT_EF_CallbackStruct	struc	; Structure for CT_EVAL_FUNCTION	
    EF_numArgs    	word
    EF_funcID    	word
    EF_opStack		fptr
    EF_argStack		fptr
    EF_errorOccurred 	byte
    EF_error    	byte
CT_EF_CallbackStruct	ends

CT_LN_CallbackStruct	struc	; Structure for CT_LOCK_NAME		
    LN_nameToken 	word
    LN_defPtr   	dword
    LN_errorOccurred 	byte
    LN_error    	byte
CT_LN_CallbackStruct	ends

CT_UL_CallbackStruct	struc	; Structure for CT_UNLOCK		
    UL_dataPtr   	fptr
CT_UL_CallbackStruct	ends

CT_FF_CallbackStruct	struc	; Structure for CT_FORMAT_FUNCTION	
    FF_funcID	 	word
    FF_maxChars 	word
    FF_resultPtr	fptr
    FF_numWritten 	word
CT_FF_CallbackStruct	ends

CT_FN_CallbackStruct	struc	; Structure for CT_FORMAT_NAME		
    FN_textPtr		fptr
    FN_nameToken 	word
    FN_maxChars 	word
    FN_resultPtr	fptr
    FN_numWritten 	word
CT_FN_CallbackStruct	ends

CT_CC_CallbackStruct	struc	; Structure for CT_CREATE_CELL		
    CC_row    	    	word
    CC_column    	word
    CC_errorOccurred 	byte
    CC_error    	byte
CT_CC_CallbackStruct	ends

CT_EC_CallbackStruct	struc	; Structure for CT_EMPTY_CELL		
    EC_row    	    	word
    EC_column    	word
    EC_errorOccurred 	byte
    EC_error    	byte
CT_EC_CallbackStruct	ends

CT_NTC_CallbackStruct	struc	; Structure for CT_NAME_TO_CELL		
    NTC_nameToken 	word
    NTC_row    	    	word
    NTC_column    	word
CT_NTC_CallbackStruct	ends

CT_FTC_CallbackStruct	struc	; Structure for CT_FUNCTION_TO_CELL	
    FTC_funcID    	word
    FTC_row    	    	word
    FTC_column    	word
    FTC_errorOccurred	byte
    FTC_error		byte
CT_FTC_CallbackStruct	ends

CT_DC_CallbackStruct	struc	; Structure for CT_DEREF_CELL		
    DC_argStack		fptr
    DC_opFnStack	fptr
    DC_row    	    	word
    DC_column    	byte
    DC_derefFlags	DerefFlags
    DC_newArgStack	fptr
    DC_errorOccurred	byte
    DC_error    	byte
CT_DC_CallbackStruct	ends

CT_SF_CallbackStruct	struc	; Structure for CT_SPECIAL_FUNCTION
    SF_argStack		fptr
    SF_opFnStack	fptr
    SF_specialFunction	SpecialFunction
    SF_newArgStack	fptr
    SF_errorOccurred 	byte
    SF_error    	byte
CT_SF_CallbackStruct	ends

;
; Built-in function identifiers, one for each built-in function.
; There are tables which depend on the order that these functions
; are defined in. See parseVariables.asm and parseEval.asm
;
FunctionID	etype	word, 0, 2
FUNCTION_ID_ABS				enum	FunctionID
FUNCTION_ID_ACOS			enum	FunctionID
FUNCTION_ID_ACOSH			enum	FunctionID
FUNCTION_ID_AND				enum	FunctionID
FUNCTION_ID_ASIN			enum	FunctionID
FUNCTION_ID_ASINH			enum	FunctionID
FUNCTION_ID_ATAN			enum	FunctionID
FUNCTION_ID_ATAN2			enum	FunctionID
FUNCTION_ID_ATANH			enum	FunctionID
FUNCTION_ID_AVG				enum	FunctionID
FUNCTION_ID_CHAR			enum	FunctionID
FUNCTION_ID_CHOOSE			enum	FunctionID
FUNCTION_ID_CLEAN			enum	FunctionID
FUNCTION_ID_CODE			enum	FunctionID
FUNCTION_ID_COLS			enum	FunctionID
FUNCTION_ID_COS				enum	FunctionID
FUNCTION_ID_COSH			enum	FunctionID
FUNCTION_ID_COUNT			enum	FunctionID
FUNCTION_ID_CTERM			enum	FunctionID
FUNCTION_ID_DATE			enum	FunctionID
FUNCTION_ID_DATEVALUE			enum	FunctionID
FUNCTION_ID_DAY				enum	FunctionID
FUNCTION_ID_DDB				enum	FunctionID
FUNCTION_ID_ERR				enum	FunctionID
FUNCTION_ID_EXACT			enum	FunctionID
FUNCTION_ID_EXP				enum	FunctionID
FUNCTION_ID_FACT			enum	FunctionID
FUNCTION_ID_FALSE			enum	FunctionID
FUNCTION_ID_FIND			enum	FunctionID
FUNCTION_ID_FV				enum	FunctionID
FUNCTION_ID_HLOOKUP			enum	FunctionID
FUNCTION_ID_HOUR			enum	FunctionID
FUNCTION_ID_IF				enum	FunctionID
FUNCTION_ID_INDEX			enum	FunctionID
FUNCTION_ID_INT				enum	FunctionID
FUNCTION_ID_IRR				enum	FunctionID
FUNCTION_ID_ISERR			enum	FunctionID
FUNCTION_ID_ISNUMBER			enum	FunctionID
FUNCTION_ID_ISSTRING			enum	FunctionID
FUNCTION_ID_LEFT			enum	FunctionID
FUNCTION_ID_LENGTH			enum	FunctionID
FUNCTION_ID_LN				enum	FunctionID
FUNCTION_ID_LOG				enum	FunctionID
FUNCTION_ID_LOWER			enum	FunctionID
FUNCTION_ID_MAX				enum	FunctionID
FUNCTION_ID_MID				enum	FunctionID
FUNCTION_ID_MIN				enum	FunctionID
FUNCTION_ID_MINUTE			enum	FunctionID
FUNCTION_ID_MOD				enum	FunctionID
FUNCTION_ID_MONTH			enum	FunctionID
FUNCTION_ID_N				enum	FunctionID
FUNCTION_ID_NA				enum	FunctionID
FUNCTION_ID_NOW				enum	FunctionID
FUNCTION_ID_NPV				enum	FunctionID
FUNCTION_ID_OR				enum	FunctionID
FUNCTION_ID_PI				enum	FunctionID
FUNCTION_ID_PMT				enum	FunctionID
FUNCTION_ID_PRODUCT			enum	FunctionID
FUNCTION_ID_PROPER			enum	FunctionID
FUNCTION_ID_PV				enum	FunctionID
FUNCTION_ID_RANDOM_N			enum	FunctionID
FUNCTION_ID_RANDOM			enum	FunctionID
FUNCTION_ID_RATE			enum	FunctionID
FUNCTION_ID_REPEAT			enum	FunctionID
FUNCTION_ID_REPLACE			enum	FunctionID
FUNCTION_ID_RIGHT			enum	FunctionID
FUNCTION_ID_ROUND			enum	FunctionID
FUNCTION_ID_ROWS			enum	FunctionID
FUNCTION_ID_SECOND			enum	FunctionID
FUNCTION_ID_SIN				enum	FunctionID
FUNCTION_ID_SINH			enum	FunctionID
FUNCTION_ID_SLN				enum	FunctionID
FUNCTION_ID_SQRT			enum	FunctionID
FUNCTION_ID_STD				enum	FunctionID
FUNCTION_ID_STDP			enum	FunctionID
FUNCTION_ID_STRING			enum	FunctionID
FUNCTION_ID_SUM				enum	FunctionID
FUNCTION_ID_SYD				enum	FunctionID
FUNCTION_ID_TAN				enum	FunctionID
FUNCTION_ID_TANH			enum	FunctionID
FUNCTION_ID_TERM			enum	FunctionID
FUNCTION_ID_TIME			enum	FunctionID
FUNCTION_ID_TIMEVALUE			enum	FunctionID
FUNCTION_ID_TODAY			enum	FunctionID
FUNCTION_ID_TRIM			enum	FunctionID
FUNCTION_ID_TRUE			enum	FunctionID
FUNCTION_ID_TRUNC			enum	FunctionID
FUNCTION_ID_UPPER			enum	FunctionID
FUNCTION_ID_VALUE			enum	FunctionID
FUNCTION_ID_VAR				enum	FunctionID
FUNCTION_ID_VARP			enum	FunctionID
FUNCTION_ID_VLOOKUP			enum	FunctionID
FUNCTION_ID_WEEKDAY			enum	FunctionID
FUNCTION_ID_YEAR			enum	FunctionID
FUNCTION_ID_FILENAME			enum	FunctionID
FUNCTION_ID_PAGE			enum	FunctionID
FUNCTION_ID_PAGES			enum	FunctionID
FUNCTION_ID_DEGREES			enum	FunctionID
FUNCTION_ID_RADIANS			enum	FunctionID
PZ < FUNCTION_ID_DB			enum	FunctionID	>
	;
	; External functions (defined by the application) start here.
	;
FUNCTION_ID_FIRST_EXTERNAL_FUNCTION	enum	FunctionID, 0x8000

FunctionType	record
    :7
    FT_PRINT:1
    FT_TRIGONOMETRIC:1
    FT_LOGICAL:1
    FT_STATISTICAL:1
    FT_STRING:1
    FT_TIME_DATE:1
    FT_FINANCIAL:1
    FT_MATH:1
    FT_INFORMATION:1
FunctionType	end

;
; The structures on the OperatorStack can be one of three types
;
EvalStackOperatorType	etype	byte, 0, 1
ESOT_OPERATOR		enum	EvalStackOperatorType
ESOT_FUNCTION		enum	EvalStackOperatorType
ESOT_OPEN_PAREN		enum	EvalStackOperatorType
ESOT_TOP_OF_STACK	enum	EvalStackOperatorType

;
; One structure each for functions and operators.
;
EvalFunctionData	struct
    EFD_functionID	FunctionID		; Function ID if a function
    EFD_nArgs		word			; Number of arguments
EvalFunctionData	ends

EvalOperatorData	struct
    EOD_opType		OperatorType		; Type of the operator
EvalOperatorData	ends

;
; This is a combination of the two structures.
;
EvalStackOperatorData	union
    ESOD_operator	EvalOperatorData
    ESOD_function	EvalFunctionData
EvalStackOperatorData	end

;
; The OperatorStack is made up of these structures.
;
OperatorStackElement	struct
    OSE_type		EvalStackOperatorType	; Type of the operator
    OSE_data		EvalStackOperatorData	; The associated data
OperatorStackElement	ends

;
; The different types of numbers we have.
;
NumberType	etype	byte, 0, 1
NT_VALUE	enum	NumberType	; It's just a number
NT_BOOLEAN	enum	NumberType	; It's a boolean
NT_DATE_TIME	enum	NumberType	; It's a date/time

;
; The possible types of the structures on the argument stack.
;
EvalStackArgumentType	record
    ESAT_EMPTY:1		; Set: Argument came from an empty cell
	;
	; Only one of the following will ever be set at a time for
	; arguments on the evaluator argument stack.
	;
    ESAT_ERROR:1		; Set: Argument is an error
    ESAT_RANGE:1		; Set: Argument is a range
    ESAT_STRING:1		; Set: Argument is a string
    ESAT_NUMBER:1		; Set: Argument is a number
    :1
	;
	; Numbers have some possible sub-types
	;
    ESAT_NUM_TYPE	NumberType:2	; The type of the number
EvalStackArgumentType	end

;
; These constants define some of the argument types which we don't need
; bit-fields for. TOP_OF_STACK has no bits set, so it won't be confused
; with something else. The others are only used in the creation of the
; dependency-list block.
;
ESAT_TOP_OF_STACK = 0
ESAT_NAME	= mask ESAT_RANGE  or mask ESAT_STRING
ESAT_FUNCTION	= mask ESAT_NUMBER or mask ESAT_STRING


EvalNameData	struct
    END_name	word			; The name
EvalNameData	ends

;
; It is assumed (in the code) that the size of this structure is the same
; as the size of the ParserTokenStringConstantData structure.
; See parseEval.asm for more information.
;
EvalStringData	struct
    ESD_length		word			; Length of the string
						; (String data follows)
EvalStringData	ends

;
; Max length of a string.
; Please make this even.
;
MAX_STRING_LENGTH	=	511

EvalRangeData	struct
    ERD_firstCell	CellReference <>
    ERD_lastCell	CellReference <>
EvalRangeData	ends

EvalErrorData	struct
    EED_errorCode	ParserScannerEvaluatorError
EvalErrorData	ends

;
; A union of all the different types.
;
EvalStackArgumentData	union
    ESAD_string		EvalStringData
    ESAD_range		EvalRangeData
    ESAD_error		EvalErrorData
EvalStackArgumentData	end

ArgumentStackElement	struct
    ASE_type		EvalStackArgumentType	; The type of the argument
    ASE_data		EvalStackArgumentData	; The associated data
ArgumentStackElement	ends

MINIMUM_STACK_SPACE	=	(2 * size ArgumentStackElement) + \
				(2 * size OperatorStackElement)

EvalFlags	record
    EF_MAKE_DEPENDENCIES:1	; Make dependencies instead of recalculating
    EF_ONLY_NAMES:1		; Only name dependencies please
    EF_KEEP_LAST_CELL:1		; Don't dereference the last cell
    EF_NO_NAMES:1		; Only non-name dependencies please
    ;
    ; This flag is set inside the evaluator and shouldn't be used by
    ; applications.
    ;
    EF_ERROR_PUSHED:1		; Set: if an error was pushed on the arg stack
    :3
EvalFlags	end

;
; When the evaluator is invoked it needs some information passed in a stack
; frame.
;
EvalParameters	struct
    EP_common		CommonParameters <>
	;
	; Possible callbacks:
	;	CT_LOCK_NAME, CT_LOCK_FUNCTION, CT_UNLOCK
	;
    EP_flags		EvalFlags <>	; Evaluator flags
;
; Everything below this point is initialized by the Evaluator.
;
	EP_fpStack	word		; Floating point stack pointer
	EP_depHandle	word		; Block handle of dependency block
	EP_nestedLevel	word		; Levels of nesting

EVAL_MAX_NESTED_LEVELS	=	32
	EP_nestedAddresses	dword EVAL_MAX_NESTED_LEVELS dup (?)

	align	word
EvalParameters	ends

;
; Structure passed to the format code.
;
FormatParameters	struct
    FP_common		CommonParameters <>
    FP_nChars	word			; Count of chars left in the buffer
FormatParameters	ends

;
; Structure passed to the dependency code.
;
DependencyParameters	struct
    DP_common		CommonParameters <>
	;
	; Possible callbacks:
	;	CT_CREATE_CELL, CT_EMPTY_CELL, CT_NAME_TO_CELL,
	;	CT_FUNCTION_TO_TOKEN
	;
	
	;
	; Everything else here is used exclusively by the dependency list code.
	; Applications do not need to initialize it and should not depend on
	; the values returned in this part of the stack frame.
	;
    DP_dep	dword		; Dbase item containing the dependency list
    DP_prev	dword		; Dbase item containing previous block
    DP_prevIsCell	byte	; Non-zero, previous entry is the cell
    DP_chunk	word		; Chunk handle of the current dependency
    align	word
DependencyParameters	ends

DependencyListHeader	struct
    ;
    ; The "next" link must come first in this structure. It must be at the same
    ; position as the cells dependency list header (which must also fall at the
    ; start of the cell data).
    ;
    DLH_next	dword		; DBase item containing next block in the list
DependencyListHeader	ends

Dependency	struct
    D_row	word		; Row and column of the dependency
    D_column	byte
Dependency	ends

;
; The maximum size of a dbase item in the chain that makes up a dependency list.
; This can be set low for testing.
;
; **** The number of entries must be even (trust me) ***
;
DEPENDENCY_BLOCK_MAX_SIZE = size DependencyListHeader + (1000 * size Dependency)

;
; When generating the dependencies the evaluator keeps a list of them in
; a global memory handle. This structure is at the start of that block
; and is followed by a list of ArgumentStackElements. The types of the
; elements will be one of:
;	Range
;	Cell
;	Name
;
DependencyBlock	struct
    DB_size	word		; Size of the block containing the dependencies
DependencyBlock	ends

C_CallbackUnion	union
    CT_ftt        	CT_FTT_CallbackStruct   
    CT_ntt        	CT_NTT_CallbackStruct  
    CT_cne        	CT_CNE_CallbackStruct   
    CT_cns        	CT_CNS_CallbackStruct   
    CT_ef        	CT_EF_CallbackStruct    
    CT_ln        	CT_LN_CallbackStruct    
    CT_ul        	CT_UL_CallbackStruct    
    CT_ff        	CT_FF_CallbackStruct    
    CT_fn       	CT_FN_CallbackStruct    
    CT_cc        	CT_CC_CallbackStruct    
    CT_ec        	CT_EC_CallbackStruct    
    CT_ntc        	CT_NTC_CallbackStruct   
    CT_ftc        	CT_FTC_CallbackStruct   
    CT_dc        	CT_DC_CallbackStruct    
    CT_sf      		CT_SF_CallbackStruct    
C_CallbackUnion	end

C_CallbackStruct	struc
    C_callbackType	CallbackType
    C_params		fptr
    C_returnDS		word
    C_u			C_CallbackUnion
    align word
C_CallbackStruct	ends

; The CParserStruct is the assembly version of the C CParserStruct
; structure.  It's identical to ParserParameters, but has a far
; pointer to the C callback function and an entire callback
; union structure.
CParserStruct		struc
    C_parameters	ParserParameters
    C_callbackPtr	fptr
    C_callbackStruct	C_CallbackStruct
CParserStruct		ends

; The CFormatStruct is the assembly version of the C CFormatStruct
; structure.  It's identical to FormatParameters, but has a far
; pointer to the C callback function and an entire callback
; union structure.
CFormatStruct		struc
    CF_parameters	FormatParameters
    CF_callbackPtr	fptr
    CF_callbackStruct	C_CallbackStruct
CFormatStruct		ends

; The CEvalStruct is the assembly version of the C CEvalStruct
; structure.  It's identical to EvalParameters, but has a far
; pointer to the C callback function and an entire callback
; union structure.
CEvalStruct		struc
    CE_parameters	EvalParameters
    CE_callbackPtr	fptr
    CE_callbackStruct	C_CallbackStruct
CEvalStruct		ends

; The CDependencyStruct is the assembly version of the C CDependencyStruct
; structure.  It's identical to DependencyParameters, but has a far
; pointer to the C callback function and an entire callback
; union structure.
CDependencyStruct	struc
    DP_parameters	DependencyParameters
    DP_callbackPtr	fptr
    DP_callbackStruct	C_CallbackStruct
CDependencyStruct	ends

;******************************************************************************
;
;	CONSTANTS FOR THE DATE AND TIME ROUTINES
;
;******************************************************************************

YEAR_LENGTH	=	365
YEAR_MAX	=	2099
YEAR_MIN	=	1900
MONTH_MAX	=	12
MONTH_MIN	=	1
DAY_MAX		=	31
DAY_MIN		=	1

HOUR_MAX	=	23
HOUR_MIN	=	0
MINUTE_MAX	=	59
MINUTE_MIN	=	0
SECOND_MAX	=	59
SECOND_MIN	=	0
	
;******************************************************************************
;
;	CONSTANTS FOR REFERENCE FORMATTING ROUTINES
;
;
;******************************************************************************
SBCS< MAX_REFERENCE_SIZE	=	6		;5+NULL 	>
DBCS< MAX_REFERENCE_SIZE	=	(6)*(size wchar) ;5+NULL 	>
SBCS< MAX_CELL_REF_SIZE 	=	5+5+1		;5+5+NULL	>
DBCS< MAX_CELL_REF_SIZE 	=	(5+5+1)*(size wchar) ;5+5+NULL	>
SBCS< MAX_RANGE_REF_SIZE	=	7+7+2		;7+1+7+NULL	>
DBCS< MAX_RANGE_REF_SIZE	=	(7+7+2)*(size wchar) ;7+1+7+NULL >

;
; Maximum size for function argument descriptions for ParserGetFunctionArgs()
;
SBCS< MAX_FUNCTION_ARGS_SIZE	equ	256				>
DBCS< MAX_FUNCTION_ARGS_SIZE	equ	(256)*(size wchar) ; test-> 196	>
SBCS< MAX_FUNCTION_NAME_SIZE	equ	20				>
DBCS< MAX_FUNCTION_NAME_SIZE	equ	(20)*(size wchar)		>
SBCS< MAX_FUNCTION_DESCRIPTION_SIZE	equ	256			>
DBCS< MAX_FUNCTION_DESCRIPTION_SIZE	equ    (256)*(size wchar) ; test-> 196	>

;******************************************************************************

;
; The following assertions test some assumptions which are made (and
; documented) above.
;
.assert (SCANNER_TOKEN_NUMBER		 eq PARSER_TOKEN_NUMBER)
.assert (SCANNER_TOKEN_STRING		 eq PARSER_TOKEN_STRING)
.assert (SCANNER_TOKEN_CELL		 eq PARSER_TOKEN_CELL)
.assert (SCANNER_TOKEN_END_OF_EXPRESSION eq PARSER_TOKEN_END_OF_EXPRESSION)
.assert (SCANNER_TOKEN_OPEN_PAREN        eq PARSER_TOKEN_OPEN_PAREN)
.assert (SCANNER_TOKEN_CLOSE_PAREN       eq PARSER_TOKEN_CLOSE_PAREN)
.assert (SCANNER_TOKEN_IDENTIFIER        eq PARSER_TOKEN_NAME)

.assert (size ScannerTokenNumberData     eq size ParserTokenNumberData)
;;; .assert (size ParserTokenNumberData      eq size EvalNumberData)
.assert (size ScannerTokenCellData       eq size ParserTokenCellData)
.assert (size ScannerTokenIdentifierData eq size ParserTokenNameData)
.assert (size ParserTokenNameData	 eq size ParserTokenFunctionData)
.assert (size ScannerTokenOperatorData   eq size ParserTokenOperatorData)

;******************************************************************************

;
; Global routines definitions.
;
global	ParserParseString:far
;
; Convert a string into a parsed expression
;
; PASS:		ds:si - ptr to text to scan
;		es:di - buffer to put parsed data in
;		ss:bp - ParserParameters
; RETURN:	carry - set if error
;			al - ParserScannerEvaluatorError
;			cx, dx - start, end of text where error occurred
;		es:di - ptr paste last token written
;
global	ParserEvalExpression:far
; Evaluate a parsed expression

global	ParserFormatExpression:far
; Format an expression from parsed data

global	ParserErrorMessage:far
; Get an error message for a parser error

global	ParserEvalPushArgument:far
; Push an argument on the ArgumentStack

global	ParserEvalPopNArgs:far
; Pop a number of arguments off the stack

global	ParserEvalForeachArg:far
; Call a callback once foreach argument

global	ParserEvalPushNumericConstant:far
; Push a number on the argument stack

global	ParserEvalPushNumericConstantWord:far
;

global	ParserEvalPushStringConstant:far
; Push a string on the argument stack

global	ParserEvalPushCellReference:far
; Push a cell reference on the argument stack

global	ParserEvalPushRange:far
; Push a range on the argument stack

global	ParserEvalRangeIntersection:far
; Implements the range intersection operator

global	ParserEvalPropagateEvalError:far
; Propagate an error on the eval stack

global	ParserAddDependencies:far
; Add a set of dependencies

global	ParserRemoveDependencies:far
; Remove a set of dependencies

global	ParserAddSingleDependency:far
; Add a single dependency to a cell

global	ParserForeachReference:far	; Process each cell/name reference
global  ParserForeachReferenceOLD:far	; buggy version
global	ParserForeachToken:far		; Process each cell/name token
global	ParserForeachTokenOLD:far	; buggy version
global	ParserForeachPrecedent:far	; Process each precedent

global	ParserFormatColumnReference:far	;format 0-based column # (eg. 27='AB')
global	ParserFormatRowReference:far	;format 0-based row # (eg. 27='28')
global	ParserFormatWordConstant:far	;format word constant (eg. 27='27')
global	ParserFormatCellReference:far	;format cell reference (eg. "AB27")
global	ParserFormatRangeReference:far	;format range reference (eg. "A1:C3")

global	ParserGetNumberOfFunctions:far	; return the number of functions
global	ParserGetFunctionMoniker:far	; return the name of a function
global	ParserGetFunctionArgs:far	; return arguments for a function
global	ParserGetFunctionDescription:far ;return description for a function

; C Stubs
global	PARSERGETNUMBEROFFUNCTIONS:far	; return the number of functions
global	PARSERGETFUNCTIONMONIKER:far	; return the name of a function
global	PARSERGETFUNCTIONARGS:far	; return arguments for a function
global	PARSERGETFUNCTIONDESCRIPTION:far ;return description for a function
global	PARSERFORMATCOLUMNREFERENCE:far	; format 0-based column # (eg. 27='AB')
global	PARSERPARSESTRING:far		; parse a string into tokens 
global	PARSERFORMATEXPRESSION:far	; format tokens into a string
global	PARSEREVALEXPRESSION:far	; evaluate a tokenized expression

global	ParserLocalizeFormats:far	; incorporate localization information

EndLibrary	parse
