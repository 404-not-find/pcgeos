COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) GeoWorks 1993 -- All Rights Reserved

PROJECT:	PC/GEOS System	
MODULE:		PCMCIA Library
FILE:		pcmcia.def

AUTHOR:		Todd Stumpf, Jul  6, 1993

MACROS:
	Name			Description
	----			-----------

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	TS	7/ 6/93   	Initial revision

DESCRIPTION:
	The PCMCIA library's primary purpose is to allow
	users to configure PCMCIA cards to suit their needs.

	This usually means changing the hardware settings of
	IO cards, but it also manipulates memory and disk
	cards as well.

	The library works on a level above Card Services, using
	card services to actually manipulate the pcmcia card.

	$Id: pcmcia.def,v 1.1 97/04/04 14:24:34 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

SetDef	__PCMCIA

StartLibrary		pcmcia

include	Internal/fsd.def

;------------------------------------------------------------------------------
;
;			   CIS DEFINITIONS
;
;------------------------------------------------------------------------------
CISTuple	etype	byte
CISTPL_NULL		enum CISTuple, 000h
CISTPL_DEVICE		enum CISTuple, 001h
	; Followed by array of variable-length entries describing each device
	; in the common address space, starting from address 0.
	;
	; Each entry begins with a DeviceID, possibly followed by extended
	; speed record and extended device type bytes, followed by a 
	; DeviceSize record.
	;
	; Final DeviceSize record is followed by 0xff byte
	; 

    DeviceSpeed	etype	byte
    DS_NULL		enum	DeviceSpeed		; Null speed
    DS_250NS	enum	DeviceSpeed		; 250 nano-seconds
    DS_200NS	enum	DeviceSpeed		; 200 nano-seconds
    DS_150NS	enum	DeviceSpeed		; 150 nano-seconds
    DS_100NS	enum	DeviceSpeed		; 100 nano-seconds
    DS_EXT		enum	DeviceSpeed, 7		; extended device speed

    DeviceSpeedMantissa	etype byte
    DSM_RESERVED		enum	DeviceSpeedMantissa
    DSM_1_0			enum	DeviceSpeedMantissa
    DSM_1_2			enum	DeviceSpeedMantissa
    DSM_1_3			enum	DeviceSpeedMantissa
    DSM_1_5			enum	DeviceSpeedMantissa
    DSM_2_0			enum 	DeviceSpeedMantissa
    DSM_2_5			enum	DeviceSpeedMantissa
    DSM_3_0			enum 	DeviceSpeedMantissa
    DSM_3_5			enum 	DeviceSpeedMantissa
    DSM_4_0			enum 	DeviceSpeedMantissa
    DSM_4_5			enum 	DeviceSpeedMantissa
    DSM_5_0			enum	DeviceSpeedMantissa
    DSM_5_5			enum	DeviceSpeedMantissa
    DSM_6_0			enum	DeviceSpeedMantissa
    DSM_7_0			enum	DeviceSpeedMantissa
    DSM_8_0			enum	DeviceSpeedMantissa

    DeviceSpeedExponent	etype	byte
    DSE_1_NANOSECOND	enum	DeviceSpeedExponent
    DSE_10_NANOSECOND	enum	DeviceSpeedExponent
    DSE_100_NANOSECOND	enum	DeviceSpeedExponent
    DSE_1_MICROSECOND	enum	DeviceSpeedExponent
    DSE_10_MICROSECOND	enum	DeviceSpeedExponent
    DSE_100_MICROSECOND	enum	DeviceSpeedExponent
    DSE_1_MILLISECOND	enum	DeviceSpeedExponent
    DSE_10_MILLISECOND	enum	DeviceSpeedExponent

    ExtendedDeviceSpeed	record
	EDS_EXT:1,			; set if more bytes make up speed
	EDS_MANTISSA DeviceSpeedMantissa:4	; need I say more?
	EDS_EXPONENT DeviceSpeedExponent:3
    ExtendedDeviceSpeed	end

    DeviceType		etype	byte
	DTYPE_NULL	enum DeviceType, 0x0
	DTYPE_ROM	enum DeviceType, 0x1
	DTYPE_OTPROM	enum DeviceType, 0x2
	DTYPE_EPROM	enum DeviceType, 0x3
	DTYPE_EEPROM	enum DeviceType, 0x4
	DTYPE_FLASH	enum DeviceType, 0x5
	DTYPE_SRAM	enum DeviceType, 0x6
	DTYPE_DRAM	enum DeviceType, 0x7
	DTYPE_FUNCSPEC	enum DeviceType, 0xd
	DTYPE_EXTENDED	enum DeviceType, 0xe

    DeviceID	record
	DID_TYPE DeviceType:4
	DID_WPS:1		; is device affected by write-protect switch?
	DID_SPEED DeviceSpeed:3
    DeviceID	end
    
    DeviceSizeUnit	etype byte
        DSU_512		enum DeviceSizeUnit
	DSU_2K		enum DeviceSizeUnit
	DSU_8K		enum DeviceSizeUnit
	DSU_32K		enum DeviceSizeUnit
	DSU_128K	enum DeviceSizeUnit
	DSU_512K	enum DeviceSizeUnit
	DSU_2M		enum DeviceSizeUnit

    DeviceSize record
	DS_NUM_UNITS:5			; number of units - 1
	DS_UNITS DeviceSizeUnit:3	; size of each unit
    DeviceSize end

CISTPL_CHECKSUM		enum CISTuple, 010h
CISTPL_LONGLINK_A	enum CISTuple, 011h
	; Followed by 1-4 bytes giving the address within attribute space of
	; the next CIS to process.

CISTPL_LONGLINK_C	enum CISTuple, 012h
	; Followed by 1-4 bytes giving the address within common space of
	; the next CIS to process.

CISTPL_LINKTARGET	enum CISTuple, 013h
	; Found only at the start of a secondary CIS. Followed by at least
	; three bytes containing the ascii codes for "CIS"

CISTPL_NO_LINK		enum CISTuple, 014h
	; Followed by nothing; indicates default chain (to common:0) should
	; not be taken.

CISTPL_VERS_1		enum CISTuple, 015h
	; Level-1-compliant product info.
	;
	; Followed by major number (1 byte s/b 4), minor number (1 byte s/b 1)
	; and up to four null-terminated strings:
	; 	- product manufacturer
	; 	- product name
	; 	- additional info #1 (lot number?)
	; 	- additional info #2 (programming conditions?)
	; a single 0xff byte
	; 

CISTPL_ALTSTR		enum CISTuple, 016h
CISTPL_DEVICE_A		enum CISTuple, 017h
	; Same as CISTPL_DEVICE, but defines devices that reside in attribute
	; memory space, not common memory space.

CISTPL_JEDEC_C		enum CISTuple, 018h
CISTPL_JEDEC_A		enum CISTuple, 019h
CISTPL_CONFIG		enum CISTuple, 01ah
	; Specify a group of acceptable configurations.
	; First comes a ConfigFieldSizes record, then the number of
	; configurations the card supports, then the fields whose sizes
	; are indicated, then subtuples indicating special configuration
	; information.
    ConfigFieldSizes record
        CFS_RFU:2	; number of bytes reserved for future use
	CFS_MASK_SIZE:4	; number of bytes that make up the bitmask of
			;  available configuration registers - 1
	CFS_ADDR_SIZE:2	; number of bytes that make up the base address for
			;  configuration registers - 1
    ConfigFieldSizes end


CISTPL_CFTABLE_ENTRY	enum CISTuple, 01bh
    ConfigTableIndex	record
	CTI_interface:1	; interface bit says whether there is an IFType byte
			; in the ConfigTableEntry tuple
	CTI_default:1	; bit set if this configuration is the default config
	CTI_entryNumber:6	; value used to select this configuration
    ConfigTableIndex	end

    InterfaceType	etype	byte		; aka IFtype
    IF_MEMORY		enum InterfaceType, 1
    IF_IO		enum InterfaceType, 2

    ConfigTableIFDescription record
	CTIFD_wait:1	; wait signal support required for memory cycles
	CTIFD_readyBusy:1 
			; ready busy active and should be recoverd from
			; Pin Replacement Register if not available on pin 16
	CTIFD_writeProtect:1 
			; write protect state us active and should be recovered
			; from PRR if not available on pin 33
	CTIFD_BVDs:1	; BVD1 and BVD2 statuses are active and should be
			; recoved from PRR if not available on pins 62 and 63
	CTIFD_IFType InterfaceType:4	; InterfaceType
    ConfigTableIFDescription	end

	; this record determins which compace decriptive fields aaare in the
	; ConfigTableEntry
    FeatureSelection	record
	FS_misc:1	; if set a miscellaneous fields structure is present
	FS_memSpace:2	; 0 = no memory space field present
			; 1 = single 2 byte length
			; 2 = length (2 bytes) and card address (2 bytes)
			; 3 = a memory space selection byte followed by
			; memory-space descriptors is present
	FS_irq:1	; an irq field descriptor is present
	FS_ioSpace:1	; an io space field descriptor is presend
	FS_timing:1	; a timing field descriptor is present
	FS_power:2	; 0 = no power descriptor
			; 1 = Vcc power desciptor only
			; 2 = Vcc and Vpp (Vpp1 = Vpp2)
			; 3 = Vcc, Vpp1 and Vpp2
    FeatureSelection	end

    PowerDescriptor	record
	PD_nomimalVoltage:1
	PD_minimunVoltable:1
	PD_maximumVoltage:1
	PD_staticCurrent:1
	PD_averageCurrent:1
	PD_peakCurrent:1
	PD_powerDownCurrent:1
	PD_RFU:1
    PowerDescriptor	end

	; for voltages: exponent = 0 for 100 micro volts
	; for currents: exponent = 0 for 100 nano amps
    PowerDescriptorValue record  
	PDV_ext:1		; extention bit
	PDV_mantissa:4		; mantissa for value
	PDV_exponent:3		; exponent for value
    PowerDescriptorValue end

    TimingInformation	record
	TI_reservedScale:3	
	TI_readyBusyScale:3 	; max power of 10 for busy state
	TI_waitScale:2		; max power of 10 for a wait 
    TimingInformation	end

    IOSpaceDescriptor	record
	IOSD_range:1	; an I/O range descriptor byte follow this byte
	IOSD_bus16:1	; can handle 16 bit buses
	IOSD_bus8:1	; can handle 8 bit buses
	IOSD_addressLines:5	; total number of address lines used
    IOSpaceDescriptor	end

    IORangeDescriptor	record
	IORD_lengthSize:2	; length and address have same format 
	IORD_addressSize:2	; 0 = none
				; 1 = 1 byte long
				; 2 = 2 bytes long
				; 3 = 4 bytes long
	IORD_numberOfRanges:4	; 'nuff said
    IORangeDescriptor	end

    IrqDescriptor	record
	ID_share:1		; sharing logic
	ID_pulse:1		; set to allow pulsing to request an interrupt
	ID_level:1		; can repsond to level interrupts
	ID_mask:1		; describes destination of interrupt
	ID_nmi:1		; non-maskabke interrupt (mask = 1 only)
	ID_lock:1		; I/O check signal (mask = 1 only)
	ID_busError:1		; bus error signal (mask = 1 only)
	ID_vendor:1		; vendor specific signal (mask = 1 only)
    IrqDescriptor	end

    MemSpaceDescriptor	record
	MSD_hostAddress:1	; set if host address is present
	MSD_cardAddressSize:2	; size of card address
	MSD_lengthSize:2	; size of length
	MSD_windows:3		; number of window descriptors following - 1
    MemSpaceDescriptor	end

    ConfigurationOptionRegister record
	COR_sreset:1		; reset card
	COR_levelRequest:1	; get level interrupts, not pulse interrupts
	COR_index:6		; index value to select configuration
    ConfigurationOptionRegister	end

    StatusRegisterOrganization	record
	SRO_changed:1		; one or more Pin Replacement registers has 
				; been set to 1 if this is set
	SRO_stateChange:1	; set to 1 if you want to get state changes
	SRO_8BitBus:1		; set to 1 for hosts that can only do 8 bit
				; data transfers
	SRO_reseved:1
	SRO_audio:1		; enable audio information when set
	SRO_powerDown:1		; set to 1 to enter power down state
	SRO_interrupt:1		; internal interrupt request state 
     StatusRegisterOrganization	end

CISTPL_DEVICE_OC	enum CISTuple, 01ch
	; Specify different device characteristics if certain conditions
	; apply. Replaces CISTPL_DEVICE if the indicated conditions exist.
    OtherConditions record
        OC_3VCC:1		; if 3.3V power applied (indicates card can
				;  support 3.3V)
	OC_MWAIT:1		; if -WAIT signal supported
    OtherConditions end

CISTPL_DEVICE_OA	enum CISTuple, 01dh

CISTPL_DEVICEGEO	enum CISTuple, 01eh		; v2.01
CISTPL_DEVICEGEO_A	enum CISTuple, 01fh		; v2.01

CISTPL_MANFID		enum CISTuple, 020h		; v2.01
CISTPL_FUNCID		enum CISTuple, 021h		; v2.01
    CISCardFunction	etype	byte, 0, 1
    CISCF_MULTI_FUNCTION	enum CISCardFunction	; additional FUNCID
							;  tuples follow with
							;  each function
    CISCF_MEMORY		enum CISCardFunction
    CISCF_SERIAL_PORT		enum CISCardFunction
    CISCF_PARALLEL_PORT		enum CISCardFunction
    CISCF_FIXED_DISK		enum CISCardFunction
    CISCF_VIDEO_ADAPTER		enum CISCardFunction
    CISCF_NETWORK_ADAPTER	enum CISCardFunction
    CISCF_AIMS			enum CISCardFunction
    
    CISSysInitMask	record
	:6
        CISSIM_ROM:1		; card holds expansion ROM that needs to be
				;  mapped in and configured during
				;  system initialization
	CISSIM_POST:1		; card should be configured during power-on
				;  self-test
    CISSysInitMask	end
    
CISTPL_FUNCE		enum CISTuple, 022h		; v2.01
    
CISTPL_VERS_2		enum CISTuple, 040h
CISTPL_FORMAT		enum CISTuple, 041h

    TPLFormatType	etype	byte, 0, 1
    TPLFT_DISK	enum	TPLFormatType
    TPLFT_MEM	enum	TPLFormatType
    TPLFT_VS	enum	TPLFormatType, 0ffh
    
    TPLFormat	struct
	TPLFMT_type	TPLFormatType
	TPLFMT_EDC	byte
	TPLFMT_offset	dword
	TPLFMT_size	dword
    TPLFormat	ends
	

CISTPL_GEOMETRY		enum CISTuple, 042h
CISTPL_BYTEORDER	enum CISTuple, 043h
CISTPL_DATE		enum CISTuple, 044h
CISTPL_BATTERY		enum CISTuple, 045h

CISTPL_ORG		enum CISTuple, 046h

    TPLOrgType	etype	byte, 0, 1
	TPLOT_FS	enum	TPLOrgType
	TPLOT_APP	enum	TPLOrgType
	TPLOT_ROMCODE	enum	TPLOrgType


    TPLOrg	struct
	TPLORG_type	TPLOrgType
	TPLORG_data	label	char
    TPLOrg	ends

CISTPL_END		enum CISTuple, 0ffh

;------------------------------------------------------------------------------
;
;		      CARD SERVICES DEFINITIONS
;
;------------------------------------------------------------------------------

;
; All Card Services functions return with the carry flag indicating success
; or failure (set => failure), and AX being a return code from the
; CardServicesReturnCode enumerated type.
; 
CardServicesFunction			etype	word

CSF_CLOSE_MEMORY			enum	CardServicesFunction, 000h
    ;
    ;	CloseMemory
    ;
    ;	Pass:	al	= CSF_CLOSE_MEMORY
    ;		dx	= memory handle
    ;	Return:	carry + AX
    ;

CSF_COPY_MEMORY				enum	CardServicesFunction, 001h
    ;
    ;	CopyMemory
    ;
    ;	Pass:	al	= CSF_COPY_MEMORY
    ;		dx	= memory handle
    ;		cx	= argument length
    ;		es:bx	= CSCopyMemoryArgs
    ;	Return:	carry + AX
    ;
    ;	May not be used for memory handles that reference attribute
    ;	memory.
    ;

    CSCopyMemoryAttrs	record
	:12
	CSCMA_VERIFY_AFTER_WRITE:1
	CSCMA_DISABLE_ERASE_BEFORE_WRITE:1
	:2
    CSCopyMemoryAttrs	end

    CSCopyMemoryArgs	struct
	CSCMA_sourceOffset	dword	; offset within region for
					;  source of move
	CSCMA_destOffset	dword	; offset within region for
					;  destination of move
	CSCMA_count		dword	; number of bytes to move
	CSCMA_attributes	CSCopyMemoryAttrs
    CSCopyMemoryArgs	ends

CSF_DEREGISTER_CLIENT			enum	CardServicesFunction, 002h
    ;
    ;	DeregisterClient
    ;
    ;	Pass:	al	= CSF_DEREGISTER_CLIENT
    ;		dx	= client handle
    ;	        cx      = 0 (for 2.01+)
    ;	Return:	carry + AX
    ;

CSF_GET_CLIENT_INFO			enum	CardServicesFunction, 003h
    ;
    ;	GetClientInfo
    ;
    ;	Pass:	al	= CSF_GET_CLIENT_INFO
    ;		dx	= client handle for which info is desired
    ;		cx	= argument length
    ;		es:bx	= CSGetClientInfoArgs
    ;	Return:	carry + ax
    ;		CSGCIA_clientInfo, CSGCIA_attributes, and CSGCIA_infoLen
    ;		filled in
    ;

    CSDateInfo	record
	CSDI_YEAR	:7		; year (from 1980) 1980=0, 1992=12, etc
	CSDI_MONTH	:4		; month (1-12)
	CSDI_DAY	:5		; day (1-31)
    CSDateInfo	end

    CSGCI_STRING_BUFFER_LENGTH	equ	256	; seems enough
    CSClientInfoBuffer	type	CSGCI_STRING_BUFFER_LENGTH	dup (char)

    ;
    ;  The following structure (Client Info) has two strings at
    ;  the end.  The offset field for each is the offset into the 
    ;  structure at which the string starts.  The length string is 
    ;  the length ofthe ASCIIZ string, including the null terminator.
    ;
    ;  We try to allocate enough space for name & vendor strings at the end.
    ;
    CSClientInfo	struct
	CSCI_revision		word		;BCD value of vendor client rev
	CSCI_csLevel		word		; BCD value of CS release
	CSCI_revDate		CSDateInfo	; revision date
	CSCI_nameOffset		nptr		; offset to client name string
	CSCI_nameLength		word		; length of client name string
	CSCI_vStringOffset	nptr		; offset to vendor string
	CSCI_vStringLength	word		; length of vendor string
	CSCI_data		CSClientInfoBuffer	; string section
    CSClientInfo	ends

    CSGetClientInfoArgsAttributes	record
	CSGCIAA_INFO_SUBFUNCTION:8		; Info Subfunction
	CSGCIAA_RESERVED:3			; do not use
	CSGCIAA_EXCLUSIVE_CARDS:1		; CARD_INSERTION events for
						;  cards being exclusively
						;  used.
	CSGCIAA_SHARABLE_CARDS:1		; CARD_INSERTION events for
						;  sharable PC cards.
	CSGCIAA_IO_CLIENT_DEVICE_DRIVER:1	; 
	CSGCIAA_MEMORY_TECHNOLOGY_DRIVER:1	; 
	CSGCIAA_MEMORY_CLIENT_DEVICE_DRIVER:1	; 
    CSGetClientInfoArgsAttributes	end

    CSGetClientInfoArgs	struct
	CSGCIA_maxLen		word		; length of this packet (same
						;  as CX)
	CSGCIA_infoLen		word		; # bytes required to hold all
						;  info. If > maxLen, then not
						;  all info has been returned.
	CSGCIA_attributes	CSGetClientInfoArgsAttributes
	CSGCIA_clientInfo	CSClientInfo
    CSGetClientInfoArgs	ends

CSF_GET_CONFIGURATION_INFO		enum	CardServicesFunction, 004h
    ;
    ;	GetConfigurationInfo
    ;
    ;	Pass:	al	= CSF_GET_CONFIGURATION_INFO
    ;		cx	= buffer size
    ;		es:bx	= CSGetConfigurationInfoArgs
    ;	Return:	carry + ax
    ;		dx	= handle of client that configured the card
    ;		
    ;
    CSGetConfigurationInfoAttrs record
        :7
	CSGCIA_VALID_CLIENT:1
	:6
	CSGCIA_IRQ_STEERING:1
	CSGCIA_EXCLUSIVELY_USED:1
    CSGetConfigurationInfoAttrs end

    CSCardValues record			; which registers have been programmed
        :4
	CSCV_COPY_VALUE_VALID:1
	CSCV_PIN_VALUE_VALID:1
	CSCV_STATUS_VALUE_VALID:1
	CSCV_OPTION_VALUE_VALID:1
    CSCardValues end

    CSIRQType	etype byte, 0, 1
        CSIRQT_EXCLUSIVE	enum CSIRQType
	CSIRQT_TIME_MULTIPLEXED	enum CSIRQType
	CSIRQT_DYNAMIC_SHARED	enum CSIRQType
	
    CSIRQAttributes record
        :7
	CSIRQA_PULSE_ALLOCATED:1
	:4
	CSIRQA_FIRST_SHARED:1
	CSIRQA_FORCE_PULSE:1
	CSIRQA_TYPE CSIRQType:2
    CSIRQAttributes end
    
    CSIOAttributes record
        :4
	CSIOA_16_BIT:1
	CSIOA_FORCE_ALIAS:1
	CSIOA_FIRST_SHARED:1
	CSIOA_SHARED:1
    CSIOAttributes end

    CSInterfaceType	record
        :6
	CSIT_MEM_AND_IO:1
	CSIT_MEMORY:1
    CSInterfaceType	end

    CSGetConfigurationInfoArgs	struct
        CSGCfIA_socket		word		; socket for which info
						;  requested
	CSGCfIA_attributes	CSGetConfigurationInfoAttrs
	CSGCfIA_Vcc		byte		; current Vcc (V * 10)
	CSGCfIA_Vpp1		byte		; current Vpp1 (V * 10)
	CSGCfIA_Vpp2		byte		; current Vpp2 (V * 10)
	CSGCfIA_intType		CSInterfaceType	; current interface
	CSGCfIA_configBase	dword		; base of config registers
	CSGCfIA_statusReg	byte		; current status reg, if present
	CSGCfIA_pinReg		byte		; current pin replacment reg,
						;  if present
	CSGCfIA_copyReg		byte		; current socket/copy reg, if
						;  present
	CSGCfIA_optionReg	byte		; current option reg, if present
	CSGCfIA_present		byte		; mask of present registers
	CSGCfIA_firstDevice	DeviceType	; first entry in
						;  CISTPL_DEVICE
	CSGCfIA_funcCode	CISCardFunction	; from FUNCTION_ID tuple
	CSGCfIA_sysInitMask	CISSysInitMask	; from FUNCTION_ID tuple
	CSGCfIA_manufCode	word		; from MANUF_ID tuple
	CSGCfIA_manufInfo	word		; from MANUF_ID tuple
	CSGCfIA_cardValues	CSCardValues	; valid card register values
	CSGCfIA_assignedIRQ	byte		; 0xff if none assigned
	CSGCfIA_irqAttributes	CSIRQAttributes
	CSGCfIA_basePort1	word
	CSGCfIA_numPorts1	byte
	CSGCfIA_ioAttributes1	CSIOAttributes
	CSGCfIA_basePort2	word
	CSGCfIA_numPorts2	byte
	CSGCfIA_ioAttributes2	CSIOAttributes
	CSGCfIA_ioAddrLines	byte		; number of I/O lines decoded
    CSGetConfigurationInfoArgs	ends
	.assert size CSGetConfigurationInfoArgs eq 37

	
CSF_GET_FIRST_PARTITION			enum	CardServicesFunction, 005h
    ;
    ;	GetFirstPartition
    ;
    ;	Pass:	al	= CSF_GET_FIRST_PARTITION
    ;		cx	= argument length
    ;		es:bx	= CSGetPartitionArgs
    ;	Return:	carry + ax
    ;
    
    CSWriteEraseInteraction etype byte, 0, 1
        CSWEI_NO_ERASE			enum CSWriteEraseInteraction
	CSWEI_WITH_ERASE		enum CSWriteEraseInteraction
	CSWEI_RESERVED			enum CSWriteEraseInteraction
	CSWEI_ERASE_DISABLEABLE		enum CSWriteEraseInteraction

    CSPartitionAttributes record
	:3
        CSPA_ERASE_SUPPORTED:1
	CSPA_WRITE_WITH_VERIFY:1
	CSPA_ERASE_TYPE CSWriteEraseInteraction:2
	CSPA_VIRTUAL_PARTITION:1
	:7
	CSPA_ATTRIBUTE_MEMORY:1
    CSPartitionAttributes end

    CSTupleMask	record	; bit is set if field determined from tuples
	:1
        CSTM_PART_TYPE:1		; only for GET_*_PARTITION
	CSTM_JEDEC_ID:1
	CSTM_PART_MULTIPLE:1
	CSTM_EFF_BLOCK_SIZE:1
	CSTM_PART_SIZE:1
	CSTM_CARD_OFFSET:1
	CSTM_SPEED:1
    CSTupleMask	end

    CSPartitionFormat	etype word
        CSPF_NO_TYPE		enum CSPartitionFormat, 0
	CSPF_FAT_FS		enum CSPartitionFormat, 1
	CSPF_FFS_I		enum CSPartitionFormat, 2
	CSPF_FFS_II		enum CSPartitionFormat, 3
	CSPF_XIP		enum CSPartitionFormat, 4
	CSPF_UNKNOWN		enum CSPartitionFormat, 7fffh

    CSPartitionType	record
        CSPT_HAS_EDC:1
	CSPT_FORMAT CSPartitionFormat:15
    CSPartitionType	end

    CSEnumState	struct		; state internal to Card Services when
				;  enumerating partitions, regions, or the CIS.
				;  DO NOT MODIFY
	CSES_flags		word
	CSES_linkOffset		dword
	CSES_cisOffset		dword
    CSEnumState	ends

    CSGetPartitionArgs	struct
        CSGPA_socket		word
	CSGPA_attributes	CSPartitionAttributes
	CSGPA_tupleMask		CSTupleMask
	CSGPA_speed		ExtendedDeviceSpeed	; EDS_EXT => use -WAIT
							; EDS_MANTISSA == 0 =>
							;  EDS_EXPONENT =
							;  DeviceSpeed
	CSGPA_internal		CSEnumState
	CSGPA_cardOffset	dword		; start of partition
	CSGPA_partSize		dword		; size of partition
	CSGPA_effBlockSize	dword		; erasure unit
	CSGPA_partMultiple	word
	CSGPA_jedecID		word
	CSGPA_partType		CSPartitionType
    CSGetPartitionArgs	ends
	.assert size CSGetPartitionArgs eq 34

CSF_GET_FIRST_REGION			enum	CardServicesFunction, 006h
    ;
    ;	GetFirstRegion
    ;
    ;	Pass:	al	= CSF_GET_FIRST_REGION
    ;		cx	= argument length
    ;		es:bx	= CSGetRegionArgs
    ;	Return:	carry + ax
    ;		dx	= handle of MTD client for the region
    ;

    CSGetRegionArgs	struct
        CSGRA_socket		word
	CSGRA_attributes	CSPartitionAttributes
	CSGRA_tupleMask		CSTupleMask
	CSGRA_speed		ExtendedDeviceSpeed	; EDS_EXT => use -WAIT
							; EDS_MANTISSA == 0 =>
							;  EDS_EXPONENT =
							;  DeviceSpeed
 	CSGRA_internal		CSEnumState
	CSGRA_cardOffset	dword		; start of region
	CSGRA_regionSize	dword		; size of region
	CSGRA_effBlockSize	dword		; erasure unit
	CSGRA_partMultiple	word
	CSGRA_jedecID		word
    CSGetRegionArgs	ends
    	.assert size CSGetRegionArgs eq 32

CSF_GET_FIRST_TUPLE			enum	CardServicesFunction, 007h
    ;
    ;	GetFirstTuple
    ;
    ;	Pass:	al	= CSF_GET_FIRST_TUPLE
    ;		cx	= argument length
    ;		es:bx	= CSGetTupleArgs
    ;	Return:	carry + ax
    ;

    CSGetTupleAttributes record
        :15
	CSGTA_RETURN_LINK_TUPLES:1
    CSGetTupleAttributes end
    
    CSGetTupleArgs	struct
        CSGTA_socket		word
	CSGTA_attributes	CSGetTupleAttributes
	CSGTA_desiredTuple	CISTuple	; CISTPL_END to enumerate all
				byte	0
	CSGTA_internal		CSEnumState
	CSGTA_tupleCode		CISTuple	; tuple found
	CSGTA_tupleLink		byte		; link value found (data size,
						;  usually)
    CSGetTupleArgs	ends
    	.assert size CSGetTupleArgs eq 18

CSF_GET_NEXT_PARTITION			enum	CardServicesFunction, 008h
    ;
    ;	GetNextPartition
    ;
    ;	Pass:	al	= CSF_GET_NEXT_PARTITION
    ;		cx	= argument length
    ;		es:bx	= CSGetPartitionArgs
    ;	Return:	carry + ax
    ;

CSF_GET_NEXT_REGION			enum	CardServicesFunction, 009h
    ;
    ;	GetNextRegion
    ;
    ;	Pass:	al	= CSF_GET_NEXT_REGION
    ;		cx	= argument length
    ;		es:bx	= CSGetRegionArgs
    ;	Return:	carry + ax
    ;		dx	= handle of MTD client for the region
    ;

CSF_GET_NEXT_TUPLE			enum	CardServicesFunction, 00ah
    ;
    ;	GetNextTuple
    ;
    ;	Pass:	al	= CSF_GET_NEXT_TUPLE
    ;		cx	= argument length
    ;		es:bx	= CSGetTupleArgs
    ;	Return:	carry + ax
    ;

CSF_GET_CARD_SERVICES_INFO		enum	CardServicesFunction, 00bh
    ;
    ;	GetCardServicesInfo
    ;
    ;	Pass:	al	= CSF_GET_CARD_SERVICES_INFO
    ;		cx	= argument length
    ;		es:bx	= CSGetCSInfoArgs
    ;	Return:	carry + ax
    ;

    CSGetCSInfoArgs		struct
	CSGCSIA_infoLen		word		; total info CS would like to
						;  return. if > arg length,
						;  you didn't get it all
	CSGCSIA_signature	char 2 dup (0)	; 00h or 'C''S'
	CSGCSIA_socketCount	word		; # of pcmcia sockets
	CSGCSIA_revision	word		; vendor version # (BCD)
	CSGCSIA_csVersion	word		; Card Services version (BCD)
	CSGCSIA_vendorPtr	nptr		; offset to vendor string
	CSGCSIA_vendorLen	word		; length of string
	CSGCSIA_vendorString	char 114 dup (0); 114 bytes of string space
    CSGetCSInfoArgs		ends

CSF_GET_STATUS				enum	CardServicesFunction, 00ch
    ;
    ;	GetStatus
    ;
    ;	Pass:	al	= CSF_GET_STATUS
    ;		cx	= argument length
    ;		es:bx	= CSGetStatusArgs
    ;	Return:	carry + ax
    ;
    ;	CSRC_NO_CARD will *not* be returned if there is no card in the socket.
    ;

    CSGetStatusCardState		record
	:8
	CSGSCS_CARD_DETECT:1			; set if true
	CSGSCS_READY:1				; set if true
	CSGSCS_LOW_VOLTAGE:1			; set if true
	CSGSCS_DEAD_VOLTAGE:1			; set if true
	CSGSCS_INSERT_REQUEST:1			; set if true
	CSGSCS_EJECT_REQUEST:1			; set if true
	CSGSCS_CARD_LOCK:1			; set if true
	CSGSCS_WRITE_PROTECT:1			; set if true
    CSGetStatuCardState			end

    CSGetStatusSocketState		record
	:8
	CSGSSS_CARD_DETECT_CHANGE:1		; set if true
	CSGSSS_READY_CHANGE:1			; set if true
	CSGSSS_LOW_VOLT_CHANGE:1		; set if true
	CSGSSS_DEAD_VOLT_CHANGE:1		; set if true
	CSGSSS_INSERT_REQ_PENDING:1		; set if true
	CSGSSS_EJECT_REQ_PENDING:1		; set if true
	CSGSSS_CARD_LOCK_CHANGE:1		; set if true
	CSGSSS_WRITE_PROTECT_CHANGE:1		; set if true
    CSGetStatusSocketState		end

    CSGetStatusArgs		struct
	CSGSA_socket		word			; The socket to check
	CSGSA_cardState		CSGetStatusCardState	; Current state
	CSGSA_socketState	CSGetStatusSocketState	; Current state
    CSGetStatusArgs		ends

CSF_GET_TUPLE_DATA			enum	CardServicesFunction, 00dh
    ;
    ;	GetTupleData
    ;
    ;	Pass:	al	= CSF_GET_TUPLE_DATA
    ;		cx	= argument length
    ;		es:bx	= CSGetTupleDataArgs
    ;	Return:	carry + ax
    ;
    ;	CSGetTupleDataArgs is actually the same as CSGetTupleArgs, except it's
    ;	a bit longer. The two are designed to overlay well, however. 
    ;
    
    CSGetTupleDataArgs	struct
        CSGTDA_socket		word
	CSGTDA_attributes	CSGetTupleAttributes
	CSGTDA_desiredTuple	CISTuple
	CSGTDA_tupleOffset	byte		; offset into tuple from which
						;  to read
	CSGTDA_internal		CSEnumState
	CSGTDA_maxData		word		; most # bytes to return
	CSGTDA_dataLen		word		; number of bytes in the tuple
						;  body. may be larger than
						;  maxData (XXX: minus the
						;  tupleOffset?)
	CSGTDA_data		label	byte	; data buffer for return starts
						;  here
    CSGetTupleDataArgs	ends
    	.assert size CSGetTupleDataArgs eq 20


    ; This data structure can be used when making CSF_GET_FIRST(NEXT)_TUPLE &
    ; CSF_GET_TUPLE_DATA calls

    CSGetTupleUnion	union
	CSGTU_search	CSGetTupleArgs		<> ; for searching for desired 
    						   ;  tuple
	CSGTU_data	CSGetTupleDataArgs	<> ; for fetching its data, once
						;  it's found
    CSGetTupleUnion	end


CSF_GET_FIRST_CLIENT			enum	CardServicesFunction, 00eh
    ;
    ;	GetFirstClient
    ;
    ;	Pass:	al	= CSF_GET_FIRST_CLIENT
    ;		cx	= argument length
    ;		es:bx	= CSGetClientArgs
    ;	Return:	carry + ax
    ;		dx	= client handle
    ;

    CSGetClientArgsAttributes	record
	:15
	CSGCAA_CLIENTS_THIS_SOCKET_ONLY:1	; zero to request all clients
    CSGetClientArgsAttributes	end

    CSGetClientArgs	struct
	CSGCA_socket		word		; socket we're asking about
	CSGCA_attributes	CSGetClientArgsAttributes
    CSGetClientArgs	ends

CSF_REGISTER_ERASE_QUEUE		enum	CardServicesFunction, 00fh
    ;
    ;	RegisterEraseQueue
    ;
    ;	Pass:	al	= CSF_REGISTER_ERASE_QUEUE
    ;		dx	= client registering the queue
    ;		di:si	= CSEraseQueue
    ;	Return:	carry + ax
    ;		dx	= queue handle
    ;
    
    CSEraseQueueEntryState	etype	byte
        CSEQES_IDLE			enum CSEraseQueueEntryState, 0xff
	CSEQES_QUEUED_FOR_ERASE		enum CSEraseQueueEntryState, 0x00
	CSEQES_IN_PROGRESS		enum CSEraseQueueEntryState, 0x01
					     ; can actually range from 0x01-0x7f
	CSEQES_ERASE_PASSED		enum CSEraseQueueEntryState, 0xe0
	CSEQES_ERASE_FAILED		enum CSEraseQueueEntryState, 0xe1
	CSEQES_MEDIA_WRITE_PROTECTED	enum CSEraseQueueEntryState, 0x84
	CSEQES_MEDIA_NOT_ERASABLE	enum CSEraseQueueEntryState, 0x86
	CSEQES_MEDIA_MISSING		enum CSEraseQueueEntryState, 0x80
	CSEQES_NOT_WRITABLE		enum CSEraseQueueEntryState, 0x87
	CSEQES_BAD_SOCKET		enum CSEraseQueueEntryState, 0xc3
	CSEQES_BAD_TECHNOLOGY		enum CSEraseQueueEntryState, 0xc2
	CSEQES_BAD_OFFSET		enum CSEraseQueueEntryState, 0xc1
	CSEQES_BAD_VCC			enum CSEraseQueueEntryState, 0xc4
	CSEQES_BAD_VPP			enum CSEraseQueueEntryState, 0xc5
	CSEQES_BAD_SIZE			enum CSEraseQueueEntryState, 0xc6
	
    CSEraseQueueEntry	struct
        CSEQE_memHandle		word
	CSEQE_state		CSEraseQueueEntryState CSEQES_IDLE
	CSEQE_size		byte		; power of 2
	CSEQE_offset		dword
	CSEQE_clientData	label byte	; place for client to put
						;  additional info of
						;  arbitrary length (limited
						;  by CSEQ_entrySize value)
    CSEraseQueueEntry	ends
    
    CSEraseQueue	struct
        CSEQ_entrySize	word		; size of each entry
	CSEQ_queueLen	word		; total number of queue entries
	CSEQ_entries	label	CSEraseQueueEntry
    CSEraseQueue	ends

CSF_REGISTER_CLIENT			enum	CardServicesFunction, 010h
    ;
    ;	RegisterClient
    ;
    ;	Pass:	al	= CSF_REGISTER_CLIENT
    ;		cx	= argument length
    ;		es:bx	= CSRegisterClientArgs
    ;		di:si	= entry point
    ;	Return:	carry + ax
    ;		dx	= client handle
    ;

    CSRegisterClientArgsAttributes	record
	:11
	CSRCAA_ARTIFICIAL_EXCLUSIVE:1	; want artificial INSERTION events
					;  after exclusive access released
	CSRCAA_ARTIFICIAL_SHARED:1
	CSRCAA_IO:1			; I/O cards
	CSRCAA_MTD:1			; Memory Technology Driver
	CSRCAA_MCD:1			; Memory cards
    CSRegisterClientArgsAttributes	end

    CSEventMask			record
	:5
	CSEM_SOCKET_SERVICES_UPDATED:1
	CSEM_RESET:1
	CSEM_POWER_MANAGEMENT_CHANGE:1
	CSEM_CARD_DETECT_CHANGE:1
	CSEM_READY_CHANGE:1
	CSEM_BATTERY_LOW:1
	CSEM_BATTERY_DEAD:1
	CSEM_INSERTION_REQUEST:1
	CSEM_EJECTION_REQUEST:1
	CSEM_CARD_LOCK_CHANGE:1
	CSEM_WRITE_PROTECT_CHANGE:1
    CSEventMask			end

    CSClientData		struct
	CSCD_data		word		; DI for callback
	CSCD_segment		word		; DS for callback
	CSCD_offset		word		; SI for callback
	CSCD_extra		word		; reserved word that's not
						;  loaded into anything...
    CSClientData		ends

    CSRegisterClientArgs	struct
	CSRCA_attributes	CSRegisterClientArgsAttributes
	CSRCA_eventMask		CSEventMask
	CSRCA_clientData	CSClientData
	CSRCA_version		word		; expected CS version (BCD?)
    CSRegisterClientArgs	ends

CSF_RESET_CARD				enum	CardServicesFunction, 011h
    ;
    ;	ResetCard
    ;
    ;	Pass:	al	= CSF_RESET_CARD
    ;		dx	= client requesting the reset
    ;		cx	= argument length
    ;		es:bx	= CSResetCardArgs
    ;	Return:	carry + ax
    ;
    ;	RESET_COMPLETE event sent when reset is done (performed in the
    ;	background).
    ;
    
    CSResetCardAttributes	record	:16
    
    CSResetCardArgs	struct
        CSRCdA_socket		word
	CSRCdA_attributes	CSResetCardAttributes
    CSResetCardArgs	ends

CSF_MAP_LOG_SOCKET			enum	CardServicesFunction, 012h
    ;
    ;	MapLogSocket
    ;
    ;	Pass:	al 	= CSF_MAP_LOG_SOCKET
    ;		cx	= argument length
    ;		es:bx	= CSMapLogSocketArgs
    ;	Return:	carry + ax
    ;
    
    CSMapLogSocketArgs	struct
        CSMLSA_socket		word
	CSMLSA_physAdapter	byte
	CSMLSA_physSocket	byte
    CSMapLogSocketArgs	ends

CSF_MAP_LOG_WINDOW			enum	CardServicesFunction, 013h
    ;
    ;	MapLogwindow
    ;
    ;	Pass:	al	= CSF_MAP_LOG_WINDOW
    ;		cx	= argument length
    ;		dx	= window handle
    ;		es:bx	= CSMapLogWindowArgs
    ;	Return:	carry + ax
    ;
    
    CSMapLogWindowArgs	struct
        CSMLWA_physAdapter	byte
	CSMLWA_physWindow	byte
    CSMapLogWindowArgs	ends

CSF_MAP_MEM_PAGE			enum	CardServicesFunction, 014h
    ;
    ;	MapMemPage
    ;
    ;	Pass:	al	= CSF_MAP_MEM_PAGE
    ;		cx	= argument length
    ;		dx	= window handle
    ;		es:bx	= CSMapMemPageArgs
    ;	Return:	carry + ax
    ;
    
    CSMapMemPageArgs	struct
        CSMMPA_cardOffset	dword
	CSMMPA_page		byte	; page # within window to which to map
					;  the given offset
    CSMapMemPageArgs	ends

CSF_MAP_PHYSICAL_SOCKET			enum	CardServicesFunction, 015h
    ;
    ;	MapPhysicalSocket
    ;
    ;	Pass:	al	= CSF_MAP_PHYSICAL_SOCKET
    ;		cx	= argument length
    ;		es:bx	= CSMapPhysicalSocketArgs
    ;	Return:	carry + ax
    ;
    
    CSMapPhysicalSocketArgs	struct
        CSMPSA_socket		word
	CSMPSA_physAdapter	byte
	CSMPSA_physSocket	byte
    CSMapPhysicalSocketArgs	ends

CSF_MAP_PHYSICAL_WINDOW			enum	CardServicesFunction, 016h
    ;
    ;	MapPhysicalWindow
    ;
    ;	Pass:	al	= CSF_MAP_PHYSICAL_WINDOW
    ;		cx	= argument length
    ;		es:bx	= CSMapPhysicalWindowArgs
    ;	Return:	carry + ax
    ;		dx	= window handle
    ;
    
    CSMapPhysicalWindowArgs	struct
        CSMPWA_physAdapter	byte
	CSMPWA_physWindow	byte
    CSMapPhysicalWindowArgs	ends

CSF_MODIFY_WINDOW			enum	CardServicesFunction, 017h
    ;
    ;	ModifyWindow
    ;
    ;	Pass:	al	= CSF_MODIFY_WINDOW
    ;		cx	= argument length
    ;		dx	= window handle to modify
    ;		es:bx	= CSModifyWindowArgs
    ;	Return:	carry + ax
    ;
    
    CSModifyWindowAttributes record
        :12
	CSMWA_SPEED_VALID:1
	CSMWA_ENABLE:1
	CSMWA_ATTRIBUTE_MEM:1
	:1
    CSModifyWindowAttributes end

    CSModifyWindowArgs	struct
        CSMWA_attributes	CSModifyWindowAttributes
	CSMWA_speed		ExtendedDeviceSpeed	; EDS_EXT => use -WAIT
							; EDS_MANTISSA == 0 =>
							;  EDS_EXPONENT =
							;  DeviceSpeed
    CSModifyWindowArgs	ends

CSF_OPEN_MEMORY				enum	CardServicesFunction, 018h
    ;
    ;	OpenMemory
    ;
    ;	Pass:	al	= CSF_OPEN_MEMORY
    ;		cx	= argument length
    ;		dx	= client requesting the open
    ;		es:bx	= CSOpenMemoryArgs
    ;	Return:	carry + ax
    ;		dx	= memory handle
    ;
    CSOpenMemoryAttributes	record
        :14
	CSOMA_EXCLUSIVE:1
	CSOMA_ATTRIBUTE_MEM:1
    CSOpenMemoryAttributes	end

    CSOpenMemoryArgs	struct
        CSOMA_socket		word
	CSOMA_attributes	CSOpenMemoryAttributes
	CSOMA_offset		dword
    CSOpenMemoryArgs	ends

CSF_READ_MEMORY				enum	CardServicesFunction, 019h
    ;
    ;	ReadMemory
    ;
    ;	Pass:	al	= CSF_READ_MEMORY
    ;		cx	= argument length
    ;		dx	= memory handle
    ;		es:bx	= CSReadMemoryArgs
    ;		di:si	= buffer into which to read
    ;	Return:	carry + ax
    ;
    
    CSReadMemoryArgs	struct
        CSRMA_cardOffset	dword
	CSRMA_count		dword
    CSReadMemoryArgs	ends

CSF_REGISTER_MTD			enum	CardServicesFunction, 01ah
    ;
    ;	Register MTD
    ;
    ;	Pass:	al	= CSF_REGISTER_MTD
    ;		cx	= argument length
    ;		dx	= client registering for region
    ;		es:bx	= CSRegisterMTDArgs
    ;	Return:	carry + ax
    ;
    
    CSRegisterMTDArgs	struct
        CSRMTDA_socket		word
	CSRMTDA_attributes	CSPartitionAttributes	; CSPA_VIRTUAL_PARTITION
							;  must be zero
	CSRMTDA_offset		dword		; start of region
	CSRMTDA_mediaID		word		; client data for MTD
    CSRegisterMTDArgs	ends

CSF_RELEASE_IO				enum	CardServicesFunction, 01bh
    ;
    ;	ReleaseIO
    ;
    ;	Pass:	al	= CSF_RELEASE_IO
    ;		cx	= argument length
    ;		dx	= handle of client that requested the IO
    ;		es:bx	= CSIOArgs
    ;	Return:	carry + ax
    ;
    CSIOArgs		struct
	CSIOA_socket		word
	CSIOA_basePort1		word
	CSIOA_numPorts1		byte
	CSIOA_attributes1	CSIOAttributes
	CSIOA_basePort2		word
	CSIOA_numPorts2		byte
	CSIOA_attributes2	CSIOAttributes
	CSIOA_addrLines		byte
    CSIOArgs		ends

CSF_RELEASE_IRQ				enum	CardServicesFunction, 01ch
    ;
    ;	ReleaseIRQ
    ;
    ;	Pass:	al	= CSF_RELEASE_IRQ
    ;		cx	= argument length
    ;		dx	= handle of client that requested the interrupt
    ;		es:bx	= CSReleaseIRQArgs
    ;	Return:	carry + ax
    ;
    CSReleaseIRQArgs		struct
        CSRIRQA_socket		word
	CSRIRQA_attributes	CSIRQAttributes
	CSRIRQA_assignedIRQ	byte
    CSReleaseIRQArgs		ends

CSF_RELEASE_WINDOW			enum	CardServicesFunction, 01dh
    ;
    ;	ReleaseWindow
    ;
    ;	Pass:	al	= CSF_RELEASE_WINDOW
    ;		cx	- MUST BE ZERO
    ;		dx	= window handle
    ;	Return:	carry + ax
    ;

CSF_RELEASE_CONFIGURATION		enum	CardServicesFunction, 01eh
    ;
    ;	ReleaseConfiguration
    ;
    ;	Pass:	al	= CSF_RELEASE_CONFIGURATION
    ;		cx	= argument length
    ;		dx	= client that requested the configuration
    ;		es:bx	= CSReleaseConfigurationArgs
    ;	Return:	carry + ax
    ;
    
    CSReleaseConfigurationArgs	struct
        CSRCfA_socket		word
    CSReleaseConfigurationArgs	ends

CSF_REQUEST_IO				enum	CardServicesFunction, 01fh
    ;
    ;	RequestIO
    ;
    ;	Pass:	al	= CSF_REQUEST_IO
    ;		cx	= argument length
    ;		dx	= handle of requesting client
    ;		es:bx	= CSIOArgs
    ;	Return:	carry + ax
    ;

CSF_REQUEST_IRQ				enum	CardServicesFunction, 020h
    ;
    ;	RequestIRQ
    ;
    ;	Pass:	al	= CSF_REQUEST_IRQ
    ;		cx	= argument length
    ;		dx	= handle of requesting client
    ;		es:bx	= CSRequestIRQArgs
    ;	Return:	carry + ax
    ;
    
    CSRequestIRQArgs		struct
        CSRqIRQA_socket		word
	CSRqIRQA_attributes	CSIRQAttributes
	CSRqIRQA_assignedIRQ	byte	; IRQ assigned by card services
	CSRqIRQA_irqInfo1	byte	; from CFTABLE_ENTRY tuple
	CSRqIRQA_irqInfo2	word	; additional bytes from same
    CSRequestIRQArgs		ends

CSF_REQUEST_WINDOW			enum	CardServicesFunction, 021h
    ;
    ;	RequestWindow
    ;
    ;	Pass:	al	= CSF_REQUEST_WINDOW
    ;		cx	= argument length
    ;		dx	= handle of client requesting the window
    ;		es:bx	= CSRequestWindowArgs
    ;	Return:	carry + ax
    ;		dx	= window handle
    ;

    CSRequestWindowAttributes record
	:7
        CSRWA_OFFSETS_WINDOW_SIZED:1
	CSRWA_BINDING_SPECIFIC:1
	CSRWA_FIRST_SHARED:1
	CSRWA_SHARED:1
	CSRWA_PAGED:1
	CSRWA_16_BIT:1
	CSRWA_ENABLED:1
	CSRWA_ATTRIBUTE_MEM:1
	:1
    CSRequestWindowAttributes end

    CSRequestWindowArgs		struct
        CSRWA_socket		word
	CSRWA_attributes	CSRequestWindowAttributes
	CSRWA_base		dword			; if 0, CS will assign
	CSRWA_size		dword			; if 0, CS will assign
							;  largest possible
	CSRWA_speed		ExtendedDeviceSpeed	; EDS_EXT => use -WAIT
							; EDS_MANTISSA == 0 =>
							;  EDS_EXPONENT =
							;  DeviceSpeed
    CSRequestWindowArgs		ends
	.assert size CSRequestWindowArgs eq 13

CSF_REQUEST_SOCKET_MASK			enum	CardServicesFunction, 022h
    ;
    ;	RequestSocketMask
    ;
    ;	Pass:	al	= CSF_REQUEST_SOCKET_MASK
    ;		cx	= argument length
    ;		dx	= handle of client making request
    ;		es:bx	= CSRequestSocketMaskArgs
    ;	Return:	carry + ax
    ;
    ;	Socket event masks must be released when CARD_REMOVAL event is received
    ;
    
    CSRequestSocketMaskArgs	struct
        CSRSMA_socket		word
	CSRSMA_eventMask	CSEventMask
    CSRequestSocketMaskArgs	ends

CSF_RETURN_SS_ENTRY			enum	CardServicesFunction, 023h
    ;
    ;	ReturnSSEntry
    ;
    ;	Pass:	al	= CSF_RETURN_SS_ENTRY
    ;		cx	= argument length
    ;		es:bx	= CSReturnSSEntryArgs
    ;	Return:	carry + ax
    ;		di:si	= entry to socket services for the socket
    ;
    
    CSSSAttributes	etype byte, 0, 1
        CSSSA_REAL_MODE				enum CSSSAttributes
	CSSSA_16_BIT_PROTECTED_SEGMENTED	enum CSSSAttributes
	CSSSA_32_BIT_PROTECTED_SEGMENTED	enum CSSSAttributes
	CSSSA_32_BIT_PROTECTED_FLAT		enum CSSSAttributes

    CSReturnSSEntryArgs	struct
        CSRSSEA_attributes	CSSSAttributes	CSSSA_REAL_MODE
    CSReturnSSEntryArgs	ends

CSF_WRITE_MEMORY			enum	CardServicesFunction, 024h
    ;
    ;	WriteMemory
    ;
    ;	Pass:	al	= CSF_WRITE_MEMORY
    ;		cx	= argument length
    ;		dx	= memory handle
    ;		es:bx	= CSWriteMemoryArgs
    ;		di:si	= buffer from which to write
    ;	Return:	carry + ax
    ;
    
    CSWriteMemoryAttributes	record
	:12
        CSWMA_VERIFY:1
	CSWMA_DISABLE_ERASE:1
	:2
    CSWriteMemoryAttributes	end
    
    CSWriteMemoryArgs	struct
        CSWMA_cardOffset	dword	; offset within region
	CSWMA_count		dword
	CSWMA_attributes	CSWriteMemoryAttributes
    CSWriteMemoryArgs	ends

CSF_DEREGISTER_ERASE_QUEUE		enum	CardServicesFunction, 025h
    ;
    ;	DeregisterEraseQueue
    ;
    ;	Pass:	al	= CSF_DEREGISTER_ERASE_QUEUE
    ;		dx	= erase queue handle
    ;	Return:	carry + ax
    ;

CSF_CHECK_ERASE_QUEUE			enum	CardServicesFunction, 026h
    ;
    ;	CheckEraseQueue
    ;
    ;	Pass:	al	= CSF_CHECK_ERASE_QUEUE
    ;		dx	= erase queue to check
    ;	Return:	carry + ax
    ;

CSF_MODIFY_CONFIGURATION		enum	CardServicesFunction, 027h
    ;
    ;	ModifyConfiguration
    ;
    ;	Pass:	al	= CSF_MODIFY_CONFIGURATION
    ;		cx	= argument length
    ;		dx	= handle of client requesting the modification
    ;		es:bx	= CSModifyConfigurationArgs
    ;	Return:	carry + ax
    ;

    CSModifyConfigurationAttributes	record
        :10
	CSMCA_VPP2_CHANGE:1
	CSMCA_VPP1_CHANGE:1
	CSMCA_VCC_CHANGE:1
	CSMCA_IRQ_CHANGE:1
	CSMCA_ENABLE_IRQ:1
	:1
    CSModifyConfigurationAttributes	end
    
    CSModifyConfigurationArgs	struct
        CSMCA_socket		word
	CSMCA_attributes	CSModifyConfigurationAttributes
	CSMCA_Vcc		byte	; (V * 10)
	CSMCA_Vpp1		byte	; (V * 10)
	CSMCA_Vpp2		byte	; (V * 10)
    CSModifyConfigurationArgs	ends

CSF_REGISTER_TIMER			enum	CardServicesFunction, 028h
    ;
    ;	RegisterTimer
    ;
    ;	Pass:	al	= CSF_REGISTER_TIMER
    ;		cx	= argument length
    ;		dx	= client requesting timer
    ;		es:bx	= CSRegisterTimerArgs
    ;	Return:	carry + ax
    ;		dx	= timer handle
    ;

    CSRegisterTimerArgs	struct
        CSRTA_delay		word	; 1ms ticks
    CSRegisterTimerArgs	ends

CSF_SET_REGION				enum	CardServicesFunction, 029h
    ;
    ;	SetRegion
    ;
    ;	Pass:	al	= CSF_SET_REGION
    ;		cx	= argument length
    ;		es:bx	= CSSetRegionArgs
    ;	Return:	carry + ax
    ;
    
    CSSetRegionAttributes	record
	:4
        CSSRA_VIRTUAL:1
	:6
	CSSRA_DELETE_REGION:1
	CSSRA_ATTRIBUTE_MEM:1
    CSSetRegionAttributes	end

    CSSetRegionArgs	struct
        CSSRA_socket		word
	CSSRA_attributes	CSSetRegionAttributes
	CSSRA_cardOffset	dword
	CSSRA_regionSize	dword
	CSSRA_effBlockSize	dword
	CSSRA_partMultiple	word
	CSSRA_jedecID		word
	CSSRA_biasOffset	dword
	CSSRA_speed		ExtendedDeviceSpeed	; EDS_EXT => use -WAIT
							; EDS_MANTISSA == 0 =>
							;  EDS_EXPONENT =
							;  DeviceSpeed
    CSSetRegionArgs	ends


CSF_GET_NEXT_CLIENT			enum	CardServicesFunction, 02ah
    ;
    ;	GetNextClient
    ;
    ;	Pass:	al	= CSF_GET_NEXT_CLIENT
    ;		cx	= argument length
    ;		dx	= handle returned by previous
    ;			  GET_FIRST_CLIENT/GET_NEXT_CLIENT call
    ;		es:bx	= CSGetClientArgs
    ;	Return:	carry + ax
    ;		dx	= handle of next client
    ;


CSF_VALIDATE_CIS			enum	CardServicesFunction, 02bh
    ;
    ;	ValidateCIS
    ;
    ;	Pass:	al	= CSF_VALIDATE_CIS
    ;		cx	= argument length
    ;		es:bx	= CSValidateCISArgs
    ;	Return:	carry + ax
    ;
    
    CSValidateCISArgs	struct
        CSVCISA_socket		word
	CSVCISA_chains		word		; number of chains validated
    CSValidateCISArgs	ends

CSF_REQUEST_EXCLUSIVE			enum	CardServicesFunction, 02ch
    ;
    ;	RequestExclusive
    ;
    ;	Pass:	al	= CSF_REQUEST_EXCLUSIVE
    ;		cx	= argument length
    ;		dx	= handle of client requesting exclusive access
    ;		es:bx	= CSExclusiveArgs
    ;	Return:	carry + ax
    ;
    CSExclusiveAttributes record :16
    
    CSExclusiveArgs	struct
        CSREA_socket		word
	CSREA_attributes	CSExclusiveAttributes
    CSExclusiveArgs	ends

CSF_RELEASE_EXCLUSIVE			enum	CardServicesFunction, 02dh
    ;
    ;	ReleaseExclusive
    ;
    ;	Pass:	al	= CSF_RELEASE_EXCLUSIVE
    ;		cx	= argument length
    ;		dx	= handle of client with exclusive access
    ;		es:bx	= CSExclusiveArgs
    ;	Return:	carry + ax
    ;

CSF_GET_EVENT_MASK			enum	CardServicesFunction, 02eh
    ;
    ;	GetEventMask
    ;
    ;	Pass:	al	= CSF_GET_EVENT_MASK
    ;		cx	= argument length
    ;		dx	= handle of client for which event mask is desired
    ;		es:bx	= CSEventMaskArgs
    ;	Return:	carry + ax
    ;
    CSEventMaskAttributes	record
        :15
	CSEMA_THIS_SOCKET_ONLY:1
    CSEventMaskAttributes	end

    CSEventMaskArgs	struct
        CSEMA_attributes	CSEventMaskAttributes
	CSEMA_eventMask		CSEventMask
	CSEMA_socket		word
    CSEventMaskArgs	ends

CSF_RELEASE_SOCKET_MASK			enum	CardServicesFunction, 02fh
    ;
    ;	ReleaseSocketMask
    ;
    ;	Pass:	al	= CSF_RELEASE_SOCKET_MASK
    ;		cx	= argument lengh
    ;		dx	= handle of client whose mask is being released
    ;		es:bx	= CSReleaseSocketMaskArgs
    ;	Return:	carry + ax
    ;
    
    CSReleaseSocketMaskArgs	struct
        CSRlSMA_socket		word
    CSReleaseSocketMaskArgs	ends

CSF_REQUEST_CONFIGURATION		enum	CardServicesFunction, 030h
    ;
    ;	RequestConfiguration
    ;
    ;	Pass:	al	= CSF_REQUEST_CONFIGURATION
    ;		cx	= argument length
    ;		dx	= handle of client requesting the configuration
    ;		es:bx	= CSRequestConfigurationArgs
    ;
    CSRequestConfigurationAttributes record
	:14
        CSRQCA_ENABLE_IRQ:1
	:1
    CSRequestConfigurationAttributes end

    CSRequestConfigurationArgs	struct
        CSRqCA_socket		word
	CSRqCA_attributes	CSRequestConfigurationAttributes
	CSRqCA_Vcc		byte	; (V*10)
	CSRqCA_Vpp1		byte	; (V*10)
	CSRqCA_Vpp2		byte	; (V*10)
	CSRqCA_interface	CSInterfaceType
	CSRqCA_configBase	dword
	CSRqCA_statusReg	byte
	CSRqCA_pinReg		byte
	CSRqCA_copyReg		byte
	CSRqCA_optionReg	byte
	CSRqCA_present		byte
    CSRequestConfigurationArgs	ends

CSF_SET_EVENT_MASK			enum	CardServicesFunction, 031h
    ;
    ;	SetEventMask
    ;
    ;	Pass:	al	= CSF_SET_EVENT_MASK
    ;		cx	= argument length
    ;		dx	= handle of client whose mask is to be set
    ;		es:bx	= CSEventMaskArgs
    ;	Return:	carry + ax
    ;

CSF_ADD_SOCKET_SERVICES			enum	CardServicesFunction, 032h
    ;
    ;	AddSocketServices
    ;
    ;	Pass:	al	= CSF_ADD_SOCKET_SERVICES
    ;		cx	= argument length
    ;		es:bx	= CSAddSocketServicesArgs
    ;		di:si	= entry point for the socket services
    ;	Return:	carry + ax
    ;
    CSAddSocketServicesArgs	struct
        CSASSA_attributes	CSSSAttributes
	CSASSA_dataPointer	label	byte	; undefined, but intended to
						;  make the SS's data
						;  addressable in this mode
    CSAddSocketServicesArgs	ends

CSF_REPLACE_SOCKET_SERVICES		enum	CardServicesFunction, 033h
    ;
    ;	ReplaceSocketServices
    ;
    ;	Pass:	al	= CSF_REPLACE_SOCKET_SERVICES
    ;		cx	= argument length
    ;		es:bx	= CSReplaceSocketServicesArgs
    ;		di:si	= entry point for the socket services
    ;	Return:	carry + ax
    ;
    CSReplaceSocketServicesArgs	struct
        CSRSSA_socket		word
	CSRSSA_numSockets	word
	CSRSSA_attributes	CSSSAttributes
	CSRSSA_dataPointer	label	byte
    CSReplaceSocketServicesArgs	ends

CSF_VENDOR_SPECIFIC			enum	CardServicesFunction, 034h
    ;
    ;	VendorSpecific
    ;
    ;	Pass:	al	= CSF_VENDOR_SPECIFIC
    ;		cx	= argument length
    ;		es:bx	= CSVendorSpecificArgs
    ;	Return:	carry + ax
    ;
    
    CSVendorSpecificArgs	struct
        CSVSA_infoLen		word
	CSVSA_data		label	byte
    CSVendorSpecificArgs	ends

CSF_ADJUST_RESOURCE_INFO		enum	CardServicesFunction, 035h
    ;
    ;	AdjustResourceInfo
    ;
    ;	Pass:	al	= CSF_ADJUST_RESOURCE_INFO
    ;		cx	= argument length
    ;		es:bx	= CSAdjustResourceInfoArgs
    ;	Return:	carry + ax
    ;		dx	= client handle
    ;
    ; 	The structures for this call are not defined here, as they are even
    ;	less likely to be needed than those for replacing socket services.
    ;

CSF_ACCESS_CONFIGURATION_REGISTER	enum	CardServicesFunction, 036h
    ;
    ; 	AccessConfigurationRegister
    ;
    ; 	Pass:	al	= CSF_ACCESS_CONFIGURATION_REGISTER
    ; 		cx	= arument length
    ; 		es:bx	= CSAccessConfigurationRegisterArgs
    ; 	Return:	carry + ax
    ; 
    
    CSAccessConfigurationRegisterAccessType etype byte, 0, 1
        CSACRAT_READ		enum CSAccessConfigurationRegisterAccessType
	CSACRAT_WRITE		enum CSAccessConfigurationRegisterAccessType
	
    CSAccessConfigurationRegisterArgs struct
        CSACRA_socket		word
	CSACRA_action		CSAccessConfigurationRegisterAccessType
	CSACRA_offset		byte
	CSACRA_value		byte
    CSAccessConfigurationRegisterArgs ends



;-----------------------------------------------------------------------------
;		Card Services Event Code
;-----------------------------------------------------------------------------

CardServicesEventCode			etype	word
CSEC_PM_BATTERY_DEAD		enum	CardServicesEventCode, 001h
CSEC_PM_BATTERY_LOW		enum	CardServicesEventCode, 002h
CSEC_CARD_LOCK			enum	CardServicesEventCode, 003h
CSEC_CARD_READY			enum	CardServicesEventCode, 004h
CSEC_CARD_REMOVAL		enum	CardServicesEventCode, 005h
CSEC_CARD_UNLOCK		enum	CardServicesEventCode, 006h
CSEC_EJECTION_COMPLETE		enum	CardServicesEventCode, 007h
CSEC_EJECTION_REQUEST		enum	CardServicesEventCode, 008h
CSEC_INSERTION_COMPLETE		enum	CardServicesEventCode, 009h
CSEC_INSERTION_REQUEST		enum	CardServicesEventCode, 00ah
CSEC_PM_RESUME			enum	CardServicesEventCode, 00bh
CSEC_PM_SUSPEND			enum	CardServicesEventCode, 00ch
CSEC_EXCLUSIVE_COMPLETE		enum	CardServicesEventCode, 00dh
CSEC_EXCLUSIVE_REQUEST		enum	CardServicesEventCode, 00eh
CSEC_RESET_PHYSICAL		enum	CardServicesEventCode, 00fh
CSEC_RESET_REQUEST		enum	CardServicesEventCode, 010h
CSEC_CARD_RESET			enum	CardServicesEventCode, 011h
CSEC_MTD_REQUEST		enum	CardServicesEventCode, 012h
CSEC_RESERVED_1			enum	CardServicesEventCode, 013h
CSEC_CLIENT_INFO		enum	CardServicesEventCode, 014h
CSEC_TIMER_EXPIRED		enum	CardServicesEventCode, 015h
CSEC_SS_UPDATED			enum	CardServicesEventCode, 016h

CSEC_CARD_INSERTION		enum	CardServicesEventCode, 040h

CSEC_RESET_COMPLETE		enum	CardServicesEventCode, 080h
CSEC_ERASE_COMPLETE		enum	CardServicesEventCode, 081h
CSEC_REGISTRATION_COMPLETE	enum	CardServicesEventCode, 082h



;-----------------------------------------------------------------------------
;		Card Service Funcion Return Codes
;-----------------------------------------------------------------------------

CardServicesReturnCode			etype	word, 0, 1
CSRC_SUCCESS				enum	CardServicesReturnCode
CSRC_BAD_ADATPER			enum	CardServicesReturnCode
CSRC_BAD_ATTRIBUTE			enum	CardServicesReturnCode
CSRC_BAD_BASE				enum	CardServicesReturnCode
CSRC_BAD_EDC				enum	CardServicesReturnCode
CSRC_RESERVED_1				enum	CardServicesReturnCode
CSRC_BAD_IRQ				enum	CardServicesReturnCode
CSRC_BAD_OFFSET				enum	CardServicesReturnCode
CSRC_BAD_PAGE				enum	CardServicesReturnCode
CSRC_READ_FAILURE			enum	CardServicesReturnCode
CSRC_BAD_SIZE				enum	CardServicesReturnCode
CSRC_BAD_SOCKET				enum	CardServicesReturnCode
CSRC_RESERVED_2				enum	CardServicesReturnCode
CSRC_BAD_TYPE				enum	CardServicesReturnCode
CSRC_BAD_VCC				enum	CardServicesReturnCode
CSRC_BAD_VPP				enum	CardServicesReturnCode
CSRC_RESERVED_3				enum	CardServicesReturnCode
CSRC_BAD_WINDOW				enum	CardServicesReturnCode
CSRC_WRITE_FAILURE			enum	CardServicesReturnCode
CSRC_RESERVED_4				enum	CardServicesReturnCode
CSRC_NO_CARD				enum	CardServicesReturnCode
CSRC_UNSUPPORTED_FUNCTION		enum	CardServicesReturnCode
CSRC_UNSUPPORTED_MODE			enum	CardServicesReturnCode
CSRC_BAD_SPEED				enum	CardServicesReturnCode
CSRC_BUSY				enum	CardServicesReturnCode
CSRC_GENERAL_FAILURE			enum	CardServicesReturnCode
CSRC_WRITE_PROTECTED			enum	CardServicesReturnCode
CSRC_BAD_ARG_LENGTH			enum	CardServicesReturnCode
CSRC_BAD_ARGS				enum	CardServicesReturnCode
CSRC_CONFIGURATION_LOCKED		enum	CardServicesReturnCode
CSRC_IN_USE				enum	CardServicesReturnCode
CSRC_NO_MORE_ITEMS			enum	CardServicesReturnCode
CSRC_OUT_OF_RESOURCE			enum	CardServicesReturnCode
CSRC_BAD_HANDLE				enum	CardServicesReturnCode

;-----------------------------------------------------------------------------
;		Card Services Interrupt
;-----------------------------------------------------------------------------

CARD_SERVICES_INT		equ	01ah
CARD_SERVICES_SUB_COMMAND	equ	0afh

;-----------------------------------------------------------------------------
;		Outgoing Card Services argument binding
;-----------------------------------------------------------------------------
CS_FUNCTION_REG			equ	al
CS_HANDLE_REG			equ	dx
CS_POINTER_SEGMENT_REG		equ	di
CS_POINTER_OFFSET_REG		equ	si
CS_ARG_LENGTH_REG		equ	cx
CS_ARG_POINTER_SEGMENT_REG	equ	es
CS_ARG_POINTER_OFFSET_REG	equ	bx

CS_STATUS_REG			equ	ax

;-----------------------------------------------------------------------------
;		Incoming (Callback) argument binding
;-----------------------------------------------------------------------------

CB_FUNCTION_REG			equ	al
CB_SOCKET_REG			equ	cx
CB_INFO_REG			equ	dx
CB_REGISTER_CLIENT_DATA_1_REG	equ	di
CB_REGISTER_CLIENT_DATA_2_REG	equ	ds
CB_REGISTER_CLIENT_DATA_3_REG	equ	si
CB_MTD_REQUEST_SEGMENT_REG	equ	ss
CB_MTD_REQUEST_OFFSET_REG	equ	bp
CB_BUFFER_SEGMENT_REG		equ	es
CB_BUFFER_OFFSET_REG		equ	bx
CB_MISC_REG			equ	bx ; when no buffer present...

CB_STATUS_REG			equ	ax

;-----------------------------------------------------------------------------
;		Macros
;-----------------------------------------------------------------------------


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		CallCS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Issue a call to Card Services

PASS:		command		= CardServicesFunction to invoke
		[options]	= DONT_LOCK_BIOS if macro invoked from a
				  card services callback procedure.

PSEUDO CODE/STRATEGY:
		Because Card Services callbacks occur on the timer interrupt,
		when semaphores may not be grabbed, you must pass DONT_LOCK_BIOS
		when invoking this macro within a routine that is, or is
		called by, a card services callback routine.
		
		At all other times, unless you've called SysLockBIOS yourself,
		you must *not* pass DONT_LOCK_BIOS, as Card Services isn't
		reentrant.
		

KNOWN BUGS/SIDE EFFECTS/IDEAS:
		AX is loaded with the CSF before card services is called

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	TS	11/ 4/93	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
CallCS		macro		command, options

	mov	ax, (CARD_SERVICES_SUB_COMMAND shl 8) or command

if <options> ne <DONT_LOCK_BIOS>
   	call	PCMCIACardServices
else
	int	CARD_SERVICES_INT
endif

endm


;-----------------------------------------------------------------------------
;		Exported Library Routines
;-----------------------------------------------------------------------------


global	PCMCIACardServices:far
	;
	; May not be called from card services callback

global 	PCMCIAThreadMessage:far
global	PCMCIACallRoutineOnThread:far

global	PCMCIAObjectToRemoval:far

global	PCMCIARegisterDriver:far
	; PASS:		cx	= socket number
	; 		bx	= driver's geode handle
	; 		es:di	= CSRegisterClientArgs passed to Card Services
	; 		ax:si	= Card Services callback routine
	; 		dx	= Card Services client handle for driver
	; RETURN:	nothing
	; DESTROYED:	ax
	;
	; May not be called from card services callback

global	PCMCIAAddStdPathIfPresent:far
	; PASS:		al	= drive number to check
	; RETURN:	carry clear if standard path added
	; DESTROYED:	nothing
	;
	; May not be called from card services callback

global	PCMCIADeleteStdPath:far
	; PASS:		al	= drive number
	; RETURN:	nothing
	; DESTROYED:	nothing
	;
	; May not be called from card services callback


global	PCMCIAGetPrimaryIFSStrat:far
	; PASS:		nothing
	; RETURN:	carry set if primary not loaded or is incompatible
	; 			bx, ax	= destroyed
	; 		carry clear if we're happy
	; 			bxax	= strategy routine
	; DESTROYED:	nothing
	;
	; May not be called from card services callback

global	PCMCIADoesDriveExist?:far
	; PASS:		al	= drive number
	; RETURN:	carry set if drive exists:
	; 			cx	= 0 if it's already formatted
	; 		carry clear if drive doesn't exist
	; DESTROYED:	nothing
	;
	; May not be called from card services callback

PCMCIADrivePrivateData	struct	; first part of private data for any PCMCIA
				;  drive, if its driver hopes to use our
				;  routines...
    PCMDPD_socket	word
PCMCIADrivePrivateData	ends

global	PCMCIANotifyRemoval:far
	; PASS:		cx	= socket number
	; 		dx	= driver geode handle
	; RETURN:	nothing
	; DESTROYED:	nothing
	;
	; May not be called from card services callback

global	PCMCIAAskAboutFormatting:far
	; PASS:		nothing
	; RETURN:	carry set if user wants to format
	; DESTROYED:	ax
	;
	; May not be called from card services callback

global	PCMCIADisplayFormatResults:far
	; PASS:		carry set on error
	; 		carry clear if ok:
	;			sidi	= good bytes
	;			dxcx	= bad bytes
	; RETURN:	nothing
	; DESTROYED:	ax, bx, cx, dx, si, di, bp
	;
	; May not be called from card services callback

global	PCMCIADetach:far
	; PASS:		nothing
	; RETURN:	nothing
	; DESTROYED:	nothing
	;
	; May not be called from card services callback

global	PCMCIANotifyFormat:far
	; PASS:		cx	= socket
	; RETURN:	nothing
	; DESTROYED:	nothing
	;
	; Take note that a filesystem on the card has been reformatted, which
	; means the 32-bit ID for the card may have changed.
	;
	; May not be called from card services callback


global	PCMCIADeviceOnOff:far
	; PASS:		bx	= socket number
	; 		cx	= 0 if turning device off
	;		dx	= PCMCIAPowerInfo
	; RETURN:	nothing
	; DESTROYED:	nothing
	;
	; May not be called from card services callback

global	PCMCIASocketOn:far
	; PASS:		cx	= socket number
	; 		dx	= CS client handle
	; 		es:bx	= CSModifyConfigurationArgs
	; RETURN:	carry set on error
	; 			ax	= CardServicesReturnCode
	; DESTROYED:	nothing
	;
	; May not be called from card services callback

global	PCMCIASocketOff:far
	; PASS:		cx	= socket number
	; RETURN:	nothing
	; DESTROYED:	nothing
	;
	; May not be called from card services callback
	;

global	PCMCIAExclusiveGranted:far
	; PASS:		cx	= socket number
	; RETURN:	nothing
	; DESTROYED:	nothing

global	PCMCIAExclusiveCardRemoved:far
	; PASS:		cx	= socket number
	; RETURN:	nothing
	; DESTROYED:	nothing

global	PCMCIAChangeConfigurationOwner:far
	; PASS:		cx	= socket number
	; 		dx	= card services client to own the configuration
	;		ax	= PCMChangeConfigurationOwnerFlags
	;		es:bx	= PCMChangeConfigurationOwnerArgs, if any
	;			  flag set in AX
	; RETURN:	carry set if unable to change the ownership. Card
	;		    may be unusable following such an error.
	;		carry clear if ok:
	;			dx	= old owner of the configuration
	; DESTROYED:	nothing
	;
	; May not be called from card services callback
	; 

PCMChangeConfigurationOwnerFlags	record
    :14
    PCMCCOF_NEW_IRQ:1
    PCMCCOF_NEW_IO:1
PCMChangeConfigurationOwnerFlags	end

PCMChangeConfigurationOwnerArgs	struct
    PCMCCOA_io		CSIOArgs
    PCMCCOA_irq		CSRequestIRQArgs
PCMChangeConfigurationOwnerArgs	ends

;-----------------------------------------------------------------------------
;			GCN Schme
;-----------------------------------------------------------------------------

PCMNotifyType		etype	byte,	0, 1
	PCMNT_CARD_CHANGE	enum	PCMNotifyType
	PCMNT_CONTENT_CHANGE	enum	PCMNotifyType
	PCMNT_SYSTEM_REQUEST	enum	PCMNotifyType

PCMCardData		record
	:3	; 5 bits maximum
	:1
	PCMCD_INSERTION	:1
	PCMCD_REMOVAL	:1
	PCMCD_RECOGNIZED:1
	PCMCD_COMPLETED :1
PCMCardData		end

PCMContentData		etype	byte,	0, 1
	PCMCD_FORMAT	enum	PCMContentData
	.assert	PCMContentData	lt	020h	; don't use top 3 bits

PCMSystemData		record
	:3	; 5 bits maximum
	:2
	PCMSD_EJECT	:1
	PCMSD_FAILURE	:1
	PCMSD_COMPLETED :1
PCMSystemData		end

PCMNotifyData		union
	PCMND_CARD_DATA		PCMCardData
	PCMND_CONTENT_DATA	PCMContentData
	PCMND_SYSTEM_DATA	PCMSystemData
PCMNotifyData		ends

PCMCardChangeFlags	record
	PCCF_TYPE	PCMNotifyType :3
	PCCF_DATA	PCMNotifyData :5
PCMCardChangeFlags	end



	;
	;  Various sorts of CardChange flags
	VANILLA_INSERT_FLAG		equ	PCMCardChangeFlags <
			PCMNT_CARD_CHANGE, PCMCardData <1,0,0,0>>
	UNRECOGNIZED_INSERT_FLAG	equ	PCMCardChangeFlags <
			PCMNT_CARD_CHANGE, PCMCardData <1,0,0,1>>
	RECOGNIZED_INSERT_FLAG	equ	PCMCardChangeFlags <
			PCMNT_CARD_CHANGE, PCMCardData <1,0,1,1>>
	RECOGNIZED_REMOVAL_FLAG		equ	PCMCardChangeFlags <
			PCMNT_CARD_CHANGE, PCMCardData <0,1,1,1>>
	UNRECOGNIZED_REMOVAL_FLAG	equ	PCMCardChangeFlags <
			PCMNT_CARD_CHANGE, PCMCardData <0,1,0,1>>
	VANILLA_REMOVAL_FLAG		equ	PCMCardChangeFlags <
			PCMNT_CARD_CHANGE, PCMCardData <0,1,0,0>>

	;
	;  Various sorts of ContentChange flags
	GENERAL_FORMAT_FLAG		equ	PCMCardChangeFlags <
			PCMNT_CONTENT_CHANGE, PCMCD_FORMAT >

	;
	;  Various sorts of SystemRequests
	EJECT_REQUEST_FLAG		equ	PCMCardChangeFlags <
			PCMNT_SYSTEM_REQUEST, PCMSystemData <1,0,0>>
	EJECT_SUCCESS_FLAG		equ	PCMCardChangeFlags <
			PCMNT_SYSTEM_REQUEST, PCMSystemData <1,0,1>>
	EJECT_FAILED_FLAG		equ	PCMCardChangeFlags <
			PCMNT_SYSTEM_REQUEST, PCMSystemData <1,1,1>>



global	PCMCIASetupComplete:far
	; PASS:		nothing
	; RETURN:	nothing
	; DESTROYED:	nothing

global	PCMCIAEjectCard:far
	; PASS:		cx	= socket
	; RETURN:	carry set if unsuccessful
	; DESTROYED:	nothing
	;
	; User will *not* be notified when close-out procedure is complete.
	; 
	; May not be called from card services callback
	; 

global	PCMCIAEjectCardNoWait:far
	; PASS:		cx	= socket
	; RETURN:	nothing
	; DESTROYED:	nothing
	;
	; When everything has been cleaned up, the user will be notified it's
	; ok to remove the card.
	; 
	; May not be called from card services callback
	; 

global	PCMCIAAddFontsIfPresent:far
	; PASS:		al	= drive number to check
	; RETURN:	carry clear if fonts added
	; DESTROYED:	nothing
	;
	; May not be called from card services callback

global	PCMCIADeleteFonts:far
	; PASS:		ds:dx - ptr to top of std path from which fonts will
	; be deleted
	; RETURN:	cx - number of fonts tried to delete
	;		bx - handle to block of font file name deleted
	;		carry clear if fonts deleted
	; DESTROYED:	nothing
	;
	; May not be called from card services callback

global	PCMCIACheckRebooting:far
	; PASS:		cx = socket
	; RETURN:	carry set if rebooting after "wrong card: continue,
	;		close out card, reboot" option
	; DESTROYED:	nothing

global	PCMCIACopyPatchesIfPresent:far
	; PASS:		al	= drive number to check
	; RETURN:	carry clear if patches added
	; DESTROYED:	nothing
	;
	; May not be called from card services callback

global	PCMCIAGetCardStatus:far
	; PASS:		cx = socket # to check
	; RETURN:	ax = CardServicesReturnCode
	;		cx = CSGetStatusCardState
	;		dx = CSGetStatusSocketState
	;		carry set if operation failed
	; DESTROYED:	nothing

EndLibrary	pcmcia
