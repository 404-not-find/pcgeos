COMMENT @----------------------------------------------------------------------

	Copyright (c) GeoWorks 1992 -- All Rights Reserved

PROJECT:	PC/GEOS
MODULE:		Novell NetWare Library
FILE:		netware.def

REVISION HISTORY
	Name	Date		Description
	----	----		-----------
	Eric	2/92		Initial version
	Eric	7/92		Ported to 2.0
	Chung	10/92		Added lots of calls

DESCRIPTION
	This library allows PC/GEOS applications to access the Novell NetWare
	Applications Programmers Interface (API). This permits an application
	to send and receive packets, set up connections between nodes on the
	network, access Novell's "Bindery", which contains information about
	network users, etc.

	$Id: netware.def,v 1.1 97/04/04 14:24:24 newdeal Exp $

TABLE OF CONTENTS
-----------------
	TODO list for this file and our NetWare support in general.

	How to call Novell's Developer Support

	Other Novell Tools We Can Get

	Novell version information

	Misc. NetWare definitions

	NetWare calls, by category.


TODO LIST FOR THIS FILE AND OUR NETWARE SUPPORT IN GENERAL
----------------------------------------------------------

	- reorganize this file. It's a mess.

	- get NSA_GEOWORKS_FIXED_SOCKET_ADDRESS registered with Novell.

	- ASK NOVELL ABOUT NCITI_connectionStatus = 0/FF


HOW TO CALL NOVELL'S DEVELOPER SUPPORT
--------------------------------------

Call 1-800-NETWARE

You can also fax questions to 1-512-794-1775.

Normally, there is a charge for these services. During March of 1992,
I was able to get a whole bunch of questions answered for free. -EDS.

OTHER NOVELL TOOLS WE CAN GET
-----------------------------

The Novell "C Interface For DOS" provides sample C code for all of the
API calls. Can link in their C definition library to C programs.

For $100K, we can license the Novell Core Protocol (NCP) Manual. Even though
it is out of date, it gives lots of internal info about NetWare.


NOVELL VERSION INFORMATION
--------------------------

Most of the 3.11 API calls also work with NetWare 2.2. (Obviously, we need
to find out more about this. :)

NetWare Lite supports most of the IPX/SPX calls. It does have user name
and information support, but no API!

NetWare	4.0


NetWare 3.11
		250 users max


netWare 2.2
		100 users max


------------------------------------------------------------------------------@

;##############################################################################
;		Misc. NetWare Definitions
;##############################################################################

; Filenames, etc

NETWARE_FILENAME_SIZE equ 14
NetWareFileName	type	NETWARE_FILENAME_SIZE dup (char)

NETWARE_VOLUME_NAME_SIZE equ 16
NetWareVolumeName type	NETWARE_VOLUME_NAME_SIZE dup (char)

NetWareFileHandle type 6 dup (byte)	; ???


NetWareConnectionNumber		type	byte	;what it is now
FutureNetWareConnectionNumber	type	word	;what we should probably use,
						;when defining our own data
						;structures.

NW_MAX_NUM_DRIVES		equ	32	; 32 drives supported by
						;  NetWare shell.

NW_MAX_SERVERS			equ	8	; can be connected to at most
						;  8 servers at once

;------------------------------------------------------------------------------
;for Bindery Objects:

NetWareBinderyObjectID		type	HiLoDWord

;A bindery object name can be from 1 to 47 characters long. A null-terminator
;is not necessary. Only printable characters can be used. An object name cannot
;include spaces or the following chars: / \ : ; , * ?

NW_BINDERY_OBJECT_NAME_LEN	equ	47
NetWareBinderyObjectName	type	NW_BINDERY_OBJECT_NAME_LEN dup (char)

NetWareBinderyObjectNameZ	type	NW_BINDERY_OBJECT_NAME_LEN+1 dup (char)
					;for cases where name is returned
					;from NetWare with a null-terminator
					;at the end.

;A binder object property name can be from 1 to 15 characters long.

NW_BINDERY_OBJECT_PROPERTY_NAME_LEN	equ	15
NetWareBinderyObjectPropertyName type	\
				NW_BINDERY_OBJECT_PROPERTY_NAME_LEN dup (char)

NW_BINARY_OBJECT_PROPERTY_INITIAL_SEGMENT equ	1
					;initial segment value to use when
					;reading a property value which could
					;be multiple segments.

NW_BINARY_OBJECT_PROPERTY_MAX_SEGMENT_SIZE equ	128
					;maximum amount of data that will
					;be returned in one segment.

NWBinderyObjPropName_NetAddress equ	"NET_ADDRESS"

NetWareBinderyObjectRealNameZ	type	\
			NW_BINARY_OBJECT_PROPERTY_MAX_SEGMENT_SIZE dup (char)
					;User's real names can be this long.

;A bindery object password can be from 0 to 127 characters long. A null-
;terminator is not necessary. It must be all upper-case, and can be null.

;QUESTION: NULL MEANS 0 CHARS, RIGHT?

NW_BINDERY_OBJECT_PASSWORD_LEN	equ	127
NetWareBinderyObjectPassword	type	NW_BINDERY_OBJECT_PASSWORD_LEN \
							dup (char)

;NO! Is a DWORD -- 0x00000001.
;;pre-defined user object IDs, for ANY Novell file server.
;
;NetWarePredefinedUserObjectID	etype	word
;    HiLoEnum NPUOID_SUPERVISOR		NetWarePredefinedUserObjectID, 0x0001



;##############################################################################
;		Misc.
;##############################################################################
;These types are also used below.

NOVELL_NETWORK_ADDRESS_LENGTH	equ	4	;4 bytes
NOVELL_NODE_ADDRESS_LENGTH	equ	6	;up to 6 bytes
NOVELL_STATION_ADDRESS_LENGTH	equ	6	;6 bytes

NovellNetworkAddress	type	NOVELL_NETWORK_ADDRESS_LENGTH dup (byte)
NovellNodeAddress	type	NOVELL_NODE_ADDRESS_LENGTH dup (byte)
NovellStationAddress	type	NOVELL_STATION_ADDRESS_LENGTH dup (byte)
						;physical station address

;This enum is used within the IPXPacketHeaderStruct, which is defined below.
;Sockets #1-0xBB8 are registered with Zerox. Anything above that is dynamically
;assignable.

NovellSocketAddress	etype	word
    HiLoEnum NSA_ROUTING_INFO_PACKET,		NovellSocketAddress, 0x0001
    HiLoEnum NSA_ECHO_PROTOCOL_PACKET,		NovellSocketAddress, 0x0002
    HiLoEnum NSA_ERROR_HANDLER_PACKET		NovellSocketAddress, 0x0003
    HiLoEnum NSA_EXPERIMENTAL			NovellSocketAddress, 0x0020
		;0x20 - 0x3F are experimental
    HiLoEnum NSA_DYNAMICALLY_ASSIGNABLE		NovellSocketAddress, 0x0BB8

    ;Xerox has assigned Novell the following socket addresses:

    HiLoEnum NSA_NOVELL_FILE_SERVICE_PACKET	NovellSocketAddress, 0x0451
    HiLoEnum NSA_NOVELL_SERVICE_ADVERTISING_PACKET NovellSocketAddress, 0x0452
    HiLoEnum NSA_NOVELL_ROUTING_INFO_PACKET	NovellSocketAddress, 0x0453
    HiLoEnum NSA_NOVELL_NETBIOS_PACKET		NovellSocketAddress, 0x0455
    HiLoEnum NSA_NOVELL_DIAGNOSTIC_PACKET	NovellSocketAddress, 0x0456

    HiLoEnum NSA_NOVELL_DYNAMIC_SOCKET		NovellSocketAddress, 0x4000
		;Novell can dynamically assign an application a socket
		;in the 0x4000 - 0x7FFF range.

    HiLoEnum NSA_NOVELL_WELL_KNOWN_SOCKET	NovellSocketAddress, 0x8000
		;Novell assigns socket numbers to third parties, starting
		;at 0x8000.

    ;--------------------------------------------------------------------------
    ;		De-Facto Standard Setting Happens Here...
    ;--------------------------------------------------------------------------
    ;Without Novell's permission, let's just use this socket...
    ;(We will fatal error if it is already opened.)

    HiLoEnum NSA_GEOWORKS_FIXED_SOCKET_ADDRESS	NovellSocketAddress, 0xED26



;This structure completely defines a Novell node address.

NovellNodeSocketAddrStruct	struct
    NNSAS_network	NovellNetworkAddress	;4 bytes
    NNSAS_node		NovellNodeAddress	;6 bytes
    NNSAS_socket	NovellSocketAddress	;2 bytes
NovellNodeSocketAddrStruct	ends

;The ConnectionIDTable on this workstation contains 8 of the following
;items, one for each server connected to that workstation:
;Doc: NetWare System Calls -- DOS, page 17-9.

NetWareConnectionIDTableItem	struct
    NCITI_slotInUse			byte	;0x00 = empty, 0xFF = in use
    NCITI_serverOrderNumber		byte
    NCITI_serverAddress			NovellNodeSocketAddrStruct
						;12 bytes: network, node, socket
    NCITI_receiveTimeOut		word
    NCITI_routersPhysicalNodeAddress	NovellNodeAddress
    NCITI_packetSequenceNumber		byte
    NCITI_connectionNumber		NetWareConnectionNumber
						 ;byte -- will be a word soon...
;PrintMessage <ASK NOVELL ABOUT NCITI_connectionStatus = 0/FF >
    NCITI_connectionStatus		byte	;0 = still functioning
	;Docs say 0 = connection OK, but it seems they mean 0xFF.

    NCITI_maximumTimeOut		word
    NCITI_filler			byte 5 dup (?)
NetWareConnectionIDTableItem	ends


;##############################################################################
;		Definitions for the NetWare: Top Level Stuff
;##############################################################################

NetWareSoftwareInterrupt	etype	byte
    NSI_STD_INTERRUPT			enum NetWareSoftwareInterrupt, 0x21
	;This is the standard DOS interrupt vector, for almost all
	;NetWare API calls. (IPX/SPX calls are the exception).

    NSI_GET_IPX_VECTOR			enum NetWareSoftwareInterrupt, 0x2F
	;Important: make sure that you are running under DOS 3.0 or later
	;before calling int 2Fh.
	;
	;sample code:
	;	;make sure we are running on DOS 3.0 or better
	;	;(or else int 2Fh will do nothing!)
	;
	;	mov	ax, 0x3000
	;	call	FileInt21	;returns [al, ah] = DOS version #
	;	cmp	al, 0x03	;at or above DOS 3.0?
	;	jb	done		;skip if not...
	;


NW_USER_NAME_LENGTH		equ	NW_BINDERY_OBJECT_NAME_LEN+1
						;47 chars +null term.

NW_MAX_CONNECTION_NUMBER	equ	250

NW_MESSAGE_LENGTH	equ	55


;##############################################################################
;		Definitions for the PC/GEOS NetWare Driver
;		...used when calling standard NetWare routines
;##############################################################################

;These are some common return values you can expect from NetWare.
;For each NetWare call, refer to the documentation in the NetWareFunctionCode
;enum to see exactly which return codes to expect from each call.

NetWareReturnCode	etype	byte
    NRC_GENERAL_SUCCESSFUL	enum NetWareReturnCode, 0x00
    NRC_INVALID_PATH		enum NetWareReturnCode, 0x9C
    NRC_NO_SUCH_OBJECT		enum NetWareReturnCode, 0xFC
    NRC_SERVER_BINDERY_LOCKED	enum NetWareReturnCode, 0xFE
    NRC_BINDERY_FAILURE		enum NetWareReturnCode, 0xFF



;General definition of a NetWare Request Buffer:
;(For each NetWare call that requires a special Request buffer, see the
;structure definition next to that enum, below.)

    NReqBuf	struct
	NREQBUF_length			word
	NREQBUF_subFunc			byte
    NReqBuf	ends

;NetWare uses byte-length Function Codes to identify its entry points.
;In some cases, a byte-length Sub-Function Code is also necessary. We combine
;these two values into a word enum, setting the Sub-Function Code to FF in
;cases where it is not necessary. (May have to change this...)
;
;Unless specified otherwise, you pass these values in AH and AL when calling
;DOS int 21h. (If the low byte is 0xFF, that usually means that NetWare
;only cares about the high byte. See the Pass/Return info for specifics.)
;
;Also note that the request and reply buffers are MAX sizes. Often a buffer
;will contain a variable-length string. If the string you are passing
;(or get in return) is shorter than the maximum, the fields following it
;MAY begin after the last character of the string, and then buffer size
;MAY be adjusted to fit the exact contents. See comments next to the
;structure definitions for more info.

NetWareFunctionCode	etype	word


;##############################################################################
;			NetWare Calls - Misc
;##############################################################################

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_IPX_VECTOR			enum NetWareFunctionCode, 0x7A00

;Use this function code when calling int 2FH to get the IPX/SPX
;vector address, to use when calling IPX/SPX facilities.
;This is the 1st step in determining if a machine has NetWare
;running at all.
;
;Pass:		ax	= NFC_GET_IPX_VECTOR
;
;Returns:	es:di	= address of vector to call IPX/SPX with.
;		al	= NetWareReturnCode
    NRC_GET_IPX_VECTOR_SUCCESSFUL	enum NetWareReturnCode, 0xFF
;Doc: NetWare System Calls -- DOS, page 5-11.


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_BROADCAST_MODE			enum NetWareFunctionCode, 0xDE04

;This call returns the message mode of the requesting workstation.
;
;Pass:		ah	= (NFC_GET_BROADCAST_MODE shr 8)
;		dl	= (NFC_GET_BROADCAST_MODE and 0xff)
;
;Returns:	al	= NetWareMessageMode
;
;Doc: NetWare System Calls -- DOS, page 10-21.


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_SET_BROADCAST_MODE			enum NetWareFunctionCode, 0xDEFF

;This call sets the message mode of the requesting workstation.
;
;Pass:		ah	= (NFC_SET_BROADCAST_MODE shr 8)
;		dl	= NetWareMessageMode
;
;Returns:	al	= NetWareMessageMode
;
;Doc: NetWare System Calls -- DOS, page 10-25.


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_BROADCAST_TO_CONSOLE		enum NetWareFunctionCode, 0xE109


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_BROADCAST_MESSAGE		enum NetWareFunctionCode, 0xE101

;An application can use this call to poll for and return a broadcast
;message from the default file server.
;
;Pass:		ah	= (NFC_GET_BROADCAST_MESSAGE shr 8)
;		ds:si	= RequestBuffer:

    NReqBuf_GetBroadcastMessage	struct
	NREQBUF_GBM_length		word		3-2
	NREQBUF_GBM_subFunc		byte		0x01
    NReqBuf_GetBroadcastMessage	ends

;Pass:		es:di	= ReplyBuffer:

    NRepBuf_GetBroadcastMessage	struct
	NREPBUF_GBM_length	    word (size NRepBuf_GetBroadcastMessage)-2
	NREPBUF_GBM_messageLength   byte 0
	NREPBUF_GBM_message	    byte NET_TEXT_MESSAGE_BUFFER_SIZE dup (?)
    NRepBuf_GetBroadcastMessage	ends

;Returns:	es:di	= ReplyBuffer
;		al	= NetWareReturnCode (0 = successful)

NRC_MESSAGE_QUEUE_FULL		enum NetWareReturnCode, 0xFC
NRC_IO_FAILURE_LACK_OF_DYNAMIC_WORKSPACE  enum NetWareReturnCode, 0xFE

;
;Doc: NetWare System Calls -- DOS, page 10-10.


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_SEND_BROADCAST_MESSAGE		enum NetWareFunctionCode, 0xE100

    NReqBuf_SendBroadcastMessage	struct
	NREQBUF_SBM_length	word	size NReqBuf_SendBroadcastMessage-2
	NREQBUF_SBM_subFunc	byte
	NREQBUF_SBM_connectionCount byte
	NREQBUF_SBM_connectionList label byte
	; the rest of this structure is variable-sized.  After the
	; connection list comes the message length (byte), which is
	; 1-55 chars, and then the message text after that.
    NReqBuf_SendBroadcastMessage	ends

	


    NRepBuf_SendBroadcastMessage	struct
	NREPBUF_SBM_length	word	size NReqBuf_SendBroadcastMessage-2
	NREPBUF_SBM_connectionCount byte
	NREPBUF_SBM_resultList byte 100 dup (?)
    NRepBuf_SendBroadcastMessage	ends

; Doc: NetWare System Calls -- DOS, p 10-20.

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_PERSONAL_MESSAGE		enum NetWareFunctionCode, 0xE105


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_SEND_PERSONAL_MESSAGE		enum NetWareFunctionCode, 0xE104


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_LOG_NETWORK_MESSAGE			enum NetWareFunctionCode, 0xE30D


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_OPEN_MESSAGE_PIPE			enum NetWareFunctionCode, 0xE106


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_CLOSE_MESSAGE_PIPE			enum NetWareFunctionCode, 0xE107


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_CHECK_PIPE_STATUS			enum NetWareFunctionCode, 0xE108


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_CONNECTION_NUMBER		enum NetWareFunctionCode, 0xDCFF

;This call returns the connection number that the requesting
;workstation uses to communicate with the default file server.
;
;Pass:		ah	= (NFC_GET_CONNECTION_NUMBER shr 8)
;Returns:	al	= NetWareConnectionNumber (1-250)
;		cl	= first ascii digit of connection #, in hex
;		ch	= second ascii digit of connection #, in hex
;
;Note: WILL BE BUSTED IN NETWARE4, because connection number is byte.
;Doc: NetWare System Calls -- DOS, page 5-13.

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_CONNECTION_INFORMATION	enum NetWareFunctionCode, 0xE316
;This call returns information about the object logged in as the
;specified connection number.
;
;Pass:		ah	= (NFC_GET_CONNECTION_INFORMATION shr 8)
;		ds:si	= RequestBuffer

    NReqBuf_GetConnectionInfo	struct
	NREQBUF_GCI_length		word		4-2
	NREQBUF_GCI_subFunc		byte		0x16
	NREQBUF_GCI_logicalConnectionNum NetWareConnectionNumber 0
    NReqBuf_GetConnectionInfo	ends

;Pass:		es:di	= ReplyBuffer:

    NRepBuf_GetConnectionInfo	struct
	NREPBUF_GCI_length		word		64-2
	NREPBUF_GCI_objectID		NetWareBinderyObjectID
	NREPBUF_GCI_objectType		NetObjectType
	NREPBUF_GCI_objectName		NetWareBinderyObjectNameZ 0
	NREPBUF_GCI_loginTime		byte 7 dup (?)	;
	NREPBUF_GCI_reserved		byte		;???
    NRepBuf_GetConnectionInfo	ends

;Returns:	es:di	= ReplyBuffer
;		al	= completion code (0 = successful)
;
;Note: WILL BE BUSTED IN NETWARE4, because connection number is byte.
;Doc: NetWare System Calls -- DOS, page 5-11.

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_DEFAULT_CONNECTION_ID enum NetWareFunctionCode, 0xF002
;This call returns the connection ID of the file server to which request
;packets are currently being sent.  
;The default server is where the user gets logged into.
;
;Pass:		ax	= NFC_GET_DEFAULT_CONNECTION_ID
;
;Returns:	al	= Connection ID of file server to which
;			  packets are currently being sent (1 to 8)
;
;Doc: NetWare System Calls -- DOS, page 17-11.

NFC_SET_PREFERRED_CONNECTION_ID enum NetWareFunctionCode, 0xF000
;This call sets the preferred file server.  The preferred server is the 
;default server to which request packets are sent.  For example, login 
;will login to the server set as the preferred connection.
;
;Pass:		ax	= NFC_SET_PREFERRED_CONNECTION_ID
;		dl	= connection id of the preferred file server.
;			  (1 to 8) or 0, which means the preferred
;			  server is not set (unspecified.)
;
;Returns:	nothing  (NetWare call specifies no return values)
;
;Doc: NetWare system calls -- DOS, page 17-30
      
NFC_GET_PREFERRED_CONNECTION_ID enum NetWareFunctionCode, 0xF001
;This call gets the preferred file server.  The preferred server is the 
;default server to which request packets are sent.  For example, login 
;will login to the server set as the preferred connection.
;
;Pass:		ax	= NFC_GET_PREFERRED_CONNECTION_ID
;
;Returns:	al	= connection id of the preferred file server.
;			  (1 to 8) or 0, which means the preferred
;			  server is not set (unspecified.)
;
;Doc: NetWare system calls -- DOS, page 17-18
      
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_OBJECT_CONNECTION_NUMBERS enum NetWareFunctionCode, 0xE315
;
;Return a list of connection numbers indicating how many times and
;under what connection numbers a bindery object is logged in to the
;default file server.
;
;Pass:		ah - E3h
;ds:si		- request buffer
;es:di		- reply buffer
    NReqBuf_GetObjectConnectionNumbers struct
	NREQBUF_GOCN_length	word (size NReqBuf_GetObjectConnectionNumbers-2)
	NREQBUF_GOCN_subFunc	byte	15h
	NREQBUF_GOCN_objectType	NetObjectType
	NREQBUF_GOCN_objectNameLen	byte
	NREQBUF_GOCN_objectName	NetWareBinderyObjectNameZ
    NReqBuf_GetObjectConnectionNumbers	ends

    NRepBuf_GetObjectConnectionNumbers struct
	NREPBUF_GOCN_length	word (size NRepBuf_GetObjectConnectionNumbers-2)
	NREPBUF_GOCN_numConnections byte
	NREPBUF_GOCN_connections byte 100 dup (?)
    NRepBuf_GetObjectConnectionNumbers	ends
	

; Doc: NetWare System Calls -- DOS p 17-11

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_ATTACH_TO_FILE_SERVER enum NetWareFunctionCode, 0xF100
;This call attaches the requesting workstation to the specified file server.
;
;Pass:		ax 	= NFC_ATTACH_TO_FILE_SERVER
;		dl	= Server Connection ID (1 to 8)
;
;Returns:	al 	= NetWareReturnCode
    NRC_ALREADY_ATTACHED_TO_SERVER		enum	NetWareReturnCode, 0xF8
    NRC_NO_FREE_CONNECTION_SLOTS_AT_SERVER	enum	NetWareReturnCode, 0xF9
    NRC_NO_MORE_SERVER_SLOTS			enum	NetWareReturnCode, 0xFA
    NRC_UNKNOWN_FILE_SERVER			enum	NetWareReturnCode, 0xFA
;Doc: NetWare System Calls -- Dos, Page 5-6.
				
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_LOGIN_TO_FILE_SERVER enum NetWareFunctionCode, 0xE314
;This call logs a bindery object in to the preferred file server
;
;Pass:		ah	= (NFC_LOGIN_TO_FILE_SERVER shr 8)
;		ds:si	= RequestBuffer:

    NReqBuf_LoginToFileServer struct
    	NREQBUF_LFS_length		word		181-2
			;update length according to combined
			;length of name and password, plus other
			;info in this structure

	NREQBUF_LFS_subFunc		byte		0x14
	NREQBUF_LFS_objectType		NetObjectType 0
	NREQBUF_LFS_objectNameLen	byte 		0
	NREQBUF_LFS_objectName		NetWareBinderyObjectName 0

			;password info begins IMMEDIATELY following
			;name (do not use structure offsets)

	NREQBUF_LFS_passwordLen	byte		0
	NREQBUF_LFS_password		NetWareBinderyObjectPassword 0
					;must be in UPPER CASE only

    NReqBuf_LoginToFileServer ends
    
;Pass:		es:di	= Replybuffer:

    NRepBuf_LoginToFileServer struct
    	NREPBUF_LFS_length		word		2-2
    NRepBuf_LoginToFileServer ends
    
;Returns:    	es:di 	= ReplyBuffer
;		al 	= NetWareReturnCode
;
;doc: NetWare System Calls -- DOS, page 5-19			
	; returned when concurrent login is disallowed, and user is already
	; logged in from elsewhere.
	NRC_LOGIN_DENIED		enum NetWareReturnCode, 0xD9
	
	; returned password was expired, but login was successful on a
	; grace login.
	NRC_PASSWORD_EXPIRED		enum NetWareReturnCode, 0xDF

	; password expired; login failed.
	NRC_PASSWORD_EXPIRED_NO_GRACE	enum NetWareReturnCode, 0xDE

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_LOGOUT_FROM_FILE_SERVER enum NetWareFunctionCode, 0xF102
;This call logs the object out from a file server, but does not detach the 
;workstation from the server.
;
;Pass:		ax	= NFC_LOGOUT_FROM_FILE_SERVER
;		dl	= Server Connection ID (1 to 8)
;
;Return:	none
;
;Doc: NetWare System Calls - DOS, page 5-22

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_DETACH_FROM_FILE_SERVER enum NetWareFunctionCode, 0xF101
;This call detaches the requesting workstation from the specified file server.
;
;Pass:		ax 	= NFC_DETACH_FROM_FILE_SERVER
;		dl	= Server Connection ID (1 to 8)
;
;Returns:	al 	= NetWareReturnCode
;Doc: NetWare System Calls -- Dos, Page ???
				
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_INTERNET_ADDRESS enum NetWareFunctionCode, 0xE313
;This call returns a connection's internetwork address.  The internetwork
;address uniquely identifies a workstation.
;
;Pass:		ax	= NFC_GET_INTERNET_ADDRESS
;		ds:si	= RequestBuffer:
    NReqBuf_GetInternetAddress struct
    	NREQBUF_GIA_length		word		4-2
	NREQBUF_GIA_subFunc		byte		0x13
	NREQBUF_GIA_connectionNumber	NetWareConnectionNumber
    NReqBuf_GetInternetAddress ends
    
;Return:	es:di 	= ReplyBuffer:    
    NRepBuf_GetInternetAddress struct
    	NREPBUF_GIA_length		word		14-2
	NREPBUF_GIA_netAddr		NovellNodeSocketAddrStruct
    NRepBuf_GetInternetAddress ends
;    
;Doc: NetWare System Calls - DOS, page 5-14		
 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -> NFC_GET_STATION_ADDRESS enum NetWareFunctionCode, 0xEE00
;This call returns the workstation's address, a unique value that is supplied
;by the network adapter card.
;
;Pass:		ah	= (NFC_GET_STATION_ADDRESS shr 8)
    
;Return:	cx,bx,ax = NovellStationAddress

;Doc: NetWare System Calls - DOS, page 5-18

;##############################################################################
;	BINDERY FUNCTION CALLS
;##############################################################################

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_SCAN_BINDERY_OBJECT	enum NetWareFunctionCode, 0xE337
;This call scans the bindery for an object of the requested type.
;Successive calls will return more objects, until there are no more
;objects of the desired type.
;
;On the first call, set NREQBUF_SBO_lastObjectID = 0xFFFFFFFF.
;
;Pass:		ah	= (NFC_SCAN_BINDERY_OBJECT shr 8)
;		ds:si	= RequestBuffer
;		es:di 	= ReplyBuffer
				 
    NReqBuf_ScanBinderyObject struct
	NREQBUF_SBO_length		word		57-2
	NREQBUF_SBO_subFunc		byte		0x37
	NREQBUF_SBO_lastObjectID	NetWareBinderyObjectID
	NREQBUF_SBO_objectType		NetObjectType
	NREQBUF_SBO_objectNameLen	byte
	NREQBUF_SBO_objectName		NetWareBinderyObjectName
    NReqBuf_ScanBinderyObject ends

    NRepBuf_ScanBinderyObject struct
    	NREPBUF_SBO_length		word		59-2
	NREPBUF_SBO_objectID		NetWareBinderyObjectID
	NREPBUF_SBO_objectType		NetObjectType
	NREPBUF_SBO_objectName		NetWareBinderyObjectNameZ
	NREPBUF_SBO_objectFlag		byte
	NREPBUF_SBO_objectSecurity	byte
	NREPBUF_SBO_objectHasProperties	byte
    NRepBuf_ScanBinderyObject ends

;Returns:	es:di	= ReplyBuffer
;		al	= NetWareReturnCode (0 = successful)


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_SCAN_PROPERTY	enum	NetWareFunctionCode,	0xE33C
; Scan the bindery for an object's properties
; Pass:		ah - E3h
; 		ds:si - RequestBuffer
;		es:di - ReplyBuffer
; Return:	al - NetWareReturnCode
;
    NReqBuf_ScanProperty	struct
	NREQBUF_SP_length	word	(size NReqBuf_ScanProperty)-2
	NREQBUF_SP_subFunc	byte	0x3C
	NREQBUF_SP_objectType	HiLoWord
	NREQBUF_SP_objectNameLen	byte
	NREQBUF_SP_objectName	NetObjectName

; NOTE:  This is another one of those screwy NOVELL data structures
; where the next 3 fields are IMMEDIATELY following the last character
; of the object name -- DO NOT use these structure offsets!  They're
; here merely so that we can allocate a maximally-sized structure.

	NREQBUF_SP_sequenceNum	HiLoDWord
	NREQBUF_SP_propertyNameLen	byte
	NREQBUF_SP_propertyName		NetPropertyName
    NReqBuf_ScanProperty	ends

    NRepBuf_ScanProperty	struct
	NREPBUF_SP_length	word	(size NRepBuf_ScanProperty)-2
	NREPBUF_SP_propertyName	NetPropertyName
	NREPBUF_SP_propertyFlags	byte
	NREPBUF_SP_propertySecurity	byte
	NREPBUF_SP_sequenceNumber	HiLoDWord
	NREPBUF_SP_propertyHasValue	byte
	NREPBUF_SP_moreProperties	byte
    NRepBuf_ScanProperty	ends

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_CHANGE_BINDERY_OBJECT_PASSWORD	enum NetWareFunctionCode, 0xE340
;This call changes the password of a bindery object.
;
;Pass:		ah	= (NFC_CHANGE_BINDERY_OBJECT_PASSWORD shr 8)
;		ds:si	= RequestBuffer:

    NReqBuf_ChangeBinderyObjectPassword	struct
	NREQBUF_CBOP_length		word		309-2
			;update length according to combined
			;length of name and password, plus other
			;info in this structure

	NREQBUF_CBOP_subFunc		byte		0x40
	NREQBUF_CBOP_objectType		NetObjectType 0
	NREQBUF_CBOP_objectNameLen	byte 		0
	NREQBUF_CBOP_objectName		NetWareBinderyObjectName 0

			;password info begins IMMEDIATELY following
			;name (do not use structure offsets)

	NREQBUF_CBOP_oldPasswordLen	byte		0
	NREQBUF_CBOP_oldPassword	NetWareBinderyObjectPassword 0
	NREQBUF_CBOP_newPasswordLen	byte		0
	NREQBUF_CBOP_newPassword	NetWareBinderyObjectPassword 0
					;must be in UPPER CASE only
    NReqBuf_ChangeBinderyObjectPassword	ends

;Pass:		es:di	= ReplyBuffer:

    NRepBuf_ChangeBinderyObjectPassword	struct
	NREPBUF_CBOP_length		word		2-2
    NRepBuf_ChangeBinderyObjectPassword	ends

;Returns:	es:di	= ReplyBuffer
;		al	= completion code:
;
;Doc: NetWare System Calls -- DOS, page 3-12

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_VERIFY_BINDERY_OBJECT_PASSWORD	enum NetWareFunctionCode, 0xE33F
;This call verifies that the password of a bindery object is valid.
;
;Pass:		ah	= (NFC_VERIFY_BINDERY_OBJECT_PASSWORD shr 8)
;		ds:si	= RequestBuffer:

    NReqBuf_VerifyBinderyObjectPassword	struct
	NREQBUF_VBOP_length		word		181-2
			;update length according to combined
			;length of name and password, plus other
			;info in this structure

	NREQBUF_VBOP_subFunc		byte		0x3F
	NREQBUF_VBOP_objectType		NetObjectType 0
	NREQBUF_VBOP_objectNameLen	byte 		0
	NREQBUF_VBOP_objectName		NetWareBinderyObjectName 0

			;password info begins IMMEDIATELY following
			;name (do not use structure offsets)

	NREQBUF_VBOP_passwordLen	byte		0
	NREQBUF_VBOP_password		NetWareBinderyObjectPassword 0
					;must be in UPPER CASE only
    NReqBuf_VerifyBinderyObjectPassword	ends

;Pass:		es:di	= ReplyBuffer:

    NRepBuf_VerifyBinderyObjectPassword	struct
	NREPBUF_VBOP_length		word		2-2
    NRepBuf_VerifyBinderyObjectPassword	ends

;Returns:	es:di	= ReplyBuffer
;		al	= completion code:
;
;Doc: NetWare System Calls -- DOS, page 3-60.

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_BINDERY_OBJECT_NAME		enum NetWareFunctionCode, 0xE336
;This call returns the name and type of a bindery object.
;
;Pass:		ah	= (NFC_GET_BINDERY_OBJECT_NAME shr 8)
;		ds:si	= RequestBuffer:

    NReqBuf_GetBinderyObjectName	struct
	NREQBUF_GBON_length		word		7-2
	NREQBUF_GBON_subFunc		byte		0x36
	NREQBUF_GBON_objectID		NetWareBinderyObjectID 0
    NReqBuf_GetBinderyObjectName	ends

;Pass:		es:di	= ReplyBuffer:

    NRepBuf_GetBinderyObjectName	struct
	NREPBUF_GBON_length		word		56-2
	NREPBUF_GBON_objectID		NetWareBinderyObjectID 0
	NREPBUF_GBON_objectType		NetObjectType 0
	NREPBUF_GBON_objectName		NetWareBinderyObjectNameZ 0
    NRepBuf_GetBinderyObjectName	ends

;Returns:	es:di	= ReplyBuffer
;		al	= completion code
;
;Doc: NetWare System Calls -- DOS, page 3-40.

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_READ_PROPERTY_VALUE			enum NetWareFunctionCode, 0xE33D
;Read one segment of data from a specific property for an object in the
;NetWare Bindery.
;
;Pass:		ah	= (NFC_READ_PROPERTY_VALUE shr 8)
;		ds:si	= RequestBuffer:

    NReqBuf_ReadPropertyValue	struct
	NREQBUF_RPV_length		word		70-2
			;update length according to combined
			;length of name and property name, plus other
			;info in this structure

	NREQBUF_RPV_subFunc		byte		0x3D
	NREQBUF_RPV_objectType		NetObjectType
	NREQBUF_RPV_objectNameLen	byte		0
	NREQBUF_RPV_objectName		NetWareBinderyObjectName	0

	; this info begins IMMEDIATELY following name (do not use
	; structure offsets -- structure elements are named here so
	; that "size NReqBuf_ReadPropertyValue" returns the maximum
	; possible size).

	NREQBUF_RPV_segmentNumber	byte		0
	NREQBUF_RPV_propertyNameLength	byte		0
	NREQBUF_RPV_propertyName	NetWareBinderyObjectPropertyName 0
    NReqBuf_ReadPropertyValue	ends

;Pass:		es:di	= ReplyBuffer:

    NRepBuf_ReadPropertyValue	struct
	NREPBUF_RPV_length		word		132-2
	NREPBUF_RPV_propertyValue	byte 128 dup (?)
	NREPBUF_RPV_moreSegments	byte
	NREPBUF_RPV_propertyFlags	byte
    NRepBuf_ReadPropertyValue	ends

;Returns:	es:di	= ReplyBuffer
;		al	= completion code (0 = successful)
;
;Doc: NetWare System Calls -- DOS, page 3-47


;##############################################################################
;			NetWare Calls - Semaphores
;##############################################################################
;IMPORTANT: there are some bugs in NetWare 2.2 and 3.11 relating to semaphores:
;
;	1) If a workstation that has opened and grabbed (P'd) a semaphore
;	happens to lose its connection, then the server will fix the open count
;	on the semaphore, but will not fix the actual value. Over time,
;	this will make the available range of values smaller and smaller,
;	until workstations are refused access (cannot P the semaphore) for
;	no reason.
;
;	For this reason, many developers just use the open count of the
;	semaphore as the semaphore value. Obviously, this is not a perfect
;	solution, but it seems to satisfy some.
;
;	2) If you are using the NetWare "timed wait on semaphore", and your
;	workstation loses its connection, then the timer does not reset
;	properly. Novell developer support warns developers to not use
;	timed waits for this reason.
;
;	I've not investigated this fully, because the PC/GEOS NetWare library
;	DOES NOT use timed waits anyway. It polls NetWare for each semaphore,
;	because it does not want to get blocked within a call to NetWare
;	while waiting on one semaphore, when other semaphore requests
;	could be quickly serviced (not to mention that standard DOS/BIOS
;	file request could be serviced during this time).
;
;	3) I'm not sure if you would call this a bug. NetWare semaphore open/
;	close requests cannot be nested on a workstation. If you open
;	a semaphore twice and then close it once, it will be closed.
;
;See the PC/GEOS NetWare driver's SPEC file for more information about how
;these cases are handled.

NetWareSemaphore		type	dword

NW_SEMAPHORE_NAME_LENGTH	equ	127	;127 chars, w/out null term.

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_OPEN_SEMAPHORE			enum NetWareFunctionCode, 0xC500
;This call opens the specified semaphore on the Novell server.
;
;Pass:		ax	= NFC_OPEN_SEMAPHORE
;		cl	= initial value for semaphore, in case we
;			are the first to request that it be opened. (0-127)
;		ds:dx	= RequestBuffer

    NReqBuf_OpenSemaphore	struct
	NREQBUF_OS_semNameLength	byte
					;length of semaphore, w/out null term.

	NREQBUF_OS_semName		char	NW_SEMAPHORE_NAME_LENGTH dup (?)
					;name of semaphore. Does not have to
					;be null-terminated.
    NReqBuf_OpenSemaphore	ends

;Returns:	bl	= open count
;		al	= completion code (0 = successful)
;		cx,dx	= NetWare semaphore handle
;
;Note: WILL BE BUSTED IN NETWARE4, because semaphores will hopefully support
;values of over 127.
;
;Doc: NetWare System Calls -- DOS, page 14-29.

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_EXAMINE_SEMAPHORE		enum NetWareFunctionCode, 0xC501
;This call
;Doc: NetWare System Calls -- DOS, page x-xx.

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_WAIT_ON_SEMAPHORE		enum NetWareFunctionCode, 0xC502
;This call
;Doc: NetWare System Calls -- DOS, page x-xx.

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_SIGNAL_SEMAPHORE		enum NetWareFunctionCode, 0xC503
;This call
;Doc: NetWare System Calls -- DOS, page x-xx.

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_CLOSE_SEMAPHORE			enum NetWareFunctionCode, 0xC504
;Pass:		cx:dx 	= NetWare semaphore handle
;		ax	= NFC_CLOSE_SEMAPHORE
;Return:	al	= NetWareReturnCode
;This call
;Doc: NetWare System Calls -- DOS, page x-xx.


;##############################################################################
;			NetWare Calls - Misc
;##############################################################################

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_DRIVE_HANDLE_TABLE		enum NetWareFunctionCode, 0xEF00
;This call returns a pointer to the NetWare shell's DriveHandleTable
;For each of the 32 possible drives (A-Z, [/]^_'), this table contains
;the NetWare DirectoryHandle for the current directory on that drive
;(0 means none). You can then use that value in the ScanFileInformation
;call to find out about files in that directory.
;
;Pass:		ax	= NFC_GET_DRIVE_HANDLE_TABLE
;
;Returns:	es:si	= DriveHandleTable
;
;Note: If your F: drive is mapped to VOLUME:\USER\ERIC, then that
;will be the default path for the DirectoryHandle for that drive.
;
;Doc: NetWare System Calls -- DOS, page 17-15.

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_DRIVE_FLAG_TABLE		enum NetWareFunctionCode, 0xEF01
;This call returns a pointer to the NetWare shell's Drive Flag Table.
;For each of the 32 possible drives, this table contains the
;NWDriveFlags for the drive.
;
;Pass:		ax	= NFC_GET_DRIVE_FLAG_TABLE
;
;Returns:	es:si	= drive flag table
;
	NWDriveType	etype	byte, 0
	    NWDT_FREE		enum NWDriveType; not mapped
	    NWDT_PERMANENT	enum NWDriveType; mapping valid after
						 ;  process exit
	    NWDT_TEMPORARY	enum NWDriveType; mapping valid until
						 ;  process exit
	    
	NWDriveFlags record
	    NWDF_LOCAL:1		; set if drive is local. This
					;  does not prevent a network
					;  directory from being mapped
					;  on top of it, though.
	    :5
	    NWDF_TYPE NWDriveType:2	; type of mapping, if any
	NWDriveFlags end

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_DRIVE_CONNECTION_ID_TABLE	enum NetWareFunctionCode, 0xEF02
;This call returns a pointer to the NetWare shell's Drive Connection
;ID Table. For each of the 32 possible drives (A-Z, [/]^_'),
;this table contains the ConnectionID (1-8) of the server associated
;with that drive (0 means none). You can then use that value, *32,
;as an offset into the ConnectionIDTable on this machine, to get
;more information about the server, or *48, as an offset into the
;Server Name Table on this machine, to get the name of the server.
;
;Pass:		ax	= NFC_GET_DRIVE_CONNECTION_ID_TABLE
;
;Returns:	es:si	= DriveConnectionIDTable
;
;Doc: NetWare System Calls -- DOS, page 17-12.

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_CONNECTION_ID_TABLE		enum NetWareFunctionCode, 0xEF03
;This call returns a pointer to the NetWare shell's ConnectionIDTable,
;which contains up to 8 32-byte entries of NetWareConnectionIDTableItem: 
;one for each server connected to this workstation. 
;You use the server's ConnectionID (1-8) to locate a specific entry 
;in this table.
;
;Pass:		ax	= NFC_GET_CONNECTION_ID_TABLE
;
;Returns:	es:si	= ConnectionIDTable
;
;Doc: NetWare System Calls -- DOS, page 17-8.
;      

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_FILE_SERVER_NAME_TABLE		enum NetWareFunctionCode, 0xEF04
;This call returns a pointer to the NetWare shell's FileServerNameTable,
;which contains eight entries (1 to 8) of NW_USER_NAME_LENGTH bytes.
;Each entry can contain a null-terminated server name.         
;
;Pass:		ax	= NFC_GET_FILE_SERVER_NAME_TABLE
;
;Returns:	es:si	= FileServerNameTable
;
;Doc: NetWare System Calls -- DOS, page 17-16.

NetWareFileServerName	type	48 dup(char)	

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_BINDERY_OBJECT_ID		enum NetWareFunctionCode, 0xE335
;This call returns a bindery object's unique identification number.
;
;Pass:		ah	= (NFC_GET_BINDERY_OBJECT_ID shr 8)
;		ds:si	= RequestBuffer:

    NReqBuf_GetBinderyObjectID	struct
	NREQBUF_GBOID_length		word		53-2
	NREQBUF_GBOID_subFunc		byte		0x35
	NREQBUF_GBOID_objectType	NetObjectType 0
	NREQBUF_GBOID_objectNameLen	byte		0
	NREQBUF_GBOID_objectName	NetWareBinderyObjectName 0
    NReqBuf_GetBinderyObjectID	ends

;Pass:		es:di	= ReplyBuffer:

    NRepBuf_GetBinderyObjectID	struct
	NREPBUF_GBOID_length		word		56-2
	NREPBUF_GBOID_objectID		HiLoDWord	0
	NREPBUF_GBOID_objectType	NetObjectType 0
	NREPBUF_GBOID_objectName	NetWareBinderyObjectNameZ 0
    NRepBuf_GetBinderyObjectID	ends

;Returns:	es:di	= ReplyBuffer
;		al	= completion code
;
;Doc: NetWare System Calls -- DOS, page 3-38.

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_SCAN_FILE_INFORMATION		enum NetWareFunctionCode, 0xE30F
;This call returns information about a file. An application can execute
;this call iteratively to return information about a related group
;of files by including wildcards in the file name.
;
;Note:	For each workstation, the NetWare server keeps track of the
;	user's current directory on each of the network drives.
;	This information can be accessed using the DirectoryHandle
;	for each drive (see NFC_GET_DRIVE_HANDLE_TABLE). So the
;	easiest way to use this call it to get the DirectoryHandle
;	for the drive, stuff it into the request buffer
;	at offset NREQBUF_SFI_dirHandle, and then just place
;	the filename (or wildcard) in the request buffer. You
;	don't have to worry about pathnames, then.)
;
;Pass:		ah	= (NFC_SCAN_FILE_INFORMATION shr 8)
;		ds:si	= RequestBuffer:

    NetWareScanFileInfoFilePath	type	255 dup (char)

    NReqBuf_ScanFileInfo	struct
	NREQBUF_SFI_length		word		263-2
	NREQBUF_SFI_subFunc		byte		0x0F
	NREQBUF_SFI_sequenceNum		HiLoWord	0xFFFF
	NREQBUF_SFI_dirHandle		byte		0
	NREQBUF_SFI_searchAttributes	byte		0

	NREQBUF_SFI_filePathLen		byte		0
		;place the length of the name here

	NREQBUF_SFI_filePath		NetWareScanFileInfoFilePath <0>
		;place the DOS filename here, without a null-term.

    NReqBuf_ScanFileInfo	ends


;Pass:		es:di	= ReplyBuffer:

    NRepBuf_ScanFileInfo	struct
	NREPBUF_SFI_length		word		96-2
	NREPBUF_SFI_sequenceNum		HiLoWord
	NREPBUF_SFI_fileName		char 14 dup (?)
	NREPBUF_SFI_fileAttr		byte
	NREPBUF_SFI_extFileAttr		byte
	NREPBUF_SFI_fileSize		HiLoDWord
	NREPBUF_SFI_creationDate	HiLoWord
	NREPBUF_SFI_lastAccessDate	HiLoWord
	NREPBUF_SFI_lastUpdateDateTime	HiLoDWord
	NREPBUF_SFI_ownerObjectID	HiLoDWord
	NREPBUF_SFI_lastArchiveDateTime HiLoDWord
	NREPBUF_SFI_reserved		byte 56 dup (?)
    NRepBuf_ScanFileInfo	ends

;Returns:	es:di	= ReplyBuffer
;		al	= completion code:
	NRC_NO_SEARCH_PRIVILEGES	enum NetWareReturnCode, 0x89
	NRC_NO_MORE_MATCHING_FILES	enum NetWareReturnCode, 0xFF
;
;Doc: NetWare System Calls -- DOS, page 9-16.

;##############################################################################
; 			DIRECTORY SERVICES
;##############################################################################

NFC_GET_VOLUME_NAME			enum NetWareFunctionCode, 0xE206
;This call returns a volume name for a volume.
;
;Pass:		ax	= NFC_GET_VOLUME_NAME
;		ds:si 	= request buffer

    NReqBuf_GetVolumeName	struct
	NREQBUF_GVN_length		word		4-2
	NREQBUF_GVN_subfunc		byte		0x06
	NREQBUF_GVN_volumeNumber	byte	
    NReqBuf_GetVolumeName	ends

;		es:di	= reply buffer	

    NRepBuf_GetVolumeName	struct
	NREPBUF_GVN_length		word		19-2
	NREPBUF_GVN_nameLength		byte
	NREPBUF_GVN_name		NetWareVolumeName
    NRepBuf_GetVolumeName	ends

;Returns:	es:di	= ReplyBuffer
;		al	= completion code:
	;NRC_VOLUME_DOESNT_EXIST		enum NetWareReturnCode, 0x98
;Doc: NetWare System Calls -- DOS, pg. 7-43	
;	

NFC_ALLOC_PERMANENT_DIRECTORY_HANDLE	enum NetWareFunctionCode, 0xE212
;This call permanently assigns a workstation drive to a network directory
;
;Pass:		ax	= NFC_ALLOC_PERMANENT_DIRECTORY_HANDLE
;		ds:si	= request buffer

    NReqBuf_AllocPermDirHandle	struct
	NREQBUF_APDH_length		word		261-2
	NREQBUF_APDH_subfunc		byte		0x12
	NREQBUF_APDH_dirHandle		byte	
	NREQBUF_APDH_driveLetter	byte	
	NREQBUF_APDH_pathLength		byte
	NREQBUF_APDH_path		char	255 dup(?)
    NReqBuf_AllocPermDirHandle	ends

;		es:di	= reply buffer	

    NRepBuf_AllocPermDirHandle	struct
	NREPBUF_APDH_length		word		4-2
	NREPBUF_APDH_newDirHandle	byte
	NREPBUF_APDH_rightsMask		byte
    NRepBuf_AllocPermDirHandle	ends

;Notes:		pass dirHandle = 0 when the directory is defined using
;		only a path.
;Doc: NetWare System Calls -- DOS, pg. 7-10		
;	

NFC_GET_DIRECTORY_HANDLE		enum NetWareFunctionCode, 0xE900
;Returns the directory handle for the given drive.
;
;Pass:		ax	= NFC_GET_DIRECTORY_HANDLE
;		dx	= drive number (0-origin)
;
;Returns:	al	= Directory handle (0 if drive is invalid)
;		ah	= NWDriveFlags
;
;Notes:		the directory handle returned for a drive is for the
;		current directory on that drive, not for the root directory
;		of the drive. To find the root directory, you must ask
;		the shell for the current dir on the drive and clip the
;		path returned by NFC_GET_DIRECTORY_PATH by that many
;		chars.
;
;Doc: NetWare System Calls -- DOS, page 7-28.

NFC_DEALLOC_DIRECTORY_HANDLE		enum NetWareFunctionCode, 0xE214
;This call deallocates a permanent or temporary directory handle.
;
;Pass:		ax 	= NFC_DEALLOC_DIRECTORY_HANDLE
;		ds:si 	= request buffer:
    NReqBuf_DeallocDirectoryHandle	struct
	NREQBUF_DDH_length	word	size NReqBuf_DeallocDirectoryHandle-2
	NREQBUF_DDH_subFunc	byte	low NFC_DEALLOC_DIRECTORY_HANDLE
	NREQBUF_DDH_dirHandle	byte	
    NReqBuf_DeallocDirectoryHandle	ends
	
;
;		es:di	= reply buffer:
    NRepBuf_DeallocDirectoryHandle	struct
	NREPBUF_DDH_nada	word	0
    NRepBuf_DeallocDirectoryHandle	ends
;
;Returns:	al	= completion code
;
;Doc: NetWare System Calls -- DOS, page 7-20

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_DIRECTORY_PATH			enum NetWareFunctionCode, 0xE201
;Maps a directory handle, as returned by NFC_GET_DIRECTORY_HANDLE
;into its full ASCII path.
;
;Pass:		ax	= NFC_GET_DIRECTORY_PATH
;		ds:si	= request buffer:
    NReqBuf_GetDirectoryPath	struct
        NREQBUF_GDP_length	word	size NReqBuf_GetDirectoryPath-2
	NREQBUF_GDP_subFunc	byte	low NFC_GET_DIRECTORY_PATH
	NREQBUF_GDP_dirHandle	byte
    NReqBuf_GetDirectoryPath	ends
;
;		es:di	= reply buffer:
;
    NRepBuf_GetDirectoryPath	struct
	NREPBUF_GDP_length	word	size NRepBuf_GetDirectoryPath-2
	NREPBUF_GDP_pathLength	byte
	NREPBUF_GDP_path	char	255 dup(?)
    NRepBuf_GetDirectoryPath	ends
;
;Returns:	al	= completion code:
	NRC_BAD_DIRECTORY_HANDLE	enum NetWareReturnCode, 0x9B
;
;Doc: NetWare System Calls -- DOS, page 7-30


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_MAP_ROOT				enum NetWareFunctionCode, 0xE905
;Map a netware path as the root of a drive.
;
;Pass:		ax 	= NFC_MAP_ROOT
;		bx	= drive # (1-origin)
;		ds:dx	= NetWork path (XXX: INCLUDING SERVER?)
;
;Returns:	al	= completion code
;
;Doc:	NetWare Bullets 2/92, page 2
;

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_SCAN_DIRECTORY_INFORMATION		enum NetWareFunctionCode, 0xE202
;This call returns information about a subdirectory. An application can execute
;this call iteratively to return information about all subdirectories of
;a particular directory. This works exactly the same as
;NFC_SCAN_FILE_INFORMATION, except it works on subdirectories, not files.
;
;Note:	For each workstation, the NetWare server keeps track of the
;	user's current directory on each of the network drives.
;	This information can be accessed using the DirectoryHandle
;	for each drive (see NFC_GET_DRIVE_HANDLE_TABLE). So the
;	easiest way to use this call it to get the DirectoryHandle
;	for the drive, stuff it into the request buffer
;	at offset NREQBUF_SDI_dirHandle,  and then just place
;	the filename (or wildcard) in the request buffer. You don't have
;	to worry about pathnames, then.)
;
;Pass:		ah	= (NFC_SCAN_DIRECTORY_INFORMATION shr 8)
;		ds:si	= RequestBuffer:

    NetWareScanDirectoryInfoFilePath	type	255 dup (char)

    NReqBuf_ScanDirectoryInfo	struct
	NREQBUF_SDI_length		word		263-2
	NREQBUF_SDI_subFunc		byte		2
	NREQBUF_SDI_dirHandle		byte		0
	NREQBUF_SDI_sequenceNum		HiLoWord	0
	NREQBUF_SDI_dirPathLength	byte		0

	NREQBUF_SDI_dirPath		NetWareScanDirectoryInfoFilePath

    NReqBuf_ScanDirectoryInfo	ends


;Pass:		es:di	= ReplyBuffer:

    NRepBuf_ScanDirectoryInfo	struct
	NREPBUF_SDI_length		word		30-2
	NREPBUF_SDI_name		char	16 dup(?)
	NREPBUF_SDI_creationDate	HiLoWord	; FileDate, reversed
	NREPBUF_SDI_creationTime	HiLoWord	; FileTime, reversed
	NREPBUF_SDI_ownerObjectID	HiLoDWord
	NREPBUF_SDI_maxRightsMask	byte
					byte
	NREPBUF_SDI_sequenceNum		HiLoWord
    NRepBuf_ScanDirectoryInfo	ends

;Returns:	es:di	= ReplyBuffer
;		al	= completion code:
	NRC_VOLUME_DOESNT_EXIST		enum NetWareReturnCode, 0x98
	;NRC_BAD_DIRECTORY_HANDLE	enum NetWareReturnCode, 0x9B
	;NRC_INVALID_PATH		enum NetWareReturnCode, 0x9C
;			  NRC_INVALID_PATH is the expected result when there
;			  are no more subdirectories to enumerate.
;Doc: NetWare System Calls -- DOS, page 9-16.


;The NetWare functions NFC_GET_BROADCAST_MODE and NFC_SET_BROADCAST_MODE
;use this byte record:

NetWareMessageMode	etype	byte

NMM_RETRIEVE_SERVER_AND_USER	enum	NetWareMessageMode
; Both server and user messages will be retrived and displayed by the
; shell. 

NMM_RETRIEVE_SERVER_DISCARD_USER enum	NetWareMessageMode
; Server messages will be retrieved and displayed by the shell -- user
; messages will be discarded 

NMM_STORE_SERVER_DISCARD_USER	enum	NetWareMessageMode
; Server messages will be stored in the server -- applications can get
; the message by calling NFC_GET_BROADCAST_MESSAGE

NMM_STORE_SERVER_AND_USER	enum	NetWareMessageMode
; Both server and user messages will be stored in the server --
; applications can fetch either by calling NFC_GET_BROADCAST_MESSAGE



NETWARE_BROADCAST_MESSAGE_SIZE equ 55



;#############################################################################
;	PRINTING		
;#############################################################################
FORM_NAME_SIZE equ 16
PRINT_CRA_RESERVED_SIZE equ 6
BANNER_NAME_SIZE equ 14
BANNER_FILENAME_SIZE equ 13
HEADER_FILENAME_SIZE equ 14
NETWARE_PATH_NAME_SIZE equ 80

PrintJobClientRecordArea	struct
    PJCRA_versionNumber		byte
    PJCRA_tabSize		byte
    PJCRA_numberOfCopies	word
    PJCRA_controlFlags		word
    PJCRA_maximumLines		word
    PJCRA_maximumCharacters	word
    PJCRA_formName		char FORM_NAME_SIZE dup (?)
    PJCRA_reserved		char PRINT_CRA_RESERVED_SIZE dup (?)
    PJCRA_bannerName		char BANNER_NAME_SIZE dup (?)
    PJCRA_bannerFileName	char BANNER_FILENAME_SIZE dup (?)
    PJCRA_headerFileName	char HEADER_FILENAME_SIZE dup (?)
    PJCRA_directoryPath		char NETWARE_PATH_NAME_SIZE dup (?)
PrintJobClientRecordArea	ends

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_SET_CAPTURE_PRINT_QUEUE		enum NetWareFunctionCode, 0xB806
;
; Pass:		dh 	- LPT device (0-2)
;		bx:cx 	- Queue ID (use NFC_SCAN_BINDERY_OBJECT to get
;				list of available print queues)
;
; Return:	nothing 
;
; Destroyed:	nothing 
;
;

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_START_LPT_CAPTURE		enum NetWareFunctionCode, 0xDF00
;
; Begin capture to the previously specified queue.  This function
; should be called AFTER NFC_SET_CAPTURE_PRINT_QUEUE.
;
; Pass:		ah -  DFh
;		dl - 00h
;
; Return:	al - completion code
;
; Destroyed:	nothing 
;
; Doc: NetWare System Calls -- DOS  P. 11-50


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_START_SPECIFIC_LPT_CAPTURE		enum NetWareFunctionCode, 0XDF04
;
; Begin capture to the previously specified queue.  This function
; should be called AFTER NFC_SET_CAPTURE_PRINT_QUEUE.
;
; Pass:		ah -  DFh
;		dl - 04h
;		dh - LPT device (0-2)
;
; Return:	al - completion code
;
; Destroyed:	nothing 
;
; Doc: NetWare System Calls -- DOS  P. 11-52


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_END_LPT_CAPTURE		enum NetWareFunctionCode, 0XDF01
;
; End capture of the default LPT device
;
; Pass:		ah -  DFh
;		dl - 01h
;
; Return:	al - completion code
;
; Destroyed:	nothing 
;
; Doc: NetWare System Calls -- DOS  P. 11-7


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_END_SPECIFIC_LPT_CAPTURE		enum NetWareFunctionCode, 0XDF05
;
; End capture for the specified port
;
; Pass:		ah -  DFh
;		dl - 05h
;		dh - LPT device (0-2)
;
; Return:	al - completion code
;
; Destroyed:	nothing 
;
; Doc: NetWare System Calls -- DOS  P. 11-8


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_CANCEL_SPECIFIC_LPT_CAPTURE		enum NetWareFunctionCode, 0XDF06
;
; cancel capture for the specified port
;
; Pass:		ah -  DFh
;		dl - 06h
;		dh - LPT device (0-2)
;
; Return:	al - completion code
;
; Destroyed:	nothing 
;
; Doc: NetWare System Calls -- DOS  P. 11-5

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_SPECIFIC_CAPTURE_FLAGS	enum	NetWareFunctionCode, 0xB802
;
; Return the capture flags for the specified LPT device
;
; Pass:	ah 	- B8h
;	al 	- 02h		 shouldn't this say DL instead of AL?
;				 to be safe, pass it in both regs.
;	cx 	- reply buffer length
;	es:bx 	- reply buffer address
;	dh 	- LPT device
;
NetWarePrintFlags	record
    NWPF_BANNER:1
    NWPF_SERVER_CONTROL:1
    :2
    NWPF_SUPPRESS_FORM_FEED:1
    NWPF_PRINT_IF_CONNECTION_LOST:1
    :2
NetWarePrintFlags	end

    NRepBuf_GetCaptureFlags	struct
	NREPBUF_GCF_status		byte
	NREPBUF_GCF_flags		NetWarePrintFlags <>
	NREPBUF_GCF_tabSize		byte
	; 1-18

	NREPBUF_GCF_serverPrinter	byte
	NREPBUF_GCF_numCopies		byte
	NREPBUF_GCF_formType		byte
	NREPBUF_GCF_reserved1		byte
	NREPBUF_GCF_bannerText		char 13 dup (?)
	NREPBUF_GCF_reserved2		byte
	NREPBUF_GCF_lptDevice		byte
	; 0-2

	NREPBUF_GCF_flushTimeoutCount	HiLoWord	<>
	NREPBUF_GCF_flushOnDeviceClose	byte
	NREPBUF_GCF_maxLines		HiLoWord	<>
	NREPBUF_GCF_maxChars		HiLoWord	<>
	NREPBUF_GCF_formName		char 13 dup (?)
	NREPBUF_GCF_lptCaptureFlag	BooleanByte	<>
	NREPBUF_GCF_fileCaptureFlag	BooleanByte	<>
	NREPBUF_GCF_timingOutFlag	BooleanByte	<>
	NREPBUF_GCF_setupBuffer	HiLoDWord		<>
	; far pointer to buffer stored in shell

	NREPBUF_GCF_resetBuffer	HiLoDWord		<>
	; far pointer to buffer stored in shell

	NREPBUF_GCF_connIDJob		byte
	NREPBUF_GCF_captureInProgress	BooleanByte	<>
	NREPBUF_GCF_printQueueFlag	BooleanByte	<>
	NREPBUF_GCF_printJobValid	BooleanByte	<>
	NREPBUF_GCF_printQueueID	NetWareBinderyObjectID	<>
	NREPBUF_GCF_printJobNumber	HiLoWord	<>
    NRepBuf_GetCaptureFlags	ends

;
; Doc: NetWare System Calls -- DOS  P. 11-24


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_DEFAULT_CAPTURE_FLAGS	enum	NetWareFunctionCode, 0xB800
;
; Return the default capture flags
;
; Pass:	ah 	- B8h
;	al 	- 00h
;	cx 	- reply buffer length
;	es:bx 	- reply buffer (NRepBuf_GetCaptureFlags)
;	dh 	- LPT device
;
; Doc: NetWare System Calls -- DOS  P. 11-14

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_SET_DEFAULT_LOCAL_PRINTER	enum 	NetWareFunctionCode, 0xB805
; Sets the default LPT device for doing default local LPT capture calls.
;
; Pass:		ah - B8h
;		al - 05h
;		dh - LPT device (00h to 02h)
;
; Return:	al - completion code
;
; Doc: NetWare System Calls -- DOS p. 11-40
;


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_SET_SPECIFIC_CAPTURE_FLAGS	enum 	NetWareFunctionCode, 0xB803
;
; Set the capture flags for the specified LPT device
;
; Pass:		ah - B8h
;		al - 03h
;		cx - Request Buffer Length (1 to 42)
;		es:bx - request buffer
;		dh - LPT device (00h to 02h)
;
; Return:	al - completion code.
;
; 
; Doc: NetWare System Calls -- DOS  P. 11-41


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_SET_DEFAULT_CAPTURE_FLAGS	enum 	NetWareFunctionCode, 0xB801
;
; Set the capture flags for the specified LPT device
;
; Pass:		ah - B8h
;		al - 03h
;		cx - Request Buffer Length (1 to 42). 
;		es:bx - request buffer
;
; Return:	al - completion code.
;
; 
; Doc: NetWare System Calls -- DOS  P. 11-35




;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_GET_BANNER_USER_NAME	enum	NetWareFunctionCode, 0xB808
; Return the user name that is printed on the banner page.
;
; Pass:		ah - B8h
;		al - 08h
;		es:bx - reply buffer address (at least 12 bytes)
;
; Return:
;		al - completion code
;		
;
; Doc: NetWare System Calls -- DOS  P. 11-13


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_SET_BANNER_USER_NAME	enum	NetWareFunctionCode, 0xB809
;
; Set the user name that is printed on the banner page
;
; Pass:		ah - B8h
;		al - 09h
;		es:bx - request buffer (banner text).
;			Null-terminated?
;
; Doc: NetWare System Calls -- DOS  P. 11-30



;##############################################################################
;	QUEUE MANAGEMENT SERVICES
;##############################################################################
;
; This is the common data structure for creating / changing queue jobs.
;
QueueJobHeader	struct
    QJH_clientStation		byte
    QJH_clientTaskNumber	byte
    QJH_clientIDNumber		dword
    QJH_targetServerIDNumber	HiLoDWord	0xFFFFFFFF
    QJH_targetExecutionTime	byte 6 dup (0xFF)
    QJH_jobEntryTime		byte 6 dup (0xFF)
    QJH_jobNumber		HiLoWord
    QJH_jobType			HiLoWord
    QJH_jobPosition		byte
    QJH_jobControlFlags		byte
    QJH_jobFileName		NetWareFileName
    QJH_jobFileHandle		NetWareFileHandle
    QJH_serverStation		byte
    QJH_serverTaskNumber	byte
    QJH_serverIDNumber		dword
QueueJobHeader	ends


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_CREATE_QUEUE_JOB_AND_FILE	enum NetWareFunctionCode, 0xE368
; 
; Pass: ah - E3h
;	ds:si - Request buffer	
;	es:di - Reply buffer
;
;
; Return: al - Completion Code
;
; See PrintJobClientRecordArea for more information

; Note:  the "clientRecordArea" field of this data structure is
; actually defined to be an opaque 152 bytes.  However, since the
; primary (only?) purpose of this is for printing, I've cast it to be
; PrintJobClientRecordArea.  -cb
;
JOB_DESCRIPTION_SIZE equ 50

    NReqBuf_CreateQueueJobAndFile	struct
        NREQBUF_CQJAF_length	word	size NReqBuf_CreateQueueJobAndFile-2
	NREQBUF_CQJAF_subFunc	byte	low NFC_CREATE_QUEUE_JOB_AND_FILE
	NREQBUF_CQJAF_queueID	HiLoDWord
	NREQBUF_CQJAF_job		QueueJobHeader
	NREQBUF_CQJAF_descr	char JOB_DESCRIPTION_SIZE dup (?)
	NREQBUF_CQJAF_clientRecordArea	PrintJobClientRecordArea
    NReqBuf_CreateQueueJobAndFile	ends

    NRepBuf_CreateQueueJobAndFile	struct
	NREPBUF_CQJAF_length	word	size NRepBuf_CreateQueueJobAndFile-2
	NREPBUF_CQJAF_job		QueueJobHeader
    NRepBuf_CreateQueueJobAndFile	ends


; Doc: NetWare System Calls -- DOS, p. 12-23
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NFC_CLOSE_FILE_AND_START_QUEUE_JOB enum NetWareFunctionCode, 0xE369
;
; Pass:	ah - E3h
;	ds:si - RequestBuffer address
;	es:di - Reply Buffer address 

    NReqBuf_CloseFileAndStartQueueJob	struct
	NREQBUF_CFASQJ_length	word size NReqBuf_CloseFileAndStartQueueJob-2
	NREQBUF_CFASQJ_subFunc	byte low NFC_CLOSE_FILE_AND_START_QUEUE_JOB
	NREQBUF_CFASQJ_queueID		HiLoDWord
	NREQBUF_CFASQJ_jobNumber	HiLoWord
    NReqBuf_CloseFileAndStartQueueJob	ends

    NRepBuf_CloseFileAndStartQueueJob	struct
	NREPBUF_CFASQJ_null	word	0
    NRepBuf_CloseFileAndStartQueueJob	ends

; Doc: NetWare System Calls -- DOS, p. 12-18

;##############################################################################
;		Definitions for the NetWare IPX/SPX Facilities
;##############################################################################

;-----------------------------------------------------------------------------
;		Novell IPX/SPX Functions
;-----------------------------------------------------------------------------
;defined by NetWare.

IPXSPXFunction	etype	word
   ISF_IPX_OPEN_SOCKET			enum IPXSPXFunction, 0x0000
   ISF_IPX_CLOSE_SOCKET			enum IPXSPXFunction, 0x0001
   ISF_IPX_GET_LOCAL_TARGET		enum IPXSPXFunction, 0x0002
   ISF_IPX_SEND_PACKET			enum IPXSPXFunction, 0x0003
   ISF_IPX_LISTEN_FOR_PACKET		enum IPXSPXFunction, 0x0004
   ISF_IPX_CANCEL_EVENT			enum IPXSPXFunction, 0x0006
   ISF_IPX_GET_INTER_NETWORK_ADDRESS	enum IPXSPXFunction, 0x0009


;-----------------------------------------------------------------------------
;		Novell IPX/SPX Structures
;-----------------------------------------------------------------------------

;This enum is used within the IPXPacketHeaderStruct, which is defined below.
;For IPX packets, use 0 or 4. For SPX, only use 5.
;Note: we generally use type 0 or 4.

IPXPacketType	etype	byte
    IPXPT_UNKNOWN_PACKET_TYPE		enum IPXPacketType, 0
    IPXPT_ROUTING_INFO_PACKET		enum IPXPacketType, 1
    IPXPT_ECHO_PACKET			enum IPXPacketType, 2
    IPXPT_ERROR_PACKET			enum IPXPacketType, 3
    IPXPT_PACKET_EXCHANGE_PACKET	enum IPXPacketType, 4
    IPXPT_SEQUENCED_PACKET_PROTOCOL_PACKET enum IPXPacketType, 5
    IPXPT_EXPERIMENTAL			enum IPXPacketType, 16
		;#16-31 are experimental protocols.
    IPXPT_NETWARE_CORE_PROTOCOL		enum IPXPacketType, 17
		;I guess this is one of the experimental packet types...

;-----------------------------------------------------------------------------
;			IPX Packet Structure
;-----------------------------------------------------------------------------

;Under Novell, an IPX packet consists of two parts: a 30-byte header, and a
;data portion that can be from 0 to 546 bytes.
;
;IMPORTANT: some, but not all of the word-length values are stored in
;high-low byte order.

IPX_PACKET_HEADER_SIZE		equ	30	;30 bytes long, minimum

IPXPacketHeaderStruct	struct
    IPX_checksum		word	;Unused. Physical layer will perform
					;its own checksum on the entire packet,
					;so no need to set this.

    IPX_length			HiLoWord ;length of entire packet, including
					 ;the data portion. Hi-Lo byte order.

    IPX_transportControl	byte	;Used by NetWare inter-network bridges.
					;IPX layer will set this for us.

    IPX_packetType		IPXPacketType
					;Packet Type: see enum above.

    IPX_dest			NovellNodeSocketAddrStruct <>
					;Full destination network, node, and
					;socket address. Set network = 0 to use
					;the source network (will not pass
					;through an inter-network bridge.)
					;Use node = 0xFF FF FF FF FF FF for
					;broadcasting.

    IPX_source			NovellNodeSocketAddrStruct <>
					;Full source network, node, and socket
					;address. IPX will set this for us.
					;Passing the socket # is optional.

    ;ONLY if this structure is used to set up an actual IPX packet,
    ;will the "data" portion come next. The "data" portion of the packet
    ;isn't really part of the header. This is just defined here to show how
    ;things fit together.

    IPX_data			label	byte
					;data starts here. Can have up to
					;546 bytes.
IPXPacketHeaderStruct	ends

.assert (size IPXPacketHeaderStruct) eq IPX_PACKET_HEADER_SIZE

;-----------------------------------------------------------------------------
;			IPX/SPX Packet Structure
;-----------------------------------------------------------------------------
;This field controls the bi-directional flow of data across an SPX connection.

SPXConnectionControl	record
    SPXCC_SYSTEM_PACKET:1	;
    SPXCC_ACK_REQUIRED:1	;
    SPXCC_RESERVED:1		;
    SPXCC_END_OF_MESSAGE:1	;
    :4
SPXConnectionControl	end

;This field indicates the type of data in the packet.

SPXDatastreamType	etype	byte
    SPXDT_CLIENT_DEFINED			enum SPXDatastreamType, 0x00
				;values 0x00-0xFD can be defined by the client
    SPXDT_END_OF_CONNECTION_ACK_PACKET		enum SPXDatastreamType, 0xFE
				;this may be wrong...
    SPXDT_RESERVED		enum SPXDatastreamType, 0xFE
				;"values 0xFE - 0xFF are reserved for use
				;by SPX connection management"

SPXConnectionIDType	type	byte

;This structure defines an SPX packet. Our "HugeECB" structure contains one
;of these, so that it can be used for both IPX and SPX packets.
;(IPX_packetType = IPXPT_SEQUENCED_PACKET_PROTOCOL_PACKET if is SPX packet).

;Under Novell, an SPX packet consists of two parts: a 40-byte header, and a
;data portion that can be from 0 to 536 bytes.

SPX_PACKET_HEADER_SIZE		equ	IPX_PACKET_HEADER_SIZE+10
					;40 bytes long, minimum

IPX_SPXPacketHeaderStruct	struct
    IPXSPX_ipx			IPXPacketHeaderStruct <>
					;the IPX portion of this structure

    IPXSPX_connectionControl	SPXConnectionControl
					;This field controls the bi-directional
					;flow of data across an SPX connection.

    IPXSPX_datastreamType	SPXDatastreamType
					;This field indicates the type of data
					;in the packet.

    IPXSPX_sourceConnectionID	SPXConnectionIDType
					;Source connection ID

    IPXSPX_destConnectionID	SPXConnectionIDType
					;Destination connection ID

    IPXSPX_sequenceNumber	word	;internal, for sequencing

    IPXSPX_ackNumber		word	;the next sequence value expected

    IPXSPX_allocationNumber	word	;used to track how many packets have
					;been sent but not acknowledged.

    ;ONLY if this structure is used to set up an actual IPX packet,
    ;will the "data" portion come next. The "data" portion of the packet
    ;isn't really part of the header. This is just defined here to show how
    ;things fit together.

    IPXSPX_data			label	byte
					;data starts here. Can have up to
					;536 bytes.
IPX_SPXPacketHeaderStruct	ends

.assert (size IPX_SPXPacketHeaderStruct) eq SPX_PACKET_HEADER_SIZE

;This is the size of the largest IPX/SPX packet that NetWare will accept:

MAX_IPXSPX_PACKET_SIZE		equ	576


;-----------------------------------------------------------------------------
;			Event Control Block (ECB)
;-----------------------------------------------------------------------------

;This enum is used below.

ECB_InUseFlag	etype	byte
    ECBIUF_RELEASED_BY_IPX	enum ECB_InUseFlag, 0x00
    ECBIUF_IPX_TEMP_HOLD	enum ECB_InUseFlag, 0xFB
    ECBIUF_IPX_WAITING_ON_TIMER	enum ECB_InUseFlag, 0xFD
    ECBIUF_IPX_LISTENING	enum ECB_InUseFlag, 0xFE
    ECBIUF_IPX_IN_USE_FOR_SEND	enum ECB_InUseFlag, 0xFF
    ECBIUF_IPX_PROCESSING	enum ECB_InUseFlag, 0xFA
    ECBIUF_IPX_IN_WAIT_QUEUE	enum ECB_InUseFlag, 0xF8

;This enum is used below.

ECB_CompletionCode	etype	byte
    ECBCC_SUCCESSFUL		enum ECB_CompletionCode, 0x00
		;indicates successful send or receive.

    ECBCC_CANCEL_FAILED		enum ECB_CompletionCode, 0xF9
		;if an ECB is resubmitted to IPX for cancelling, this code
		;will be returned if the event could not be cancelled.

    ECBCC_CANCELLED		enum ECB_CompletionCode, 0xFC
		;indicates send or receive cancelled.

    ECBCC_BAD_PACKET		enum ECB_CompletionCode, 0xFD
		;on send, returned when you pass a bad packet.
		;on receive, returned if received packet is too big.

    ECBCC_UNDELIVERED		enum ECB_CompletionCode, 0xFE
		;on send, returned when packet cannot be delivered.

    ECBCC_FAILURE		enum ECB_CompletionCode, 0xFF
		;on send, indicates a hardware failure
		;on receive, indicates that the socket to listen to
		;does not exit (have to open it first, dummy).

;To send a packet, you must fill in this structure, and pass it to IPX.
;Similarly, to receive a packet, you must pass this structure to IPX.
;When a packet is received, this IPX will return this structure to you
;by calling through the "ESR Address" field.

IPX_WORKSPACE_SIZE		equ	4
IPXWorkspaceType		type	IPX_WORKSPACE_SIZE dup (byte)

DRIVER_WORKSPACE_SIZE		equ	12
DriverWorkspaceType		type	DRIVER_WORKSPACE_SIZE dup (byte)

	
ECB_SIZE			equ	42	;42 bytes long, minimum

EventControlBlockStruct	struct
    ECB_linkAddress		fptr	;IPX will use this to chain ECBs
					;together. Before you pass an ECB,
					;or after IPX has returned it, your
					;application can link ECBs using
					;this field. (So it is not necessarily
					;an fptr.)

    ECB_eventServiceRoutine	fptr	;pointer to your fixed callback routine
					;which will handle incoming packets.
					;Interrupts will be off. Return quickly!

    ECB_inUseFlag		ECB_InUseFlag
					;indicates whether ECB structure is
					;being processed by IPX, or whether we
					;have control over it.

    ECB_completionCode		ECB_CompletionCode
					;returned to indicate status of send
					;or receive ooperation.

    ECB_socketAddress		NovellSocketAddress <>
					;when sending, place dest. socket #
					;here. When listening, this is the
					;socket # to listen on.

    ECB_IPXWorkspace		IPXWorkspaceType
					;IPX will use this area.

    ECB_driverWorkspace		DriverWorkspaceType
					;driver will use this area.

    ECB_immediateAddress	NovellNodeAddress <>	;guess
					;when sending, place dest. node address
					;here. When listening, this is the
					;source node address.

    ECB_fragmentCount		word	 ;number of buffers that will be
					 ;used to hold the inbound our
					 ;outbound packet. (NOT Hi-Lo.)
					 ;For each, this ECB structure has two
					 ;fields as follows:

    ECB_fragmentAddress1	fptr	;address of first buffer for incoming
					;or outgoing packet. This MUST be at
					;least 30 bytes long.

    ECB_fragmentSize1		word	;size of first buffer (NOT Hi-Lo)

    ;if the ECB will use more than one "fragment" buffer, then additional
    ;lie here.

EventControlBlockStruct	ends

.assert (size EventControlBlockStruct) eq ECB_SIZE


;------------------------------------------------------------------------------
;		Misc NetWare Definitions
;------------------------------------------------------------------------------

;for IPXOpenSocket:

SocketLongevityFlag	etype	byte
    SLF_KEEP_SOCKET_UNTIL_APP_EXITS		enum SocketLongevityFlag, 0x00
		;NetWare will automatically close the socket if the DOS
		;application (meaning PC/GEOS) exits, or is task-switched out.

    SLF_KEEP_SOCKET_UNTIL_EXPLICITLY_CLOSED	enum SocketLongevityFlag, 0xFF
		;NetWare will not close the socket unless specifically asked
		;to. This is dangerous, because the socket will remain open
		;during a task switch or exit to DOS, and your callback routines
		;and buffers will have been swapped out.
		;			(DO NOT USE UNDER PC/GEOS!)

IPXOpenSocketCompletionCode	etype byte
    IOSCC_SUCCESSFUL			enum IPXOpenSocketCompletionCode, 0x00
    IOSCC_SOCKET_TABLE_FULL		enum IPXOpenSocketCompletionCode, 0xFE
    IOSCC_SOCKET_ALREADY_OPEN		enum IPXOpenSocketCompletionCode, 0xFF

