COMMENT @----------------------------------------------------------------------

	Copyright (c) GeoWorks 1989 -- All Rights Reserved

PROJECT:	PC GEOS

FILE:		dos.def

DECLARER:	Kernel

REQUIRES:

DESCRIPTION:
	This file provides constants for the Boot and File modules.

	$Id: dos.def,v 1.1 97/04/04 14:15:01 newdeal Exp $

------------------------------------------------------------------------------@

SetDef	__DOS

StartKernel

include file.def
include fileEnum.def

;==============================================================================
;
;			BIOS-RELATED CONSTANTS
;
;==============================================================================

;
;	Int 13h function codes
;

BiosInt13Func	etype	byte
    B13F_RESET_DISK_SYSTEM		enum	BiosInt13Func, 0
    B13F_GET_DISK_SYSTEM_STATUS		enum	BiosInt13Func, 1
    B13F_READ_SECTOR			enum	BiosInt13Func,	2
    ;
    ;	Pass:	al	= number of sectors
    ;		ch	= track number (0-origin)
    ;		cl	= sector number (1-origin)
    ;		dh	= head number (0-origin)
    ;		dl	= drive number
    ;		es:bx	= buffer to which to read
    ;	Return:	carry set on error:
    ;			ah	= error code
    ;		al	= number of sectors read
    ;		
    B13F_WRITE_SECTOR			enum	BiosInt13Func,	3
    ;
    ;	Pass:	al	= number of sectors
    ;		ch	= track number (0-origin)
    ;		cl	= sector number (1-origin)
    ;		dh	= head number (0-origin)
    ;		dl	= drive number
    ;		es:bx	= buffer from which to write
    ;	Return:	carry set on error:
    ;			ah	= error code
    ;		al	= number of sectors written
    ;		
    B13F_VERIFY_SECTORS			enum	BiosInt13Func, 4
    ;
    ;	Pass:	al	= number of sectors (1-18)
    ;		ch	= track number (0-79)
    ;		cl	= starting sector number (1-18)
    ;		dh	= head number (0/1)
    ;		dl	= drive number
    ;		es:bx	= address field data
    ;	Return:	carry set on error:
    ;			ah	= error code
    ;		al	= number of sectors verified.
    ;
    B13F_FORMAT_TRACK			enum	BiosInt13Func, 5
    ;
    ;	Pass:	al	= number of sectors to be formatted
    ;		ch	= track number (0-origin)
    ;		cl	= head number (0 or 1)
    ;		dl	= drive number (0 or 1)
    ;		es:bx	= array of AddrFieldEntry structures, 1 per sector
    ;	Return:	carry set on error:
    ;			ah	= BiosInt13Error
    ;
    B13F_GET_DRIVE_PARAMS		enum	BiosInt13Func,	8
    B13F_GET_DISK_TYPE			enum	BiosInt13Func,	15h
    B13F_SET_DISK_TYPE			enum	BiosInt13Func, 17h
    ;
    ;	Pass:	al	= BiosDiskType
    ;		dl	= drive number (0 or 1)
    ;	Return:	carry set on error:
    ;			ah	= BiosInt13Error
    ;		carry clear on success:
    ;			ah	= 0
    ;
    ;	Not valid for XT machines

BiosDiskType	etype	byte, 1
    BDT_360_IN_360	enum BiosDiskType
    BDT_360_IN_1M2	enum BiosDiskType
    BDT_1M2_IN_1M2	enum BiosDiskType
    BDT_720_IN_720	enum BiosDiskType

    B13F_SET_MEDIA_TYPE			enum 	BiosInt13Func, 18h
    ;
    ; 	Pass:	ch	= maximum number of tracks
    ; 		cl	= sectors per track
    ; 		dl	= drive number (0 or 1)
    ; 	Return:	carry set on error:
    ;			ah	= BiosInt13Error
    ;		carry clear on success:
    ;			ah	= 0
    ;			es:di	= drive parameter table
    ;
    ;	Not valid for XT machines.
    ; 		

B13F_MAX_RETRIES		equ	3	; # of times to retry operation
						;  to account for BIOS
						;  impatience w/drive motor
B13F_FORMAT_RETRIES		equ	5

BiosInt13Error	etype	byte
    B13E_DRIVE_NOT_READY	enum	BiosInt13Error, 0x80
    B13E_SEEK_FAILED		enum	BiosInt13Error, 0x40
    B13E_CONTROLLER_FAILURE	enum	BiosInt13Error, 0x20
    B13E_CRC_ERROR		enum	BiosInt13Error, 0x10
    B13E_BAD_MEDIA_TYPE		enum	BiosInt13Error, 0x0c
    B13E_DMA_CROSSES_64K	enum	BiosInt13Error, 0x09
    B13E_DMA_OVERRUN		enum	BiosInt13Error, 0x08
    B13E_DISK_CHANGED		enum	BiosInt13Error, 0x06
    B13E_SECTOR_NOT_FOUND	enum	BiosInt13Error, 0x04
    B13E_WRITE_PROTECTED	enum	BiosInt13Error, 0x03
    B13E_ADDRESS_MARK_NOT_FOUND	enum	BiosInt13Error, 0x02
    B13E_INVALID_PARAMETER	enum	BiosInt13Error, 0x01
    
;
;	address field entry for int 13h, function B13F_FORMAT_TRACK
;

AddrFieldEntry	struct
	AFE_cylinderNum		db	(?)
	AFE_headNum		db	(?)
	AFE_sectorNum		db	(?)
	AFE_sectorSize		db	(?)
AddrFieldEntry	ends

ByteArrayEntry	struct
	BAE_sectorStat		db	(?)
	BAE_sectorNum		db	(?)
ByteArrayEntry	ends

;--------------------------------------------------------------------------
;	Equipment configuration list code word returned by int 11h
;	See Advanced MSDOS Programming, 2ed by Ray Duncan, pg 535
;--------------------------------------------------------------------------

EqptConfig record
	EC_NUM_PRNS:2
	EC_INT_MDM:1
	EC_GAME_ADAPTER:1
	EC_NUM_RS232_PORTS:3
	:1
	EC_NUM_FLOPPIES:2
	EC_VIDEO_MODE:2
	:1
	EC_POINTER:1
	EC_MATH_COPROC:1
	EC_FLOPPY:1
EqptConfig end

;--------------------------------------------------------------------------
;	Equipment configuration codes
;
;Use these constants after the irrelevant bits have been masked off
;--------------------------------------------------------------------------

ECC_1_FLOPPY	=	0 shl offset EC_NUM_FLOPPIES
ECC_2_FLOPPIES	=	1 shl offset EC_NUM_FLOPPIES
ECC_3_FLOPPIES	=	2 shl offset EC_NUM_FLOPPIES
ECC_4_FLOPPIES	=	3 shl offset EC_NUM_FLOPPIES


BIOS_DATA_SEG	equ	40h

BIOS_SERIAL_PORTS	equ	{word}[0]	; Offset of array of up to four
						;  base serial port numbers
BIOS_PRINTER_PORTS	equ	{word}[8]	; Offset of array of up to four
						;  base parallel ports
BIOS_EQUIPMENT		equ	{EqptConfig}[10h]; Installed hardware
BIOS_MEMORY_SIZE	equ	{word}[13h]	;Total conventional memory, in
						; Kbytes
BIOS_SYSTEM_COUNTER	equ	{dword}[6ch]	;Timer counter
BIOS_RESET_FLAG		equ	{word}[72h]	;Type of reset
    BRF_WARM_START	equ	1234h		; warm start: no memory test
    BRF_SAVE_MEMORY	equ	4321h		; hot start: don't touch mem


BiosDataRate	etype	byte, 0
    BDR_500KPS	enum	BiosDataRate
    BDR_300KPS	enum	BiosDataRate
    BDR_250KPS	enum	BiosDataRate
    BDR_RESV	enum	BiosDataRate

BiosDriveMediaState etype byte, 0
    ; 360K disk in 360K drive, media not established (might be wrong)
    BDMS_360IN360NE	enum	BiosDriveMediaState
    ; 360K disk in 1.2M drive, media not established (might be wrong)
    BDMS_360IN1_2NE	enum	BiosDriveMediaState
    ; 1.2M disk in 1.2M drive, media not established (might be wrong)
    BDMS_1_2IN1_2NE	enum	BiosDriveMediaState
    ; 360K disk in 360K drive, media correct
    BDMS_360IN360	enum	BiosDriveMediaState
    ; 360K disk in 1.2M drive, media correct
    BDMS_360IN1_2	enum	BiosDriveMediaState
    ; 1.2M disk in 1.2M drive, media correct
    BDMS_1_2IN1_2	enum	BiosDriveMediaState
    
    BDMS_RESERVED	enum	BiosDriveMediaState
    BDMS_UNKNOWN	enum	BiosDriveMediaState

BiosMediaState	record
    BMS_DATA_RATE BiosDataRate:2,	; transfer rate
    BMS_DOUBLE_STEP:1,			; set if double-step required per track
    BMS_MEDIA_ESTABLISHED:1,		; set if type of disk is definitely
					;  correct
    :1,
    BMS_DRIVE_MEDIA BiosDriveMediaState:3,	; drive/media combo and if it's
						;  definite.
BiosMediaState	end

BIOS_MEDIA_STATE_0	equ {BiosMediaState}[90h]
BIOS_MEDIA_STATE_1	equ {BiosMediaState}[91h]

;------------------------------------------------------------------------------
;	Bios Param Block
;------------------------------------------------------------------------------

BiosParamBlock	struct
    BPB_sectorSize		word	; Bytes/sector
    BPB_clusterSize		byte	; Sectors/cluster
    BPB_numReservedSectors	word	; Number of reserved sectors
    BPB_numFATs			byte	; Number of FATs in volume
    BPB_numRootDirEntries	word	; Number of entries in root dir
    BPB_numSectors		word	; Total number of sectors
    BPB_mediaDescriptor		byte	; Media descriptor
    BPB_sectorsPerFAT		word	; Sectors in a FAT
    BPB_sectorsPerTrack		word	; Sectors per track
    BPB_numHeads		word	; Number of heads on the drive
    BPB_numHiddenSectors	dword	; Number of hidden sectors (only
					;  low word significant for 3.x)
    BPB_largeNumSectors		dword	; Total number of sectors
					;  if BPB_numSectors is 0.
    BPB_reserved		byte 6 dup(?)
BiosParamBlock	ends

BiosBytesPerSector	etype	byte, 0
    BBPS_128		enum	BiosBytesPerSector
    BBPS_256		enum	BiosBytesPerSector
    BBPS_512		enum	BiosBytesPerSector
    BBPS_1024		enum	BiosBytesPerSector

DisketteParams	struct		; Parameter block pointed to by INT 1EH
    DP_specBytes	byte	2 dup(?)
    DP_motorOff		byte
    DP_bytesPerSector	BiosBytesPerSector
    DP_sectorsPerTrack	byte
    DP_gapLength	byte
    DP_dataLength	byte
    DP_formatGapLength	byte
    DP_fillByte		byte
    DP_settleTime	byte
    DP_motorStart	byte
DisketteParams	ends

BIOS_DISK_PARAMS_VECTOR	equ	1eh

; Descriptor table return by INT 15h, function c0h
SysDescFeatures	record
    SDF_USES_DMA3:1,		; Set if fixed disk uses DMA channel 3
    SDF_2ND_IC:1,		; Set if second interrupt controller present
    SDF_RTC_PRESENT:1,		; Set if real-time-clock present
    SDF_KBD_INTERCEPT:1,	; Set it keyboard intercept is available
    SDF_WAIT_FOR_EVENT:1,	; Set if "wait for event" call available
    SDF_XTNDED_BIOS:1,		; Set if extended BIOS area is allocated
    SDF_MCA:1,			; Set if system uses Micro Channel Architecture
    :1,
SysDescFeatures	end

SysDescTable    struct
    SDT_length          word            ; Length of table
    SDT_model           byte            ; Model byte
    SDT_subModel        byte            ; Sub model byte
    SDT_biosRev         byte            ; BIOS revision #
    SDT_features        SysDescFeatures ; Feature bits
SysDescTable    ends

BIOS_GET_SYS_DESC	equ	0xc0	; Subfunction of int 15h to obtain
					;  SysDescTable
;==============================================================================
;
;			DOS-RELATED CONSTANTS
;
;==============================================================================

;--------------------------------------------------------------------------
;			Hardware locations
;--------------------------------------------------------------------------

CRITICAL_VECTOR		=	24h		;INT 24h vector

CriticalErrorRegion	etype	byte
    CER_RESERVED	enum CriticalErrorRegion	; reserved area of
							;  disk (i.e. boot sect)
    CER_FAT		enum CriticalErrorRegion
    CER_ROOT_DIR	enum CriticalErrorRegion
    CER_FILES		enum CriticalErrorRegion

CriticalErrorFlags	record
    CEF_CHAR_DEV:1			; set if char dev or corrupted FAT image
					;  in memory, clear if block device
    :1
    CEF_IGNOREABLE:1			; set if CR_IGNORE return allowed
    CEF_RETRYABLE:1			; set if CR_RETRY return allowed
    CEF_FAILABLE:1			; set if CR_FAIL return allowed
    CEF_REGION CriticalErrorRegion:2	; area of disk affected
    CEF_WRITE:1				; set if writing, clear if reading
CriticalErrorFlags	end

CriticalErrors	etype	byte, 0
    CE_WRITE_PROTECTED	enum	CriticalErrors	; Should never happen
    CE_UNKNOWN_DRIVE	enum	CriticalErrors
    CE_DRIVE_NOT_READY	enum	CriticalErrors
    CE_UNKNOWN_COMMAND	enum	CriticalErrors
    CE_DATA_ERROR	enum	CriticalErrors
    CE_BAD_REQUEST	enum	CriticalErrors
    CE_SEEK_ERROR	enum	CriticalErrors
    CE_UNKNOWN_MEDIA	enum	CriticalErrors
    CE_SECTOR_NOT_FOUND	enum	CriticalErrors
    CE_OUT_OF_PAPER	enum	CriticalErrors	; Should never happen
    CE_WRITE_FAULT	enum	CriticalErrors
    CE_READ_FAULT	enum	CriticalErrors
    CE_GENERAL		enum	CriticalErrors
    CE_SHARING_VIOLATION enum	CriticalErrors	; Generated by Netware VLM

CriticalReturns	etype	byte, 0
    CR_IGNORE		enum	CriticalReturns
    CR_RETRY		enum	CriticalReturns
    CR_TERMINATE	enum	CriticalReturns
    CR_FAIL		enum	CriticalReturns

;--------------------------------------------------------------------------
;			System constants
;--------------------------------------------------------------------------

MSDOS_MAX_DRIVES	=	26

MSDOS_STD_SECTOR_SIZE	=	512

MSDOS_TEXT_FILE_EOF	=	26
MSDOS_DRIVE_REF_LENGTH	=	2
MSDOS_MAX_SECTORS_PER_TRACK	=	64	; for 2.88 Mb 3.5" floppies.
						;  The notion of having this
						;  as a constant, however, is
						;  doomed to failure.

;
;	Highest sector number for read/write sectors that may not be gotten from
;	the DOS cache. If the read/write stays completely below this sector
;	number, we will use BIOS to perform the operation.
;
MSDOS_MAX_NON_CACHE		= 	9

MSDOS_PATH_BUFFER_SIZE		equ	66

;--------------------------------------------------------------------------
;			MS-DOS Function calls
;--------------------------------------------------------------------------

;	Codes for INT 21 calls

Int21Call	etype	byte

MSDOS_CONSOLE_INPUT		enum Int21Call, 07h
MSDOS_DISPLAY_STRING		enum Int21Call, 09h
MSDOS_FLUSH_AND_DO_CONSOLE	enum Int21Call, 0ch
MSDOS_RESET_DISK		enum Int21Call, 0dh
MSDOS_SET_DEFAULT_DRIVE		enum Int21Call, 0eh
MSDOS_FIRST_FCB_CALL		enum Int21Call, 0fh
MSDOS_FCB_SEARCH_FOR_FIRST	enum Int21Call, 11h
MSDOS_FCB_DELETE		enum Int21Call, 13h
MSDOS_FCB_CREATE		enum Int21Call, 16h
MSDOS_FCB_RENAME		enum Int21Call, 17h
MSDOS_GET_DEFAULT_DRIVE		enum Int21Call, 19h
MSDOS_SET_DTA			enum Int21Call, 1ah
MSDOS_GET_DISK_GEOMETRY		enum Int21Call, 1ch
;	Pass:	dl	= drive number (1-origin)
;	Return:	al	= sectors/cluster
;		cx	= bytes/sector
;		dx	= clusters/disk
;		ds:bx	= points to media descriptor byte
;	Doesn't seem to return an error...
;

MSDOS_PARSE_FILENAME		enum Int21Call, 29h
DosParseFilenameControl record
    DPFC_DONT_SET_EXTENSION:1	; don't set extension in FCB unless one is
				;  given. If 0 and no extension given,
				;  extension is filled w/spaces
    DPFC_DONT_SET_FILENAME:1	; don't set name in FCB unless one is
				;  given. If 0 and no name given,
				;  name is filled w/spaces
    DPFC_DONT_SET_DRIVE:1	; don't set drive in FCB unless one is
				;  given. If 0 and no drive given,
				;  drive is set to 0 (default drive)
    DPFC_IGNORE_LEADING_SEP:1	; skip over leading separators
DosParseFilenameControl	end

MSDOS_LAST_FCB_CALL		enum Int21Call, 2dh

MSDOS_GET_VERSION		enum Int21Call, 30h
MSDOS_TSR			enum Int21Call, 31h
MSDOS_GET_DCB			enum Int21Call, 32h
;	Pass:	dl	= drive number (1-origin)
;	Return:	al	= ffh if drive invalid.
;		ds:bx	= pointer to DCB appropriate to DOS version.
;
;	Notes:	OS/2 DOS box supports 3.3 version of this call, except
;		no DeviceHeader fptr is available.
;
;		This call access the drive if the DCB is marked invalid,
;		making it useless for our purposes.
;

MSDOS_GET_INDOS_FLAG_ADDRESS	enum Int21Call, 34h
MSDOS_FREE_SPACE		enum Int21Call, 36h
MSDOS_CREATE_DIR		enum Int21Call, 39h
MSDOS_DELETE_DIR		enum Int21Call, 3ah
MSDOS_SET_CURRENT_DIR		enum Int21Call, 3bh
MSDOS_CREATE_TRUNCATE		enum Int21Call, 3ch
MSDOS_OPEN_FILE			enum Int21Call, 3dh
MSDOS_CLOSE_FILE		enum Int21Call, 3eh
MSDOS_READ_FILE			enum Int21Call, 3fh
MSDOS_WRITE_FILE		enum Int21Call, 40h
MSDOS_DELETE_FILE		enum Int21Call, 41h
MSDOS_POS_FILE			enum Int21Call, 42h
MSDOS_GET_SET_ATTRIBUTES	enum Int21Call, 43h
MSDOS_IOCTL			enum Int21Call, 44h

MSDOS_IOCTL_GET_DEV_INFO	equ (MSDOS_IOCTL shl 8) or 0
;
;	Pass:	bx	= handle
;	Return:	dx	= DosIOCTLRec
;
;	Notes:	this doesn't seem to work if the handle is open to a remote
;		file, certainly not with DR DOS 6 and NetWare 3.11, where
;		it returns a garbage drive number
;

DosIOCTLRec	record	; record returned if DOS_IOCTL_IS_CHAR_DEVICE set
	:1=0
	DOS_IOCTL_HANDLES_CONTROL_STRINGS:1
	:6=0
	DOS_IOCTL_IS_CHAR_DEVICE:1=1
	DOS_IOCTL_NOT_EOF_INPUT:1
	DOS_IOCTL_RAW_MODE:1
	:1=0
	DOS_IOCTL_IS_CLOCK:1
	DOS_IOCTL_IS_NUL:1
	DOS_IOCTL_IS_CONSOLE_OUT:1
	DOS_IOCTL_IS_CONSOLE_IN:1
DosIOCTLRec	end

DosBDevIOCTLRec	record	; record returned if DOS_IOCTL_IS_CHAR_DEVICE clear
	:1=0
	DOS_BDEV_IOCTL_HANDLES_CONTROL_STRINGS:1
	:6=0
	DOS_BDEV_IOCTL_IS_CHAR_DEVICE:1=0
	DOS_BDEV_IOCTL_FILE_CLEAN:1	; set if file not written to
	DOS_BDEV_IOCTL_DRIVE_NUMBER:6	; drive on which file is open.
DosBDevIOCTLRec	end

MSDOS_IOCTL_SET_DEV_INFO	equ (MSDOS_IOCTL shl 8) or 1
MSDOS_IOCTL_READ_CONTROL_STRING	equ (MSDOS_IOCTL shl 8) or 2
;
;	Pass:	ds:dx	= buffer to which to read
;		cx	= # bytes
;		bx	= DOS handle
;	Return:	carry set on error
;

MSDOS_IOCTL_CHECK_REMOVABLE	equ (MSDOS_IOCTL shl 8) or 8
MSDOS_IOCTL_GEN_BLOCK_DEV	equ (MSDOS_IOCTL shl 8) or 0xd
;
;	Pass:	bl	= drive code (0 = default, 1 = A)
;		ch	= category: 8 = disk (no other defined)
;		cl	= DosGenBlockDevFunc
;		ds:dx	= parameter block
;	Return:	carry set on error:
;			ax	= FileError

DosGenBlockDevFunc	etype	byte
    DGBDF_SET_DEVICE_PARAMS		enum	DosGenBlockDevFunc, 0x40
    ;
    ;	Pass:	ds:dx	= SetDeviceParams
    ;
    DGBDF_WRITE_TRACK			enum	DosGenBlockDevFunc, 0x41
    ;
    ;	Pass:	ds:dx	= ReadWriteTrackParams
    ;

    DGBDF_FORMAT_AND_VERIFY_TRACK	enum	DosGenBlockDevFunc, 0x42
    ;
    ;	Pass:	ds:dx	= FormatVerifyParams
    ;

    DGBDF_SET_ACCESS_FLAG		enum	DosGenBlockDevFunc, 0x47
    ;
    ;	Pass:	ds:dx	= GetSetAccessFlagParams
    ;
    ;	NOTE:	valid/necessary for MS 4+ only
    ;

    DGBDF_GET_DEVICE_PARAMS		enum	DosGenBlockDevFunc, 0x60
    ;
    ;	Pass:	ds:dx	= GetDeviceParams
    ;
    
    DGBDF_READ_TRACK			enum	DosGenBlockDevFunc, 0x61
    ;
    ;	Pass:	ds:dx	= ReadWriteTrackParams
    ;
    
    DGBDF_VERIFY_TRACK			enum	DosGenBlockDevFunc, 0x62
    ;
    ;	Pass:	ds:dx	= FormatVerifyParams
    ;
    
    DGBDF_GET_ACCESS_FLAG		enum	DosGenBlockDevFunc, 0x67
    ;
    ;	Pass:	ds:dx	= GetSetAccessFlagParams
    ;
    ;	NOTE:	valid/necessary for MS 4+ only
    ;

IoctlDeviceType	etype	byte
    IDT_LOW_5_25	enum	IoctlDeviceType
    IDT_HIGH_5_25	enum	IoctlDeviceType
    IDT_LOW_3_5		enum	IoctlDeviceType
    IDT_LOW_8		enum	IoctlDeviceType
    IDT_HIGH_8		enum	IoctlDeviceType
    IDT_FIXED		enum	IoctlDeviceType
    IDT_TAPE		enum	IoctlDeviceType
    IDT_OTHER		enum	IoctlDeviceType
    IDT_RW_OPTICAL	enum	IoctlDeviceType
    IDT_ULTRA_HIGH_3_5	enum	IoctlDeviceType	; 2.88Mb
    
IoctlDeviceAttrs record
    :14=0
    IDA_HAS_CHANGE_LINE:1		; Set if drive knows when disk has
					;  changed.
    IDA_FIXED:1				; Set if disk cannot be removed
IoctlDeviceAttrs end

SpecialFuncs	record
    SF_SECTORS_SAME_SIZE:1,		; Set if sectors are all the same size
    SF_SET_TRACK_LAYOUT_ONLY:1,		; Set if wanting to set the track layout
					;  only, clear if wanting to set all
					;  aspects of the device.
    SF_SET_CURRENT_BPB:1,		; Set if wanting to set the current
					;  BPB, clear if wanting to set/get the
					;  default BPB
SpecialFuncs	end

GetDeviceParams	struct
    GDP_specialFuncs	SpecialFuncs	; b0 = 1 to return BPB that
					;  DDF_BUILD_BPB would return
					;    = 0 to return the default BPB
					;  for the device
					; b1 = 1 to specify track layout only
					;  (when setting device params)
					; b2 = 1 for standard layout (when
					;  setting only)
    GDP_deviceType	IoctlDeviceType	; Type of device present
    GDP_deviceAttrs	IoctlDeviceAttrs; Attributes of the device
    GDP_cylinders	word
    GDP_mediaType	byte		; 0 => default media (highest density)
    					; 1 => other
    GDP_bpb		BiosParamBlock
GetDeviceParams	ends

TrackLayoutEntry	struct
    TLE_sectorNum	dw	?
    TLE_sectorSize	dw	?
TrackLayoutEntry	ends

SetDeviceParams	struct
    SDP_common		GetDeviceParams
    SDP_numSectors	word
    SDP_trackLayout	TrackLayoutEntry MSDOS_MAX_SECTORS_PER_TRACK dup (<>)
SetDeviceParams	ends

ReadWriteTrackParams	struct
    RWTP_specialFuncs	byte	0	; always 0
    RWTP_head		word
    RWTP_cylinder	word
    RWTP_startSector	word
    RWTP_numSectors	word
    RWTP_buffer		fptr.byte
ReadWriteTrackParams	ends

FormatVerifyParams	struct
    FVP_specialFuncs	byte	0	; MS 4: 1 => status call to see
					;  if driver supports format set with
					;  DGBDF_SET_DEVICE_PARAMS
    FVP_head		word
    FVP_cylinder	word
FormatVerifyParams	ends

GetSetAccessFlagParams	struct
    GSAFP_specialFuncs	byte	0	; always 0
    GSAFP_accessFlag	byte		; 0 => access to medium is blocked by
					;  driver. Flag is set 0 when an
					;  unformatted or invalid medium is
					;  found in the drive. Access flag
					;  must be set non-zero before
					;  formatting may commence.
GetSetAccessFlagParams	ends

MSDOS_IOCTL_DRIVE_REMOTE?	equ (MSDOS_IOCTL shl 8) or 0x9
;
;	Pass:	bl	= 1-origin drive number (0 = default drive)
;	Return:	carry clear if network present:
;			dx	= device attribute word; bit 12 = 1 => remote
;		carry set if network absent:
;			ax	= 1 (invalid function)
;				= 0fh (invalid drive)
;

MSDOS_IOCTL_HANDLE_REMOTE?	equ (MSDOS_IOCTL shl 8) or 0xa
;
;	Pass:	bx	= handle
;	Return:	carry clear if network present:
;			dx	= bit 15 set if handle is remote
;		carry set if network absent:
;			ax	= 1 (invalid function)

MSDOS_DUPLICATE_HANDLE		enum Int21Call, 45h
MSDOS_FORCE_DUPLICATE_HANDLE	enum Int21Call, 46h
MSDOS_GET_CURRENT_DIR		enum Int21Call, 47h
MSDOS_ALLOC_MEM_BLK		enum Int21Call, 48h
MSDOS_FREE_MEM_BLK		enum Int21Call, 49h
MSDOS_RESIZE_MEM_BLK		enum Int21Call, 4ah
MSDOS_EXEC			enum Int21Call, 4bh

MSExecSubFunction	etype	byte, 0
    MSESF_EXECUTE	enum	MSExecSubFunction, 0
    MSESF_LOAD		enum	MSExecSubFunction, 1	; create new process and
							;  load it, but don't
							;  let it run
    MSESF_LOAD_OVERLAY	enum	MSExecSubFunction, 3

DosExecuteArgs		struct
    DEA_envBlk		sptr.char
    DEA_cmdTail		fptr.char
    DEA_fcb1		fptr.StdFCB
    DEA_fcb2		fptr.StdFCB
DosExecuteArgs		ends

DosLoadOverlayArgs	struct
    DLOA_base		sptr		; place at which to load file
    DLOA_reloc		sptr		; amount by which to relocate every
					;  segment (always the same as DLOA_base
					;  in my experience...)
DosLoadOverlayArgs	ends

MSDOS_QUIT_APPL			enum Int21Call, 4ch

MSDOS_GET_RETURN_CODE           enum Int21Call, 4dh
;
;       Pass:   ah      = MSDOS_GET_RETURN_CODE
;       Return: ah      = DosSystemExitCode
;

DosSystemExitCode       etype   byte
        DSEC_NORMAL                     enum    DosSystemExitCode, 0x00
        DSEC_CONTROL_C                  enum    DosSystemExitCode, 0x01
        DSEC_CRITICAL_DEVICE_ERROR      enum    DosSystemExitCode, 0x02
        DSEC_TSR                        enum    DosSystemExitCode, 0x03

MSDOS_FIND_FIRST		enum Int21Call, 4eh
MSDOS_FIND_NEXT			enum Int21Call, 4fh
MSDOS_SET_PSP			enum Int21Call, 50h
MSDOS_GET_PSP			enum Int21Call, 51h
MSDOS_GET_DOS_TABLES		enum Int21Call, 52h

MemoryControlBlock	struct
	MCB_endMarker	byte		;'Z' if last block. 'M' otherwise.
	MCB_PSP		sptr.ProgramSegmentPrefix
	MCB_size	word		;size or block in paragraphs, not 
					;including 16 bytes of the MCB.
			align 16
MemoryControlBlock	ends

MCB_NOT_LAST_BLOCK_MARKER	equ	'M'
MCB_LAST_BLOCK_MARKER		equ	'Z'

MSDOS_TRANSLATE_BPB		enum Int21Call, 53h
MSDOS_RENAME_FILE		enum Int21Call, 56h
MSDOS_GET_SET_DATE		enum Int21Call, 57h
MSDOS_ALLOC_STRAT		enum Int21Call, 58h
MSDOS_GET_STRAT		equ (MSDOS_ALLOC_STRAT shl 8) or 0
MSDOS_SET_STRAT		equ (MSDOS_ALLOC_STRAT shl 8) or 1
MSDOS_GET_UMB_LINK	equ (MSDOS_ALLOC_STRAT shl 8) or 2 ; DOS 5+ only,
							   ;  al = 0/1 if umb
							   ;  arena not/is
							   ;  being searched
MSDOS_SET_UMB_LINK	equ (MSDOS_ALLOC_STRAT shl 8) or 3 ; DOS 5+ only,
							   ;  bx = 0/1 if umb
							   ;  arena not/is to
							   ;  be searched
DosAllocStrategy	etype	byte, 0
   DAS_FIRST_FIT	enum	DosAllocStrategy
   DAS_BEST_FIT		enum	DosAllocStrategy
   DAS_LAST_FIT		enum	DosAllocStrategy

DosAllocStrat	record	; passed in BL for MSDOS_SET_STRAT, returned in AL
			;  for MSDOS_GET_STRAT
    DAS_USE_UMB:1,		; 1 => alloc in a UMB first, looking at low
				;  memory only if the request cannot be
				;  satisfied from upper memory.
    :5,				; unused bits (for now...)
    DAS_STRAT DosAllocStrategy:2
DosAllocStrat	end
    
MSDOS_GET_EXT_ERROR_INFO	enum Int21Call, 59h
MSDOS_CREATE_TEMP_FILE		enum Int21Call, 5ah
MSDOS_CREATE_ONLY		enum Int21Call, 5bh
MSDOS_LOCK_RECORD		enum Int21Call, 5ch
MSDOS_NETWORK_CALL		enum Int21Call, 5eh
MSDOS_GET_MACHINE_NAME	equ	(MSDOS_NETWORK_CALL shl 8) + 0
;	Pass:	ds:dx	= buffer to receive 15-byte machine name
;		ds:si	= pointer to setup string (?)
;	Return:	carry set on error:
;			ax	= ERROR_UNSUPPORTED_FUNCTION
;		carry clear if ok:
;			ch	= 0, if name not defined
;			ch	> 0, if name defined
;			cl	= NETBIOS name number
;			ds:dx	= pointer to identifier

MSNET_EXISTENCE_CHECK	equ	0xb800	; int 2fh function
;	Pass:	ax	= MSNET_EXISTENCE_CHECK
;	Return:	al	= 0 if not installed
;			= non-zero if some part of network installed
;		bl	= MSNetInstallationFlags
;
MSNetInstallationFlags	record
    MSNIF_REDIR_POPUP:1		; set if redirector can handle popup messages
    MSNIF_SERVER:1		; set if server installed
    :2
    MSNIF_REDIRECTOR:1		; set if redirector installed
    :1
    MSNIF_LANPUP:1		; set if LANPUP (whatever that is) installed
    :1
MSNetInstallationFlags	end


MSDOS_NETWORK_DEVICE_CALL	enum	Int21Call, 5fh
MSNetDeviceName	type 16 dup (char)
MSNetPath	type 128 dup(char)

MSNetDeviceType	etype	byte
MSNDT_PRINTER	enum	MSNetDeviceType, 3
MSNDT_DISK	enum	MSNetDeviceType, 4

MSDOS_GET_REDIRECTED_DEVICE	equ	(MSDOS_NETWORK_DEVICE_CALL shl 8) + 2
;	Pass:	bx	= redirection entry index (0-origin)
;		ds:si	= MSNetDeviceName buffer
;		es:di	= MSNetPath buffer
;	Return:	carry clear if ok:
;			bl	= MSNetDeviceType
;			cx	= value stored when redirected (0 for LANtastic)
;			ds:si	= filled
;			es:di	= filled
;		carry set on error:
;			ax	= error code (ERROR_NO_MORE_FILES if entry #
;				  out of bounds)
;	Destroyed:	dx, bp

MSDOS_REDIRECT_DEVICE		equ	(MSDOS_NETWORK_DEVICE_CALL shl 8) + 3
;	Pass:	bl	= MSNetDeviceType
;		cx	= value to store with redirected device (0 for
;			  LANtastic)
;		ds:si	= MSNetDeviceName (null-terminated w/trailing colon)
;		es:di	= target path
;	Return:	carry set on error:
;			ax	= error code
;		carry clear if successful
;

MSDOS_SELECT_CODE_PAGE		enum Int21Call, 66h	; >= 3.3 only
MSDOS_COMMIT			enum Int21Call, 68h	; >= 3.3 only

ExtendedFileAccessFlags	record
    :1
    EFAF_SYNCHRONOUS:1		; if set, all writes are followed by commits
    EFAF_NO_CRITICAL:1		; if set and a critical error would be generated
				;  during the open, an error will be returned
				;  rather than the critical error displayed.
    :5
    EFAF_STANDARD FileAccessFlags:8
ExtendedFileAccessFlags	end

ExtendedOpenAction	record
    :11
    EOA_CREATE:1		; create if file doesn't exist
    :2
    EOA_TRUNCATE:1		; truncate existing file to 0 length (fails if
				;  file doesn't exist)
    EOA_OPEN:1			; standard open. Fail if file doesn't exist
ExtendedOpenAction	end

ExtendedOpenResult	etype	word, 1
    EOR_OPENED		enum ExtendedOpenResult
    EOR_CREATED		enum ExtendedOpenResult
    EOR_TRUNCATED	enum ExtendedOpenResult

MSDOS_EXTENDED_OPEN_FILE	enum Int21Call, 6ch
;	Pass:	bx	= ExtendedFileAccessFlags
;		cx	= FileAttrs
;		dx	= ExtendedOpenAction
;		ds:si	= file to open/create/truncate
;	Return:	carry set on error:
;			ax	= error code
;		carry clear if successful:
;			ax	= file handle
;			cx	= ExtendedOpenResult
;

MSDOS_EXEC_LOAD_AND_EXECUTE	= (MSDOS_EXEC shl 8) + 0
MSDOS_EXEC_LOAD			= (MSDOS_EXEC shl 8) + 3

DRDosVersion	etype	word
    DVER_3_40	enum	DRDosVersion, 0x1060
    DVER_3_41	enum	DRDosVersion, 0x1063
    DVER_5_0	enum	DRDosVersion, 0x1065
    DVER_6_0	enum	DRDosVersion, 0x1067
    DVER_7_0	enum	DRDosVersion, 0x1070

DRDOS_GET_VERSION	equ (MSDOS_IOCTL shl 8) or 52h
;
;	Internal IOCTL call to determine current version of DR-DOS.
;	Other DOS's should return carry set.
;	PASS:	ah	= MSDOS_IOCTL
;		al	= 52h
;		bx	= 0 so if running off a network (e.g. NetWare 3.11),
;			  it doesn't think this weird IOCTL is intended for
;			  it and return an ERROR_UNSUPPORTED_FUNCTION
;	RETURN:	ax	= DRDosVersion
;

;	MS-DOS errors caught by PC GEOS

MSDOS_GET_LOGICAL_DRIVE_MAP equ (MSDOS_IOCTL shl 8) or 0xe
;
;	IOCTL to see if a logical drive number shares a physical device
;	with another logical drive. This is only supported for DOS >= 3.20
;
;	PASS:	bl	= logical drive number
;	RETURN:	carry clear if successful:
;			al	= drive number last used, or 0 if device isn't
;				  shared.
;
ERROR_FUNCTION_INVALID	=	1
ERROR_HANDLE_INVALID	=	6	;MS-DOS error
ERROR_NO_MATCH_FOUND	=	18	;MS-DOS error

MSDOS_SET_LOGICAL_DRIVE_MAP equ (MSDOS_IOCTL shl 8) or 0xf
;
;	IOCTL to specify which of the two drive letters that are mapped to
;	the same physical drive is the current one. This is only supported
;	for DOS >= 3.20
;
;	PASS:	bl	= logical drive number to be current.
;	RETURN:	carry clear if successful:
;			al	= drive number last used, or 0 device isn't
;				  shared.
;


CDROM_GET_STATUS	equ	0x1500
;
;	Function call for INT 2FH to find the number and location of any
;	installed CD-ROM drives that use the MS-DOS CD-ROM Extensions
;
;	PASS:	ah	= 15h
;		al	= 00h
;	RETURN:	bx	= number of CD-ROM drives
;		cx	= first CD-ROM drive number (all CD-ROM drives are
;			  contiguous in the logical-drive namespace)
;
;	NOTE:	The DOS 4.X GRAPHICS.COM extension uses this same interrupt
;		and function call. There is a workaround, but we haven't
;		got it yet.
;
;	10/30/91: The workaround is to clear BX before the call. If it's still
;		  0 on return, the extensions are not resident.
;

CDROM_GET_DRIVE_DEVICE_LIST	equ	0x1501
;
;	Function call for INT 2Fh to find the device drivers and unit numbers
;	for the supported CD-ROM devices. This is useful in determining if a
;	critical error is generated by a CD-ROM access.
;
;	PASS:	ah	= 15h
;		al	= 01h
;		es:bx	= array of CDROMDeviceStructs
;	RETURN:	buffer filled
;
CDROMDeviceStruct	struct
    CDRDS_unit		byte
    CDRDS_device	fptr.DeviceHeader
CDROMDeviceStruct	ends

CDROM_GET_DRIVES	equ	0x150d
;
;	Function call for INT 2FH to locate the drive letters allocated to
;	all CD ROM drives by the MS CD Extensions, since letters may not
;	be contiguous.
;
;	PASS:	ax	= 0x150d
;		es:bx	= buffer in which to store allocated drive numbers
;	RETURN:	buffer filled with 0-origin drive numbers used by the drives.
;

;--------------------------------------------------------------------------
;	DOS media constants
;--------------------------------------------------------------------------

DosMediaType		etype	byte
DOS_MEDIA_160K		enum	DosMediaType, 0feh
DOS_MEDIA_320K		enum	DosMediaType, 0ffh
DOS_MEDIA_180K		enum	DosMediaType, 0fch
DOS_MEDIA_360K		enum	DosMediaType, 0fdh
DOS_MEDIA_1M2		enum	DosMediaType, 0f9h
DOS_MEDIA_720K		enum	DosMediaType, 0f9h
DOS_MEDIA_1M44		enum	DosMediaType, 0f0h
DOS_MEDIA_2M88		enum	DosMediaType, 0f0h
DOS_MEDIA_FIXED_DISK	enum	DosMediaType, 0f8h
DOS_MEDIA_CUSTOM	enum	DosMediaType, 0
if PZ_PCGEOS
DOS_MEDIA_640K		enum	DosMediaType, 0fbh
DOS_MEDIA_1M232		enum	DosMediaType, 0feh
endif

;------------------------------------------------------------------------------
;		       DEVICE DRIVER INTERFACE
;------------------------------------------------------------------------------
DeviceAttrs	record	; (q.v. MS-DOS Papers pp. 308-9)
    DA_CHAR_DEV:1		; 1 if character device
    DA_IOCTL:1			; 1 if device supports IOCTL
    DA_NONIBM:1			; Block device does *not* obey IBM formatting
				;  conventions
    :1
    DA_OCRM:1			; 1 if supports Open/Close/Removable Media
				;  calls
    :4
    DA_GENIOCTL:1		; 1 if device supports *generic* ioctl,
				;  as opposed to read/write ioctl
    :1
    DA_SPECL:1			; 1 if has int 29h entry point.
    DA_CUR_CLOCK:1		; 1 if device is current CLOCK device
    DA_CUR_NUL:1		; 1 if device is current NUL device
    DA_STDIN_HUGE:1		; character dev: 1 if device is current stdin
				; block dev: 1 if device supports 32-bit
				;  sector addressing
    DA_STDOUT:1			; 1 if device is current stdout
DeviceAttrs	end

DEVICE_NAME_SIZE equ 8

DeviceHeader	struct
    DH_next	fptr.DeviceHeader	; Next device
    DH_attr	DeviceAttrs		; Attributes
    DH_strat	nptr			; Offset to strategy routine
    DH_intr	nptr			; Offset to "interrupt" routine
    DH_name	char	DEVICE_NAME_SIZE dup(?)	; Device name
DeviceHeader	ends

;
; Common portion of an MS-DOS device driver request
;
DosDriverFunction	etype	byte
    DDF_INIT		enum	DosDriverFunction
    DDF_MEDIA_CHECK	enum	DosDriverFunction
    DDF_BUILD_BPB	enum	DosDriverFunction
    DDF_IOCTL_READ	enum	DosDriverFunction
    DDF_READ		enum	DosDriverFunction
    DDF_ND_READ		enum	DosDriverFunction
    DDF_READ_STATUS	enum	DosDriverFunction
    DDF_READ_FLUSH	enum	DosDriverFunction
    DDF_WRITE		enum	DosDriverFunction
    DDF_WRITE_VERIFY	enum	DosDriverFunction
    DDF_WRITE_STATUS	enum	DosDriverFunction
    DDF_WRITE_FLUSH	enum	DosDriverFunction
    DDF_IOCTL_WRITE	enum	DosDriverFunction
    DDF_OPEN		enum	DosDriverFunction
    DDF_CLOSE		enum	DosDriverFunction
    DDF_REMOVABLE_MEDIA? enum	DosDriverFunction
    DDF_WRITE_TIL_BUSY	enum	DosDriverFunction
    DDF_IOCTL		enum	DosDriverFunction, 13h
    DDF_GET_DEVICE	enum	DosDriverFunction, 17h
    DDF_SET_DEVICE	enum	DosDriverFunction, 18h

DosDriverError	etype	byte, 0
    DDE_WRITE_PROTECT		enum	DosDriverError
    DDE_UNKNOWN_UNIT		enum	DosDriverError
    DDE_DEVICE_NOT_READY	enum	DosDriverError
    DDE_UNKNOWN_COMMAND		enum	DosDriverError
    DDE_CRC_ERROR		enum	DosDriverError
    DDE_BAD_REQUEST_LENGTH	enum	DosDriverError
    DDE_SEEK_ERROR		enum	DosDriverError
    DDE_UNKNOWN_MEDIA		enum	DosDriverError
    DDE_SECTOR_NOT_FOUND	enum	DosDriverError
    DDE_OUT_OF_PAPER		enum	DosDriverError
    DDE_WRITE_FAULT		enum	DosDriverError
    DDE_READ_FAULT		enum	DosDriverError
    DDE_GENERAL_FAILURE		enum	DosDriverError
    DDE_RESERVED_1		enum	DosDriverError
    DDE_RESERVED_2		enum	DosDriverError
    DDE_INVALID_DISK_CHANGE	enum	DosDriverError

DosDriverStatus	record
    DDS_ERROR:1				; If set, then error
    :5
    DDS_BUSY:1				; Set if device busy (DDF_*_STATUS) or
					;  media is non-removable
					;  (DDF_REMOVABLE_MEDIA?)
    DDS_DONE:1				; Set if requested operation is complete
    DDS_ERROR_CODE DosDriverError:8	; Holds the error code if DDS_ERROR is
					;  set
DosDriverStatus	end

RequestHeader	struct
    RH_length	byte	; Length of request header plus any data at the end
    RH_unit	byte	; Unit number pertinent to the device
    RH_command	DosDriverFunction
    RH_status	DosDriverStatus
    RH_reserved	byte	8 dup(?)
RequestHeader	ends

BuildBPBRequest	struct
    BBPBR_common	RequestHeader <size BuildBPBRequest,,DDF_BUILD_BPB,0>
    BBPBR_media		DosMediaType
    BBPBR_buffer	fptr
    BBPBR_bpb		fptr.BiosParamBlock
BuildBPBRequest	ends

ReadRequest	struct
    RR_common		RequestHeader <size ReadRequest,,DDF_READ,0>
    RR_media		DosMediaType
    RR_buffer		fptr
    RR_count		word		; Sector count
    RR_startSector	word		; Starting sector number
    RR_volumeID		fptr.char	; 3.0-3.30: volume that should
					;  be in the drive if
					;  DDE_INVALID_DISK_CHANGE is returned.
ReadRequest	ends

GenIoctlRequest	struct
    GIR_common		RequestHeader <,,DDF_IOCTL,0>
    GIR_major		byte		; Major function
    GIR_minor		byte		; Minor function
    GIR_param1		word		; Value in SI for MSDOS_IOCTL call
    GIR_param2		word		; Value in DI for MSDOS_IOCTL call
    GIR_otherData	fptr		; Pointer to request data
GenIoctlRequest	ends

MediaCheckRequest struct
    MCR_common	RequestHeader <,,DDF_MEDIA_CHECK,0>
    MCR_media	DosMediaType		; Previous media type
    MCR_change	byte			; -1 => disk changed
    					; 0 => not sure
					; 1 => disk not changed
    MCR_prevVol	fptr.char		; Previous volume if disk changed
MediaCheckRequest ends

DevInitRequest	struct
    DIR_common		RequestHeader <,,DDF_INIT,0>
    DIR_numUnits	byte
    DIR_memBreak	fptr
    DIR_argString	fptr.char	; points to array of bpb's for block
					;  device
    DIR_firstUnit	byte
DevInitRequest	ends

IoctlReadRequest	struct
    IRR_common		RequestHeader <,,DDF_IOCTL_READ,0>
    IRR_media		DosMediaType
    IRR_buffer		fptr
    IRR_count		word
    IRR_startSect	word		; block devices only
IoctlReadRequest	ends

AllRequests	union
    AR_header	RequestHeader
    AR_bbpb	BuildBPBRequest
    AR_rr	ReadRequest
    AR_gir	GenIoctlRequest
    AR_mcr	MediaCheckRequest
AllRequests	end
;--------------------------------------------------------------------------
;	 Program Segment Prefix
;--------------------------------------------------------------------------

CMD_TAIL_SIZE	=	128

ProgramSegmentPrefix	struct
	PSP_int20h		word
	PSP_endAllocBlk		sptr		;seg addr of end of alloc blk
	PSP_reserved		byte
	PSP_callFuncDisp	byte	5 dup (?)	;call MSDOS func disp
	PSP_saveQuit		fptr.far	;save int 22h
	PSP_saveBrk		fptr.far	;save int 23h
	PSP_saveCritErr		fptr.far	;save int 24h

	PSP_parentId		sptr.ProgramSegmentPrefix
	PSP_handleTable		byte	20 dup (?)

	PSP_envBlk		sptr.char	;seg addr of environment block
	PSP_userStack		fptr		;saved stack ptr
	PSP_numHandles		word		;number of handles in jft
	PSP_jftAddr		fptr.byte	;address of JFT
						;(PSP_handleTable at start)
				byte	24 dup(?)	; for what?
	PSP_dosCall		byte	3 dup (?)	;int 21h and retf
				byte	9 dup (?)
	PSP_fcb1		byte	16 dup (?)
	PSP_fcb2		byte	16 dup (?)
				byte	4 dup (?)
	PSP_cmdTail		byte	CMD_TAIL_SIZE dup (?)
ProgramSegmentPrefix	ends

;--------------------------------------------------------------------------
;			Constants for standard file handles
;--------------------------------------------------------------------------

StandardDOSFile	etype word
STDIN		enum StandardDOSFile, 0
STDOUT		enum StandardDOSFile, 1
STDERR		enum StandardDOSFile, 2
STDAUX		enum StandardDOSFile, 3
STDPRN		enum StandardDOSFile, 4

;--------------------------------------------------------------------------
;	File Control Block
;--------------------------------------------------------------------------

StdFCB			struct
    SFCB_volume		byte
    SFCB_name		char	VOLUME_NAME_LENGTH dup(?)
    SFCB_curBlock	word
    SFCB_recordSize	word
    SFCB_fileSize	dword
    SFCB_fileDate	FileDate
    SFCB_fileTime	FileTime
    			byte	8 dup(?)
    SFCB_curRecord	byte
    SFCB_relativeRecord	dword
StdFCB			ends

FCB	struct
    FCB_type		byte	0ffh		;extended FCB
    FCB_reserved	byte	5 dup (0)
    FCB_attributes	FileAttrs
    FCB_volume		byte
    FCB_name		char	VOLUME_NAME_LENGTH dup(?)
    FCB_curBlock	word
    FCB_recordSize	word
    FCB_fileSize	dword
    FCB_fileDate	FileDate
    FCB_fileTime	FileTime
    FCB_reserved2	byte	8 dup(?)
    FCB_curRecord	byte
    FCB_relativeRecord	dword
FCB	ends

RenameFCB	struct
    RFCB_type		byte	0ffh		;extended FCB
    RFCB_reserved	byte	5 dup (0)
    RFCB_attributes	FileAttrs
    RFCB_volume		byte
    RFCB_name		char	VOLUME_NAME_LENGTH dup(?)
			byte	5 dup(?)
    RFCB_newName	char	VOLUME_NAME_LENGTH dup(?)
			align	size FCB
RenameFCB	ends

;------------------------------------------------------------------------------
;	Boot Sector
;------------------------------------------------------------------------------

JMP_INTRA_SEG		=	0e9h
JMP_SHORT		=	0ebh
EXTENDED_BOOT_SIGNATURE	=	29h
MSDOS_DISK_BOOTABLE_SIG	=	0aa55h

;
;structure for the boot sector (extended version)
;

BootSector	struct
	BS_jumpInstr		byte	3 dup (?)
	BS_oemNameAndVersion	char	8 dup (?)

	BS_bpbSectorSize	sword
	BS_bpbClusterSize	sbyte
	BS_bpbNumReserved	sword
	BS_bpbNumFATs		sbyte
	BS_bpbNumRootDirs	sword
	BS_bpbNumSectors	sword
	BS_bpbMediaDescriptor	DosMediaType
	BS_bpbFATSize		sword
	BS_bpbSectorsPerTrack	sword
	BS_bpbNumHeads		sword
	BS_bpbNumHiddenSectors	sdword

	BS_totalSectorsInVolume	sdword
	BS_physicalDriveNumber	byte
	BS_reserved		byte
	BS_extendedBootSig	byte
	BS_volumeID		dword
	BS_volumeLabel		char	11 dup (?)
	BS_fsType		char	8 dup (?)
	BS_bootstrap		byte	448 dup (?)
	BS_bootableSig		word
BootSector	ends

;------------------------------------------------------------------------------
;	Fixed disk partitions
;------------------------------------------------------------------------------

MSDOS_NUM_PARTITIONS	=	4

PARTITION_1_OFFSET	=	01beh
PARTITION_2_OFFSET	=	01ceh
PARTITION_3_OFFSET	=	01deh
PARTITION_4_OFFSET	=	01eeh

PARTITION_SIG		=	0aa55h
PARTITION_SIG_OFFSET	=	01feh

CylSector	record
    CS_cylLow:8		; low 8 bits of cylinder number
    CS_cylHigh:2	; high 2 bits of cylinder number
    CS_sector:6		; sector number
CylSector	end

PartitionEntry	struct
	PE_activeFlag		byte
	PE_startHead		byte
	PE_startCylSector	CylSector
	PE_partitionType	byte
	PE_endHead		byte
	PE_endCylSector		CylSector
	PE_startSector		dword
	PE_numSectors		dword
PartitionEntry	ends

PARTITION_TYPE_FAT12	=	1
PARTITION_TYPE_FAT16	=	2
PARTITION_TYPE_EXTENDED	=	3
PARTITION_TYPE_HUGE	=	4

;------------------------------------------------------------------------------
;	Files Area
;------------------------------------------------------------------------------

RootDirEntry	struct
	RDE_filename		char	8 dup (?)
	RDE_extension		char	3 dup (?)
	RDE_fileAttr		FileAttrs
	RDE_reserved		byte	10 dup (?)
	RDE_time		FileTime
	RDE_date		FileDate
	RDE_startCluster	word
	RDE_fileSize		sdword
RootDirEntry	ends




EndKernel
