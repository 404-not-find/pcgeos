COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) GeoWorks 1992 -- All Rights Reserved

PROJECT:	User Interface
MODULE:		Interapplication Communication Protocol
FILE:		iacpMain.asm

AUTHOR:		Adam de Boor, Oct 12, 1992

ROUTINES:
	Name			Description
	----			-----------
    GLB IACPRegisterServer	Register a server object for a list.

    GLB IACPUnregisterServer	Remove an object from the list of servers
				for a given list.

    GLB IACPConnect		Connect to one or more servers on the
				indicated list.

    INT IACPFindServerOwnedByCX Locate a server object owned by the given
				geode.

    GLB IACPSendMessage		Send a message through an IACP connection
				to all connected servers, or to the client,
				depending on which side is doing the
				sending.

    GLB IACPShutdown		Shutdown one side of an IACP connection

    GLB IACPShutdownAll		Shutdown all connections open to or from
				the given object.

    INT IACPSA_callback		Callback function to search for connections
				that need to be shut down.

    GLB IACPProcessMessage	Process a received message.

    GLB IACPLostConnection	Utility routine for server objects to
				handle MSG_META_IACP_LOST_CONNECTION

    GLB IACPShutdownConnection	Utility routine to handle
				MSG_META_IACP_SHUTDOWN_CONNECTION, as
				generated by a call to IACPLostConnection

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Adam	10/12/92	Initial revision


DESCRIPTION:
	Implementation of IACP
		

	$Id: iacpMain.asm,v 1.1 97/04/07 11:47:21 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

IACPCommon	segment	resource


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPRegisterServer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Register a server object for a list.

CALLED BY:	(GLOBAL) and IACPRegisterServerXIP()
PASS:		es:di	= GeodeToken for the list
		^lcx:dx	= server object
		al	= IACPServerMode
		ah	= IACPServerFlags
RETURN:		nothing
DESTROYED:	nothing
SIDE EFFECTS:	none you need worry about

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	10/12/92	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPRegisterServer proc	far
		uses	ax, ds, si, es, di, cx, dx, bx
		.enter
	;
	; Gain exclusive access to the list block so we can be sure our
	; possibly creating a new list is atomic and won't louse anyone else
	; up. Besides, adding a new entry to the server array could cause the
	; block to move, so no matter what we do, we need to gain exclusive
	; access to the block.
	; 
		call	IACPLockListBlockExcl	; ds <- IACPListBlock
	;
	; Look for a list with the given token.
	; 
		mov_tr	bx, ax			; bx <- server mode
		call	IACPFindList		; ax <- list #, if present
		jc	haveList
	;
	; List doesn't exist, so create it.
	; 
		push	cx, dx, bx
	    ;
	    ; First create the array that will hold the server ODs so we have
	    ; its chunk handle to store in the IACPList structure
	    ; 
		mov	bx, size IACPServer
		clr	cx
		clr	si
		call	ChunkArrayCreate
		push	di
	    ;
	    ; Now append an IACPList structure to the end of the iacpListArray
	    ; array.
	    ; 
		push	si
		mov	si, offset iacpListArray
		call	ChunkArrayAppend
	    ;
	    ; Save its element # for storing the server OD
	    ; 
		call	ChunkArrayPtrToElement
	    ;
	    ; Initialize the IACPList structure with the handle of the server
	    ; array and no connections.
	    ; 
		pop	ds:[di].IACPL_servers
		clr	cx
		mov	ds:[di].IACPL_numConnect, cx
		mov	ds:[di].IACPL_connections, cx
	    ;
	    ; Now copy the token into the structure.
	    ; 
		segxchg	es, ds
		pop	si		; ds:si <- search token
		mov	cx, size GeodeToken
			CheckHack <offset IACPL_token eq 0>
		rep	movsb
	;
	; Recover the server OD and set ds = IACPListBlock again.
	; 
		pop	cx, dx, bx
		segmov	ds, es
haveList:
	;
	; ax = IACPList element #
	; 
		mov	si, offset iacpListArray
		call	ChunkArrayElementToPtr
	;
	; Save list token for mailbox notification.
	;
		push	{word}ds:[di].IACPL_token.GT_chars[0],
			{word}ds:[di].IACPL_token.GT_chars[2],
			ds:[di].IACPL_token.GT_manufID
	;
	; See if we're just changing the mode for the server.
	; 
		mov	si, ds:[di].IACPL_servers
		
		push	bx
		clr	ax			; first elt is #0...
		mov	bx, cs
		mov	di, offset IACPFindServer
		call	ChunkArrayEnum
		pop	bx
		jnc	addNew			; => not found
	;
	; Yes; just alter the mode stored in the element.
	; 
		call	ChunkArrayElementToPtr
		mov	{word}ds:[di].IACPS_mode, bx
	CheckHack <size IACPS_flags eq 1 and IACPS_flags eq IACPS_mode+1>
		jmp	releaseListBlock
addNew:
	;
	; Append another entry to the array of servers for the list.
	; 
		call	ChunkArrayAppend
		mov	ds:[di].IACPS_object.handle, cx
		mov	ds:[di].IACPS_object.chunk, dx
		mov	{word}ds:[di].IACPS_mode, bx
	CheckHack <size IACPS_flags eq 1 and IACPS_flags eq IACPS_mode+1>

	;
	; See if anyone might be waiting for this registration. If
	; iacpInstantiateSem.Sem_value is less than 1, it means someone is
	; in the process of instantiating an app for a list.
	;
	; 1/14/94: NOTE: We do this *only* when we've added a new server,
	; *not* when just changing the server mode. By definition, the only
	; sort of registration someone blocked on the instantiate queue
	; could possibly care about is a brand-spanking-new server,
	; not a moldy old server that's changing its plumage (after
	; all, the thing is attempting to create a new server, not
	; talk to a has-been). We used to do this below releaseListBlock, 
	; but that led to ugly, ugly death when iacpInstantiateQueue
	; ended up at 16, owing to two wakeups having been done for
	; each app starting up (once for the non-interactible-server
	; registration and once for the interactible-server
	; registration). -- ardeb
	; 
		push	ds
		segmov	ds, dgroup, ax
		cmp	ds:[iacpInstantiateSem].Sem_value, 1
		jge	popDSreleaseListBlock
	;
	; Someone's instantiating, and this might be it; wake the thing up
	; and let it decide for itself.
	; 
		mov	ax, ds
		mov	bx, offset iacpInstantiateQueue
		call	ThreadWakeUpQueue

popDSreleaseListBlock:
		pop	ds
	;
	; Release access to the list block.
	; 
releaseListBlock:
	;
	; Let Mailbox subsystem know about this. Can't use 
	; IACPPrepareMailboxNotify because app might be registering for
	; an alias and mailbox needs to know the alias, not the app's token.
	; 
		pop	bx, cx, dx		; bxcxdx <- token
		mov	si, SST_MAILBOX
			CheckHack <IACPS_flags eq IACPS_mode+1>
			CheckHack <size IACPS_flags eq 1>
		mov	ax, {word}ds:[di].IACPS_mode
		mov	di, MSN_APP_LOADED
		call	SysSendNotification
	;
	; Finally, really release access to the block.
	; 
		call	IACPUnlockListBlockExcl
		.leave
		ret
IACPRegisterServer endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPPrepareMailboxNotify
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Prepare registers to notify the Mailbox library of the
		loading/unloading of a server

CALLED BY:	(INTERNAL) GenApplication::META_GAINED_FOCUS_EXCL,
			   GenApplication::META_GAINED_FULL_SCREEN_EXCL
PASS:		bx	= server optr.handle
RETURN:		bxcxdx	= GeodeToken
		si	= SST_MAILBOX
DESTROYED:	di, es
SIDE EFFECTS:	none

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	4/28/94		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPPrepareMailboxNotify proc	far
		uses	ax
		.enter
	;
	; Find owner of server object, so we can get its token.
	; 
		call	MemOwner

		sub	sp, size GeodeToken
		mov	di, sp
		segmov	es, ss			; es:di <- buffer for token
		mov	ax, GGIT_TOKEN_ID
		call	GeodeGetInfo
	;
	; Pop the token into the proper registers.
	; 
			CheckHack <GT_chars eq 0>
		pop	bx
		pop	cx
			CheckHack <GT_manufID eq 4>
		pop	dx
			CheckHack <size GeodeToken eq 6>
	;
	; Return the proper subsystem type.
	; 
		mov	si, SST_MAILBOX
		.leave
		ret
IACPPrepareMailboxNotify endp
if FULL_EXECUTE_IN_PLACE

IACPCommon	ends

ResidentXIP	segment	resource


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPRegisterServerXIP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Register a server object for a list.

CALLED BY:	(GLOBAL)
PASS:		es:di	= GeodeToken for the list
		^lcx:dx	= server object
		al	= IACPServerMode
		ah	= IACPServerFlags
RETURN:		nothing
DESTROYED:	nothing
SIDE EFFECTS:	none you need worry about

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	10/12/92	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPRegisterServerXIP	proc	far
		uses	es, di
		.enter	

		call	IACPCopyGeoTokenToStackESDI	;es:di = GeodeToken in stack
		call	IACPRegisterServer
		call	SysRemoveFromStack

		.leave
		ret
IACPRegisterServerXIP	endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPCopyGeoTokenToStackESDI
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Copy GeodeToken pointed by es:di to stack.

CALLED BY:	(Internal) XIP routines in fixed memory
PASS:		es:di	= Geode Token
RETURN:		es:di	= Geode Token in stack
DESTROYED:	nothing
SIDE EFFECTS:	

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	CL	5/ 4/94    	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPCopyGeoTokenToStackESDI	proc	near
		.enter
	;
	; Copy the GeodeToken onto stack
	;
		push	ds, si, cx
		segmov	ds, es, cx
		mov	si, di			;ds:si = ptr to Geode Token
		mov	cx, size GeodeToken
		call	SysCopyToStackDSSI	;ds:si = ptr to Geode Token on stack
		segmov	es, ds, cx
		mov	di, si			;es:di = ptr to Geode Token on stack
		pop	ds, si, cx
		
	.leave
	ret
IACPCopyGeoTokenToStackESDI	endp


ResidentXIP	ends

IACPCommon	segment	resource

endif		; FULL_EXECUTE_IN_PLACE



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPUnregisterServer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Remove an object from the list of servers for a given list.

CALLED BY:	(GLOBAL)
PASS:		es:di	= GeodeToken for list
		^lcx:dx	= server object to remove
RETURN:		nothing
DESTROYED:	nothing
SIDE EFFECTS:	none you need worry about

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	10/12/92	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPUnregisterServer proc	far
		uses	ax, bx, cx, si, di, ds, es
		.enter
	;
	; Lock the block of lists for exclusive access, as we'll be shifting
	; things around.
	; 
		call	IACPLockListBlockExcl
	;
	; Locate the list with that token. If there is none, we don't get upset,
	; though we should likely fatal-error.
	; 
		call	IACPFindList
		jnc	done
	;
	; Locate the index of the server object within the array of servers
	; registered with the list.
	; 
		push	ax				; save list element #
							;  so we can delete
							;  the list if nec'y
		mov	si, offset iacpListArray
		call	ChunkArrayElementToPtr
		mov	si, ds:[di].IACPL_servers
		clr	ax
		mov	bx, cs
		mov	di, offset IACPFindServer
		call	ChunkArrayEnum
		jnc	noSuchServer
	;
	; Delete the server from the list of servers for the list.
	; 
		call	ChunkArrayElementToPtr
		mov	bx, ds:[di].IACPS_object.handle	; save for possible
							;  mailbox notify
		call	ChunkArrayDelete
	;
	; Now see if there any other servers or active connections for the
	; list.
	; 
		call	ChunkArrayGetCount
		tst	cx
		jnz	findNumConnect
	    ;
	    ; No more servers for the token, so make sure the Mailbox library
	    ; is apprised of this. (ax, bx, si, di all nukable here, as they
	    ; will be nuked soon w/o being used.)
	    ; 
		pop	ax
		push	cx, dx
		push	ax
		mov	si, offset iacpListArray
		call	ChunkArrayElementToPtr
		movtok	bxcxdx, ds:[di].IACPL_token
		mov	si, SST_MAILBOX
		mov	di, MSN_APP_NOT_LOADED
		call	SysSendNotification
		pop	ax
		pop	cx, dx
		push	ax
findNumConnect:
		pop	ax
					; XXX: jcxz here?
		mov	si, offset iacpListArray
		call	ChunkArrayElementToPtr
		or	cx, ds:[di].IACPL_numConnect
		jnz	done
	;
	; Neither server objects nor connections remain fro the list, so
	; nuke the server array...
	; 
		mov	ax, ds:[di].IACPL_servers
		call	LMemFree
	;
	; ...and delete the list itself.
	; 
		call	ChunkArrayDelete
done:
	;
	; Done our damage, so get out.
	; 
		call	IACPUnlockListBlockExcl
		.leave
		ret
noSuchServer:
	;
	; No such server registered for the list. Again, we should probably
	; fatal-error, but for now we just pop the list's element # and
	; clear out.
	; 
		pop	ax
		jmp	done
IACPUnregisterServer endp

if FULL_EXECUTE_IN_PLACE

IACPCommon	ends

ResidentXIP	segment	resource

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPUnregisterServerXIP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Remove an object from the list of servers for a given list.

CALLED BY:	(GLOBAL)
PASS:		es:di	= GeodeToken for list
		^lcx:dx	= server object to remove
RETURN:		nothing
DESTROYED:	nothing
SIDE EFFECTS:	none you need worry about

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	10/12/92	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPUnregisterServerXIP	proc	far
		uses	es, di
		.enter
		
		call	IACPCopyGeoTokenToStackESDI	;es:di = GeodeToken in stack
		call	IACPUnregisterServer	
		call	SysRemoveFromStack
		
		.leave
		ret
IACPUnregisterServerXIP	endp

ResidentXIP	ends

IACPCommon	segment	resource

endif



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPRegisterDocument
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Register an open document and the server object for it.

CALLED BY:	(GLOBAL)
PASS:		ax	= disk handle
		cxdx	= FileID
		^lbx:si	= server
RETURN:		nothing
DESTROYED:	nothing
SIDE EFFECTS:	

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	3/ 9/93		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPRegisterDocument proc	far
		uses	es, ds, si, di, ax, bx, cx, dx, bp
		.enter
		call	IACPLockListBlockExcl
		call	IACPLocateDocument
		jc	done

		mov	bp, si
   		mov	si, offset iacpDocArray
		call	ChunkArrayAppend
		mov	ds:[di].IACPD_disk, ax
		movdw	ds:[di].IACPD_id, cxdx
		mov	ds:[di].IACPD_server.handle, bx
		mov	ds:[di].IACPD_server.chunk, bp

if 0	; just say "no" to non-app servers.

	;
	; If the server object isn't an application, then let's register
	; it as a "normal" server under its application's GeodeToken, so
	; that IACPConnectToDocumentServer has a place to store a connection.
	;

		movdw	cxdx, bxbp
		call	IACPFindAppObj
		cmpdw	cxdx, bxbp
		je	done

	;
	; OK, the server isn't an application, so register it on the list.
	; If we've already done this (eg., this object is serving more than
	; one document), then IACPRegisterServer won't do anything. We need
	;

		movdw	cxdx, bxbp			; ^lcx:dx <- new server

		call	MemOwner			; bx <- process handle
		mov	ax, GGIT_TOKEN_ID
		sub	sp, size GeodeToken
		mov	di, sp
		segmov	es, ss
		call	GeodeGetInfo

		mov	ax, IACPSM_NON_APPLICATION	;clears IACPServerFlags
		call	IACPRegisterServer

		add	sp, size GeodeToken

endif

done:
		call	IACPUnlockListBlockExcl
		.leave
		ret
IACPRegisterDocument endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPUnregisterDocument
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Take note of the closure of a document.

CALLED BY:	(GLOBAL)
PASS:		ax	= disk handle
		cxdx	= FileID
		^lbx:si	= server
RETURN:		nothing
DESTROYED:	nothing
SIDE EFFECTS:	

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	3/ 9/93		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPUnregisterDocument proc	far
		uses	ds, si, di, ax, bp
		.enter
		call	IACPLockListBlockExcl
		call	IACPLocateDocument
EC <		WARNING_NC	DOCUMENT_NOT_REGISTERED			>
		jnc	done
		
		mov	si, offset iacpDocArray
		call	ChunkArrayElementToPtr
		call	ChunkArrayDelete

done:
		call	IACPUnlockListBlockExcl
		.leave
		ret
IACPUnregisterDocument		endp



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPSendMessageCleanUp
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Clean up after an IACPSendMessage or IACPSendMessageToServer

CALLED BY:	(INTERNAL) IACPSendMessageToServer, IACPSendMessage
PASS:		bx	= # of servers to which message was sent
		ds	= IACPListBlock locked shared.
		cx	= handle of message sent
		bp	= handle of completion msg, or 0
RETURN:		ax	= # of servers to which message was sent
DESTROYED:	bx
SIDE EFFECTS:	recorded messages are freed; IACPListBlock is unlocked

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	10/25/92	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPSendMessageCleanUp proc	far
		.enter
	;
	; Return the number of servers that actually received the message.
	; 
		mov_tr	ax, bx
	;
	; Free the two recorded messages.
	; 
		mov	bx, cx
		call	ObjFreeMessage
		tst	bp
		jz	done
		mov	bx, bp
		call	ObjFreeMessage
done:
		call	IACPUnlockListBlockShared
		.leave
		ret
IACPSendMessageCleanUp endp

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPSendOneMessage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Common code to send a single IACP message

CALLED BY:	(INTERNAL) IACPSendMessage, IACPSendMessageToServer
PASS:		ds:si	= address of optr of server
		cx	= handle of recorded message
		dx	= TravelOption/-1
		bp	= handle of recorded completion message
		ax	= owner for completion msg
RETURN:		carry set if other side gone, so ^hcx not sent
DESTROYED:	ax
SIDE EFFECTS:	

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	10/25/92	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPSendOneMessage proc	far
		uses	si, di, cx, dx, bp, bx, ax
		.enter
		tst	ds:[si].handle
		jz	sendCompletionOurselves

	;
	; Fetch owner of server object so we can make the recorded message
	; be owned by it, rather than the current thread, whose owner might
	; go away before the message is received. We don't change the owner
	; of the completion message, if such there be, as a completion message
	; implies we'll be around long enough to receive the thing.
	; 
		push	dx
		push	ax
		mov	bx, ds:[si].handle
		call	MemOwner
		mov	dx, bx
	;
	; Make copies of the two messages, so we still have them for the
	; next call, should there be one.
	; 
		mov	bx, cx
		call	ObjDuplicateMessage
		mov_tr	cx, ax

		mov	bx, cx		; bx <- event handle
		mov_tr	ax, dx		; ax <- new owner
		call	HandleModifyOwner

		pop	ax		; ax <- completion msg owner
		tst	bp
		jz	sendProcessMessage

		mov	bx, bp		; bx <- completion msg
		push	ax
		call	ObjDuplicateMessage	; ax <- copy of same
		mov_tr	bx, ax
		pop	ax
		call	HandleModifyOwner
		mov	bp, bx

sendProcessMessage:
		pop	dx		; restore TravelOption
	;
	; Send MSG_META_IACP_PROCESS_MESSAGE to the server object. Force-queue
	; the thing so we don't have to worry about fixing up DS or ES for our
	; caller.
	; 
		mov	bx, ds:[si].handle
		mov	si, ds:[si].chunk
		mov	ax, MSG_META_IACP_PROCESS_MESSAGE
		mov	di, mask MF_FORCE_QUEUE
		call	ObjMessage
		clc
done:
		.leave
		ret

sendCompletionOurselves:
	;
	; Server shutdown, so queue the completion message ourselves, if there
	; is one. Be sure to keep the recorded message around (i.e. pass
	; MF_RECORD to MessageDispatch).
	; 
		tst	bp
		stc
		jz	done

		push	di
		mov	di, mask MF_RECORD or mask MF_FORCE_QUEUE
		mov	bx, bp
		call	MessageDispatch
		pop	di
		stc
		jmp	done
IACPSendOneMessage endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPSendMessage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Send a message through an IACP connection to all connected
		servers, or to the client, depending on which side is doing
		the sending.

CALLED BY:	(GLOBAL)
PASS:		bp	= IACPConnection
		bx	= recorded message to send
		dx	= TravelOption, -1 if recorded message contains
			  the proper destination already
		cx	= completionMsg, 0 if none
		ax	= IACPSide doing the sending.
RETURN:		ax	= number of servers to which message was sent
DESTROYED:	bx, cx, dx
SIDE EFFECTS:	the recorded messages are freed

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	10/12/92	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPSendMessage	proc	far
		uses	ds
		.enter
		call	IACPLockListBlockShared
		call	IACPSendMessageInternal
		.leave
		ret
IACPSendMessage	endp



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPSendMessageAndWait
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Send a message through an IACP connection to all connected
		servers, or to the client, depending on which side is doing
		the sending, and wait for the server to handle it.

CALLED BY:	(GLOBAL)
PASS:		bp	= IACPConnection
		bx	= recorded message to send
		dx	= TravelOption, -1 if recorded message contains
			  the proper destination already
		ax	= IACPSide doing the sending.
RETURN:		ax	= number of servers to which message was sent
DESTROYED:	bx, cx, dx
SIDE EFFECTS:	the recorded messages are freed

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	jon	1 feb 95	initial revision

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPSendMessageAndWait	proc	far
		uses	ds, si
		.enter

		push	ax, bx				;save IACPSide, msg

	;
	;  Allocate a disembodied event queue so we can send our
	;  competion message to it, and we'll know when it's done.
	;  
		call	GeodeAllocQueue			;bx <- queue

	;
	;  Record a message to be sent to our new queue.
	;
		mov	ax, MSG_META_DUMMY
		mov	di, mask MF_RECORD
		call	ObjMessage			;di <- wait event

		mov	cx, di				;cx <- wait event
		mov	si, bx				;si <- queue

	;
	;  Do the sending. IACPSendMessage will send the completion message
	;  to our queue when the IACP message has been successfully handled.
	;

		pop	ax, bx				;ax <- IACPSide
							;bx <- msg to send
		call	IACPSendMessage
		push	ax				;save # servers

	;
	;  Wait for the completion message to come back.
	;
		mov	bx, si				;bx <- queue
		call	QueueGetMessage

	;
	;  Free the message, since all we really cared about was *when*
	;  it was delivered.
	;
		xchg	bx,ax				;bx <- wait event
							;ax <- queue
		call	ObjFreeMessage

	;
	;  We don't need the queue anymore.
	;
		mov_tr	bx, ax				;bx <- queue
		call	GeodeFreeQueue

		pop	ax				;ax <- # servers
		.leave
		ret
IACPSendMessageAndWait	endp



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPHoldUp
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Record the passed messages on the hold-up queue for the
		connection.

CALLED BY:	(INTERNAL) IACPSendMessageInternal, IACPSendMessageToServer
PASS:		bx	= recorded message
		dx	= travel option
		cx	= completion message
		ds:si	= IACPConnectionStruct
RETURN:		ax	= # servers to which it was sent (1, as that's all
			  that can be here, and it can't have gone away)
		IACPListBlock unlocked shared
DESTROYED:	bx, di, bp
SIDE EFFECTS:	

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	3/ 9/93		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPHoldUp	proc	far
		.enter
		mov	bp, bx		; store recorded message in bp
					;  parameter of queued message
		mov	bx, cx
		tst	bx
		jz	afterHaveOwner
		call	MemOwner	; get owner of completion msg
		mov_tr	ax, bx		; ax <- owner for completion
afterHaveOwner:
		
		mov	bx, ds:[si].IACPCS_holdQueue
		mov	di, mask MF_FORCE_QUEUE
		call	ObjMessage
	;
	; Change recorded messages to be owned by the owner of the server
	; for the connection, so when IACPFinishConnect is called, it can
	; do its thang without blowing up.
	; 
		mov	bx, ds:[si].IACPCS_servers[0].handle
		call	MemOwner
		push	bx
		mov_tr	ax, bx
		jcxz	changeRealMsgOwner	 ;=> no completion msg
		mov	bx, cx
		call	HandleModifyOwner
changeRealMsgOwner:
		pop	ax
		mov	bx, bp
		call	HandleModifyOwner
	;
	; Return number of servers contacted (always 1) and unlock the
	; IACPListBlock.
	; 
		mov	ax, 1
		call	IACPUnlockListBlockShared
		.leave
		ret
IACPHoldUp	endp

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPSendMessageInternal
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Send a message to the other side of a connection when
		IACPListBlock is already locked

CALLED BY:	(INTERNAL) IACPSendMessage, IACPShutdown
PASS:		*ds:bp	= IACPConnection
		bx	= recorded message to send
		dx	= TravelOption, -1 if recorded message contains
			  the proper destination already
		cx	= completionMsg, 0 if none
		ax	= IACPSide doing the sending.
RETURN:		ax	= number of servers to which message was sent
DESTROYED:	bx, cx, dx
SIDE EFFECTS:	the recorded messages are freed

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	10/28/92	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPSendMessageInternal proc	near
		uses	si, di, bp
		.enter
EC <		call	IACPValidateConnection			>
		mov	si, ds:[bp]
			CheckHack < IACPS_CLIENT eq 0 >
		tst	ax
		jz	sendFromClient
		
		add	si, offset IACPCS_client
		mov	di, 1
		jmp	sendToOptrs

sendFromClient:
		tst	ds:[si].IACPCS_holdQueue
		jnz	holdUp

		ChunkSizePtr	ds, si, di
		sub	di, offset IACPCS_servers
		shr	di
		shr	di
		add	si, offset IACPCS_servers
sendToOptrs:
	;
	; di = # optrs
	; ds:si = array of optrs
	; bx = recorded message
	; dx = TravelOption
	; cx = completionMsg
	;
	; set up registers to be convenient for sending the message.
	; 
		mov	bp, cx
		mov	cx, bx
		mov	bx, bp		; get completion msg in bx
		tst	bx
		jz	afterHaveOwner
		call	MemOwner	; get owner of completion msg
		mov_tr	ax, bx		; ax <- owner for completion
afterHaveOwner:
		clr	bx
sendLoop:
		call	IACPSendOneMessage
		jc	nextOptr		; => not sent
		inc	bx
nextOptr:
		add	si, size optr
		dec	di
		jnz	sendLoop
		call	IACPSendMessageCleanUp
done:
		.leave
		ret

holdUp:
	;
	; Record the things on the hold-up queue. They'll be sent on later.
	; 
		call	IACPHoldUp
		jmp	done
IACPSendMessageInternal		endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPShutdown
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Shutdown one side of an IACP connection

CALLED BY:	(GLOBAL)
PASS:		bp	= IACPConnection
		^lcx:dx	= server optr (cx == 0 if client is shutting down)
RETURN:		nothing
DESTROYED:	ax
SIDE EFFECTS:	MSG_META_IACP_LOST_CONNECTION is sent to the other side of
		    the connection.

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	10/12/92	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPShutdown	proc	far
		uses	ds, si, di, cx, dx, bx
		.enter
	;
	; Lock down the block holding the lists and deref the IACPConnection.
	; Grab it for exclusive access to eliminate race condition where both
	; ends shut down at the same time and the double-chunk free that
	; leads to.
	; 
		call	IACPLockListBlockExcl
	;
	; If handle of optr is 0, it's the client shutting down. Point ds:di
	; at the place we store its optr.
	; 
EC <		call	IACPValidateConnection			>
		mov	di, ds:[bp]
		add	di, offset IACPCS_client
		jcxz	haveOptrAddr

EC <		tst	ds:[di-IACPCS_client].IACPCS_holdQueue		>
EC <		ERROR_NZ CANT_SHUT_DOWN_IACP_CONNECTION_THAT_WAS_NEVER_FINISHED>

	;
	; Not the client, so locate the server in the array of server optrs
	; in the chunk.
	; 
		ChunkSizeHandle ds, bp, ax
		sub	ax, offset IACPCS_servers
		shr	ax
		shr	ax
		mov	bx, ax		; save # servers
	CheckHack <offset IACPCS_servers - offset IACPCS_client eq size optr>
findLoop:
		dec	ax
		jl	notPresent		; XXX: fatal-error?
		add	di, size optr
		cmp	ds:[di].handle, cx
		jne	findLoop
		cmp	ds:[di].chunk, dx
		jne	findLoop
	;
	; Calculate server number to send to client.
	; 
		sub	bx, ax
		mov	cx, bx

haveOptrAddr:
	;
	; ds:di = place where optr of server/client is stored, which optr we
	; need to zero out.
	;
	; Zero out the handle portion of the optr.
	; 
		clr	ax
		mov	ds:[di].handle, ax

		push	cx		; save server #
	;
	; See if all the optrs, including the client, are now 0, meaning we
	; can nuke the connection (and that there's no one to notify).
	; 
		mov	si, ds:[bp]
		ChunkSizePtr	ds, si, cx
		sub	cx, offset IACPCS_client
		shr	cx
		shr	cx
		add	si, offset IACPCS_client
		clr	ax
checkDeleteLoop:
		or	ax, ds:[si].handle
		add	si, size optr
		loop	checkDeleteLoop
		pop	cx		; cx <- 0 if client shutdown,
					;  server # if server

		tst	ax		; anyone left?
		jz	biffConnection	; no
	;
	; Now let the other side know that it's lost the connection.
	;
		mov	bx, handle IACPListBlock
		call	MemDowngradeExclLock
	;
	; First, record the message to be sent.
	; 
		mov	ax, MSG_META_IACP_LOST_CONNECTION
		clr	bx, si
		mov	di, mask MF_RECORD
		call	ObjMessage
	;
	; Now call IACPSendMessageInternal to send it to the server/client
	; object on the other side.
	; 
		mov	bx, di
		mov	dx, TO_SELF
			CheckHack <IACPS_CLIENT eq 0>
		mov	ax, cx		; ax <- 0 if client
		clr	cx		; no completion message
		call	IACPSendMessageInternal	; (unlocks IACPListBlock)
done:
		.leave
		ret

biffConnection:
	;
	; Nobody left to celebrate the funeral rites, so nuke the connection
	; 
		call	IACPDeleteConnection
notPresent:
		call	IACPUnlockListBlockExcl
		jmp	done
IACPShutdown	endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPShutdownAll
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Shutdown all connections open to or from the given object.

CALLED BY:	(GLOBAL)
PASS:		cx:dx	= optr of client or server object for which all
			  connections are to be shutdown.
RETURN:		nothing
DESTROYED:	ax
SIDE EFFECTS:	all connections in which the object has an interest are
     		    placed off-limits to it.
		lots of MSG_META_IACP_LOST_CONNECTION messages may be sent

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	10/12/92	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPShutdownAll	proc	far
		uses	bx, di, ds, bp, es
		.enter
		call	IACPLockListBlockExcl
	;
	; Create an array into which we can put the connections to be shut down.
	; It gets too complex, having to cope with connections being nuked
	; out from under us during the enumeration, so we take this in two
	; passes: one finds the connections that involve this object, holding
	; exclusive access to the block during the course of the check, so
	; we can add things to our array without risk of hosing another thread.
	; The second pass shuts down the connections stored within the
	; array of connections we found during the first pass.
	; 
		push	cx
		mov	bx, size lptr
		clr	cx
		clr	si
		call	ChunkArrayCreate
		mov	bp, si
		pop	cx
		
		mov	si, offset iacpListArray
		mov	bx, cs
		mov	di, offset IACPSA_callback
		call	ChunkArrayEnum
	;
	; Downgrade the exclusive lock to a shared one, since we're no longer
	; causing things to move around on the heap.
	; 
		mov	bx, handle IACPListBlock
		call	MemDowngradeExclLock
	;
	; Figure the number of connections found and set it as our loop counter/
	; array index.
	; 
		mov	si, bp
		push	cx
		call	ChunkArrayGetCount
		mov_tr	ax, cx
		pop	cx
shutdownLoop:
		dec	ax
		jl	shutdownLoopDone
	;
	; Fetch the next element from the array.
	; 
		push	cx, ax
		call	ChunkArrayElementToPtr
		mov	bp, ds:[di]
	;
	; See if the object is the client or a server for the connection,
	; setting cx to 0 if it's a client.
	; 
		mov	bx, ds:[bp]
		cmp	cx, ds:[bx].IACPCS_client.handle
		jne	doShutdown
		cmp	dx, ds:[bx].IACPCS_client.chunk
		jne	doShutdown
		clr	cx
doShutdown:
	;
	; Release the IACPList block so IACPShutdown can lock it itself.
	; 
		call	IACPUnlockListBlockShared
	;
	; Shutdown the connection.
	; 
		call	IACPShutdown
	;
	; Grab the IACPList block again.
	; 
		call	IACPLockListBlockShared
		pop	cx, ax
		jmp	shutdownLoop

shutdownLoopDone:
	;
	; Free the chunkarray that held the connections to shut down.
	; 
		mov	ax, si
		call	LMemFree
	;
	; Release the IACPListBlock.
	; 
		call	IACPUnlockListBlockShared
		.leave
		ret
IACPShutdownAll	endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPSA_callback
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Callback function to search for connections that need
		to be shut down.

CALLED BY:	(INTERNAL) IACPShutdownAll via ChunkArrayEnum
PASS:		*ds:si	= iacpListArray
		ds:di	= IACPList to process
		*ds:bp	= array to which to add any connections we find
		^lcx:dx	= object for which we're shutting down
			  connections
RETURN:		ds	= fixed up
		carry set to stop enumerating (always clear)
DESTROYED:	ax, si, di, es
SIDE EFFECTS:	

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	10/12/92	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPSA_callback	proc	far
		.enter
		mov	bx, ds:[di].IACPL_connections
connectionLoop:
		mov	si, bx
		tst	si
		jz	done

		mov	di, ds:[si]
	;
	; Save the handle of the next connection to check.
	; 
		mov	bx, ds:[di].IACPCS_next
	;
	; Figure the number of optrs to examine and point di one behind the
	; first, so we can easily adjust di at the start of the loop.
	; 
		ChunkSizePtr ds, di, ax
		sub	ax, offset IACPCS_client
		shr	ax
		shr	ax
		add	di, offset IACPCS_client - size optr
optrLoop:
		dec	ax
		jl	connectionLoop
		add	di, size optr
	;
	; See if this optr matches the object in question.
	; 
		cmp	ds:[di].handle, cx
		jne	optrLoop
		cmp	ds:[di].chunk, dx
		jne	optrLoop
	;
	; Yes. Append another entry to the return array and store the chunk
	; handle of this connection in the new entry.
	; 
		xchg	si, bp
		call	ChunkArrayAppend
		mov	ds:[di], bp
		mov	bp, si			; bp <- return array, again
		jmp	connectionLoop
done:
	; (carry cleared by tst si)
		.leave
		ret
IACPSA_callback	endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPProcessMessage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Process a received message.

CALLED BY:	(GLOBAL)
PASS:		cx	= handle of message to send
		dx	= TravelOption/-1
		bp	= handle of message to send after cx is processed,
			  or 0 if no completion notification needed.
		*ds:si	= server object
RETURN:		nothing
DESTROYED:	ax, cx, dx, bp
SIDE EFFECTS:	

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	10/12/92	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPProcessMessage proc	far
		.enter
EC <		xchg	bx, cx					>
EC <		call	ECCheckEventHandle			>
EC <		xchg	bx, cx					>
EC <		xchg	bx, bp					>
EC <		tst	bx					>
EC <		jz	10$					>
EC <		call	ECCheckEventHandle			>
EC <10$:							>
EC <		xchg	bx, bp					>
	;
	; If there's a completion message, fetch and save the destination of
	; the recorded message, as we'll need it for sending the completion
	; message via the recorded message's destination.
	; 
		mov	bx, cx
		tst	bp
		jz	dispatch

		push	si
		call	ObjGetMessageInfo
		mov_tr	ax, si
		pop	si
		push	cx, ax

dispatch:
	;
	; Dispatch the recorded message itself. To cope with being called from
	; a method, or as a method, pass MF_FIXUP_DS.
	; 
		cmp	dx, -1
		jne	dispatchClassed

		mov	di, mask MF_FIXUP_DS
		call	MessageDispatch

checkCompletionMsg:
		tst	bp
		jz	done

	;
	; Send MSG_META_DISPATCH_EVENT to the same place, passing the completion
	; message as the event to dispatch.
	; 
		mov_tr	ax, si				; save server object
							;  chunk
		pop	bx, si
		mov	di, mask MF_FIXUP_DS

		push	dx, ax
		cmp	dx, -1
		je	dispatchCompletionMsg
	    ;
	    ; Recorded message was classed, so MSG_META_DISPATCH_EVENT must
	    ; be classed as well: set MF_RECORD to record the thing instead
	    ; of sending it.
	    ; 
		mov	di, mask MF_RECORD

dispatchCompletionMsg:
		mov	cx, bp
		mov	dx, mask MF_FORCE_QUEUE
		mov	bp, 0xadeb
		mov	ax, MSG_META_DISPATCH_EVENT
		call	ObjMessage

		pop	dx, si
		cmp	dx, -1		; classed?
		je	done		; no -- message sent
		
		mov	cx, di		; cx <- recorded message
		call	sendClassed
done:
		.leave
		ret

dispatchClassed:
	;
	; A bit more complex.
	; 
		mov	cx, bx
		call	sendClassed
		jmp	checkCompletionMsg

	;--------------------
	; Internal routine to send a recorded message with a TravelOption
	; Pass:
	; 	*ds:si	= server object
	; 	cx	= handle of recorded message
	; 	dx	= TravelOption
	; Return:
	; 	ds	= fixed up
	; Destroyed:
	; 	ax, cx
	; 
sendClassed:
		push	bp, dx
		mov	ax, MSG_META_SEND_CLASSED_EVENT
		call	ObjCallInstanceNoLock
		pop	bp, dx
		retn
IACPProcessMessage endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPLostConnection
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Utility routine for server objects to handle
		MSG_META_IACP_LOST_CONNECTION

CALLED BY:	(GLOBAL)
PASS:		*ds:si	= server object
		bp	= IACPConnection
RETURN:		nothing
DESTROYED:	ax, cx, dx, bp, bx, di
SIDE EFFECTS:	queue-flushing messages are sent out; the object will
     		    eventually receive a MSG_META_IACP_SHUTDOWN_CONNECTION

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	10/12/92	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPLostConnection proc	far
		.enter
EC <		call	IACPValidateConnectionNoDS		>
	;
	; Record message to send when queues have been flushed.
	; 
		mov	bx, ds:[LMBH_handle]
		mov	ax, MSG_META_IACP_SHUTDOWN_CONNECTION
		mov	di, mask MF_RECORD
		call	ObjMessage
	;
	; Send MSG_META_OBJ_FLUSH_INPUT_QUEUE to the server object.
	; 
		mov	cx, di		; cx <- event handle
		mov	dx, bx		; dx <- block for which flushing is
					;  being done
		clr	bp		; bp <- is first call
		mov	ax, MSG_META_OBJ_FLUSH_INPUT_QUEUE
		call	ObjCallInstanceNoLock
		.leave
		ret
IACPLostConnection endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPShutdownConnection
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Utility routine to handle MSG_META_IACP_SHUTDOWN_CONNECTION,
		as generated by a call to IACPLostConnection

CALLED BY:	(GLOBAL)
PASS:		*ds:si	= server object
		bp	= IACPConnection to shut down.
RETURN:		nothing
DESTROYED:	ax, cx, dx, bp
SIDE EFFECTS:	

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	10/12/92	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPShutdownConnection proc	far
		.enter
	;
	; Load ^lcx:dx with server object's optr and shutdown the connection.
	; 
		mov	cx, ds:[LMBH_handle]
		mov	dx, si
		call	IACPShutdown
		.leave
		ret
IACPShutdownConnection endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPFinishConnect
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Finish a connection made to a server that had to change
		from non-interactible to interactible.

CALLED BY:	(GLOBAL)
PASS:		^lcx:dx	= server object
		bp	= IACPConnection
RETURN:		nothing
DESTROYED:	nothing
SIDE EFFECTS:	

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	3/ 9/93		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPFinishConnect proc	far
		uses	ds, si, bx, di, bp, cx, dx, ax
		.enter
	;
	; Since we only handle single-server pending connections, we can just
	; lock the block shared.
	; 
		call	IACPLockListBlockShared
EC <		call	IACPValidateConnection				>
		mov	si, ds:[bp]
		clr	bx
		xchg	ds:[si].IACPCS_holdQueue, bx
		tst	bx
		jz	connectionFinished
EC <		call	ECCheckQueueHandle				>
		mov	di, bp			; *ds:di <- IACPConnectionStruct
						;  for the duration
queueLoop:
		call	GeodeInfoQueue
		tst	ax
		jz	nukeQueue		; all done
		
		call	QueueGetMessage		; ax <- message
		push	bx			; save queue
		mov_tr	bx, ax			; bx <- message to process
		push	cs
		mov	ax, offset sendMessage
		push	ax			; push routine to call
		clr	si			; free event, please
		call	MessageProcess
		pop	bx			; bx <- queue, again
		jmp	queueLoop

nukeQueue:
		call	GeodeFreeQueue

connectionFinished:
		call	IACPUnlockListBlockShared
		.leave
		ret

sendMessage:
	; Pass: cx	= completion message
	; 	dx	= TravelOption/-1
	; 	bp	= recorded message
	; 	ax	= owner for completion msg
	; 	*ds:di	= IACPConnectionStruct
	; Return:
	; 	nothing
	; 
	; Send the recorded messages to the sole server on the list
		mov	si, ds:[di]
		add	si, offset IACPCS_servers
		xchg	cx, bp
		call	IACPSendOneMessage
	;
	; Free the recorded messages, as IACPSendOneMessage will have
	; duplicated them (alas)
	; 
		mov	bx, cx
		call	ObjFreeMessage
		tst	bp
		jz	sendDone
		mov	bx, bp
		call	ObjFreeMessage
sendDone:
		retf
IACPFinishConnect endp

IACPCommon ends

;---

IACPCode segment resource


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPSendMessageToServer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Send a message to a particular server on a connection

CALLED BY:	(GLOBAL)
PASS:		bp	= IACPConnection
		bx	= recorded message to send
		dx	= TravelOption, -1 if recorded message contains
			  the proper destination already
		cx	= completionMsg, 0 if none
		ax	= server number (1 -> numServers)
RETURN:		ax	= number of servers to which message was sent (1 or 0)
DESTROYED:	bx, cx, dx
SIDE EFFECTS:	the recorded messages are freed

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	10/25/92	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPSendMessageToServer proc	far
		uses	si, ds, di, bp
		.enter
		call	IACPLockListBlockShared
EC <		call	IACPValidateConnection			>
		mov	si, ds:[bp]
		dec	ax
EC <		ERROR_S	IACP_INVALID_SERVER_NUMBER			>
		shl	ax
		shl	ax
		add	ax, offset IACPCS_servers

EC < ; since we're multiplying by 4 and LMC_size holds actual size + 2, >
EC < ; ax will always be out of bounds if the server # is illegal	>
EC <		cmp	ax, ds:[si].LMC_size				>
EC <		ERROR_A	IACP_INVALID_SERVER_NUMBER			>

   		tst	ds:[si].IACPCS_holdQueue
		jnz	holdUp

		add	si, ax
		mov	bp, cx
		mov	cx, bx
		mov	bx, bp		; get completion msg in bx
		tst	bx
		jz	afterHaveOwner
		call	MemOwner	; get owner of completion msg
		mov_tr	ax, bx		; ax <- owner for completion
afterHaveOwner:
		clr	bx
		call	IACPSendOneMessage
		jc	done
		inc	bx
done:
		call	IACPSendMessageCleanUp
exit:
		.leave
		ret
holdUp:
	;
	; Record the things on the hold-up queue. They'll be sent on later.
	; 
		call	IACPHoldUp
		jmp	exit
IACPSendMessageToServer endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPCreateDefaultLaunchBlock
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Create an AppLaunchBlock one can pass to IACPConnect
		presuming the following defaults:
			- IACP will locate the app, given its token
			- initial directory should be SP_DOCUMENT
			- no initial data file
			- application will determine generic parent for
			  itself
			- no one to notify in event of an error
			- no extra data

CALLED BY:	(GLOBAL)
PASS:		dx	= mode in which server should be launched:
			  MSG_GEN_PROCESS_OPEN_APPLICATION or
			  MSG_GEN_PROCESS_OPEN_ENGINE
RETURN:		carry clear if block created:
			^hdx	= AppLaunchBlock
		carry set if couldn't allocate memory
DESTROYED:	nothing
SIDE EFFECTS:	

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	10/22/92	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPCreateDefaultLaunchBlock proc	far
		uses	ds, ax, cx, bx
		.enter
		mov	ax, size AppLaunchBlock
		mov	cx, ALLOC_DYNAMIC_LOCK or (mask HAF_ZERO_INIT shl 8)\
				 or mask HF_SHARABLE
		call	MemAlloc
		jc	done
		mov	ds, ax
		mov	ds:[ALB_appMode], dx

if UNTITLED_DOCS_ON_SP_TOP
		mov	ds:[ALB_diskHandle], SP_TOP
else
		mov	ds:[ALB_diskHandle], SP_DOCUMENT
endif
		call	MemUnlock
		mov	dx, bx
done:
		.leave
		ret
IACPCreateDefaultLaunchBlock endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		IACPGetServerNumber
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Get the server number for a particular server in a 
		particular connection.

CALLED BY:	(GLOBAL)
PASS:		bp	= IACPConnection
		^lcx:dx	= server object
RETURN:		ax	= server number (0 if object isn't a server for the
			  connection)
DESTROYED:	nothing
SIDE EFFECTS:	none

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	10/25/92	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
IACPGetServerNumber proc	far
		uses	ds, si, bx
		.enter
		call	IACPLockListBlockShared
EC <		call	IACPValidateConnection			>
		mov	si, ds:[bp]
		ChunkSizePtr	ds, si, ax
		sub	ax, offset IACPCS_servers
		shr	ax
		shr	ax
		mov	bx, ax			; save # servers
		add	si, offset IACPCS_servers - size optr
findLoop:
		add	si, size optr
		dec	ax
		js	fail		; => not found, so return ax = 0

		cmp	ds:[si].handle, cx
		jne	findLoop
		cmp	ds:[si].chunk, dx
		jne	findLoop

		sub	bx, ax		; bx <- server #
		mov_tr	ax, bx		; return it in AX, though
exit:
		call	IACPUnlockListBlockShared
		.leave
		ret
fail:
		clr	ax
		jmp	exit
IACPGetServerNumber endp


IACPCode	ends
