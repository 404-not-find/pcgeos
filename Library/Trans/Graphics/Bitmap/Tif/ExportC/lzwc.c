/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) GeoWorks 1992 -- All Rights Reserved

PROJECT:	PC GEOS
MODULE:		
FILE:		lzwc.c

AUTHOR:		Maryann Simmons, Feb 13, 1992

METHODS:

Name			Description
----			-----------

FUNCTIONS:

Scope	Name			Description
-----	----			-----------

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	MS	2/13/92   	Initial version.

DESCRIPTION:
	

	$Id: lzwc.c,v 1.1 97/04/07 11:27:37 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
/* 
       ----- Copyright(c), 1990-91  Halcyon Software -----

   Lzwc.C 
   
Description

   LZW compression routines
 
*/
#pragma Comment("@" __FILE__);

#include "hsimem.h"
#include "hsierror.h"

#include <Ansi/stdio.h>
#include <Ansi/string.h>
#include <Ansi/stdlib.h>


#include "lzwc.h"

#pragma Code ("LzwcCode")

/* clear the table structure */

HSI_ERROR_CODE 
ClearTab (LPTREENODE lpTab)      /* a locked version of pLzw->hTab */
   {
   HSI_ERROR_CODE err = 0;
   WORD        nRoots = 1 << CHARBITS;
   WORD        TableBytes;
   register LPTREENODE    lpTabPtr;
   register WORD        ii;

   /* clear the table, to set all the pointers to 0. */
   TableBytes = MAXTABENTRIES * sizeof(TREENODE);
   _fmemset ((LPSTR)lpTab, (BYTE)'\0', TableBytes);
        
   /* continue the initialization of the table by
   * storing each of the root values into their
   * spot in the table, in the Suffix field of
   * the structure.
   *
   * todo: try to get rid of this step.  I don't think
   * I ever look at the Suffix values for the roots.
   */
   for (ii = 0, lpTabPtr = lpTab; ii < nRoots;     ii++, lpTabPtr++) 
        {
        lpTabPtr->Suffix = (BYTE)ii;
        }
                
   /* return         */
   cu0:
   return err;
   }



/* do the LZW coding thing, using 16-bit words to hold the codes.
 * after this step, we will change the 16-bit words into 9-, 10-,
 * 11-, or 12-bit codes, using a different routine.
 */
HSI_ERROR_CODE             
Lzw16 (
   PLZWSTRUCT   pLzw,             // the control structure 
   LPBYTE       lpIn,             // the input values 
   DWORD        dwInCount,        // number of bytes to compress 
   DWORD        *pdwNumCodes )    // OUT: number of 16-bit codes generated by this routine 
   {
   register LPTREENODE  lpNode;      /* the order of registerization has been tuned */
   register WORD        CurrentNode;
   register BYTE        val;         /* value to be added to the current string */
   register LPTREENODE  lpTab;       /* locked-down version of pLzw->hTab */
   register WORD        LoopCnt;
        
   short       err = 0;
   WORD        Code;
   DWORD       dwLoopCount = dwInCount;
   WORD        Empty;
   WORD        StringLen;
   DWORD       dwNumCodes = 0;
   LPWORD      lp16BufPtr;
        
   lp16BufPtr  = (LPWORD)      pLzw->lp16Buf;
   lpTab       = (LPTREENODE)  pLzw->lpTable;
                
   /* clear the LZW table */

   if ((err = ClearTab (lpTab)) !=0) 
        goto cu0;

   *lp16BufPtr++ = CLEARCODE;

   dwNumCodes++;
   StringLen = 0;
   Empty = EOICODE+1;

   /* for each value (each value is stored in a byte) */
   while (dwLoopCount--) 
        {
        /* grab the value */
        val = *lpIn++;

        /* increment the string length */
        StringLen++;
            
        /* if the first value in the string, we know it's in the table,
        * so just update the current tree node.  This happens on
        * the first row of the strip, and after we do a CLEAR
        */
        if (StringLen == 1) 
            {
            CurrentNode = (WORD)val;
            /* TODO: efficient address computation: */
            lpNode   = lpTab + CurrentNode;
            goto NextVal;
            }
            
        /* if the NextSuffix pointer is null,
        * point to the new node that we're going
        * to add, and branch to the code that
        * writes a code and fills out the new node
        */
        if (!lpNode->NextSuffix)     
            {
            lpNode->NextSuffix = Empty;
            Code = CurrentNode;
            goto WriteCodeAddNode;
            } /* end of null NextSuffix pointer section */
            
        /* else if the NextSuffix pointer is not null, look
        * through this binary search tree...
        */
        else 
            {
            /* here's the root of our tree */
            Code = CurrentNode;
            CurrentNode = lpNode->NextSuffix;
            lpNode = lpTab + CurrentNode;
                
            /* do the binary search thing */
            LoopCnt = 0;
            while (TRUE)
            {
            if (val == lpNode->Suffix)
                goto NextVal;   /* We found the string */
            else
            if (val < lpNode->Suffix)
                {
                if (lpNode->Left == 0)
                    {
                    lpNode->Left = Empty;
                    goto WriteCodeAddNode;
                    }
                else
                    {
                    CurrentNode = lpNode->Left;
                    lpNode = lpTab + CurrentNode;
                    }
                }
            else /* if (val >= lpNode->Suffix) */
                {
                if (lpNode->Right == 0)
                    {
                    lpNode->Right = Empty;
                    goto WriteCodeAddNode;
                    }
                else
                    {
                    CurrentNode = lpNode->Right;
                    lpNode = lpTab + CurrentNode;
                    }
                }
            LoopCnt++;
            if (LoopCnt > 1000)
                {
                err = HSI_EC_INVALIDFILE;
                goto cu0;
                }
            } /* end while (TRUE) */
        } /* end of non-null NextSuffix pointer section */
            
        /* nothing falls though to here. you either WriteCodeAddNode
        * or, if found, continue back up to the top of the loop to
        * get another character (value).
        */
   WriteCodeAddNode:

        /* write out the code for the "current prefix" */
        *lp16BufPtr++ = Code;
        dwNumCodes++;
            
        /* add a table entry for the "current prefix" plus
        * this value.    remember, the code is simply the array
        * index of the table entry, so we don't have to store
        * it explicitly with the table entry.
        */
        lpNode = lpTab + Empty; /* TODO: do explicit 3-bit shifts? */
        lpNode->Suffix = val;
            
        /* set the current prefix to just the current value */
        CurrentNode = (WORD)val;
        lpNode = lpTab + CurrentNode;
        StringLen = 1;
            
        /* update the Empty pointer */
        Empty++;                

                
        /* if we are at the end of our table, do a clear
        * while we can still do a 12-bit one.  I was
        * waiting too long. 88-5-3
        * 5-6: changed from -1 to -2, since we need room
        * to write out the current string as well as
        * the Clear code.
        */
        if (Empty == MAXTABENTRIES - 2) 
            {    /* 4094 */
            if (StringLen > 0) 
                {
                *lp16BufPtr++ = CurrentNode;
                dwNumCodes++;
                }
            if ((err = ClearTab (lpTab)) != 0) 
                goto cu0;

            *lp16BufPtr++ = CLEARCODE;
            dwNumCodes++;
            StringLen = 0;
            Empty = EOICODE+1;
            }
            
   NextVal:
            continue;
        
        } /* end of LoopCount loop */
        
   /* issue an "end-of-information" LZW code */
   if (StringLen > 0) 
        {
        *lp16BufPtr++ = CurrentNode;
        dwNumCodes++;
        }

   *lp16BufPtr++ = EOICODE;
   dwNumCodes++;
        
   /* return */

   *pdwNumCodes = dwNumCodes;
        
   cu0:    

   return err;
   }



/* shrink all the codes in the strip from 16 bits per code,
 * in the native byte order for words for this machine, 
 * low-order-justified,
 * to 9, 10, 11, or 12 bits per code,
 * so that I don't have to make a function call every
 * time I want to write a code.
 *
 * the output data must be stored "as bytes", but we will
 * write a word at a time; so the caller
 * must be careful to pass even addresses for the output
 * buffers to this routine.
 * this routine must swap bytes if executing
 * on an Intel-type machine.
 *
 * This routine was inspired by Eric R's word-at-a-time
 * variable-bit i/o routines.
 *
 */

HSI_ERROR_CODE         
LzwShrinkCodes (
   PLZWSTRUCT pLzw,          
   DWORD      dwNumCodes,     // number of 16-bit codes in hCodeStrip 
   DWORD      *pdwOutByteCnt) // number of bytes written into hCmStrip 
   {
   short           err = 0;
   LPWORD            lpCodeStrip;        /* source: LZW-coded, before shrinking */
   register LPWORD    lpCmStripPtr;
   register LPWORD    lpCodeStripPtr;
   register WORD    ComprSize;
   register WORD    BitsLeft;
   register WORD    Diff;
   register WORD    TempCode;
   register WORD    Code;
   register WORD    OutWord;
   register WORD    NextOne;
   register WORD    NextBoundary;
   LPWORD    lpCmStrip;
   WORD    NumOutWords;
   DWORD    dwNumOutBytes;
   DWORD    dwNumSwappedBytes;
   WORD    LoopCount;
   WORD    MaxLoops;
                
   extern void  _lswab(LPSTR, LPSTR, WORD);

   lpCodeStrip     = (LPWORD) pLzw->lp16Buf;
   lpCodeStripPtr  = lpCodeStrip;

   lpCmStrip       = (LPWORD)pLzw->lpOutStripBuf;
   lpCmStripPtr    = lpCmStrip;
                
   /* other setup */

   NextOne = EOICODE + 1;    /* so that we know when we are about
                            * to cross over a bit boundary.
                            * used similarly to "Empty" in 
                            * compression routines
                            */

   ComprSize = CHARBITS + 1;        /* we start with 9-bit codes */
   NextBoundary = 1 << ComprSize;
   OutWord = 0;
   BitsLeft = 16;
   LoopCount = 0;    /* for debugging only */
   MaxLoops = 20;    /* for debugging only */
                
   while (dwNumCodes--) 
        {
        /* get the next 16-bit code     */
        Code = *lpCodeStripPtr++;
        if (LoopCount < MaxLoops) 
            {
   /*        DBMSG((" Code=%u",Code)) */;
            }
            
        /* write the low-order ComprSize bits into
        * one or two words
        */
        {
        /* we're going to have to cross a word boundary.
        * the most common case.
        */
        if (BitsLeft < ComprSize) 
            {
            TempCode = Code;
            Diff = ComprSize - BitsLeft;

            TempCode >>= Diff;    /* assume zeros are shifted in on left */
                    
            OutWord |= TempCode;

            if (LoopCount < MaxLoops) 
                {
                /*            DBMSG((" A OutWord=%x\n",OutWord)) */;
                }

        /* *lpCmStripPtr++ = fixshortnow(OutWord); */

            *lpCmStripPtr++ =OutWord;

            OutWord = 0;
                    
            BitsLeft = 16 - Diff;
                    
            TempCode = Code;
            TempCode <<= BitsLeft;
            OutWord |= TempCode;
                
            /* fits into output word, with some left over */
            } 
        else 
        if (BitsLeft > ComprSize) 
            {
            if (LoopCount < MaxLoops) 
                {
                /*            DBMSG((" B\n")) */ ;
                }

            Diff = BitsLeft - ComprSize;
            TempCode = Code;
            TempCode <<= Diff;
            OutWord |= TempCode;
            BitsLeft -= ComprSize;
                
            /* fits into output word, with none left over */
            } 
        else 
            {
            OutWord |= Code;

            /*
            if (LoopCount < MaxLoops) 
                {
                }
            */

       /*  *lpCmStripPtr++ = fixshortnow(OutWord); */

            *lpCmStripPtr++ =OutWord;
            OutWord = 0;
            BitsLeft = 16;
            }
        } /* end of the 3 cases */
            
        /* check for CLEAR code     */

        if (Code == CLEARCODE) 
            {
            NextOne = EOICODE + 1;
            ComprSize = CHARBITS + 1;
            NextBoundary = 1 << ComprSize;
            }

        /* if at bit boundary, adjust compression size */

        else if (++NextOne == NextBoundary) 
            {
            ComprSize++;

            if (ComprSize > MAXCODEWIDTH) 
                {
                err = HSI_EC_INVALIDFILE;
                goto cu0;
                }

            NextBoundary <<= 1;
            }

        LoopCount++;

        } /* end of loop */
        
   /* calculate the number of output bytes. note:  I should
   * use a double-word counter, but that would slow things
   * down a bit...keep the strips small enough so that
   * we don't overflow 64K!
   */

   NumOutWords = lpCmStripPtr - lpCmStrip;    /* caution: word arithmetic! */
   dwNumOutBytes = (DWORD)NumOutWords * 2;
        
   /* write out any remaining stuff */

   if (BitsLeft < 16) 
        {
   /*   *lpCmStripPtr++ = fixshortnow(OutWord); */
        *lpCmStripPtr++ =OutWord;

        dwNumOutBytes++;
        if (BitsLeft < 8 ) 
            {
            dwNumOutBytes++;
            }
        }
        

   dwNumSwappedBytes = dwNumOutBytes;

   if (ODD(dwNumSwappedBytes))
        dwNumSwappedBytes++;

   if (dwNumSwappedBytes > MAXWORD) 
        {
        err = HSI_EC_INVALIDFILE;
        goto cu0;
        }

   /* swap bytes on Intel-type machine     */

   _lswab ((LPSTR)lpCmStrip, (LPSTR)lpCmStrip, (WORD)dwNumSwappedBytes);

   /* store output information(caution: word arithmetic) */

   *pdwOutByteCnt = dwNumOutBytes;
                        
   cu0:    

   return err;
   }



/* Open a Lzw Compression session, has to be called by caller prior to any
 * compression.
 *
 * Allocates some buffers, does some preliminary
 * calculations, and so on.
 */

HSI_ERROR_CODE 
LzwCmOpen (
PLZWSTRUCT *p,   /* OUT: a near pointer to a private data structure (LZWSTRUCT)
                  *  is allocated by this routine.  it should be freed
                  *  only by calling LzwCmClose().
                  */
DWORD    dwInBufSize)/* maximum number of bytes that are to be compressed at 
                      * one time
                      */
   {
   short err=0;
   DWORD                dwOutStripBufSize;
   WORD                 TableBytes;
   PLZWSTRUCT      pLzw;

   // allocate and lock the main control structure     

   *p=(LZWSTRUCT *)malloc(sizeof(LZWSTRUCT));

   if (!*p) 
        {
        err = HSI_EC_NOMEMORY;
        goto cu0;
        }

   pLzw = *p;

   /* compute the required output strip buffer size
   *
   * I believe (but haven't tried to prove) that the worst case for LZW
   * is (Bits+1)*nValues output bits, although the worst case for an
   * arbitrary substring is (12 bits) * nValues.
   */

   dwOutStripBufSize = dwInBufSize * (CHARBITS+1) / CHARBITS;

   if (dwOutStripBufSize > MAXWORD) 
        {
        err = HSI_EC_INVALIDFILE;
        goto cu0;
        }

   pLzw->OutStripBufSize = (WORD)dwOutStripBufSize;
        
   /* allocate the output strip buffer     */

   pLzw->lpOutStripBuf=(LPSTR)_fmalloc(pLzw->OutStripBufSize);

   if (!pLzw->lpOutStripBuf)
        {
        err = HSI_EC_NOMEMORY;
        goto cu0;
        }
        
   /* allocate a version of the output strip buffer that uses 16-bit codes */

   if (dwInBufSize*2 > MAXWORD) 
        {
        err = HSI_EC_NOMEMORY;
        goto cu0;
        }

   pLzw->lp16Buf =(LPSTR) _fmalloc(dwInBufSize*2);

   if (!pLzw->lp16Buf)
        {
        err = HSI_EC_NOMEMORY;
        goto cu0;
        }
        
   /* allocate a table     */

   TableBytes = MAXTABENTRIES * sizeof(TREENODE);

   pLzw->lpTable = _fmalloc(TableBytes);

   if (!pLzw->lpTable)
        {
        err = HSI_EC_NOMEMORY;
        goto cu0;
        }
                
   cu0:

   if (err)
       {
       if (pLzw->lpTable)
           _ffree(pLzw->lpTable);

       if (pLzw->lpTable)
           _ffree(pLzw->lpTable);

       if (pLzw->lpOutStripBuf)
           _ffree(pLzw->lpOutStripBuf);
       }

   return err;        
   }


/* Compress a Strip
 *
 * We assume that compressing a strip is a complete LZW process.
 * The table is cleared before compressing the next strip.  This
 * means that strips can be read and decompressed independently
 * from other strips, which gives much more memory management
 * flexibility.
 */
HSI_ERROR_CODE LzwCmStrip (
PLZWSTRUCT pLzw,   /* IN: must be initialized by LzwCmOpen by caller,
                    * and eventually closed with LzwClose.  this routine
                    * will do a clear call, and EOI call, so the caller
                    * shouldn't do these things.
                    */
DWORD    dwInCount,        /* IN: number of bytes to be compressed */
LPBYTE   lpIn,             /* IN: Address of strip to be compressed */
DWORD    *pOutByteCount)   /* OUT: number of compressed bytes */
   {
   short   err=0;
/*   LPBYTE              lpOutStripBuf;*/
   static DWORD        dwNumCodes;
   static DWORD        dwOutByteCnt;
        
   /* do the LZW thing into 16-bit codes */
   err = Lzw16 (   pLzw, 
                       lpIn, 
                       dwInCount, 
                       &dwNumCodes );
   if (err)
        goto cu0;

   /* now squish the 16-bit codes into 9-, 10-, 11-, or 12-bit codes */

   if ( (err = LzwShrinkCodes( pLzw, 
                             dwNumCodes,
                             &dwOutByteCnt)) !=0) 
        goto cu0;
    
   /* pass information on how much data was actually written
   * back to the caller
   */

   *pOutByteCount = dwOutByteCnt;
            
   cu0:    
            return err;
   }


/* close down a compression session: free buffers, etc
 */
void
LzwCmClose (PLZWSTRUCT pLzw)
   {
   /* free memory     */

   if (pLzw->lpTable)  
       _ffree(pLzw->lpTable);

   if (pLzw->lp16Buf)
       _ffree(pLzw->lp16Buf);
       
   if (pLzw->lpOutStripBuf)
       _ffree(pLzw->lpOutStripBuf);

   /* free the main structure */

   _ffree(pLzw);
   }


