COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) GeoWorks 1994 -- All Rights Reserved

PROJECT:	Clavin
MODULE:		Mailbox Library Global Constants
FILE:		mailboxConstant.def

AUTHOR:		Adam de Boor, Mar 28, 1994

MACROS:
	Name			Description
	----			-----------

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ardeb	3/28/94		Initial revision


DESCRIPTION:
	Constants & structures used by the entire library.
		
	$Id: mailboxConstant.def,v 1.3 98/02/17 03:50:46 gene Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

;------------------------------------------------------------------------------
;
;		    FEATURE COMPILE-TIME CONSTANTS
;
; The description for each constant assumes the constant is set TRUE.
; 
; _SHORT_MESSAGE_MEDIUM			Causes MESN_AVAILABLE notification
;					to be sent out for GMID_SM when
;					the library loads.
;
; _CONTROL_PANELS			Provide system and specific control
;					panels.
;
; _NO_UNKNOWN_APPS_ALLOWED		Don't allow messages to be registered
;					for applications that can't be found
;					at registration time. This is usually
;					turned on when _CONTROL_PANELS is turned
;					off, as without a control panel,
;					messages for unknown apps cannot be
;					deleted.
;
; _CAN_SELECT_CONTENTS			Allow the user to change the contents
;					of the message in the create-message
;					dialog
;
; _POOF_MESSAGE_CREATION		Allow user to create poof messages from
;					the outbox control panel or the
;					MailboxSendControl
;
; _OUTBOX_SEND_WITHOUT_QUERY		Set the MMF_SEND_WITHOUT_QUERY flag
;					for all messages registered for the
;					outbox, causing them to be sent when
;					registered or scheduled or possible.
;
; _ALWAYS_DELIVER_WHEN_FOREGROUND	When a message arrives for an
;					application that's in the foreground,
;					always deliver it immediately. Used
;					in conjunction with ! _CONTROL_PANELS
;
; _CONNECTED_MEDIUM_NOTIFICATION	When medium is connected or becomes
;					available, look for messages going to
;					the same address and ask the user about
;					them.
;
; _SIMPLE_MESSAGE_NOTIFY		Causes a simple notification box to
;					come up when a message is received,
;					rather than presenting a control panel
;					for the application.
;
; _DUPS_ALWAYS_TOGETHER			Signals if duplicate addresses for a
;					message are always displayed and
;					manipulated as a single entity.
;
; _CONFIRM_AFTER_FIRST_FAILURE		Causes a simple notification box to
;					come up after the first failure telling
;					the user that the message is now in the
;					outbox.
;
; _QUERY_DELETE_AFTER_PERMANENT_ERROR	Causes a notification box to come up
;					after a permenant error occured.  The
;					user is asked whether to retry
;					transmission or delete the message.
;
; _AUTO_RETRY_AFTER_TEMP_FAILURE	After a temporary failure, Mailbox will
;					retry sending the message even if the
;					deadline has not been reached.
;
; _TRANSMIT_THREADS_KEYED_BY_MEDIUM	A single transmit thread handles
;					transmitting all messages with the same
;					token from the OutboxMedia array. If
;					false, a transmit thread handles
;					messages for a single transport+option.
;					If _AUTO_RETRY_AFTER_TEMP_FAILURE is
;					TRUE, it's usually best to have
;					_TRANSMIT_THREADS_KEYED_BY_MEDIUM true,
;					too; but beware of things that return
;					MUT_ANY for the unit...
;
; _RESPONDER_OUTBOX_CONTROL		The MailboxOutboxControl should look
;					like it does for the RESPONDER product,
;					with single-line message summaries,
;					a title on the list, vertical lines
;					between fields, etc.
;
; _OUTBOX_FEEDBACK			Provide the user with feedback when
;					she clicks the Send trigger, until
;					the immediate fate of the message is
;					known. RESPONDER ONLY, currently.
;					Must subclass GenInteraction instead
;					of FlashingNote for other platforms.
;
; _QUERY_AFTER_CANCEL			See if the user wants to cancel the
;					connection or everything queued when
;					asked to cancel a single message.
;
; _QUERY_AFTER_LOST_CONNECTION		See if the user wants to retry the
;					connection after we're told it was lost
;
; _HONK_IF_MEDIUM_REMOVED		Put up a notification box if there's
;					a message in the outbox that's destined
;					for a medium that is made unavailable
;
; _DELAY_THIRD_CLASS_MESSAGES		Obeyed only if _OUTBOX_SEND_WITHOUT_-
;					QUERY is set. Causes messages marked
;					as 3d class to not be sent immediately.
;					Instead they wait in the outbox until
;					the medium is connected, or what have
;					you.
;
; _HAS_SWAP_SPACE			Indicates the device has room to swap
;					so certain transient structures should
;					be stored in global memory blocks, not
;					in the admin file.
;
; _MAILBOX_FOR_FAX_SEND_ONLY		Mailbox will be used for fax send only.
;
;------------------------------------------------------------------------------

;
; Set the responder-specific constants
; 

_SHORT_MESSAGE_MEDIUM		equ	FALSE
_CONTROL_PANELS			equ	TRUE
_NO_UNKNOWN_APPS_ALLOWED	equ	FALSE
if LIMITED_FAX_SUPPORT
  _CAN_SELECT_CONTENTS		equ	FALSE
else
  _CAN_SELECT_CONTENTS		equ	TRUE
endif
_POOF_MESSAGE_CREATION		equ	FALSE
_OUTBOX_SEND_WITHOUT_QUERY	equ	FALSE
_ALWAYS_DELIVER_WHEN_FOREGROUND	equ	FALSE
_CONNECTED_MEDIUM_NOTIFICATION	equ	TRUE
_SIMPLE_MESSAGE_NOTIFY		equ	FALSE
_DUPS_ALWAYS_TOGETHER		equ	TRUE
_CONFIRM_AFTER_FIRST_FAILURE	equ	FALSE
_QUERY_DELETE_AFTER_PERMANENT_ERROR equ	FALSE
_AUTO_RETRY_AFTER_TEMP_FAILURE	equ	FALSE
_TRANSMIT_THREADS_KEYED_BY_MEDIUM equ	FALSE
_RESPONDER_OUTBOX_CONTROL	equ	FALSE
_OUTBOX_FEEDBACK		equ	FALSE
_QUERY_AFTER_CANCEL		equ	TRUE
_QUERY_AFTER_LOST_CONNECTION	equ	TRUE
_HONK_IF_MEDIUM_REMOVED		equ	FALSE
_DELAY_THIRD_CLASS_MESSAGES	equ	FALSE
_HAS_SWAP_SPACE			equ	TRUE
_MAILBOX_FOR_FAX_SEND_ONLY	equ	TRUE

.assert _CONTROL_PANELS or _ALWAYS_DELIVER_WHEN_FOREGROUND,
	 <must have _ALWAYS_DELIVER_WHEN_FOREGROUND true in the absence of control panels, in order to be useful>

if not _CONTROL_PANELS and (not _SIMPLE_MESSAGE_NOTIFY)
	PrintMessage <Either _CONTROL_PANELS or _SIMPLE_MESSAGE_NOTIFY should be true in order to be useful.  Do you really want both to be false?>
endif

;
; Data structure that needs to be at the start of any structure stored in a
; DBQ.
; 
DBQData	struct
    DBQD_refCount	word
    DBQD_cleanup	word
DBQData	ends

MailboxInternalMessageFlags	record
    MIMF_BODY_STOLEN:1
    ; non-zero if MailboxStealBody called on the message
   
    MIMF_DELIVERED:1
    ; non-zero if message has been delivered and acknowledged

    MIMF_NOTIFIED:1
    ; non-zero if user has been notified of the message's arrival
    
    MIMF_NOTIFIED_TRANS_WIN_OPEN:1	; set if the user has been notified
					;  that xfer window is open.

    MIMF_NOTIFIED_TRANS_WIN_CLOSE:1	; set if the user has been notified
					;  that xfer window is close

    MIMF_APPLICATION_NOTIFIED:1		; set if the application has been
					;  notified of the message's existence.
					;  Notification happens only once.
    :2
    MIMF_EXTERNAL MailboxMessageFlags:8
MailboxInternalMessageFlags	end

TalID	record
    TID_ADDR_INDEX:1		; set if TID_NUMBER is actually the index of
				;  an address (used to create a moniker for
				;  just one address of a message)
    TID_NUMBER:15
TalID	end

MailboxMessageDesc	struct
    MMD_dbqData		DBQData
    MMD_subject		lptr.char	; null-terminated subject/summary text
    MMD_bodyStorage	MailboxStorage	; underlying storage format (defines
					; data driver used)
    MMD_bodyFormat	MailboxDataFormat
    MMD_bodyRef		lptr		; mbox-ref for message body
    MMD_destApp		GeodeToken
    MMD_flags		MailboxInternalMessageFlags
    MMD_transport	MailboxTransport
    MMD_transOption	MailboxTransportOption
    MMD_transAddrs	lptr.ChunkArrayHeader	; array of transport
						;  addresses for message. Each
						;  entry is variable sized,
						;  starting with the size of
						;  the opaque address, followed
						;  by the opaque address,
						;  followed by the null-term-
						;  inated rendering of the
						;  address.
    MMD_transData	dword		; opaque data for trans driver
    MMD_transWinOpen	FileDateAndTime	; time after which it's ok to send the
					;  message
    MMD_transWinClose	FileDateAndTime	; time before which the message must be
					;  sent
    MMD_registered	FileDateAndTime	; time the message was registered
if	_AUTO_RETRY_AFTER_TEMP_FAILURE
    MMD_autoRetryTime	FileDateAndTime	; time to auto-retry transmitting the
					;  message after a failure occured.
					;  Should be MAILBOX_NOW if no message
					;  sent has been attempted (e.g.
					;  MMD_transWinOpen not reached), or
					;  MAILBOX_ETERNITY if no auto-retry
					;  is scheduled.
endif	; _AUTO_RETRY_AFTER_TEMP_FAILURE
MailboxMessageDesc	ends

;
; Common structure for storing a medium unit as a single block (as opposed to
; some integers in registers and possibly a separate memory block). Used in
; various data structures and in the call to MediaCheckMediumAvailableByPtr
; 
MailboxMediumDesc	struct
    MMD_medium		MediumType
    MMD_unitSize	word
    MMD_unitType	MediumUnitType
    MMD_unit		label	byte
MailboxMediumDesc	ends


MailboxDisplayPanelType		etype	word
    MDPT_ALL			enum	MailboxDisplayPanelType
    MDPT_BY_APP_TOKEN		enum	MailboxDisplayPanelType
    MDPT_BY_MEDIUM		enum 	MailboxDisplayPanelType
    MDPT_BY_TRANSPORT		enum	MailboxDisplayPanelType

MailboxDisplayByAppData	struct
    MDBAD_token		GeodeToken
MailboxDisplayByAppData	ends

MailboxDisplayByTransportData struct
    MDBTD_transport	MailboxTransport
    MDBTD_transOption	MailboxTransportOption
    MDBTD_medium	MediumType
    MDBTD_addrSize	word
    MDBTD_addr		label byte
MailboxDisplayByTransportData ends

MailboxDisplayByMediumData struct
    MDBMD_transport	MailboxTransport
    MDBMD_transOption	MailboxTransportOption
    MDBMD_medium	MailboxMediumDesc
MailboxDisplayByMediumData ends

MailboxDisplayPanelCriteria	union
    MDPC_byApp		MailboxDisplayByAppData
    MDPC_byMedium	MailboxDisplayByMediumData	; When passed to
							;  MA_DISPLAY_PANEL, the
							;  unit type may not
							;  be MUT_ANY
    MDPC_byTransport	MailboxDisplayByTransportData
MailboxDisplayPanelCriteria	end

MailboxAddressState	etype	byte

MAS_SENT	enum	MailboxAddressState

MAS_EXISTS	enum	MailboxAddressState

MAS_QUEUED	enum	MailboxAddressState	; address is in line for
						;  transmission (either with
						;  the current connection or
						;  with a different connection)

MAS_PREPARING	enum	MailboxAddressState

MAS_READY	enum	MailboxAddressState

MAS_SENDING	enum	MailboxAddressState	; address is the one currently
						;  being transmitted to by
						;  transmission thread.

MailboxTransFlags	record
    MTF_STATE MailboxAddressState:3
    MTF_DUP:1				; set if address is a duplicate of an
					;  earlier address
    MTF_TRIES:4
MailboxTransFlags	end

;
; Make sure that there are not too many MailboxAddressState enums.
;
.assert	MailboxAddressState le (1 shl width MTF_STATE)

MTF_INFINITY		equ	15	; max value of MTF_TRIES

if	_QUERY_DELETE_AFTER_PERMANENT_ERROR
MAX_TEMPORARY_ERRORS	equ	10	; max # of temporary errors
						;  before a temporary error
						;  becomes a permanent error
	.assert MAX_TEMPORARY_ERRORS le MTF_INFINITY
endif	; _QUERY_DELETE_AFTER_PERMANENT_ERROR

MailboxInternalTransAddr	struct
    MITA_addrList	word		; place for token used by control panels
					;  and OutboxTransmitMessage /
					;  OutboxTransmitMessageQueue to know
					;  which addresses of a message are
					;  to be transmitted to.
    MITA_reason		word		; index into outbox failure-reason name
					;  array for the reason the message
					;  did not go through on the last
					;  attempt (valid only if
					;  MITA_flags.MTF_TRIES is non-zero)
    MITA_next		word		; index of next address that is the
					;  same address, in its significant
					;  bytes. MITA_NIL => no other address
MITA_NIL	equ	-1
    MITA_flags		MailboxTransFlags
    MITA_medium		word		; index into outbox medium element
					;  array for medium & unit used by
					;  address.
    MITA_opaqueLen	word
    MITA_opaque		label	byte	; MITA_opaqueLen bytes after this
					;  comes the null-terminated user
					;  description of the address.
MailboxInternalTransAddr	ends

;
; User IDs used in admin file for various data structures (for EC purposes)
;
MailboxVMID	etype	word, 1
MBVMID_DRIVER_MAP	enum	MailboxVMID
MBVMID_MAP_BLOCK	enum	MailboxVMID
MBVMID_MEDIA_STATUS	enum	MailboxVMID
MBVMID_MEDIA_TRANSPORT	enum	MailboxVMID
MBVMID_VM_STORE		enum	MailboxVMID
MBVMID_OUTBOX_MEDIA	enum	MailboxVMID
MBVMID_APP_TOKENS	enum	MailboxVMID
MBVMID_OUTBOX_REASONS	enum	MailboxVMID


MAILBOX_MAX_DATE_SEPARATOR	equ	16


;------------------------------------------------------------------------------
;
;			       WARNINGS
;

MAILBOX_CANNOT_OPEN_OR_DELETE_ADMIN_FILE		enum Warnings
MAILBOX_CANNOT_OPEN_ADMIN_FILE				enum Warnings
ADMIN_FILE_HAS_NO_PROTOCOL				enum Warnings
ADMIN_FILE_HAS_LATER_MAJOR_PROTOCOL			enum Warnings
ADMIN_FILE_HAS_LATER_MINOR_PROTOCOL			enum Warnings
UNABLE_TO_LOAD_TRANSPORT_DRIVER_WHEN_ADDING_MEDIUM	enum Warnings
UNABLE_TO_OPEN_EXISTING_VMSTORE_FILE			enum Warnings
UNABLE_TO_CREATE_VMSTORE_FILE				enum Warnings
UNABLE_TO_DELETE_EXISTING_BAD_VMSTORE_FILE		enum Warnings
UNABLE_TO_DELETE_EMPTY_VMSTORE_FILE			enum Warnings
UNABLE_TO_LOAD_DATA_DRIVER				enum Warnings
OVERWRITING_EXISTING_ADDRESS_MARK			enum Warnings
RETURNING_ALL_FOR_TRANSPORT				enum Warnings
MANUFACTURER_ID_GENERIC_MUST_BE_USED_FOR_ALIAS_TOKEN	enum Warnings
MISSING_CALL_TO_MailboxDoneWithVMFile			enum Warnings
ASKING_FOR_PAGE_RANGE_FOR_MESSAGE_THAT_DOESNT_INVOLVE_ONE enum Warnings
MAILBOX_DEFINED_OBJECT_TYPES_MONIKER_LIST_HAS_CHANGED_SIZE enum Warnings
ADMIN_FILE_CANT_BE_UPDATED				enum Warnings
UNABLE_TO_ALLOCATE_UNIT_DATA_BLOCK			enum Warnings
; MailboxGetFirstMediumUnit is about to return MUT_NONE for a medium that
; actually has a unit available. It is doing this because it was unable to
; allocate a memory block to hold the medium data.

YOU_NEED_TO_ADD_NO_MAILBOX_EQUAL_FALSE_TO_THE_UI_CATEGORY_SO_THE_MAILBOX_LIBRARY_GETS_LOADED_AS_AN_APPLICATION enum Warnings
; The network demos have "no mailbox = true" in their [ui] category of the
; net.ini file, owing to initial instability in the mailbox library. To be
; able to use mailbox-enabled applications, you need to have "no mailbox =
; false" in the [ui] category of your geos.ini (geosec.ini for EC) in your
; local tree.

OPEN_VM_FILE_NOT_OPENED_BY_US				enum Warnings
; Someone called MailboxOpenVMFile passing a filename that was not 
; returned from MailboxGetVMFileName. Either that or the thing is recovering
; from a crash and the VM store got updated while other parts didn't, so we
; think the message body exists when it doesn't.

MESSAGE_TO_REPLY_TO_DOESNT_HAVE_EXACTLY_ONE_ADDR	enum Warnings
; The message to reply to does not contain exactly one address.  The message
; cannot be properly replied.  In this case, if there is no address, a
; reply will not be generated.  If thers is more than one address, only the
; first address will the reply be sent.

FAILED_TO_GET_FORMATS_FROM_PICKY_DRIVER			enum Warnings
; A transport driver was marked MBTC_PICKY but failed to respond to the
; request for its list of acceptable formats. Its pickiness will be ignored.

ASKED_FOR_FORMATS_OF_UNKNOWN_TRANSPORT			enum Warnings
; Someone has decided to check on the formats supported by a transport driver
; that's never been encountered before. Since the things that ask for this
; information base their decision of what to ask for on the list of transports
; that have been encountered, something very odd is going on.

NO_MESSAGE_ADDRESS_MARKED_WITH_GIVEN_ID			enum Warnings
; OutboxTransmitMessage was given a message none of whose addresses was
; marked with the talID it was told to transmit. Since other EC code checked
; this just a moment ago, something must have been messing with addresses
; that were just valid, which is bad, but could happen if the message was
; already being transmitted, for some reason..

ATTEMPTING_TO_RECORD_ADDRESS_FOR_NON_EXISTENT_UNIT	enum Warnings
; This is too weird.

COULD_NOT_LOAD_DRIVER_FROM_XIP_IMAGE			enum Warnings
; A driver that was found in the GFS could not get loaded from the XIP image.
; Most likely, it was put in the GFS, but was not put in the XIP image.

I_DONT_KNOW_WHAT_THE_CURRENT_PAGE_IS			enum Warnings
; The user has selected the current page as the thing to send, but the
; application never sent out GWNT_PAGE_STATE_CHANGE notifications to the
; GAGCNLT_APP_TARGET_NOTIFY_PAGE_STATE_CHANGE list. As a result, we will
; just pretend the current page is page 1.

INBOX_NOTIFICATION_TEXT_TOO_LONG_TO_FIT			enum Warnings
; The template text for notifying the indicator application of a received
; message, when combined with the application name for one of the apps that
; has a message, yields a string too long to fit in the notification block
; sent to the indicator application. As a result, the string has been truncated.

MESN_MEDIUM_NOT_CONNECTED_RECEIVED_WHEN_MEDIUM_NOT_YET_CONNECTED_OR_AVAILABLE	enum Warnings
; Someone has sent MESN_MEDIUM_NOT_CONNECTED notification more than the
; number of MESN_MEDIUM_CONNECTED notifications that had been received.
; It can also mean that some MESN_MEDIUM_CONNECTED/NOT_CONNECTED and
; MESN_MEDIUM_AVAILABLE/NOT_AVAILABLE pairs have gone out of order, possible
; because the user has powered off or on the medium unit at the wrong time.
;
; In any case, the connect count stays at zero.

MESN_MEDIUM_CONNECTED_RECEIVED_WHEN_MEDIUM_NOT_AVAILABLE	enum Warnings
; Someone has sent MESN_MEDIUM_CONNECTED notification when the medium is not
; available.  This can happen if right after a connection is established but
; before MESN_MEDIUM_CONNECTED is sent, the user powers off the medium unit
; and causes an MESN_MEDIUM_NOT_AVAILABLE to be sent to mailbox.
;
; In any case, the connect count stays at zero.

RECORDING_ADDRESS_FOR_NON_CONNECTED_UNIT		enum Warnings
; For some reason, something in the mailbox library is attempting to record
; a connection address for a medium we don't think is actually connected.
; Given the whole discovery process is supposed to be atomic, this is very odd.
;
; The passed address is ignored.

;------------------------------------------------------------------------------
;
;			  FATAL ERROR CODES
;
; Codes are in alphabetical order...
;

ADDRESS_CONTROL_SUBCLASS_NOT_OWNED_BY_ANYONE		enum FatalErrors
; MailboxAddressControl is attempting to find the driver that defined its
; subclass but MemSegmentToHandle returned no owner for the class segment.
; I very much doubt this will ever, ever happen, as control couldn't have
; gotten to the superclass method if the class pointer was bogus (unless the
; thing is very, very lucky).

ADDRESSES_USE_DIFFERENT_MEDIUM				enum FatalErrors
; two addresses are being compared that use different transport media. this
; should have been checked before OUCompareAddresses was called

ADMIN_FILE_NOT_OPEN_YET					enum FatalErrors
; AdminGetFile was called before the administrative file was opened by AdminInit

ADMIN_MAP_BLOCK_NOT_VALID				enum FatalErrors
; The map block for the administrative file either doesn't exist or has
; the incorrect user ID. The admin file has been corrupted somehow.

ALL_ADDRESSES_MUST_BE_FOR_SAME_TRANSPORT_AND_MEDIUM	enum FatalErrors
; OutboxTransmitMessage was called for a message, specifying more than one
; address for transmission. This is fine. What's not fine is that the multiple
; addresses use multiple transport media (as determined by their MITA_medium
; fields). Since transmit threads are spawned based on transport/medium pairs,
; and OutboxTransmitMessage has only been written to cope with one such pair,
; whoever is calling the routine is SOL.
;
; This can be caused by a left-over talID from a previous incarnation of the
; system, perhaps. I hope not, though.

ALL_DUPLICATES_NOT_MARKED_THE_SAME			enum FatalErrors
; A message has duplicate addresses but they are not all marked with the same
; talID. The UI provided to the user should not allow this condition to arise.

ALREADY_HAVE_A_SYSTEM_PANEL				enum FatalErrors
; MACreateNewPanel was called to create a panel with MCP_IS_SYSTEM set, but
; there's already a system panel for recorded in the MailboxPanelBoxData
; structure in the application object.

ASKED_FOR_NAME_OF_VM_FILE_NOT_OPENED_BY_US		enum FatalErrors
; Someone has called MailboxGetVMFileName passing a handle that was not returned
; by MailboxGetVMFile.

CANNOT_CHANGE_SIGNIFICANT_ADDRESS_BYTES			enum FatalErrors
; You've called MailboxSetTransAddr passing an address whose significant bytes
; differ from those already registered for the address. This is not supported.

CANNOT_CHANGE_TO_NON_ANCESTOR_CLASS			enum FatalErrors
; UtilChangeClass was called asking to change an object to some class that
; is not a superclass of the base class of the object.

CANNOT_MANGLE_MONIKER_OF_REALIZED_OBJECT		enum FatalErrors
; UtilMangleMoniker has been called for an object that is already on-screen.
; This function contains no code to force a visual update & geometry
; recalculation after mangling the moniker, so such an operation is not allowed.

CANNOT_REGISTER_ERROR_FOR_UNKNOWN_DRIVER		enum FatalErrors
; You are attempting to register an error message for a driver whose token is
; not in the passed driver map. Likely you destroyed the 32-bit token for
; the driver somewhere.

CANNOT_REMOVE_MASTER_LEVELS_WHEN_CHANGING_CLASS		enum FatalErrors
; You are attempting to change the class of an object using UtilChangeClass
; and the class to which you wish to change it is in a different master group
; than the class to which the object currently belongs. UtilChangeClass doesn't
; have code in it to support this.

CANNOT_V_LOCKED_OUTBOX_THREADS_BLOCK			enum FatalErrors
; Someone is calling OTV when they should be calling OTUnlock.

CHILDREN_NOT_BUILT_YET					enum FatalErrors
; Attempting to call a child of a MailboxOutboxControl object when the UI
; hasn't been generated yet.

COMPARISON_OFFSET_BEYOND_BOUNDS_OF_ITEM			enum FatalErrors
; The caller of DBQMatch has specified an offset of bytes to compare that is
; beyond the end of the current item. Likely the AX passed to DBQMatch was
; garbage.

CONNECT_COUNT_OVERFLOW					enum FatalErrors
; Someone has sent MESN_MEDIUM_CONNECTED notification more than 7 times without
; a corresponding MESN_MEDIUM_NOT_CONNECTED. Likely the NOT_CONNECTED call
; is missing.

CUR_ID_DOESNT_MATCH_SELECTED_ADDRESS			enum FatalErrors
; ODAddrEnum was called with a TalID that isn't the address-index TalID for
; the selected address, whose index was also passed in. Basically, the thing
; was passed bogus data.

CURRENT_THREAD_HAS_NO_THREAD_DATA			enum FatalErrors
; Someone is calling a function that must be called on a transmit thread (e.g.
; from a transport driver function involved in transmitting messages), but
; is doing so not on a transmit thread.

DBQ_REF_COUNT_OVERFLOW					enum FatalErrors
; An element of a DBQ has been referenced > 65535 times. In all likelihood,
; something is referencing the item (e.g. via DBQGetItem) but never calling
; DBQDelRef.

DBQ_REF_COUNT_UNDERFLOW					enum FatalErrors
; Someone has called DBQDelRef on a DBQ item for which it did not have a
; reference. It's also possible, of course, that the caller is correct, but
; someone else is at fault. I leave that to you to figure out.

DIALOG_NOT_FOUND					enum FatalErrors
; There is no child of the MailboxApp that is in the block whose handle was
; passed to MSG_MA_DESTROY_DIALOG in cx.

DMAP_ALLOCATED_ARRAY_NOT_FIRST_CHUNK			enum FatalErrors
; The chunk array that holds Driver Map info is not the first chunk in the
; VM LMem block, which is odd, since nothing else should have been allocated.

DONE_WITH_VM_FILE_NOT_OPENED_BY_US			enum FatalErrors
; Someone has called MailboxDoneWithVMFile passing a handle that we did not
; return from MailboxGetVMFile, or is calling MailboxDoneWithVMFile one too
; many times.

DS_DI_NOT_DATA_FOR_CURRENT_THREAD			enum FatalErrors
; At this point in our life, we are expecting ds:di to be the OutboxThreadData
; for the currently-executing thread, and it's not.

DS_NOT_THREAD_DATA					enum FatalErrors
; DS is supposed to point to the PLocked MainThreads resource. It doesn't

DUP_ADDRESS_SENT_BEFORE_ORIGINAL			enum FatalErrors
; An address marked with MTF_DUP has just been sent to. Given that (1) when
; an address with a duplicate has been sent to, it clears the MTF_DUP flag of
; its duplicate and disassociates itself from the duplicate, and (2) addresses
; are always sent to from the start of the array to the end, and (3) if
; transmission to an address fails, no further attempt is made to send to any
; duplicate address for that message, there should never arise a case where
; an address with MTF_DUP set is sent to. If it is, one of the above 3
; invariants has varied somehow.

DUPLICATE_MESSAGE_LOCK_DURING_SORT			enum FatalErrors
; While sorting the array of messages for a message list, the element-lock
; callback was called while there was already a cached locked element.

DUPLICATE_SET_MESSAGE					enum FatalErrors
; A confirmation box has been told more than once what message it's to
; display. It has no code to cope with changing messages...

ERR_NO_MESSAGE_ADDRESS_MARKED_WITH_GIVEN_ID		enum FatalErrors
; OutboxTransmitMessage was given a message none of whose addresses was
; marked with the talID it was told to transmit. Since other EC code checked
; this just a moment ago, something must have been messing with addresses
; that were just valid, which is bad, but could happen if the message was
; already being transmitted, for some reason..

FILE_HAS_NO_NAME_ATTRIBUTE				enum FatalErrors
; Attempting to see if a driver has already been seen, when performing a
; FileEnum, and the IFS driver has not been able to find the name of the file.
; I don't expect to ever, ever see this error come up unless ES is no longer
; pointing to the FileEnumCallbackData segment.

FILTERED_TRANSPORT_LIST_MISSING_FILTER			enum FatalErrors
; An OutboxTransportList has a type of OTLT_FILTERED, but you've forgotten
; to initialize its OTLI_filter instance variable, leaving it with no idea
; which transports you actually want to keep.

FIRST_MESSAGE_HAS_NO_XMIT_ADDR				enum FatalErrors
; When attempting to connect, after having prepared a batch of messages, the
; first message in the batch no longer has any address marked with the thread's
; xmit talID. Perhaps the message could not be prepared and it was not properly
; removed from the batch?

HOW_CAN_APPLICATION_HAVE_NO_NAME?			enum FatalErrors
; Trying to generate notification to the Indicator application on the
; Responder platform, but the name of the application that has a message isn't
; known. Since _NO_UNKNOWN_APPS_ALLOWED is defined for this platform, it should
; not be possible for the name to be unknown but there be a message.

HOW_CAN_MEDIA_TRANSPORT_BE_INVALID?			enum FatalErrors
; Attempted to find the number of significant address bytes for a message
; address and was told that the transport/medium pair is not valid. Since this
; message still exists, and should be referencing the OutboxMedia entry,
; something must have screwed up the reference count for the entry, or has
; biffed the MITA_medium entry in the address.
;
; Also comes up if you attempt to display a list for an invalid combination.
; Again, this should never happen, because a BY_TRANSPORT panel is only put up
; in response to a transport driver saying it can use a connection over a
; particular medium, so the combination of transport & medium should be valid.

HOW_CAN_TRANSPORT_DRIVER_BE_INVALID?			enum FatalErrors
; The transport driver token was probably got trashed.

INBOX_APP_NAME_ARRAY_NOT_SECOND_CHUNK			enum FatalErrors
; The chunk array that holds application name info is not the second chunk in
; the VM LMem block, which is odd, since only the token array has been allocated
; in the block.

INBOX_APP_TOKEN_MAP_NOT_FIRST_CHUNK			enum FatalErrors
; The chunk array that holds app token info is not the first chunk in the
; VM LMem block, which is odd, since nothing else should have been allocated.

INBOX_FILE_ID_TREE_NOT_THIRD_CHUNK			enum FatalErrors
; The chunk that holds the root of the FileID tree is not the third chunk in
; the VM LMem block, which is odd, since nothing else should have been
; allocated.

INCONSISTENT_UNIT_SIZES_FOR_MEDIUM			enum FatalErrors
; Something has generated notification for a unit of a particular medium using
; a different number of bytes to indicate the unit than was used before. This
; is not allowed.

INCONSISTENT_UNIT_TYPES_FOR_MEDIUM			enum FatalErrors
; Something has generated notification for a unit of a particular medium using
; a different style of expressing the unit than was used before. This is not
; allowed.

INVALID_ADDRESS_NUMBER					enum FatalErrors
; The passed address number is for an address that doesn't exist in the
; message.

INVALID_CONTENTS_INDEX_SET				enum FatalErrors
; MSG_MAILBOX_SEND_CONTROL_SET_CONTENTS was sent with an index in cx that is
; beyond the range of the MSCI_dataTypes array

INVALID_DBQ_HANDLE					enum FatalErrors
; A DBQ routine has received a handle in DI that is not for a DBQ

INVALID_DELIVERY_VERB					enum FatalErrors
; MailboxRegisterMessage was called with an invalid MMF_VERB field

INVALID_DIRECTORY					enum FatalErrors
; IATCreateDirNodeEnumSubdir could not change to a directory.

INVALID_DMAP_HANDLE					enum FatalErrors
; A DMap routine has received a handle in AX that is not for a DMap

INVALID_DUPLICATE_ADDR_LIST				enum FatalErrors
; The MITA_next field of an address has been corrupted so the list of
; duplicates of an address wanders off into nowhere.

INVALID_END_TIME					enum FatalErrors
; The MRA_endBound you passed is not valid. If you want to say "Eternity",
; both FDAT_date and FDAT_time must be MAILBOX_ETERNITY. The simplest and
; most self-documenting way to do this is to say
;
; 	movdw	ss:[bp].MRA_endBound, MAILBOX_ETERNITY

INVALID_MCP_SPECIFIC_FLAG				enum FatalErrors
; MSG_MCP_SET_SPECIFIC was called on a MessageControlPanel with CX not set
; to one of the valid values.

INVALID_MEDIUM_TRANSPORT_ARRAY				enum FatalErrors
; The array of transports that use a particular medium has gotten corrupted,
; as evidenced by it ending with a partial MediaTransportMediaRef at the end

INVALID_MESSAGE_FLAGS					enum FatalErrors
; The flags passed to MailboxRegisterMessage contain set bits that must be
; zero.

INVALID_MESSAGE_NUMBER					enum FatalErrors
; MessageListClass was asked for the MailboxMessage for a message it's not
; actually displaying (i.e. the number is > the number of entries in the list)

INVALID_MESSAGE_PRIORITY				enum FatalErrors
; The message priority passed to MailboxRegisterMessage is beyond the pale

INVALID_MONIKER_FLAG_COMBINATION			enum FatalErrors
; The MMF_ALL_VIEW, MMF_CONNECTING, and MMF_PREPARING flags are mutually
; exclusive. In addition, neither MMF_PREPARING nor MMF_CONNECTING allows
; MMF_INCLUDE_DUPS to be set, the one because no addresses are involved in
; the moniker, and the other because only one address is involved.

INVALID_MONIKER_LIST					enum FatalErrors
; The moniker list returned by DR_MBTD_GET_MEDIUM_PARAMS ends with a
; partial VisMonikerListEntry, and is thus invalid.

INVALID_MSC_CONTEXT					enum FatalErrors
; You've notified the MailboxSendControl of a new default message body type,
; but the MailboxObjectType you passed (either in BP for MSG_META_NOTIFY or
; in ^hbp.MSCN_objectType for MSG_META_NOTIFY_WITH_DATA_BLOCK) is not one
; that's in the MSCI_bodyTypes array for the controller. The type you passed
; is in CX at the moment.

INVALID_MTMR_OFFSET					enum FatalErrors
; The offset passed to MTGetMediaTransportWord in BP is larger than the
; size of a MediaTransportMediaRef structure, and thus the request for the
; data cannot be satisfied.

INVALID_OUTBOX_MEDIUM_TOKEN				enum FatalErrors
; OMUnregister was called with a media token that is not actually a valid
; entry in the outbox media array. Perhaps OMUnregister was called more than
; once for the message.

INVALID_REENTRANT_FLAG_RETURNED_BY_MAC			enum FatalErrors
; The MailboxAddressControl provided by the transport (print 
; (*ds:bp).MSCT_transport to find the driver in question) returned an invalid
; value (neither TRUE nor FALSE) in AX when indicating it would handle creating
; the message. Contact the author of the transport driver to find out why.

INVALID_START_TIME					enum FatalErrors
; The MRA_startBound you passed is not valid. If you want to say "Now", both
; FDAT_date and FDAT_time must be MAILBOX_NOW. The simplest and
; most self-documenting way to do this is to say
;
; 	movdw	ss:[bp].MRA_startBound, MAILBOX_NOW

INVALID_TRANSACTION_HANDLE				enum FatalErrors
; You called a method of the MailboxSendControl passing a transaction handle
; that is invalid. The transaction handle is what you received in the
; MSG_META_MAILBOX_CREATE_MESSAGE message and must be passed to the various
; methods used to create and register the message.

INVALID_TRANSPORT_INDEX					enum FatalErrors
; MSG_OTMS_REBUILD was called with a transport index that's beyond the
; bounds of the list of transports from the previous rebuild. No idea how
; this could come about...

INVALID_TRANSPORT_SELECTED				enum FatalErrors
; Someone has passed a transport index to the MailboxSendControl that is beyond
; the range of possible items in the controller's OutboxTransportMenu

ITEM_TOO_SMALL_FOR_COMPLETE_COMPARISON			enum FatalErrors
; The current item does not contain all the bytes needed to determine if
; the item should be included in the result queue returned by DBQMatch. Either
; the starting offset or the number of bytes to compare were passed
; incorrectly to DBQMatch.

MEDIA_STATUS_MAP_INVALID				enum FatalErrors
; The VM block that holds the status of media units in the machine either
; doesn't exist or has the wrong user ID. The admin file has been corrupted.

MEDIA_STATUS_MAP_NOT_FIRST_CHUNK			enum FatalErrors
; The chunk array that holds the media unit status info is not the first chunk
; in the VM LMem block, which is odd, since nothing else should have been
; allocated.

MEDIA_STATUS_RECORD_ONLY_FOR_AVAILABLE_AND_CONNECTED_BITS enum FatalErrors
; MSRecord was called to set some MediaStatusFlags bit other than
; MSF_AVAILABLE or MSF_CONNECTED. You'll have to write your own routine to set
; the bit(s) or modify MSRecord to deal with it.

MEDIA_TRANSPORT_MAP_INVALID				enum FatalErrors
; The VM block that holds the media -> transport map either doesn't exist or
; has the wrong user ID. The admin file has been corrupted.

MEDIA_TRANSPORT_MAP_NOT_SECOND_CHUNK			enum FatalErrors
; The chunk array that holds the transport driver tokens is not the second chunk
; in the VM LMem block, which is odd, since only the media -> transport array
; should have been allocated.

MEDIA_TRANSPORT_MEDIA_MAP_NOT_FIRST_CHUNK		enum FatalErrors
; The chunk array that holds the media -> transport info is not the first chunk
; in the VM LMem block, which is odd, since nothing else should have been
; allocated.

MEDIUM_AND_TRANSPORT_NOT_IN_OMTP_ARRAY			enum FatalErrors
; OMUnregister was called for a transport/medium combination that is not
; recorded in

MESSAGE_BODY_ERR_TOO_LONG				enum FatalErrors
; The bodyErrMsg parameter to MailboxRegisterMessage refers to a string that is
; longer than MAILBOX_MAX_BODY_ERR bytes long.

MESSAGE_BODY_FILENAME_CHUNK_DOESNT_CONTAIN_NUMBER_PLACEHOLDER enum FatalErrors
; The uiMessagesNameTemplate chunk has had the \1 character removed from it
; and so VMSCreateFilename cannot figure where to put the counter value to
; generate the file name.

MESSAGE_BODY_FILENAME_CHUNK_HAS_DUPLICATE_PLACEHOLDER	enum FatalErrors
; The uiMessagesNameTemplate chunk has more than one \1 character in it. This
; character marks the place for the element number to go when creating the
; file name.

MESSAGE_BODY_FILENAME_CHUNK_NOT_NULL_TERMINATED		enum FatalErrors
; The uiMessagesNameTemplate chunk is not null-terminated

MESSAGE_BODY_FILENAME_CHUNK_TOO_LARGE			enum FatalErrors
; The uiMessagesNameTemplate chunk is larger than a FileLongName, which means
; the generated filename cannot possibly fit within the required buffer.

MESSAGE_FILENAME_TOO_LONG				enum FatalErrors
; The generated filename fits in a FileLongName buffer, but is still too
; long for an actual filename. The uiMessagesNameTemplate has too many
; characters in it.

MESSAGE_LIST_SUBCLASS_MUST_INTERCEPT_THIS		enum FatalErrors
; A method in MessageListClass was called when it has been explicitly defined
; as something the subclass must intercept and handle on its own.

MESSAGE_NOT_READY_FOR_SENDING				enum FatalErrors
; About to call the transport driver to send a message and need to update
; the state from READY to SENDING, but the message isn't actually in the
; READY state. It could have been canceled in another thread, or something.

MESSAGE_SUBJECT_TOO_LONG				enum FatalErrors
; The null-terminated subject string is longer than MAILBOX_MAX_SUBJECT bytes.

METHOD_MUST_BE_SUBCLASSED				enum FatalErrors
; A message that must be intercepted by a subclass has made it to the class
; that defines the message.

MUT_ANY_NOT_ALLOWED_WHEN_NOTIFYING_ABOUT_MEDIA_STATUS	enum FatalErrors
; Someone has generated a medium-unit notification with a unit type of MUT_ANY.
; You should use MUT_NONE if the medium does not have units.

MONIKER_FIELD_TOO_WIDE					enum FatalErrors
; The system font is sooooo wide that a field of a message moniker
; is > 64K pixels wide. Something tells me this will never happen

MONIKER_MISSING_STRING_PLACEHOLDER			enum FatalErrors
; The moniker for an object passed to UtilMangleMoniker is missing the \1 char-
; acter that marks where the auxilliary string is supposed to be inserted.
; *ds:si is the object in question

MONIKER_MUST_BE_TEXT					enum FatalErrors
; The moniker for an object passed to UtilMangleMoniker is not a text moniker,
; which means it is unable to manufacture the proper moniker. *ds:si is the
; object in question.

MONIKERS_RETURNED_BY_TRANSPORT_DRIVER_NOT_A_LIST	enum FatalErrors
; The moniker list returned by the transport driver's DR_MBTD_GET_MEDIUM_PARAMS
; function is not actually a moniker list.

MONIKER_TOO_LONG					enum FatalErrors
; A moniker being abused by UtilMangleMoniker is about to be longer than 255
; characters, which is giving the code that's attempting to adjust the
; mnemonic offset fits.

MSC_ILLEGAL_TRANSPORT_COUNT				enum FatalErrors
; MailboxSendControl: An invalid transport number has been passed (it
; is greater than the number of transports currently available).

MSC_ILLEGAL_MEDIA_COUNT					enum FatalErrors
; MailboxSendControl: An invalid media number has been passed (it is
; greater than the number of media types available for the current
; transport).

MSC_ILLEGAL_TRANSPORT_OR_MEDIA_NAME_SEGMENT		enum FatalErrors
; MailboxSendControl: The segment in question does not point to an
; lmem block containing the names of transport or media names.

MULTIPLE_ACK_ODS_FOR_THREAD				enum FatalErrors
; An OutboxProgress box has received more than one OP_DETACH call. This is
; a bozo no-no.

MUST_HAVE_AT_LEAST_ONE_MARKED_ADDRESS			enum FatalErrors
; OutboxTransmitMessage was called for a message that has none of its addresses
; marked with the given talID

NAME_ATTRIBUTE_NOT_GIVEN_TO_ENUM_CALLBACK		enum FatalErrors
; FileEnum has failed to place FEA_NAME in the array of attributes the
; IFS driver must return to the callback. I do not expect this to ever happen.

NEW_ADDRESS_IS_ALREADY_MARKED				enum FatalErrors
; Somehow, an address for a medium that we thought we just encountered is
; already marked. Perhaps addresses aren't being initialized properly?

NO_DATA_TYPES_SET_FOR_SEND_CONTROL			enum FatalErrors
; You've defined a MailboxSendControl object without specifying any of the
; ATTR_MAILBOX_SEND_CONTROL_SEND_* attributes or providing a non-empty
; dataTypes array from which the user can select what's to go in the
; message. You must do one of these things in order for the MailboxSendControl
; to perform its job.

NOT_A_DBQ						enum FatalErrors
; A DBQ routine was given a handle that is for a HugeArray, but is not
; actually a DBQ

NO_MESSAGES_LEFT_TO_SEND				enum FatalErrors
; OTrConnect has been called with an empty queue. OTrPrepareBatch should have
; detected this and control should not have reached OTrConnect

NO_MESSAGE_LOCKED					enum FatalErrors
; While sorting the array of messages for a message list, the element-unlock
; callback was called when there was no element locked.

OUTBOX_CRITERIA_REFERS_TO_UNAVAILABLE_TRANSPORT		enum FatalErrors
; The OutboxTransportList indicated that it was unable to set the passed
; medium/transport/transOption tuple as the current selection, which means
; the criteria stored for the panel are bogus, or the array of possible
; MailboxMediaTransport structures has been trashed.

OUTBOX_INVALID_REASON_TOKEN				enum FatalErrors
; OutboxGetReason was called with a token for a reason that's not on record.

OUTBOX_MEDIA_MAP_INVALID				enum FatalErrors
; The VM block that holds the media units for all the existing addresses either
; doesn't exist or has the wrong user ID. The admin file has been corrupted.

OUTBOX_MEDIUM_TRANSPORT_MAP_NOT_FIRST_CHUNK		enum FatalErrors
; The element array that holds the MailboxTransport/MediumType pairs, by
; means of which the Outbox Control Panel knows what transports to display, is
; not the first chunk in the outbox media block, which is odd since nothing
; else should have been allocated.

OUTBOX_MEDIUM_UNIT_ARRAY_NOT_SECOND_CHUNK		enum FatalErrors
; The element array that holds the MailboxMediumDesc things, by
; means of which the outbox code knows which medium an address uses, is
; not the second chunk in the outbox media block, which is odd since only the
; transport/medium array should have been allocated.

OUTBOX_REASON_MAP_INVALID				enum FatalErrors
; The VM block that holds the strings of reasons for transmission failure either
; doesn't exist or has the wrong user ID. The admin file has been corrupted.

OUTBOX_REASON_MAP_NOT_FIRST_CHUNK			enum FatalErrors
; The name array that holds the reason strings is not the first chunk in the
; VM LMem block, which is odd since nothing else should have been allocated.

POINTER_TO_CONTROLLER_BLOCK_DOESNT_POINT_TO_ANY_CHUNK	enum FatalErrors
; In your call to MSG_MAILBOX_SEND_CONTROL_REGISTER_MESSAGE, you've passed
; a pointer to the body reference or summary text that is in the same block
; as the MailboxSendControl, but it doesn't point into any allocated chunk in
; that lmem block. Either you've put it in the header, which we can't handle,
; or you've passed a bogus pointer.

PROGRESS_BOX_NOT_RUN_BY_MAILBOX_THREAD			enum FatalErrors
; An OutboxProgress object has been duplicated but its burden thread is not
; the mailbox application thread, as it must be for the progress box to be
; attached below the mailbox application object.

PROGRESS_BOXES_NOT_SUPPORTED_BY_THIS_PRODUCT_VERSION_OF_MAILBOX_LIB enum FatalErrors
; This version of Mailbox lib is compiled with
; MAILBOX_PERSISTENT_PROGRESS_BOXES = FALSE.  An external geode is not
; supposed to use this feature when talking to this Mailbox lib.  This
; happens probably because a transport driver from a wrong product version
; is used with this Mailbox lib.
;

PROGRESS_SETUP_FOR_INVALID_TRANSPORT_MEDIUM_COMBO	enum FatalErrors
; MSG_OP_SETUP was invoked on a progress box, passing an OPSetupArgs with
; a MailboxTransport and MediumType whose combination is not recognized
; by the Media module. Most likely, the OPSetupArgs have gotten trashed
; along the way.

REQUEST_FOR_INVALID_CONTENTS_MONIKER			enum FatalErrors
; The MSCContentList for a send dialog has asked for a moniker (BP) that
; is beyond the bounds of the dataTypes array

REQUEST_FOR_INVALID_ITEM_MONIKER			enum FatalErrors
; One of the dynamic lists was asked for a moniker it cannot provide. All
; requests and stuff for these lists are synchronous (i.e. the list subclass
; takes care of the moniker provision), so unless weird queue delays are
; going on in the spui, there should be no reason for being asked for a
; moniker the subclass is unable to provide.

SEARCH_FLAGS_CORRUPTED					enum FatalErrors
; The VisMonikerSearchFlags used by MediaGetAllMonikers have been corrupted
; during the callback to copy the monikers out.

SECONDARY_CRITERIA_NOT_BY_MEDIUM			enum FatalErrors
; At the start of a rescan for an OutboxMessageList, neither the primary
; nor the secondary search criteria is MDPT_BY_MEDIUM. This causes problems,
; as we need that to decide whether a SEND_WITHOUT_QUERY message can be sent
; during the scan. Perhaps the SET_CRITERIA call was wrong?

SECONDARY_CRITERIA_SHOULD_NOT_EXIST			enum FatalErrors
; The primary criteria for a MessageList is non-existent, so the secondary
; should also be non-existent, implying that all messages from the source
; queue should be displayed.

SENDABLE_MESSAGE_REMAINS_ON_QUEUE			enum FatalErrors
; We reached the end of the life of a transmit thread but there's still a
; message on the queue that is marked for transmission. All the messages
; should have been canceled with exclusive access to the queue, so likely
; something forgot to cancel all the messages when it was supposed to.

STRING_TEMPLATE_MISSING_PLACEHOLDER			enum FatalErrors
; Someone has modified the text in a string template that's been given to
; UtilReplaceFirstMarkerInStringChunk so the \1 needed to store the string in
; the text is no longer present.

TEXT_MONIKER_MISSING_FOR_DATA_TYPE			enum FatalErrors
; You've placed an entry in the MSCI_dataTypes array whose moniker list
; does not include a text moniker. Without a text moniker, the send dialog
; is unable to set its own moniker properly, as it combines the string for
; the transport driver with the string for the message body.

TEXT_TEMPLATE_MISSING_PLACEHOLDER			enum FatalErrors
; Someone has modified the text in a template text object that's been given to
; UtilReplaceMarkerInTextChunk so the \1 needed to store the string in the
; text is no longer present.

THERE_IS_NO_POINT_CALLING_THIS_FOR_MEDIA_WITH_NO_UNITS	enum FatalErrors
; You've called MailboxGetFirstMediumUnit for a medium (cxdx = MailboxMedium)
; that does not use unit numbers. You should just call MailboxCheckMedium-
; Available instead, as MailboxGetFirstMediumUnit has no way to tell you there
; is such a medium available, with no unit, versus there is no such medium
; available.

TITLE_MONIKER_MISSING_SECOND_PLACEHOLDER		enum FatalErrors
; The template for the title of a send dialog is missing the \2 needed to
; place the contents string.

TITLE_STRING_MUST_BE_PROVIDED_BY_SUBCLASS		enum FatalErrors
; MessageControlPanel has called MSG_MCP_GET_TITLE_STRING on itself and the
; subclass has not properly fielded the message. See the definition of this
; message for details.

TRANSMISSION_THREAD_MISSING				enum FatalErrors
; You've attempted to cancel a message that is marked as being transmitted
; but it isn't actually being transmitted. Either the address state has
; gotten out of whack due to a bug (which is unlikely, naturally :), or you
; detached before the updated address got written out to the admin file after
; its last state change.

TRANSMIT_THREAD_DATA_HAS_VANISHED			enum FatalErrors
; The transmit thread attempted to locate its OutboxThreadData but it is
; not around. Either the array has been corrupted, so the OTD_thread field
; is wrong making it impossible to find the data, or something has actually
; deleted the data for the thread.

TRANSMIT_THREAD_STARTED_WITH_NOTHING_TO_DO		enum FatalErrors
; Something has changed the addresses marked as queued for transmission for
; all the messages queued for the thread, so the thread finds itself with
; absolutely nothing to do. Something has not been following the protocol
; for finding addresses that have been queued for transmission...

UNABLE_TO_CREATE_MAILBOX_DIRECTORY			enum FatalErrors
; Look at the error code in AX to figure out why we were both unable to
; change to or create SP_SPOOL:\MAILBOX

UNABLE_TO_SET_ADMIN_FILE_PROTOCOL			enum FatalErrors
; Attempted to set the protocol number for the admin file, but the filesystem
; refused. Reason is in AX

UNKNOWN_CONTROL_PANEL_SUBCLASS				enum FatalErrors
; Criteria changed on a MessageControlPanel object that is neither of class
; OutboxControlPanelClass nor InboxControlPanelClass, so the code has no clue
; what to tell the application object.

UNKNOWN_MEDIUM_UNIT_TYPE				enum FatalErrors
; Media notification/search was received with an unknown MediumUnitType
; in AL

UNKNOWN_SOURCE_FOR_TRANSPORT_SELECTED			enum FatalErrors
; Someone has called a MailboxSendControl saying a transport has been selected
; but the control has no transport menu created, so it's unable to map the
; transport index to a MailboxMediaTransport

VALID_STATE_FLAG_NEITHER_TRUE_NOR_FALSE			enum FatalErrors
; A subclass of MailboxAddressControl called MSG_MAILBOX_ADDRESS_CONTROL_SET_-
; VALID_STATE with an invalid value in CX. The only permitted values are
; TRUE or FALSE

VM_STORE_ELEMENT_INVALID				enum FatalErrors

VM_STORE_HANDLE_INVALID					enum FatalErrors
; The VM block that holds the list of VM files used for storing message bodies
; either doesn't exist or has the wrong user ID. The admin file has been
; corrupted.

VM_STORE_MAP_NOT_FIRST_CHUNK				enum FatalErrors
; The name array that holds the VM file names and data is not the first chunk
; in the VM LMem block, which is odd since nothing else should have been
; allocated.

WAS_NOT_SUPPOSED_TO_FIND_THE_DRIVER			enum FatalErrors
; We were scanning the driver map only to force a scan of the driver
; directory, but somehow we found this bogus driver.

WHERE_OH_WHERE_COULD_MY_LITTLE_CHILD_BE?		enum FatalErrors
; MSG_OTM_TRANSPORT_SELECTED sent to OutboxTransportMenu for a trigger that
; doesn't appear to be a child of the menu. How could this happen?

WHY_IS_ADDR_LIST_NON_ZERO_WHEN_ADDRESS_HAS_BEEN_SENT	enum FatalErrors
; An address marked as sent has not had its MITA_addrList field set to 0. Since
; not everything checks for MAS_SENT before using an address marked with
; a particular talID, this can cause problems.

YOUR_ADDRESS_CONTROL_SUBCLASS_MUST_INTERCEPT_THIS	enum FatalErrors
; You've subclassed MailboxAddressControl but not provided your own method
; for MSG_MAILBOX_ADDRESS_CONTROL_GET_ADDRESSES. There is no default for this
; method. You must implement it on your own without help from your superclass.

; NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
;
; The error codes above are in alphabetical order so it's easy to find
; a code and its explanation (yeah, editors can search, but i'm also
; anal-retentive from time to time). Please add new codes in the proper place.
; 
; NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
