/**********************************************************************
 *
 *	Copyright (c) Designs in Light 2002 -- All Rights Reserved
 *
 * PROJECT:        Mail	
 * MODULE:	   Mail
 * FILE:	   mime.goc
 * 
 * DESCRIPTION:
 *      Common code for MIME encoding
 * 
 ****************************************************************************/

@include <stdapp.goh>
@include <bbxmlib.goh>
@include <socket.goh>
#include <chunkarr.h>
#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/stdio.h>
#include <geoMisc.h>
#include <localize.h>
#include <product.h>

@include "mailfatals.goh"
@include "mime.goh"
#include "buffer.h"

#define HTBASE64_BUFFER_SIZE         6*76
#define HTBASE64_DECODED_BUFFER_SIZE 6*57+3 /* +2 for decoding process */

/* List of mime content type tokens.  This list is scanned from 0 to 
 * X.  So you can define a more specific type before a more general type.
 * For example define the specific type subtype combo "text/html", before
 * the general type "text"
 *
 * This list must match the ContentType enumeration in mailhub.goh
 */
char contentTypeArray[NUM_CONTENT_TYPES][MAX_CONTENT_TYPE_LEN] = {
    "application\0",
    "multipart/mixed\0",
    "multipart/alternative\0",
    "multipart/related\0",
    "multipart/report\0",
    "text/plain\0",
    "text/html\0",
    "text/enriched\0",
    "text\0",
    "image/gif\0",
    "image/jpeg\0",
    "message\0"
};
char ContentTypeField[] = "CONTENT-TYPE";

/* List of mime transfer encoding tokens
 */
char transferEncodingArray[NUM_TRANSFER_ENCODING_TYPES][MAX_TRANSFER_ENCODING_LEN] = {
    "7bit\0",
    "8bit\0",
    "binary\0",
    "quoted-printable\0",
    "base64\0",
    "x-uuencode\0"
};
char ContentTransferField[] = "CONTENT-TRANSFER-ENCODING";

char charsetTypeArray[NUM_CHARSET_TYPES][MAX_CHARSET_TYPE_LEN] = {
    "ISO-8859-1",
    "US-ASCII"
};


/***********************************************************************
 *		GetContentTypeCode
 ***********************************************************************
 *
 * SYNOPSIS:	
 * CALLED BY:	
 * RETURN:	
 ***********************************************************************/
ContentType _pascal
GetContentTypeCode (char *contentType)
{
    int i, len;

    for (i = 0; i < NUM_CONTENT_TYPES; ++i) {
	len = strlen(contentTypeArray[i]);
	if (!(strncmp(contentTypeArray[i],contentType,len))) {
	    break;
	}
    }

    return i;
}	/* End of GetContentTypeCode.	*/


/***********************************************************************
 *		GetCharset
 ***********************************************************************
 *
 * SYNOPSIS:	
 * CALLED BY:	
 * RETURN:	
 ***********************************************************************/
CharsetType
GetCharset (optr parameters)
{
    int count, i, len, j;
    char *charset, *temp;

    /* first get the value of the charset parameter
     * out of the content type parameter array
     */
    MemLock(OptrToHandle(parameters));
    count = ChunkArrayGetCount(parameters);
    for (i=0,charset=NULL;i<count;i+=2) {
	temp = ChunkArrayElementToPtr(parameters,i,0);
	if (!strncmp("charset",temp,strlen("charset"))) {
	    /* this is the boundary element, so s`et data
	     * to the value 
	     */
	    charset = ChunkArrayElementToPtr(parameters,i+1,0);
	    break;
	}
    }

    /* Find the the matching charset type, if we found a charset 
     * argument in the charset parameter array.
     */
    if (i<count) {
	RemoveQuotes(charset);
	len = strlen(charset);
	for(j=0;j<len;++j) {
	    charset[j] = TOUPPER(charset[j]);
	}
	for (i = 0; i < NUM_CHARSET_TYPES; ++i) {
	    if (!(strncmp(charsetTypeArray[i],charset,len))) {
		break;
	    }
	}
	MemUnlock(OptrToHandle(parameters));
	return i;
    } else {
	MemUnlock(OptrToHandle(parameters));
	return CHARSET_TYPE_OTHER;
    }


}	/* End of GetCharset.	*/


/***********************************************************************
 *		GetContentType
 ***********************************************************************
 *
 * SYNOPSIS:	Scan through the field and get the ContentType, 
 *              and any associated parameters.
 * CALLED BY:	
 * RETURN:	
 ***********************************************************************/
void _pascal
GetContentType (char *field, ContentTypeRecord *ct)
{
    char contentString[MAX_CONTENT_TYPE_LEN+1], *param, *temp;
    MemHandle paramHandle, tempHandle;
    ChunkHandle paramArray;
    int i, paramCount;

    if (field[0] == NULL) {
	/* there was no content type field, so just return plain
	 * text
	 */
	ct->CTR_type = CONTENT_TYPE_TEXT_PLAIN;
	ct->CTR_typeString = NULL;
	ct->CTR_parameters = NULL;
	return;
    }
    /* skip any white space  */
    for (;ISWHITE(*field) && !(*field == NULL); ++field);

    /* get all the characters before the '/'. the type */
    for (i=0;ISALNUM(*field);++field,++i) {
	contentString[i]=TOLOWER(*field);
    }
    contentString[i] = '/'; ++i;
    for(;!ISALNUM(*field);++field); /*skip until the subtype */

    /* get subtype */
    for (;(i < MAX_CONTENT_TYPE_LEN) && !(ISWHITE(*field)) && !(ISTSPECIAL(*field)) && (*field != NULL); ++field,++i) {
	contentString[i]=TOLOWER(*field);
    }
    contentString[i] = NULL; /* Null terminate the string */
    ct->CTR_type = GetContentTypeCode(contentString);
    /*
     * if the content type was longer than anything we've got, skip the rest
     * of it
     */
    if (i == MAX_CONTENT_TYPE_LEN) {
	EC_WARNING(MAILPOP3_MIME_TYPE_TOO_LONG);
	while (!(ISWHITE(*field)) && !(ISTSPECIAL(*field)) && (*field != NULL)) {
	    field++;
	}
    }

    /* Add code here to return the string if the content type 
     * is unknown, when there is something useful to do with 
     * that string.
     */

    tempHandle = MemAlloc(MAX_LINE_LEN, HF_SWAPABLE | HF_SHARABLE, 
			     HAF_LOCK | HAF_NO_ERR );
    temp = MemDeref(tempHandle);
    paramHandle = MemAllocLMem(LMEM_TYPE_GENERAL,0);
    MemLock(paramHandle);
    paramArray = ChunkArrayCreate(paramHandle, 0, 0, 0);

    /* get the parameters - attrib, value pairs - and put them
     * in a chunk array.
     */
    for (paramCount=0;*field != NULL;) {
	/* skip to the next param and then any white space following the ';'
	 */
	/* for (i=0;(*field != ';'); ++field); 
	 * This is what it should be, but I have found at least one case 
	 * where the ';' is missing between params -Ian
	 */
	/*
	 * the ';' must still be skipped when it occurs.  -gene
	 */
	for(;ISWHITE(*field) || *field == ';'; ++field);
	if (*field == NULL) { 
	    break; /* no parameters */
	}
	if (*field == ';') {
	    ++field;
	}
	for(;ISWHITE(*field); ++field);
        /* get the param
	 */
	if (*field != NULL) {
	    ++paramCount;
	    
	    /* get the attribute
	     */
	    for (i=0;!ISWHITE(*field) && (*field != NULL) && (*field != '=');
		 ++field,++i) {
		temp[i]=*field;
	    }
	    temp[i] = NULL;
	    EC_ERROR_IF((i > MAX_LINE_LEN),-1);
	    param = ChunkArrayAppendHandles(paramHandle,paramArray,i+sizeof(NULL));
	    strncpy(param,temp,i+1);
	    
	    /* skip the '=' and any white space that follows
	     */
	    for(;*field != '='; ++field);
	    ++field;
	    for(;ISWHITE(*field); ++field);
	    
	    /* get the value
	     */
	    for (i=0;!ISWHITE(*field) && (*field != NULL) && (*field != ';');
		++field,++i) {
		if (*field == '"') {
		    temp[i] = *field; 
		    ++field; 
		    ++i;
		    
		    while((*field != '"') && (*field != NULL) && 
			  (*field != ';')) {
			temp[i] =*field;
			++field;
			++i;
		    }
		    if (*field == '"') {
			temp[i] = *field;
			++field;
			++i;
		    }

		    break;
		    
		} else {
		    temp[i]=*field;
		}
	    }		    
	    temp[i] = NULL;
	    EC_ERROR_IF((i > MAX_LINE_LEN),-1);
	    param = ChunkArrayAppendHandles(paramHandle,paramArray,
					    i+sizeof(NULL));
	    strncpy(param,temp,i+1);
	}
	
    }
    
    MemUnlock(tempHandle);
    MemFree(tempHandle);
    MemUnlock(paramHandle);
    if (paramCount) {
	ct->CTR_parameters =  ConstructOptr(paramHandle, paramArray);
	ct->CTR_charset = GetCharset(ct->CTR_parameters);
    } else {
	MemFree(paramHandle);
	ct->CTR_parameters = NULL;
	ct->CTR_charset = CHARSET_TYPE_OTHER;
    }

}	/* End of GetContentType.	*/



/***********************************************************************
 *		GetTransferEncodingCode
 ***********************************************************************
 *
 * SYNOPSIS:	return the code that matches the encoding text
 * CALLED BY:	GetTransferEncoding
 * RETURN:	
 ***********************************************************************/
TransferEncoding _pascal
GetTransferEncodingCode (char *encodingString)
{
    int i;

    for (i = 0; i < NUM_TRANSFER_ENCODING_TYPES; ++i) {
	if (!(LocalCmpStringsNoCase(transferEncodingArray[i],
				    encodingString, 0))) {
	    break;
	}
    }
    return i;

}	/* End of GetTransferEncodingCode.	*/





/***********************************************************************
 *		GetTransferEncoding
 ***********************************************************************
 *
 * SYNOPSIS:	scan the field for the encoding string, and then
 *              set te to be the code for the transfer encoding type.
 * CALLED BY:	
 * RETURN:	
 ***********************************************************************/
void _pascal
GetTransferEncoding (char *field, TransferEncoding *te)
{
    char encodingString[MAX_CONTENT_TYPE_LEN];
    int i;

    if (field) {
	/* skip any white space  */
	for (;ISWHITE(*field) && !(*field == NULL); ++field);
    
	for(i=0;!ISWHITE(*field) && (*field != NULL) && 
		i < MAX_CONTENT_TYPE_LEN;++i,++field) {
	    encodingString[i] = *field;
	}
	encodingString[i] = NULL;
#if EC
	if (i > MAX_CONTENT_TYPE_LEN) {
	    EC_ERROR(-1);
	}
#endif
	*te = GetTransferEncodingCode(encodingString);
    } else {
	*te = TE_8BIT;
    }
    
}	/* End of GetTransferEncoding.	*/



/***********************************************************************
 *		RemoveQuotes
 ***********************************************************************
 *
 * SYNOPSIS:	Remove quotes from a string
 * CALLED BY:	
 * RETURN:	
 ***********************************************************************/
void _pascal
RemoveQuotes (char *data)
{
    char *temp;

    temp = data;

    while (*data != NULL) {
	if (*data == '"') {
	    ++data;
	} else {
	    *temp = *data;
	    ++temp;
	    ++data;
	}
    }
    *temp = NULL; 

}	/* End of RemoveQuotes.	*/


/***********************************************************************
 *		RemoveWhiteSpace
 ***********************************************************************
 *
 * SYNOPSIS:	
 * CALLED BY:	
 * RETURN:	
 * SIDE EFFECTS:
 ***********************************************************************/
void _pascal
RemoveWhiteSpace (char *data, int *count)
{
    char *temp;
    int len;

    len = *count;
    temp = data;

    while (len) {
	--len;
	if (ISWHITE(*data)) {
	    ++data;
	} else {
	    *temp = *data;
	    ++temp;
	    ++data;
	}
    }
    *count -= len;

}	/* End of RemoveWhiteSpace.	*/




/***********************************************************************
 *		ScanForBoundary
 ***********************************************************************
 *
 * SYNOPSIS:	We want to scan until we run into the boundary
 *              We should leave block pointing to the CRLF after the 
 *              boundary
 * CALLED BY:	
 * RETURN:	
 ***********************************************************************/
MailError _pascal
ScanForBoundary (BufferBlock *block, char *boundary,  Boolean *lastBoundary)
{
    MemHandle lineHandle;
    char *line;
    int i, len;
    MailError ret = ME_NONE;

    *lastBoundary = FALSE;
    BufferLockBlock(block);
    lineHandle = MemAlloc(100, HF_SWAPABLE | HF_SHARABLE, 
			  HAF_LOCK | HAF_NO_ERR);
    line = MemDeref(lineHandle);
    while (1) {
	/* look for the -- at the beginning of a new line
	 */
	if (ret = BufferGetNextByte(block,&line[0])) break;
	if (ret = BufferGetNextByte(block,&line[1])) break;
	line[2] = NULL;
	if (!strcmp(line,"--")) {
	    /* get the line that might be the boundary
	     */
	    if( ret = BufferGetNextByte(block,&line[0])) break;
	    if( ret = BufferGetNextByte(block,&line[1])) break;
	    for(i=2; (i < 100) && 
		    !((line[i-2] == CR) && (line[i-1] == LF)); ++i) {
		if (ret = BufferGetNextByte(block,&line[i])) 
		    break;
	    }
	    len = strlen(boundary);
	    if(!strncmp(boundary,line,len)) {
		/* we have the boundary
		 */
		i = strlen(boundary);
		if (!strncmp("--",&line[len],2)) {
		    *lastBoundary = TRUE;
		}
		break;
	    }
	} else {
	    /* skip until the next new line */
	    while(!((line[0] == CR) && (line[1] == LF))) {
		line[0] = line[1];
		BufferGetNextByte(block,&line[1]);
	    }
	}
    }
    MemUnlock(lineHandle);
    MemFree(lineHandle);
    BufferUnlockBlock(block);
    return ret;
}	/* End of ScanForBoundary.	*/


/***********************************************************************
 *		GetBoundaryHeader
 ***********************************************************************
 *
 * SYNOPSIS:	
 * CALLED BY:	
 * RETURN:	
 * SIDE EFFECTS:
 ***********************************************************************/
MemHandle _pascal
GetBoundaryHeader (BufferBlock *block, MailMessage *msg)
{
   MemHandle headerHandle;
   char *header, c;
   char match[] = {CR,LF,CR,LF,0};
   int matchLen, i, len = 0;
   
   if (!(headerHandle = MemAlloc(MAX_HEADER_SIZE+sizeof(TCHAR), 
				 HF_SWAPABLE | HF_SHARABLE, HAF_LOCK))) {
       return NULL;
   } else {
       header = MemDeref(headerHandle);
       BufferLockBlock(block);
       BufferGetNextByte(block,&header[0]);
       BufferGetNextByte(block,&header[1]);
       len = 2;
       if ((header[0] == CR) && (header[1] == LF)) {
	   /* if the first two characters are CRLF, then we know that there
	    * is no header
	    */
	   BufferUnlockBlock(block);
	   MemUnlock(headerHandle);
	   MemFree(headerHandle);
	   return NULL;
       } else {
	   i = 0;
	   matchLen = strlen(match);
	   while ((len < MAX_HEADER_SIZE) && (i < matchLen)) {
	       BufferGetNextByte(block, &c);
	       if (c == match[i]) {
		   ++i;
	       } else {
		   i = 0;
	       }
	       header[len] = c;
	       ++len;
	   }
	   BufferUnlockBlock(block);
	   header[len] = NULL;
	   if (len >= MAX_HEADER_SIZE) {
	       MemUnlock(headerHandle);
	       MemFree(headerHandle);
	       return NULL;
	   } else {
	       MemUnlock(headerHandle);
	       MemReAlloc(headerHandle, len, HAF_NO_ERR);
	       return headerHandle;
	   }
       }
   }
    
}	/* End of GetBoundaryHeader.	*/

MemHandle GetNextMultiPart(ContentTypeRecord *ctr, BufferBlock *block, 
			   MailMessage *msg, char** boundary)
{
    Boolean lastBoundary;
    int count, i;

    MemLock(OptrToHandle(ctr->CTR_parameters));
    count = ChunkArrayGetCount(ctr->CTR_parameters);
    for (i=0,*boundary=NULL;i<count;i+=2) {
	*boundary = ChunkArrayElementToPtr(ctr->CTR_parameters,i,0);
	if (!strcmp("boundary",*boundary) || !strcmp("Boundary",*boundary)) {
	    /* this is the boundary element, so set data
	     * to the value 
	     */
	    *boundary = ChunkArrayElementToPtr(ctr->CTR_parameters,i+1,0);
	    break;
	}
    }

    /* a boundary parameter can optionally contain '"'. Those need to be 
     * removed before the boundary can be matched.
     */
    RemoveQuotes(*boundary);
    
    /* now we need to scan for the first boundary.  This will move the pointer
     * to just after the boundary line.
     */
    ScanForBoundary(block,*boundary,&lastBoundary);

#if EC
    if (lastBoundary) {
	EC_ERROR(MAILPOP3_UNEXPECTED_END_BOUNDARY);
    }
#endif 
    
    /* Get the header.  This will return the header for this subsection, and 
     * move the block pointer to the just after the blank line following the 
     * header.
     */    
    return GetBoundaryHeader(block,msg);
}


/***********************************************************************
 *		GetAndDecodeLine
 ***********************************************************************
 *
 * SYNOPSIS:	Get data until we reach a CRLF, or the buffer is full, or 
 *              there is no more data to get.
 * CALLED BY:	
 * RETURN:	
 ***********************************************************************/
void _pascal
GetLine (BufferBlock *block, char *buffer, int *count)
{
    char c;
    int len;


    if (BufferGetNextByte(block,&c)) {
	*count = 0;
	return;
    }
    buffer[0] = c; 
    if (BufferGetNextByte(block,&c)) {
	*count = 0;
	return;
    }
    buffer[1] = c; 


    for (len = 2;(!((buffer[len-2]==CR)&&(buffer[len-1]==LF)))
	     && (len < *count);++len) {
	if (BufferGetNextByte(block,&c)) {
	    len = 0;
	    break;
	} else {
	    buffer[len] = c;
	}
    }
    *count = len;
}	/* End of GetLine.	*/



/***********************************************************************
 *		RemoveDoubleDot
 ***********************************************************************
 *
 * SYNOPSIS:	Remove the first dot from ".." at the start of a line
 * CALLED BY:	DecodeLine()
 * RETURN:	count updated
 * STRATEGY:
 *	    Mildly gross, shifting all the data, but cleaner than
 *          adjusting pointers hither and yon in DecodeLine().
 *
 ***********************************************************************/

void _pascal
RemoveDoubleDot(char *line, int *count)
{
    int i;

    for (i = 1; i < *count; i++) {
	line[i-1] = line[i];
    }
    (*count)--;
}


/***********************************************************************
 *		DecodeLine
 ***********************************************************************
 *
 * SYNOPSIS:	
 * CALLED BY:	
 * RETURN:	
 ***********************************************************************/
#define BASE64_BUFFER_SIZE         6*76
#define BASE64_DECODED_BUFFER_SIZE 6*57+3 /* +2 for decoding process */

void _pascal
DecodeLine (char *line, int *lineLen, TransferEncoding te)
{
    MemHandle decodedHandle;
    char *decodedLine;
    int i, len;

    /*
     * check for ".." at start -- SMTP requires "." be replaced with
     * ".." so as to not be confused with the end of message marker
     */
    if (line[0] == '.') {
	if (*lineLen > 1 && line[1] == '.') {
	    RemoveDoubleDot(line, lineLen);
	}
    }

    len = *lineLen;
    switch (te) {
    case TE_BASE64:
	decodedHandle = MemAlloc(BASE64_DECODED_BUFFER_SIZE, 
			    HF_SWAPABLE | HF_SHARABLE, HAF_LOCK | HAF_NO_ERR);
	decodedLine = MemDeref(decodedHandle);
	    /* 
	     * Skipping all white spaces, especially CRLF that
	     * ends an encoded line.
	     */
	RemoveWhiteSpace(line,&len);
#if EC
	if (len != BASE64_BUFFER_SIZE) {
	    EC_ERROR(MAILPOP3_LINE_TOO_LONG);
	}
#endif
	/* This shouldn't happen but at least this will just 
	 * cause a bad file vs crashing.  Should report this 
	 * error to the user.
	 */
	if (len > BASE64_BUFFER_SIZE) {
	    len = BASE64_BUFFER_SIZE;
	}
	len = MailB64DecodePtr((byte *)line, len, (byte *)decodedLine, 
			     BASE64_DECODED_BUFFER_SIZE);
	for(i=0;i<len;++i) {
	    line[i] = decodedLine[i];
	}
	
	MemFree(decodedHandle);
	break;

    case TE_UU:
	decodedHandle = MemAlloc(BASE64_DECODED_BUFFER_SIZE, 
			    HF_SWAPABLE | HF_SHARABLE, HAF_LOCK | HAF_NO_ERR);
	decodedLine = MemDeref(decodedHandle);
	    /* 
	     * Skipping all white spaces, especially CRLF that
	     * ends an encoded line.
	     */
#if EC
	if (len != BASE64_BUFFER_SIZE) {
	    EC_ERROR(MAILPOP3_LINE_TOO_LONG);
	}
#endif
	/* This shouldn't happen but at least this will just 
	 * cause a bad file vs crashing.  Should report this 
	 * error to the user.
	 */
	if (len > BASE64_BUFFER_SIZE) {
	    len = BASE64_BUFFER_SIZE;
	}
	len = MailUUDecodePtr((byte *)line, len, (byte *)decodedLine, 
			     BASE64_DECODED_BUFFER_SIZE);
	for(i=0;i<len;++i) {
	    line[i] = decodedLine[i];
	}

	MemFree(decodedHandle);
	break;
	
    case TE_QUOTED_PRINTABLE:	
	len = MailQPDecodePtr((byte *)line, len, (byte *)line);
	break;
    case TE_7BIT:
    case TE_8BIT: 
    case TE_BINARY:
    default:
	break;
    }
    *lineLen = len;
    
}	/* End of DecodeLine.	*/


/***********************************************************************
 *		ConvertLine
 ***********************************************************************
 *
 * SYNOPSIS:	If this is text, convert the charset of this line to 
 *              the specified charset.
 * CALLED BY:	
 * RETURN:	
 ***********************************************************************/
void
ConvertLine (char *line, int len, ContentTypeRecord *ctr)
{
    CharsetType ct;

    if (ctr == NULL) {
	/* This is a body part without a header, guess that it
	 *  conforms to ISO_8859_1
	 */
	ct = CHARSET_TYPE_ISO_8859_1;
    } else if (ctr->CTR_type == CONTENT_TYPE_TEXT_PLAIN ||
	       ctr->CTR_type == CONTENT_TYPE_TEXT_HTML ||
	       ctr->CTR_type == CONTENT_TYPE_TEXT) {
	ct = ctr->CTR_charset;
    } else {
	/* this is not text so don't mess with the data 
	 */
	return;
    }

    switch (ct) {
    case CHARSET_TYPE_ISO_8859_1:
    case CHARSET_TYPE_US_ASCII:
	LocalCodePageToGeos(line, len, CODE_PAGE_LATIN_1, '.');
	break;
    default:
	break;
    }
}	/* End of ConvertLine.	*/


/***********************************************************************
 *		UpdateProgress
 ***********************************************************************
 *
 * SYNOPSIS:	Calculate the percentage we have downloaded and
 *              update the progress dialog 
 * CALLED BY:	
 * RETURN:	
 ***********************************************************************/
Boolean _pascal
UpdateProgress (MailMessage *msg, dword *updateTime)
{
    int percent;
    Boolean stop = FALSE;
    dword now = TimerGetCount();

    if (msg->MM_progressRoutine) {
	if (msg->MM_size) {
	    percent = ((msg->MM_size - msg->MM_remainingSize) * 100) / 
		msg->MM_size;
	} else {
	    percent = 0;
	}
	if (percent == 100 || updateTime == 0 ||
	    (now - (*updateTime) > 60L)) {
	if (updateTime) *updateTime = now;
	ProcCallFixedOrMovable_pascal(MakeWWFixed(percent), (char *)NULL, &stop, msg->MM_progressRoutine);
	}
    }
    return stop;
}	/* End of UpdateProgress.	*/

Boolean _pascal
UpdateProgressAttachmentDown(MailMessage *msg, TCHAR *filename, dword *updateTime)
{
    /*
     * buffer is large because filenames aren't necessarily DOS or longname
     * in length
     */
    int percent;
    dword sizeDone;
    word sdFrac, tsFrac;
    TCHAR buf[MAX_LINE_LEN + 2*UHTA_NO_NULL_TERM_BUFFER_SIZE + 10];
    Boolean stop = FALSE;
    LocalNumericFormat nf;
    dword now = TimerGetCount();

    if (msg->MM_progressRoutine) {
	if (msg->MM_size) {
	    LocalGetNumericFormat(&nf);
	    sizeDone = msg->MM_size - msg->MM_remainingSize;
	    percent = ((sizeDone) * 100) / msg->MM_size;
	    tsFrac = ((msg->MM_size % 1024) * 10) / 1024;
	    sdFrac = ((sizeDone % 1024) * 10) / 1024;
	    sprintf(buf, "%s (%ld%c%dK/%ld%c%dK)", filename,
		    sizeDone>>10, nf.decimalSeparator, sdFrac,
		    msg->MM_size>>10, nf.decimalSeparator, tsFrac);
	} else {
	    buf[0] = 0;
	    percent = 0;
	}
	if (percent == 100 || (updateTime == 0) ||
	    (now - (*updateTime) > 60L)) {
	if (updateTime) *updateTime = now;
	ProcCallFixedOrMovable_pascal(MakeWWFixed(percent), buf, &stop, msg->MM_progressRoutine);
	}
    }
    return stop;
}
    


/***********************************************************************
 *		GetBodyCommon
 ***********************************************************************
 *
 * SYNOPSIS:	Download a body part
 * CALLED BY:	
 * RETURN:	
 ***********************************************************************/
MailError _pascal
GetBodyCommon (MailMessage *msg, BufferBlock *block, char *boundary, TransferEncoding te, Boolean *done, FileHandle fileHan, ContentTypeRecord *ctr, TCHAR *filename)
{
    MemHandle lineHandle;
    char *line;
    int len,offset,i;
    MailError ret = ME_NONE;
    Boolean stop;
    dword updateTime = 0;

    *done = FALSE;
    len = MAX_LINE_LEN;

    lineHandle = MemAlloc(MAX_LINE_LEN+sizeof(NULL), HF_SWAPABLE | HF_SHARABLE, 
			     HAF_LOCK | HAF_NO_ERR );
    line = MemDeref(lineHandle);

    BufferLockBlock(block);
    while (1) {
	len = MAX_LINE_LEN;
	GetLine(block, line, &len);
	/* either reached the end, 
	 * or there was an error
	 */
	line[len]=NULL;
	msg->MM_remainingSize -= len;
	stop = UpdateProgressAttachmentDown(msg, filename, &updateTime);

	if (len == 0) {
	    ret = ME_NETWORK_ERROR;
	    *done = TRUE;
	    break;
	}
	if (stop == TRUE) {
	    ret =  ME_USER_INTERRUPTED;
	    *done = TRUE;
	    break;
	}

	if ((line[0] == '.') && (line[1]==CR) && (line[2]==LF)) {
	    /* we have reached the end of the message
	     */
	    *done = TRUE;
	    break;
	} else if (boundary) {
	    if (!strncmp("--",line,2)) {
		offset = strlen("--");
		i = strlen(boundary);
		if (!(strncmp(boundary,&line[offset],i))) {
		    /* we have reached the end of our region
		     */
		    offset += i;
		    if (!strncmp("--",&line[offset],2)) {
			/* this is the last boundary in this multipart
			 */
			*done = TRUE;
		    }
		    break;
		}
	    }
	}

	/* Decode the line using the transfer encoding
	 */
	DecodeLine(line, &len, te);
	/* Convert the characters to Geos using the ContentType
	 */
	EC_ERROR_IF(len > MAX_LINE_LEN,-1);
	ConvertLine(line, len,  ctr);
#if EC
	for (i=0;i<len;++i) {
	    if (line[i] == 0xcc) {
		EC_ERROR(-1);
	    }
	}
#endif
	FileWrite(fileHan, line, len, TRUE);
    }

    /* force another update */
    stop = UpdateProgressAttachmentDown(msg, filename, 0);
    if (stop == TRUE) {
	ret =  ME_USER_INTERRUPTED;
	*done = TRUE;
    }
    
    BufferUnlockBlock(block);
    MemUnlock(lineHandle);
    MemFree(lineHandle);

    return ret;
}	/* End of GetBodyCommon	*/


/***********************************************************************
 *		GetBody
 ***********************************************************************
 *
 * SYNOPSIS:	
 * CALLED BY:	
 * RETURN:	
 ***********************************************************************/
MailError _pascal
GetBody (MailMessage *msg, BufferBlock *block, char *boundary, TransferEncoding te, Boolean *done, ContentTypeRecord *ctr)
{
    MailError ret = ME_NONE;

    ret = GetBodyCommon(msg,block,boundary,te,done,msg->MM_bodyFile, ctr, NULL);
    msg->MM_gotBody = TRUE;
    return ret;
}	/* End of GetBody.	*/


/***********************************************************************
 *		AddAttachmentName
 ***********************************************************************
 *
 * SYNOPSIS:	Append the new attachment name to the list of existing 
 *              attachments.
 * CALLED BY:	
 * RETURN:	
 * SIDE EFFECTS:
 ***********************************************************************/
void _pascal
AddAttachmentName (MailMessage *msg, char *name)
{
    char *aList, *path;
    ChunkHandle pathChunk;
    int aLen, pLen;

    MemLock(msg->MM_storageBlock);

    pathChunk = LMemAlloc(msg->MM_storageBlock,PATH_BUFFER_SIZE);
    path = LMemDerefHandles(msg->MM_storageBlock, pathChunk);
    path[0] = NULL;
    FileConstructFullPath(&path, PATH_BUFFER_SIZE, NULL, name, TRUE);
    /*
     * redereference path as FileConstructFullPath changes it to
     * point to the end of the path
     */
    path = LMemDerefHandles(msg->MM_storageBlock, pathChunk);

    if (path[0]) {
	/*
	 * get length of path, plus one for ;
	 */
	pLen = LocalStringSize(path) + sizeof(TCHAR);
	if (!msg->MM_attachment) {
	    /*
	     * allocate a new chunk and copy the new path
	     * sizeof(TCHAR) is for NULL
	     */
	    msg->MM_attachment = LMemAlloc(msg->MM_storageBlock,
					   pLen + sizeof(TCHAR));
	    aList = LMemDerefHandles(msg->MM_storageBlock,
				     msg->MM_attachment);
	    aList[0] = NULL;
	} else {
	    /*
	     * resize the chunk larger and append the new path
	     */
	    aLen = LMemGetChunkSizeHandles(msg->MM_storageBlock,
					   msg->MM_attachment);
	    LMemReAllocHandles(msg->MM_storageBlock,
			       msg->MM_attachment,
			       aLen + pLen);
	    aList = LMemDerefHandles(msg->MM_storageBlock,
				     msg->MM_attachment);
	}
	/*
	 * redereference the new path and append it to our list
	 */
	path = LMemDerefHandles(msg->MM_storageBlock,
				pathChunk);
	strcat(aList, path);
	strcat(aList, ";");
    }
    /*
     * free the chunk we used for the path and unlock the block
     */
    LMemFreeHandles(msg->MM_storageBlock, pathChunk);
    MemUnlock(msg->MM_storageBlock);
}	/* End of AddAttachmentName.	*/


/***********************************************************************
 *		FileCreateNewFile
 ***********************************************************************
 *
 * SYNOPSIS:	File already exists or the name is invalid for current 
 *              file system, so create a file with a new name
 * CALLED BY:	
 * RETURN:	
 *	
 * STRATEGY:    Take up to the first '.' or 8 letters whichever comes
 *              first and then find a unique extension.
 ***********************************************************************/
#define UNIQUE_NAME_FIELD_LEN 3
char *
FileCreateNewFile (FileHandle *fHan,char  *fileName, MemHandle *mh)
{
    char *ext,defExt=0,*origName,*newName;
    word i, j, len, maxPrefixLen;
#if _DOS_LONG_NAME_SUPPORT
    word extLen;
    Boolean useDOSLongname = TRUE;
#endif
    Boolean seenExt;
    MemHandle onh;

#if _DOS_LONG_NAME_SUPPORT
    /* get longname flag */
    InitFileReadBoolean("mimepop3", "useLongname", &useDOSLongname);
#endif

    /* make sure there is something before the '.' 
     */
    *mh = MemAlloc(FILE_LONGNAME_BUFFER_SIZE, HF_SWAPABLE | HF_SHARABLE, HAF_LOCK|HAF_NO_ERR);
    newName = MemDeref(*mh);
    onh = MemAlloc(FILE_LONGNAME_BUFFER_SIZE, HF_SWAPABLE | HF_SHARABLE, HAF_LOCK|HAF_NO_ERR);
    origName = MemDeref(onh);

    if (!fileName || !(*fileName)) {
	strcpy(origName,"file.000");
    } else {
	/*
	 * copy as much of the filename as we can
	 */
	len = strlen(fileName)+1;
	for (i = 0, j = 0, seenExt = FALSE; (i < len) && (i < FILE_LONGNAME_LENGTH); i++) {
	    if (fileName[i] == '.') {
		seenExt = TRUE;
	    }
	    /*
	     * don't copy more of the core name than we can handle
	     */
	    if (i < DOS_FILE_NAME_CORE_LENGTH || seenExt) {
		if (fileName[i] != ' ') {
		    origName[j] = fileName[i];
		} else {
		    origName[j] = '_';
		}
		j++;
	    }
	}
	/*
	 * copy the extension, too, if we didn't already
	 */
	if (!seenExt) {
	    ext = strrchr(fileName, '.');
	    if (ext && (j < FILE_LONGNAME_LENGTH)) {
		strncpy(origName+j, ext, FILE_LONGNAME_LENGTH-j);
		origName[FILE_LONGNAME_LENGTH] = C_NULL;
		j = strlen(origName);
	    }
	}
	/*
	 * make sure the filename is NULL-terminated
	 */
	origName[j] = NULL;

    }

    if (ext = strrchr(origName, '.')) {
	*ext=NULL;
	ext++;
	if (strlen(ext) > DOS_FILE_NAME_EXT_LENGTH) {
	    ext[DOS_FILE_NAME_EXT_LENGTH] = NULL;
	}
    } else {
	ext = &defExt;
    }

    maxPrefixLen = DOS_FILE_NAME_CORE_LENGTH-UNIQUE_NAME_FIELD_LEN;

    /*
     * come up with a unique extension 
     */
    if (strlen(origName) > maxPrefixLen) {
	origName[maxPrefixLen] = NULL;
    }
    for (i=0; i<999; ++i) {
	if (*ext) {
	    sprintf(newName,"%s%d.%s",origName,i,ext);
	}  else {
	    if (i < 10) {
		sprintf(newName,"%s.00%d",origName,i);
	    } else if (i < 100) {
		sprintf(newName,"%s.0%d",origName,i);
	    } else {
		sprintf(newName,"%s.%d",origName,i);
	    }
	}
	if (*fHan = FileCreate(newName, FILE_CREATE_ONLY | FCF_NATIVE |
			      FILE_DENY_RW | FILE_ACCESS_RW, 0)) {
	    break;
	}
    }
    MemFree(onh);
#if EC
    if (i == 999) {EC_ERROR(-1);}
#endif
    return newName;


}	/* End of FileCreateNewFile.	*/


/***********************************************************************
 *		GetAttachment
 ***********************************************************************
 *
 * SYNOPSIS:	
 * CALLED BY:	
 * RETURN:	
 * SIDE EFFECTS:
 ***********************************************************************/
typedef struct {
    byte          GFH_sig[4];
    FileLongName  GFH_name;
} GFHeader;

MailError _pascal
GetAttachment(MailMessage *msg, BufferBlock *block, 
	      ContentTypeRecord *ctr, char *boundary, 
	      TransferEncoding te, Boolean *done)
{
    char *temp,*origName = NULL, *attachName;
    char *tempName;
    GFHeader header;
    char tailBuf[4];
    word tailLen, nameLen;
    char newName[DOS_DOT_FILE_NAME_LENGTH+1];
    char newNameCore[DOS_DOT_FILE_NAME_LENGTH+1];
/* DOS_FILE_NAME_CORE_LENGTH+DOS_FILE_NAME_EXT_LENGTH+1]; */
    FileHandle fHan = NULL;
    MemHandle tempNameHan = NULL;
    int count,i;
    MailError ret = ME_NONE;
    TCHAR *iboxName, *attName;

    origName = NULL;

    if (ctr && ctr->CTR_parameters) {
	MemLock(OptrToHandle(ctr->CTR_parameters));
	count = ChunkArrayGetCount(ctr->CTR_parameters);
	for (i=0,origName=NULL;i<count;i+=2) {
	    temp = ChunkArrayElementToPtr(ctr->CTR_parameters,i,0);
	    if (!strncmp("name",temp,strlen("name"))) {
		/* this is the boundary element, so set data
		 * to the value 
		 */
		origName = ChunkArrayElementToPtr(ctr->CTR_parameters,i+1,0);

		break;
	    }
	}
    } 

    /* if we found a name open a file for the attachment, if we did not 
     * find a name, just add it to the body file.
     */
    if (origName) {
	RemoveQuotes(origName);
    } else {
	switch (ctr->CTR_type) {
	case CONTENT_TYPE_IMAGE_GIF:
	    origName = "inline0.gif";
	    break;
	case CONTENT_TYPE_IMAGE_JPEG:
	    origName = "inline0.jpg";
	    break;
	case CONTENT_TYPE_TEXT_HTML:
	    origName = "attach.htm";
	    break;
	default:

	    /*
	     * we expect to use the default for:
	     *   CONTENT_TYPE_MESSAGE
	     *   CONTENT_TYPE_TEXT_PLAIN
	     *   CONTENT_TYPE_TEXT_ENRICHED
	     * 
	     */
#if EC
	    if (!msg->MM_bodyFile) { 
		EC_ERROR(MAILPOP3_UNEXPECTED_BODY_PART);
	    }
#endif
	    fHan = msg->MM_bodyFile;
	}
    }
    attachName = origName;  /* save attachment's referring name */

    /* if we are just going to add this to the body, as is the 
     * case with an inline attached message, we don't want to 
     * open a new file
     */
    tempName = NULL;
    if (!fHan) {
	FilePushDir();
	MemLock(msg->MM_storageBlock);
	temp = LMemDerefHandles(msg->MM_storageBlock,msg->MM_path);
	iboxName = MailLockStdString(MSS_INBOX_FOLDER);
	attName = MailLockStdString(MSS_ATTACH_DIR);
	if (FileSetCurrentPath(SP_PRIVATE_DATA,temp)) { 
	    FileSetCurrentPath(NULL, iboxName);
	    if (FileSetCurrentPath(NULL, attName)) {
		fHan = FileCreate(origName, FILE_CREATE_ONLY | FCF_NATIVE |
				  FILE_DENY_RW | FILE_ACCESS_RW, 0);
		if (!fHan) {
		    tempName = FileCreateNewFile(&fHan,origName, &tempNameHan);
		    origName = tempName;
		}
		if (!fHan) ret = ME_FILE_ERROR;
	    } else if (!FileCreateDir(attName)) {
		FileSetCurrentPath(NULL, attName);
		fHan = FileCreate(origName,
				  FILE_CREATE_ONLY | FCF_NATIVE |
				  FILE_DENY_RW | FILE_ACCESS_RW, 0);
		if (!fHan) {
		    tempName = FileCreateNewFile(&fHan,origName, &tempNameHan);
		    origName = tempName;
		}
		if (!fHan) ret = ME_FILE_ERROR;
	    }
	}
	MailUnlockStdString(MSS_INBOX_FOLDER);
	MailUnlockStdString(MSS_ATTACH_DIR);
	MemUnlock(msg->MM_storageBlock);
    }

    if (fHan) {
	/* we don't know whether we'll need to update GEOS name yet, so this'll
	   show the name specified in the attachment (the same occurs for DOS
	   files, even though we do know the final name) */
	ret = GetBodyCommon(msg, block, boundary, te, done, fHan, ctr, attachName);
	if (fHan != msg->MM_bodyFile) {

/* GFH_SIG_1_2	= ('G' or 0x80) or ('E' shl 8) */
/* GFH_SIG_3_4	= ('A' or 0x80) or ('S' shl 8) */

	    FilePos(fHan, 0, FILE_POS_START);
            i=FileRead(fHan,&header,sizeof(header), 0);
	    if (i == sizeof(header)) {
		if ((header.GFH_sig[0] == (byte)('G' | 0x80)) &&
		    (header.GFH_sig[1] == (byte)'E') &&
		    (header.GFH_sig[2] == (byte)('A' | 0x80)) &&
		    (header.GFH_sig[3] == (byte)'S')) {


		    FilePos(fHan, 0, FILE_POS_START);
		    FileWrite(fHan,"X",sizeof(char), 0);
		    FileClose(fHan,TRUE);

		    for (i=0;i<DOS_FILE_NAME_CORE_LENGTH;++i) {
			if (origName[i] == '.') {
			    if (i > 0) {
				newNameCore[i] = NULL;
				break;
			    } else {
				newNameCore[i] = 'D';
				++i;
				break;
			    }
			}
			if (ISALNUM(origName[i])) {
			    newNameCore[i] = origName[i];
			} else {
			    newNameCore[i] = '_';
			}
		    }
		    newNameCore[i] = NULL;
		    /* if .GEO file, use that name unless it already exists */
		    sprintf(newName,"%s.GEO",newNameCore);
		    if (LocalCmpStringsNoCase(newName, origName, 0)!=0 ||
			/* returns -1 (8 bits) only on error */
			(FileGetAttributes(newName)&0x00ff)==0x00ff) {
		    count = 0;
		    for (i=0;i < 999;++i) {
			if (i < 10) {
			    sprintf(newName,"%s.00%d",newNameCore,i);
			} else if (i < 100) {
			    sprintf(newName,"%s.0%d",newNameCore,i);
			} else {
			    sprintf(newName,"%s.%d",newNameCore,i);
			}
			if (! FileMove(origName,newName,0,0)) {
			    break;
			}
		    }
		    }
		    /* we have GEOS file (with bad sig) with unique DOS name, now
		       ensure GEOS name is unique (do before fixing sig as we don't
		       want to recognize this file as GEOS name conflict) */
		    (void)FileGetAttributes(header.GFH_name);
		    count = 0;
		    nameLen = strlen(header.GFH_name);
		    while (count < 1000 && ThreadGetError() == 0) {
			sprintf(tailBuf, "%d", count++);
			tailLen = strlen(tailBuf);
			if (nameLen+tailLen <= FILE_LONGNAME_LENGTH) {
			    strcpy(header.GFH_name+nameLen, tailBuf);
			} else {
			    strcpy(header.GFH_name+FILE_LONGNAME_LENGTH-tailLen,
				   tailBuf);
			}
			(void)FileGetAttributes(header.GFH_name);
		    }
		    /* use as attachment's actual name */
		    origName = header.GFH_name;

		    fHan = FileOpen(newName,FILE_DENY_RW | FILE_ACCESS_RW);
		    if (fHan) {
			FileWrite(fHan,&header,sizeof(header), 0);
		    }
		}		    
	    }
	    if (fHan) {
		FileClose(fHan,TRUE);
		AddAttachmentName(msg,origName);
		FilePopDir();
	    }
	}
    }
    if (tempNameHan) {
	MemFree(tempNameHan);
    }

    return ret;
}	/* End of GetAttachment.	*/



/***********************************************************************
 *		CopyHeader
 ***********************************************************************
 *
 * SYNOPSIS:	Write the header out to the message file
 * CALLED BY:	POP3Mime()
 * RETURN:	MailError - error if any
 ***********************************************************************/
MailError  _pascal
CopyHeader(TCHAR *header, FileHandle fh)
{
    TCHAR *end, *start;
    MailError err = ME_NONE;

    start = end = header;

    while(!err) {
	end = strchr(start, '\r');
	FileWrite(fh, start, end-start+1, FALSE);
	if (ThreadGetError()) {
	    err = ME_FILE_ERROR;
	    break;
	}
	if (start == end) {
	    break;
	}
	start = end+2; /* +2 to skip LF */
    }
    return(err);
}


/***********************************************************************
 *		POP3Mime
 ***********************************************************************
 *
 * SYNOPSIS:	Decode a MIME encoded file
 * CALLED BY:	
 * RETURN:	
 ***********************************************************************/
static MailError HandlePart(char* header, MemHandle boundaryHandle, BufferBlock* block, ContentTypeRecord* ctr, 
			    MailMessage* msg, char* field, Boolean *done) 
{
    MailError ret = ME_NONE;
    TransferEncoding te;
    char* boundary = NULL;
   
    *done = TRUE;   /* assume no more parts */

    if(boundaryHandle)
	boundary = MemDeref(boundaryHandle);

    if(header) {

	switch (ctr->CTR_type) {
	case CONTENT_TYPE_MULTIPART_MIXED:
	case CONTENT_TYPE_MULTIPART_ALT:
	case CONTENT_TYPE_MULTIPART_RPT:
	case CONTENT_TYPE_MULTIPART_RELATED:
	    *done = FALSE;
	    ret = ME_NONE;    /* let POP3Mime handle this MultiPart */
	    break;
	    
	case CONTENT_TYPE_TEXT_PLAIN:
	case CONTENT_TYPE_TEXT_HTML:
	case CONTENT_TYPE_TEXT_ENRICHED:
	case CONTENT_TYPE_TEXT:
	    /*
	     * in any case we need to make sure that we scan only until 
	     * the boundary
	     */
	    MailGetHdrValue822(ContentTransferField, field,
			       FIELD_BUFFER_BLOCK_SIZE, header);
	    GetTransferEncoding(field, &te);
	    if (msg->MM_gotBody) {
		/*
		 * get the name and download the section to a file
		 * decoding it as necessary.
		 */
		ret = GetAttachment(msg, block, ctr, boundary, te, done);
	    } else {
		/* 
		 * this is the first plain text that we have
		 * run across, so lets assume that it is
		 * the message body.
		 */
		ret = GetBody(msg, block, boundary, te, done, ctr);
	    }
	    break;
	    
	case CONTENT_TYPE_MESSAGE:
	    *done = FALSE;
	    ret = ME_NONE;	
	    break;
	    
	default:
	    /*
	     * else get as attachment
	     */
	    MailGetHdrValue822(ContentTransferField, field,
			       FIELD_BUFFER_BLOCK_SIZE, header);
	    GetTransferEncoding(field, &te);
	    ret = GetAttachment(msg, block, ctr, boundary, te, done);
	    break;
	}
	if ((*done) && ctr->CTR_parameters) {
	    MemFree(OptrToHandle(ctr->CTR_parameters));
	}	
    }
    return ret;    
}

void PushBoundary(BoundaryStackElement* bse, optr boundaryStack)
{
    BoundaryStackElement* newBSE;

    MemLock(OptrToHandle(boundaryStack));
    newBSE = ChunkArrayAppend(boundaryStack, NULL);
    newBSE->BSE_boundaryHandle = bse->BSE_boundaryHandle;
    memcpy(&newBSE->BSE_ctr, &bse->BSE_ctr, sizeof(ContentTypeRecord));
    MemUnlock(OptrToHandle(boundaryStack));
} 

void PopBoundary(optr boundaryStack, MemHandle* boundaryHandle, ContentTypeRecord* ctr)
{
    word element;
    BoundaryStackElement* bse;

    MemLock(OptrToHandle(boundaryStack));
    element = ((ChunkArrayHeader*)LMemDeref(boundaryStack))->CAH_count-1;
    bse = ChunkArrayElementToPtr(boundaryStack, element, NULL);
    *boundaryHandle = bse->BSE_boundaryHandle;
    memcpy(ctr, &bse->BSE_ctr, sizeof(ContentTypeRecord));
    ChunkArrayDelete(boundaryStack, bse);
    MemUnlock(OptrToHandle(boundaryStack));
}

MailError  _pascal
POP3Mime (char *header, BufferBlock *block, MailMessage *msg)
{
    TransferEncoding te;
    ContentTypeRecord ctr;   
    MemHandle fieldHandle, newHeaderHandle;
    char *field, *newHead;
    MailError ret = ME_NONE;
    Boolean done = FALSE;
    Boolean lastBoundary;
    char* boundary = NULL;
    MemHandle boundaryHandle = NULL;
    BoundaryStackElement currBoundaryDesc;
    optr boundaryStack;
    register int x, num;

    /* if we can not allocate a buffer there is no need to crash
     */
    if (!(fieldHandle = MemAlloc(FIELD_BUFFER_BLOCK_SIZE, 
				 HF_SWAPABLE | HF_SHARABLE, HAF_LOCK))) {
	return ME_OUT_OF_MEMORY;
    }
    
    /* allocate the boundary stack */
    if(!(newHeaderHandle = MemAllocLMem(LMEM_TYPE_GENERAL, NULL))) {
	MemFree(fieldHandle);
	return ME_OUT_OF_MEMORY;
    }
    MemLock(newHeaderHandle);   /* YES, I'm reusing this variable.  No use in wasting more stack space. . .*/
    boundaryStack = ConstructOptr(newHeaderHandle, 
				  ChunkArrayCreate(newHeaderHandle, 
						   sizeof(BoundaryStackElement), 
						   0, 0));
    newHeaderHandle = NULL;

    PUSHDS;
    SET_DS_LIB_DGROUP;
    
    field = MemDeref(fieldHandle);
    if (header) {       	
	newHead = header;	

	do {
	    /*
	     * Check to see if the header is multi-part or not.
	     * At this point the ptr should be pointing to the CRLF after
	     * the boundary
	     */
	    MailGetHdrValue822(ContentTypeField, field,
			       FIELD_BUFFER_BLOCK_SIZE, newHead);
	    if (field[0] == NULL) {
		ret = ME_UNEXPECTED_VALUE;
		ctr.CTR_type = CONTENT_TYPE_TEXT_PLAIN;
		ctr.CTR_charset = CHARSET_TYPE_US_ASCII;
		ctr.CTR_parameters = 0;
	    } else {
		GetContentType(field, &ctr);
	    }

	    switch(ctr.CTR_type) {
	    case CONTENT_TYPE_MESSAGE:
		/*
		 * content-type = message/rfc22, as in forwarded
		 * messages with attachments from AOL or Netscape.
		 */
		if(newHeaderHandle)
		    MemFree(newHeaderHandle);          /* done with the old header */		
		newHeaderHandle = GetBoundaryHeader(block, msg);
		newHead = MemLock(newHeaderHandle);
		ret = CopyHeader(newHead, msg->MM_bodyFile);
		if(ret != ME_NONE)
		    goto abort;
		continue;
		
	    case CONTENT_TYPE_MULTIPART_MIXED:
	    case CONTENT_TYPE_MULTIPART_ALT:
	    case CONTENT_TYPE_MULTIPART_RPT:
	    case CONTENT_TYPE_MULTIPART_RELATED:
		/* save the last boundary to be completed */
		if(boundaryHandle) {
		    currBoundaryDesc.BSE_boundaryHandle = boundaryHandle;
		    currBoundaryDesc.BSE_ctr = ctr;
		    PushBoundary(&currBoundaryDesc, boundaryStack);
		}

		/* Read in the first header for this MultiPart */
		if(newHeaderHandle)
		    MemFree(newHeaderHandle);  /* done with the old header */
		newHeaderHandle = GetNextMultiPart(&ctr, block, msg, &boundary);

		/* save the boundary */
		if(boundary) {
		    boundaryHandle = MemAlloc(strlen(boundary), HF_FIXED, 0);   /* HF_FIXED cause these strings CAN'T move! */
		    if(!boundaryHandle) {
			ret = ME_OUT_OF_MEMORY;
			goto abort;
		    }
		    strcpy(MemDeref(boundaryHandle), boundary);

		    /* unlock parameter chunk array which GetNextMultiPart returned
		       the boundary from */
		    MemUnlock(OptrToHandle(ctr.CTR_parameters));
		}
		if(newHeaderHandle) {
		    newHead = MemLock(newHeaderHandle);
		    continue;
		}
		else {
		    /* ack!  This was highly unexpected.  we're outta' here. */
		    done = TRUE;
		}
		break;	       
		
	    default:
		ret = HandlePart(newHead, boundaryHandle, block, &ctr, msg, field, &done);
		break;
	    }	    

	    if(newHeaderHandle) {
		MemFree(newHeaderHandle);        /* done with old header */	    
		newHeaderHandle = NULL;
	    }
	    
	    if(!done) {
		/* go get the next header for this boundary */
		newHeaderHandle = GetBoundaryHeader(block,msg);
		if(newHeaderHandle)
		    newHead = MemLock(newHeaderHandle);
		else
		    done = TRUE;
	    }
	    else {
		do {
		    lastBoundary = FALSE;
		    if(ChunkArrayGetCount(boundaryStack)) {		    
			/* pop the last boundary off the stack and continue the loop */
			MemFree(boundaryHandle);  /* free the old boundary */
			PopBoundary(boundaryStack, &boundaryHandle, &ctr);
			boundary = MemDeref(boundaryHandle);
			done = FALSE;	
						
			ScanForBoundary(block, boundary, &lastBoundary);			
		    }		
		    else {
			/* we've enumerated each multipart.  get outta' here */
			done = TRUE;
			lastBoundary = FALSE;
		    }
		} while(lastBoundary);	 
   
		if(!done) {
		    newHeaderHandle = GetBoundaryHeader(block, msg);
		    if(newHeaderHandle)
			newHead = MemLock(newHeaderHandle);
		    else
			done = TRUE;
		}
	    }
	} while(!done);
    } else  { /* header == NULL (no header) */
	/* 
	 * assume content type is unencoded text/plain.  if msg->MM_gotBody
	 * == FALSE, then put this in a memblock and save it.
	 * otherwise create a name for it and save it to a file.
	 */
	if (msg->MM_gotBody) {
	    ret = GetAttachment(msg, block, NULL, boundary, te, &done);
	} else {
	    ret = GetBody(msg, block, boundary, TE_8BIT, &done, NULL);
	}
    }

abort:
    if(newHeaderHandle)
	MemFree(newHeaderHandle);
    /* free any boundaries remaining (in case we aborted) */    
    num = ChunkArrayGetCount(boundaryStack);
    for(x = 0; x < num; x++) {
	MemFree(((BoundaryStackElement*)
		 ChunkArrayElementToPtr(boundaryStack, x, NULL))->BSE_boundaryHandle);
    }    
    MemFree(fieldHandle);
    MemFree(OptrToHandle(boundaryStack));
    POPDS;
    return ret;
}	/* End of POP3Mime.	*/
