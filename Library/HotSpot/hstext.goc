/***********************************************************************
 *
 *   Copyright (c) Geoworks 1992 -- All Rights Reserved
 *
 *  PROJECT:        GEOS
 *  MODULE:         HotSpot Library
 *  FILE:           hstext.goc
 *
 *  AUTHOR:         Cassie Hartzog, Apr 13, 1994
 *
 *  REVISION HISTORY:
 *  	Name    Date            Description
 *  	----    ----            -----------
 *  	Cassie  4/13/94         Initial version.
 *
 *  DESCRIPTION:            
 *
 *	$Id: hstext.goc,v 1.1 97/04/04 18:09:08 newdeal Exp $
 *
 *
 ***********************************************************************/

/*
 ***************************************************************************
 *              Include files
 ***************************************************************************
 */

@include <stdapp.goh>
@include <hotspot.goh>  

#include <gstring.h>
#include <Ansi/string.h>
#include "hserrors.h"

/*
 ***************************************************************************
 *              Class & Message Declarations
 ***************************************************************************
 */

@classdecl HotSpotTextClass;

/* These methods are defined in hstextHS.goc */

@extern method HotSpotTextClass, MSG_HSTEXT_CREATE_HOT_SPOT;
@extern method HotSpotTextClass, MSG_HSTEXT_DELETE_HOT_SPOT;
@extern method HotSpotTextClass, MSG_HSTEXT_UPDATE_HOT_SPOT;
@extern method HotSpotTextClass, MSG_HSTEXT_CHECK_FOR_PASTED_HOT_SPOTS;

/* These methods are defined in hsUtils.goc */

@extern method HotSpotTextClass, MSG_VIS_TEXT_CREATE_STORAGE;
@extern method HotSpotTextClass, MSG_VIS_TEXT_FREE_STORAGE;
@extern method HotSpotTextClass, MSG_VIS_TEXT_SCREEN_UPDATE;
@extern method HotSpotTextClass, MSG_VIS_TEXT_SET_CONTEXT;
@extern method HotSpotTextClass, MSG_VIS_TEXT_ATTRIBUTE_CHANGE;
@extern method HotSpotTextClass, MSG_VIS_DRAW;
@extern method HotSpotTextClass, MSG_HSTEXT_RECALC_HOT_SPOTS;
@extern method HotSpotTextClass, MSG_HSTEXT_REPOSITION_HOT_SPOTS; 
@extern method HotSpotTextClass, MSG_VIS_TEXT_GRAPHIC_VARIABLE_DRAW;
@extern method HotSpotTextClass, MSG_VIS_TEXT_GRAPHIC_VARIABLE_SIZE;

/*
 ***************************************************************************
 *              Internal Function Declarations
 ***************************************************************************
 */
 
Boolean ModifyReplaceRange(optr oself, dword *start, dword *end,
			   dword insCount);
dword   GetTextPosition(optr oself, PointDWFixed *point);
dword 	GetLineHeight(optr oself, dword position);
word 	GetLineAdjustment(optr oself, dword position);

word    AddTokenAtPosition(optr oself, dword position);
GraphicType ConvertGraphicType(VisTextGraphic *graphic);
void 	CheckForDeletingVariableGraphics(optr oself, 
	    			      	 VisTextReplaceParameters *params);
void 	SendVariableGraphicNotification(optr oself, dword pos, 
					GraphicType type,
				    	VariableGraphicActionType action);
void 	SendTypeChangeNotification(optr oself, VisTextSetContextFlags flags,
				   VisTextNotifyTypeChange *data);
void 	GetAndSendTypeChangeNotification(optr oself, dword rangeEnd, 
				      	 dword rangeStart);
void 	GenerateAndSendFollowHyperlinkNotification(optr oself, word token);

/*
 ***************************************************************************
 *              Message Handlers
 ***************************************************************************
 */

/***************************************************************************
 *              MSG_VIS_TEXT_GENERATE_NOTIFY
 ***************************************************************************
 *
 *  SYNOPSIS:   
 *
 *  PARAMETERS: VisTextGenerateNotifyParams *params
 *
 *  RETURN:     nothing
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      cassie  04/14/94        Initial Revision
 *
 **************************************************************************/
@method HotSpotTextClass, MSG_VIS_TEXT_GENERATE_NOTIFY
{
    Boolean flag = (params->VTGNP_notificationTypes & VTNF_TYPE);
    optr GBody; 

    params->VTGNP_notificationTypes &= ~VTNF_TYPE;
    if (params->VTGNP_notificationTypes)
	@callsuper();

    if (flag) {
	if (params->VTGNP_sendFlags & VTNSF_NULL_STATUS)
	    GenerateAndSendFollowHyperlinkNotification(oself, CA_NULL_ELEMENT);
	else {
	    /* 
	     * If we have the target, generate a type change notification
	     * based on the currently selected range.
	     */
	    pself = ObjDerefVis(oself);
	    if (pself->VTI_intSelFlags & VTISF_IS_TARGET) 
		GetAndSendTypeChangeNotification(oself, pself->VTI_selectEnd,
		    	    	    	    	 pself->VTI_selectStart);
	    /* 
	     * If we don't have the target, tell HotSpotManager to generate
	     * the notification.  It will send the hotspot token to
	     * MSG_HSTEXT_FOLLOW_HYPERLINK_NOTIFICATION, which actually
	     * sends the notification.
	     */
	    else {
		GBody = @call self::
		    MSG_VIS_VUP_FIND_OBJECT_OF_CLASS(&HotSpotManagerClass);
		@call GBody::
		    MSG_HOT_SPOT_MANAGER_SELECTION_CHANGE_NOTIFICATION();
	    }
    	}
    }
    /* 
     * If no notification types were set, this was probably sent to 
     * generate null status events.  Let superclass do that for us.
     */
    else if (!params->VTGNP_notificationTypes)
	@callsuper();
}

/***************************************************************************
 *              MSG_VIS_TEXT_FILTER_VIA_REPLACE_PARAMS
 ***************************************************************************
 *
 *  SYNOPSIS:   The text has been modified, update the positions of
 *              elements in the HotSpotArray, add and delete elements
 *              if necessary.
 *
 *  PARAMETERS: VisTextReplaceParameters *params
 *
 *  RETURN:     FALSE to accept replacement
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      cassie  04/14/94        Initial Revision
 *
 **************************************************************************/
@method HotSpotTextClass, MSG_VIS_TEXT_FILTER_VIA_REPLACE_PARAMS
{
    /* if this is not part of an undo action....*/
    if (!(params->VTRP_flags & VTRF_UNDO)) {
	/* 
	 * Don't check the selection range when deleting a HotSpot.  
	 * In that case, we do want to delete just the one graphic.
	 * Otherwise, check that the range is valid - it must include
	 * all hotspots if it includes their embedded graphic 
     	 */
	if (!ObjVarFindData(oself, ATTR_HOT_SPOT_TEXT_ADD_OR_DELETE_HOT_SPOT)) 
	    ModifyReplaceRange(oself, &params->VTRP_range.VTR_start, 
				   &params->VTRP_range.VTR_end, 
				   params->VTRP_insCount);

    	/* update the array to account for insertions and deletions */ 
    	@send, forceQueue, insertAtFront self::
	    MSG_HSTEXT_UPDATE_HOT_SPOT_ARRAY(*params);
    }

    /* Notify ourselves if we are about to delete some variable graphics */
    CheckForDeletingVariableGraphics(oself, params);

    /* allow the replacement to continue */
    return(FALSE);  
}

/***************************************************************************
 *              MSG_VIS_TEXT_REPLACE_TEXT
 ***************************************************************************
 *
 *  SYNOPSIS:   Check if this message was sent as the result of an undo
 *              action.  If so, the replace operation won't be filtered,
 *              so update the HotSpotArray now.
 *
 *  PARAMETERS: VisTextReplaceParameters *params
 *
 *  RETURN:     Boolean 
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      cassie  05/16/94        Initial Revision
 *
 **************************************************************************/
@method HotSpotTextClass, MSG_VIS_TEXT_REPLACE_TEXT
{
    Boolean 	    flag;
    VisTextReplaceFlags	filter = (params->VTRP_flags & VTRF_FILTER);
    /*
     * MSG_VIS_TEXT_REPLACE_WITH_GRAPHIC sends this message, and we
     * rely on the fact that it doesn't set the filter flag.
     */
    EC_ERROR_IF(ObjVarFindData(oself, ATTR_HOT_SPOT_TEXT_ADDING_GRAPHIC) &&
		filter, -1);
    /*
     * Notify ourselves if we are about to delete some variable graphics.
     * if this not filtered, check for deleting variable graphics now,
     * because MSG_VIS_TEXT_FILTER_VIA_REPLACE_PARAMS is where we 
     * normally do that check.
     */
    if (!filter) 
	CheckForDeletingVariableGraphics(oself, params);

    /* Actually replace the text */
    flag = @callsuper();

    /* If the replace wasn't filtered out, then update HotSpotArray */
    if (!flag) {
	/*
	 * if this is not a filtered replace (because it is an undo or
	 * a replace with graphic), update the hotspot array now because 
	 * it won't be updated in the MSG_VIS_TEXT_FILTER_VIA_REPLACE_PARAMS
	 * or in MSG_VIS_TEXT_REPLACE_WITH_GRAPHIC.
	 */
	if (!filter) 
	    UpdateHotSpotArray(oself, params, TRUE);
	/* 
	 * If text is being inserted, and we're not in the process of 
	 * adding a graphic char, check for hotspots in the new text, which
	 * if pasted, may contain hotspots which need to be instantiated. 
	 */
	if (params->VTRP_insCount > 0 &&
	    !ObjVarFindData(oself, ATTR_HOT_SPOT_TEXT_ADDING_GRAPHIC)) {
	    	@send, forceQueue self::
		    MSG_HSTEXT_CHECK_FOR_PASTED_HOT_SPOTS(*params);
	}
    }
    return(flag);
}

/***************************************************************************
 *              MSG_VIS_TEXT_REPLACE_WITH_GRAPHIC
 ***************************************************************************
 *
 *  SYNOPSIS:   We must handle pasting of a graphic into the text layer
 *              specially, as it does some funky stuff, and doesn't even
 *              get filtered.
 *
 *  PARAMETERS: VisTextGraphic graphic
 *              word sourceFile
 *              word pasteFrame
 *              dword rangeEnd
 *              dword rangeStart
 *
 *  RETURN:     nothing
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      cassie  04/21/94        Initial Revision
 *
 **************************************************************************/
@method HotSpotTextClass, MSG_VIS_TEXT_REPLACE_WITH_GRAPHIC
{
    VisTextReplaceParameters params;
    char graphicChar = C_GRAPHIC;

    ObjVarAddData(oself, ATTR_HOT_SPOT_TEXT_ADDING_GRAPHIC, 0);
    params.VTRP_insCount = 1;
    params.VTRP_range.VTR_start = rangeStart;
    params.VTRP_range.VTR_end = rangeEnd;
    params.VTRP_flags = 0;
	
    /* convert to physical bounds from virtual range */
    @call oself::MSG_VIS_TEXT_GET_RANGE(&params.VTRP_range, 0);
    /*
     * The replace range should not need to be updated, as the cursor 
     * should not be positioned between a graphic and its hotspots 
     * but check, just in case...
     */
    if (!ObjVarFindData(oself, ATTR_HOT_SPOT_TEXT_ADD_OR_DELETE_HOT_SPOT)) 
    	ModifyReplaceRange(oself, &params.VTRP_range.VTR_start,
				     &params.VTRP_range.VTR_end, 1);

    /* add one graphic char to the text */
    params.VTRP_textReference.TR_type = TRT_POINTER;        
    params.VTRP_textReference.TR_ref.TRU_pointer.TRP_pointer = &graphicChar;
    rangeStart = params.VTRP_range.VTR_start;
    rangeEnd = params.VTRP_range.VTR_end;   
/*
 * THIS IS NOW CALLED FROM MSG_VIS_TEXT_REPLACE_TEXT if VTRF_FILTER is
 * not set, so need not be called here.
 *    Notify ourselves if we are about to delete some variable graphics 
 *    CheckForDeletingVariableGraphics(oself, &params);
 */
    @callsuper();

/*
 * THIS IS NOW CALLED FROM MSG_VIS_TEXT_REPLACE_TEXT if VTRF_FILTER is
 * not set, so need not be called here.
 *   UpdateHotSpotArray(oself, &params, FALSE); 
 */
    AddTokenAtPosition(oself, params.VTRP_range.VTR_start);
    HotSpotArraySetType(oself, params.VTRP_range.VTR_start, 
			ConvertGraphicType(&graphic));
    ObjVarDeleteData(oself, ATTR_HOT_SPOT_TEXT_ADDING_GRAPHIC);
}

/***************************************************************************
 *              MSG_VIS_TEXT_DELETE_SELECTION
 ***************************************************************************
 *
 *  SYNOPSIS:   Send to originating text object when quick-moving text
 *              to another text object.  Need to update the hotspot array,
 *              and check for deleting variable graphics
 *
 *  PARAMETERS: nothing
 *
 *  RETURN:     Boolean 
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      cassie  05/16/94        Initial Revision
 *
 **************************************************************************/
@method HotSpotTextClass, MSG_VIS_TEXT_DELETE_SELECTION
{
    VisTextReplaceParameters params;

    /*
     * Notify ourselves if we are about to delete some variable graphics.
     */
    params.VTRP_flags = 0;  	    	/* not filtered */
    params.VTRP_insCount = 0;	    	/* this is a deletion! */
    params.VTRP_range.VTR_start = pself->VTI_selectStart;
    params.VTRP_range.VTR_end = pself->VTI_selectEnd;
    CheckForDeletingVariableGraphics(oself, &params);

    /* Actually delete the text */
    @callsuper();

    /* Now update the hotspot array to account for the deletion. */
    UpdateHotSpotArray(oself, &params, TRUE);
}
 
/***************************************************************************
 *                        MSG_META_UNDO
 ***************************************************************************
 *
 *  SYNOPSIS:   See below.
 *
 *  PARAMETERS: 
 *
 *  RETURN:     nothing
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      cassie  12/14/94        Initial Revision
 *
 **************************************************************************/
@method HotSpotTextClass, MSG_META_UNDO
{
    /*
     * Set this vardata so that when MSG_VIS_TEXT_ATTRIBUTE_CHANGE is 
     * sent, when undoing run changes, it won't repositions hotspots.
     * The hotspot array is updated in the text undo part of the undo
     * chain, which comes after the run undo part.  If the hotspots
     * are repositioned before the array is updated, we will die, die, die.
     */
    ObjVarAddData(oself, ATTR_HOT_SPOT_TEXT_NO_REPOSITION_HOT_SPOTS, 0);
    @callsuper();
    /* 
     * MSG_VIS_TEXT_ATTRIBUTE_CHANGE is the only place where the above
     * vardata is removed.  We want to make sure that it gets removed
     * so that subsequent attribute changes cause the hotspots to
     * be repositioned.  The text undo operation doesn't call this
     * message itself, so we do it here.  But make sure it is handled
     * after the entire undo chain has finished undoing.
     */
    @send, forceQueue self::MSG_VIS_TEXT_ATTRIBUTE_CHANGE();
}
 
/***************************************************************************
 *                        MSG_META_KBD_CHAR
 ***************************************************************************
 *
 *  SYNOPSIS:   Handle cursor movement keyboard chars (left, right, up, 
 *              down) specially to prevent the cursor from coming between 
 *              a hotspot and its embedded graphic.
 *
 *  PARAMETERS: word character
 *              word flags
 *              word state
 *
 *  RETURN:     nothing
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      cassie  04/29/94        Initial Revision
 *
 **************************************************************************/
@method HotSpotTextClass, MSG_META_KBD_CHAR
{
    VisTextRange range;
    dword start, end, pos;

    /* we don't care about key releases, or special key combos */
    if ( ((byte) flags & (CF_RELEASE | CF_TEMP_ACCENT | CF_STATE_KEY)) ||
	 ((byte) (character >> 8) != CS_CONTROL) )
	 @callsuper();           

    else {
	@callsuper();
		
	if ((byte) character == VC_LEFT ||
	    (byte) character == VC_RIGHT ||
	    (byte) character == VC_UP ||
	    (byte) character == VC_DOWN) {
			
	    /* get the current selection range */
	    @call self::MSG_VIS_TEXT_GET_SELECTION_RANGE(&range);
		
	    start = range.VTR_start;
	    end = range.VTR_end;
			
	    /* expand the range as if for a delete - include all hotspots */
	    if (ModifyReplaceRange(oself, &start, &end, 0)) {
									
		switch((byte) character) {
		    case VC_LEFT :
			pos = start;
			break;          
		    case VC_RIGHT :
			pos = end;
			break;  
		    default :
			pos = end;                      
			break;                          
		}
				
		/* the range was modified, change the selection */
		@call self::MSG_VIS_TEXT_SELECT_RANGE(pos, pos);
	    }
	}
    }
}

/***************************************************************************
 *                  MSG_META_LARGE_END_SELECT
 ***************************************************************************
 *
 *  SYNOPSIS:   Modify the select range so that it doesn't separate
 *              an embedded graphic and its hotspot graphics.
 *
 *  PARAMETERS: MouseReturnParams *retVal
 *              LargeMouseData *largeMouseDataStruct
 *
 *  RETURN:     nothing
 *      
 *  SIDE EFFECTS: may modify the text's selection
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      cassie  04/30/94        Initial Revision
 *
 **************************************************************************/
@method HotSpotTextClass, MSG_META_LARGE_END_SELECT
{
    VisTextRange range;
	
    /* let our superclass set the selection range based on the position */  
    @callsuper();

    /* get the selection range */
    @call self::MSG_VIS_TEXT_GET_SELECTION_RANGE(&range);

    /*
     * If the replace range is non-zero, treat this as a deletion, so
     * that all associated graphic chars will be included in the range.
     * If the replace range is 0, treat this as an insertion, so that
     * the selection point is moved after all associated graphic chars.
     */
    if ( ModifyReplaceRange(oself, &range.VTR_start, &range.VTR_end, 
			    !(range.VTR_end - range.VTR_start)) )

	/* the range was modified, reset the selection */
	@send self::MSG_VIS_TEXT_SELECT_RANGE(range.VTR_end, range.VTR_start);

}

/***************************************************************************
 *              MSG_HSTEXT_UPDATE_HOT_SPOT_ARRAY
 ***************************************************************************
 *
 *  SYNOPSIS:   Check if this message was sent as the result of an undo
 *              action.  If so, the replace operation won't be filtered,
 *              so update the HotSpotArray now.
 *
 *  PARAMETERS: VisTextReplaceParamters params
 *
 *  RETURN:     Boolean - TRUE if error
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name        Date            Description
 *      ----    ----            -----------
 *      cassie  05/16/94        Initial Revision
 *
 **************************************************************************/
@method HotSpotTextClass, MSG_HSTEXT_UPDATE_HOT_SPOT_ARRAY
{
    /* do we need to check for pasted hotspots here ??? */
    UpdateHotSpotArray(oself, &params, TRUE);
    return;
}

/***************************************************************************
 *                    MSG_HSTEXT_GET_GRAPHIC_AT_POSITION
 ***************************************************************************
 *
 *  SYNOPSIS:   See if a position is within an embedded graphic.
 *
 *  PARAMETERS: PointDWFixed point - coordinate to check
 *              RectDWFixed *rect
 *  
 *  RETURN:     NULL_HOT_SPOT_TOKEN if no graphic at point,
 *              else token of graphic
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Descriptiyon
 *      ----    ----            -----------
 *      cassie  04/14/94        Initial Revision
 *
 **************************************************************************/
@method HotSpotTextClass, MSG_HSTEXT_GET_GRAPHIC_AT_POSITION
{
    word token;
    dword position;
    HotSpotArrayElement *elemPtr;
    VisTextGraphic graphic;
    PointDWFixed myPoint;
	
    myPoint.PDF_x.DWF_int = point.PDF_x.DWF_int;
    myPoint.PDF_y.DWF_int = point.PDF_y.DWF_int;
    myPoint.PDF_x.DWF_frac = point.PDF_x.DWF_frac;
    myPoint.PDF_y.DWF_frac = point.PDF_y.DWF_frac;
	
    position = GetTextPosition(oself, &myPoint);
    if (position != TEXT_ADDRESS_PAST_END) {
	HotSpotArrayLock(oself, &elemPtr);
	token = HotSpotArrayGetToken(oself, &elemPtr, position);
	HotSpotArrayUnlock(elemPtr);
    }
    else
	token = NULL_HOT_SPOT_TOKEN;

    if (token != NULL_HOT_SPOT_TOKEN) {
	@call self::MSG_VIS_TEXT_GET_GRAPHIC_AT_POSITION(&graphic, 
							 position);
	if (elemPtr->HSAE_type != GT_GSTRING) {
	    EC_WARNING(HSTEXT_INVALID_GRAPHIC);     
	    token = NULL_HOT_SPOT_TOKEN;
	    EC_ERROR_IF(graphic.VTG_type == VTGT_GSTRING,
			  HSTEXT_INVALID_GRAPHIC_TYPE);     
	}
	else {
	    EC_WARNING_IF(elemPtr->HSAE_type != GT_GSTRING,
			  HSTEXT_INVALID_GRAPHIC_TYPE);     
	    EC_ERROR_IF(graphic.VTG_type != VTGT_GSTRING,
			  HSTEXT_INVALID_GRAPHIC_TYPE);     
	    /*
	     * bottom of graphic is at point.y + line.height
	     */
	    rect->RDWF_bottom.DWF_int = myPoint.PDF_y.DWF_int +
	    	GetLineHeight(oself, position);
	    /*
	     * top of graphic is at bottom.y - graphicSize.height
	     */
	    rect->RDWF_top.DWF_int = rect->RDWF_bottom.DWF_int -
		(dword) graphic.VTG_size.XYS_height;
	    /*
	     * graphic right is at point.x + graphicSize.width
	     */
	    rect->RDWF_left.DWF_int = myPoint.PDF_x.DWF_int;
	    rect->RDWF_right.DWF_int = myPoint.PDF_x.DWF_int +
		(dword) graphic.VTG_size.XYS_width;
					
	    rect->RDWF_top.DWF_frac = 0;
	    rect->RDWF_bottom.DWF_frac = 0; 
	    rect->RDWF_left.DWF_frac = 0;
	    rect->RDWF_right.DWF_frac = 0;
	    /*
	     * Now that we have the bounds of the embedded graphic, 
	     * check that point actually falls within those bounds.
	     * It could be above the graphic, if the line height
	     * is greater than the graphic height, which happens if
	     * there is a larger graphic on the same line.
	     */
	    if (rect->RDWF_top.DWF_int > point.PDF_y.DWF_int)
		token = NULL_HOT_SPOT_TOKEN;
	}
    }
    return(token);
}


/***************************************************************************
 *                    MSG_HSTEXT_GET_GRAPHIC_BOUNDS
 ***************************************************************************
 *
 *  SYNOPSIS:   Get bounds of an embedded graphic
 *
 *  PARAMETERS: word token - token of graphic
 *              RectDWFixed *rect
 *  
 *  RETURN:     void
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Descriptiyon
 *      ----    ----            -----------
 *      cassie  04/14/94        Initial Revision
 *
 **************************************************************************/
@method HotSpotTextClass, MSG_HSTEXT_GET_GRAPHIC_BOUNDS
{
    dword position;
    HotSpotArrayElement *elemPtr;
    VisTextGraphic graphic;
    VisTextConvertOffsetParams params;

    /*          
     * get the embedded graphic
     */
    HotSpotArrayLock(oself, &elemPtr);
    position = HotSpotArrayGetPosition(&elemPtr, token);
    EC_ERROR_IF(elemPtr->HSAE_token == NULL_HOT_SPOT_TOKEN, 
		HSTEXT_HOT_SPOT_ARRAY_ELEMENT_NOT_FOUND);
    EC_ERROR_IF(elemPtr->HSAE_type != GT_GSTRING,
		  HSTEXT_INVALID_GRAPHIC_TYPE);      
    HotSpotArrayUnlock(elemPtr);

    @call self::MSG_VIS_TEXT_GET_GRAPHIC_AT_POSITION(&graphic, position);
    EC_ERROR_IF(graphic.VTG_type != VTGT_GSTRING,
		HSTEXT_INVALID_GRAPHIC);

    /*
     * Get the top, left coordinate of the line the embedded graphic is on
     */
    params.VTCOP_offset = position;                 
    @call self::MSG_VIS_TEXT_CONVERT_OFFSET_TO_COORDINATE(&params); 

    /* Get the bottom of graphic by added line height */
    rect->RDWF_bottom.DWF_int = params.VTCOP_yPos + 
	    	    	    	GetLineHeight(oself, position);
    /* Top of graphic = bottom - graphic height */
    rect->RDWF_top.DWF_int = rect->RDWF_bottom.DWF_int -
	    	    	     graphic.VTG_size.XYS_height;

    rect->RDWF_left.DWF_int = rect->RDWF_right.DWF_int = params.VTCOP_xPos;
    rect->RDWF_right.DWF_int += graphic.VTG_size.XYS_width;

    rect->RDWF_top.DWF_frac = 0;
    rect->RDWF_bottom.DWF_frac = 0; 
    rect->RDWF_left.DWF_frac = 0;
    rect->RDWF_right.DWF_frac = 0;

    return;
}

/***************************************************************************
 *              MSG_HSTEXT_GET_HOT_SPOT_POSITION
 ***************************************************************************
 *
 *  SYNOPSIS:   Get the offset of the HotSpot object's upper left corner.
 *
 *  PARAMETERS: word token - token of hot spot
 *              PointDWFixed *offset - buffer to fill with offset
 *
 *  RETURN:     *offset filled in 
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      cassie  04/28/94        Initial Revision
 *
 **************************************************************************/
@method HotSpotTextClass, MSG_HSTEXT_GET_HOT_SPOT_POSITION
{
    dword position;
    HotSpotArrayElement *elemPtr;
    VisTextGraphic graphic;

    /*
     * Get the top, left coordinate of the embedded graphic.
     */
    GetEmbeddedGraphicOffset(oself, token, offset);

    /*          
     * get the hotspot's graphic, so we can get its offset 
     */
    HotSpotArrayLock(oself, &elemPtr);
    position = HotSpotArrayGetPosition(&elemPtr, token);
    EC_ERROR_IF(elemPtr->HSAE_token == NULL_HOT_SPOT_TOKEN, 
		HSTEXT_HOT_SPOT_ARRAY_ELEMENT_NOT_FOUND);
    EC_ERROR_IF((elemPtr->HSAE_type != (GT_VARIABLE | GT_HOTSPOT)),
		HSTEXT_INVALID_GRAPHIC); 
    HotSpotArrayUnlock(elemPtr);

    @call self::MSG_VIS_TEXT_GET_GRAPHIC_AT_POSITION(&graphic, position);

    /* if this is not a hot spot graphic, we've got problems */
    EC_ERROR_IF(graphic.VTG_type != VTGT_VARIABLE, 
		HSTEXT_INVALID_GRAPHIC);
    EC_ERROR_IF(graphic.VTG_data.VTGD_variable.VTGV_type != VTVT_HOTSPOT,
		HSTEXT_INVALID_GRAPHIC); 
						
    offset->PDF_x.DWF_int += 
	(dword) ((sword*)graphic.VTG_data.VTGD_variable.VTGV_privateData)[0];
    offset->PDF_y.DWF_int += 
	(dword) ((sword *)graphic.VTG_data.VTGD_variable.VTGV_privateData)[1];
			
    offset->PDF_x.DWF_frac = 0;
    offset->PDF_y.DWF_frac = 0;
}


/***************************************************************************
 *                  MSG_META_TEXT_SET_HYPERLINK
 ***************************************************************************
 *
 *  SYNOPSIS:   Do what's needed for setting a hyperlink on text or on a hotspot.
 *
 *  PARAMETERS:	    void (VisTextSetContextFlags flags, word file,
 *			  word context, dword rangeEnd, dword rangeStart);
 *
 *  RETURN:     nothing
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jenny	10/ 6/94	Initial version
 *
 **************************************************************************/
@method HotSpotTextClass, MSG_META_TEXT_SET_HYPERLINK
{
    /*
     * Call our superclass to do the work of setting the hyperlink.
     */
    @callsuper();
    /*
     * If we don't have the target, make sure the world knows about
     * the type change. (If we do have the target, the text library
     * takes care of this.)
     */
    pself = ObjDerefVis(oself);
    if (!(pself->VTI_intSelFlags & VTISF_IS_TARGET)) {
	GetAndSendTypeChangeNotification(oself, rangeEnd, rangeStart);
    }
}

/***************************************************************************
 *                  MSG_HSTEXT_SET_HYPERLINK_ON_HOTSPOT
 ***************************************************************************
 *
 *  SYNOPSIS:   Apply the hyperlink to the hotspot
 *
 *  PARAMETERS: void (word fileToken, word contextToken, 
 *	    	      word hotspotToken, VisTextSetContextFlags flags)
 *
 *  RETURN:     nothing
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      Edwin   6/8/94      Initial Revision
 *
 **************************************************************************/
@method HotSpotTextClass, MSG_HSTEXT_SET_HYPERLINK_ON_HOTSPOT
{
    dword rangeEnd, rangeStart;
    HotSpotArrayElement *elemPtr;

    /* get the text range for the hotspot's C_GRAPHIC char */
    HotSpotArrayLock(oself, &elemPtr);
    rangeStart = HotSpotArrayGetPosition(&elemPtr, hotspotToken);
    rangeEnd = rangeStart + 1;
    HotSpotArrayUnlock(elemPtr);

    /* set a hyperlink on that char */
    @call self::MSG_META_TEXT_SET_HYPERLINK(flags, fileToken, contextToken,
					   rangeEnd, rangeStart);
}


/***************************************************************************
 *                  MSG_HSTEXT_FOLLOW_HYPERLINK_ON_HOTSPOT
 ***************************************************************************
 *
 *  SYNOPSIS:   Follow the hyperlink to the hotspot
 *
 *  PARAMETERS: void (word token)
 *
 *  RETURN:     nothing
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      Edwin   6/8/94      Initial Revision
 *
 **************************************************************************/
@method HotSpotTextClass, MSG_HSTEXT_FOLLOW_HYPERLINK_ON_HOTSPOT
{
    HotSpotArrayElement *elemPtr;
    VisTextFollowHyperLinkParams	params;

    HotSpotArrayLock(oself, &elemPtr);
    params.VTFHLP_range.VTR_start = HotSpotArrayGetPosition(&elemPtr, token);
    params.VTFHLP_range.VTR_end = params.VTFHLP_range.VTR_start + 1;
    HotSpotArrayUnlock(elemPtr);

    @call self::MSG_VIS_TEXT_FOLLOW_HYPERLINK(&params);
}

/***************************************************************************
 *                  MSG_HSTEXT_FOLLOW_HYPERLINK_NOTIFICATION
 ***************************************************************************
 *
 *  SYNOPSIS:   To enable/disable the "follow hyperlink", depending on the 
 *              passed token.  Called by 
 *              MSG_HOT_SPOT_MANAGER_SELECTION_CHANGE_NOTIFICATION.  
 *
 *  PARAMETERS: void (word token)
 *              token - token of the selected hotspot, or
 *                      CA_NULL_ELEMENT if no selected hotspot or
 *                      mutiple selected hotspots
 *  RETURN:     nothing
 *      
 *  SIDE EFFECTS: 
 *      if the passed token is valid, a GCN notification is 
 *      sent out to enable the "follow hyperlink" trigger.  If the passed
 *      token is -1, a notification is sent to disable the 
 *      "follow hyperlink" trigger.
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      Edwin   6/28/94         Initial Revision
 *
 **************************************************************************/
@method HotSpotTextClass, MSG_HSTEXT_FOLLOW_HYPERLINK_NOTIFICATION
{
    GenerateAndSendFollowHyperlinkNotification(oself, token);
}


/*
 ***************************************************************************
 *              Internal Routines
 ***************************************************************************
 */


/***************************************************************************
 *              CheckForDeletingVariableGraphics
 ***************************************************************************
 *
 *  SYNOPSIS:   If the line which is not left justified, we may need
 *	    	to move hotspots which precede the replace range.
 *
 *  PARAMETERS: optr oself - HotSpotText object
 *              VisTextReplaceParameters *params 
 *
 *  RETURN: 	void
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      cassie  04/20/94        Initial Revision
 *
 **************************************************************************/
void CheckForDeletingVariableGraphics(optr oself, 
				      VisTextReplaceParameters *params)
{
    HotSpotArrayElement     *elemPtr;
    
    /* 
     * If the replace range is non-zero, check the text to be replaced
     * for the existence of variable graphics.
     */
    if (params->VTRP_range.VTR_end - params->VTRP_range.VTR_start > 0) {
	HotSpotArrayLock(oself, &elemPtr);

	/* find the first element after the start of the replace range */
	while ((elemPtr->HSAE_position != TEXT_ADDRESS_PAST_END) &&
	       (elemPtr->HSAE_position < params->VTRP_range.VTR_start))
	    HotSpotArrayNext(&elemPtr);

	/* for all elements in the replace range... */
	while ((elemPtr->HSAE_position != TEXT_ADDRESS_PAST_END) &&
	       (elemPtr->HSAE_position < params->VTRP_range.VTR_end)) {

	    /* 
	     * If it is a variable graphic, but not at hotspot,
	     * notify ourselves that it is going to be deleted.
	     */
	    if ((elemPtr->HSAE_type & GT_VARIABLE) && 
		(elemPtr->HSAE_type != (GT_VARIABLE | GT_HOTSPOT)))
		SendVariableGraphicNotification(oself, elemPtr->HSAE_position, 
					elemPtr->HSAE_type & ~GT_VARIABLE, 
					VGAT_DELETE);
	    HotSpotArrayNext(&elemPtr);
	}
	HotSpotArrayUnlock(elemPtr);
    }
}

/***************************************************************************
 *                 SendTypeChangeNotification
 ***************************************************************************
 *
 *  SYNOPSIS:   Send out a type change notification.
 *
 *  PARAMETERS: optr oself - HotSpotText object
 *	    	flags VisTextSetContextFlags - VTCF_TOKEN set if tokens passed
 *	    	VisTextTypeNotifyChange *data - with range and tokens filled in
 *
 *  RETURN: 	nothing
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      cassie  05/03/94        Initial Revision
 *
 **************************************************************************/
void SendTypeChangeNotification(optr oself, VisTextSetContextFlags flags,
				VisTextNotifyTypeChange *data)
{
    VisTextNotifyTypeChange   *notifyDataBlock;
    MemHandle           myDataBlock;
    EventHandle         event;

    /*
     * the hyperlink controller uses the indices, so convert tokens
     * to indices, but don't bother doing the reverse
     */
    if (flags & VTCF_TOKEN)
	@call self::MSG_VIS_TEXT_NAME_TOKENS_TO_LIST_INDICES(data);
    /*
     * copy the notify data from the stack to the block which
     * is sent with notification message
     */
    myDataBlock = MemAlloc(sizeof(VisTextNotifyTypeChange), 
		    (HF_DYNAMIC | HF_SHARABLE),  HAF_STANDARD);
    if (!myDataBlock)
	FatalError(ERROR_MEMALLOC_FAILED);

    notifyDataBlock = MemLock(myDataBlock);
    memcpy(notifyDataBlock, data, sizeof(VisTextNotifyTypeChange));
    MemUnlock(myDataBlock);

    MemInitRefCount(myDataBlock, (word) 1);
    
    event = @record  (optr) NullClass::MSG_META_NOTIFY_WITH_DATA_BLOCK(
	    MANUFACTURER_ID_GEOWORKS,
	    GWNT_TEXT_TYPE_CHANGE,
	    myDataBlock);

    @send process::MSG_GEN_PROCESS_SEND_TO_APP_GCN_LIST(
	    GCNLSF_SET_STATUS, event, myDataBlock, 
	    GAGCNLT_APP_TARGET_NOTIFY_TEXT_TYPE_CHANGE,
	    MANUFACTURER_ID_GEOWORKS);

}

/***************************************************************************
 * 	    	GetTextPosition                         
 ***************************************************************************
 *
 *  SYNOPSIS:   Calculate the text offset for the passed point.
 *
 *  PARAMETERS: optr oself - HotSpotText object
 *              PointDWFixed *point - point to calculate offset for
 *
 *  RETURN:     dword - text offset of point, or
 *                      TEXT_ADDRESS_PAST_END if point is not over text
 *              point is updated to contain upper left coordinate of the
 *              character at the returned offset
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      cassie  05/03/94        Initial Revision
 *
 **************************************************************************/
dword GetTextPosition(optr oself, PointDWFixed *point)
{
    dword position, pos, size;
    PointDWFixed coord;
    VisTextConvertOffsetParams params;

    /* First check if point is above or to the left of the doc bounds */
    params.VTCOP_offset = 0;
    @call self::MSG_VIS_TEXT_CONVERT_OFFSET_TO_COORDINATE(&params);
    if (point->PDF_y.DWF_int < params.VTCOP_yPos)
	return(TEXT_ADDRESS_PAST_END);
    if (point->PDF_x.DWF_int < params.VTCOP_xPos - GetLineAdjustment(oself,0))
	return(TEXT_ADDRESS_PAST_END);

    /* Get the number of chars for later use */
    size = @call self::MSG_VIS_TEXT_GET_TEXT_SIZE();

    /* Save the mouse event point */
    coord.PDF_x.DWF_int = point->PDF_x.DWF_int;
    coord.PDF_y.DWF_int = point->PDF_y.DWF_int;
    coord.PDF_x.DWF_frac = point->PDF_x.DWF_frac;
    coord.PDF_y.DWF_frac = point->PDF_y.DWF_frac;
	
    /* 
     * This message actually returns the position of the character whose
     * offset is closest to the passed point, not necessarily the character
     * under the point.  To deal with the case where an event falls on an
     * embedded graphic, but closer to a neighboring character, we will
     * use this message just to get the *approximate* position of the event.
     */
    position = @call self::MSG_VIS_TEXT_GET_TEXT_POSITION_FROM_COORD(point);

    /*
     * If the mouse event is to the right of the returned point,
     * that point could be the left edge of the character
     * the mouse event really occurred over, or it could be the
     * right edge of last char on the line.
     */
    if (coord.PDF_x.DWF_int >= point->PDF_x.DWF_int) {
	/*
	 * If position is the last char on the line, and that char is 
	 * that last char, period, we can easily check this by comparing
	 * the position to the size of the text.  If they are equal
	 * it is past the last char in the text.
	 */
	if (position == size)
	    return(TEXT_ADDRESS_PAST_END);  
    	/*
	 * It's not past the last char in the text, so we need to check
	 * if the position returned is actually for the first char on 
	 * the next line, which we check by getting the coordinate for
	 * the returned position and seeing if the y coords differ.
	 */
    	params.VTCOP_offset = position;
    	@call self::MSG_VIS_TEXT_CONVERT_OFFSET_TO_COORDINATE(&params);
	if (point->PDF_y.DWF_int != params.VTCOP_yPos)
	    return(TEXT_ADDRESS_PAST_END);  
	else
	    return(position);
    }
    /*
     * If the mouse event is below the line of the returned point, 
     * check that it is not off the page, below all text.
     */
    if (coord.PDF_y.DWF_int >= 
	point->PDF_y.DWF_int + GetLineHeight(oself,position)) {
	/*
	 * If the returned position is the past the last char,
	 * then position = number of chars = size.
	 */
	if (position == size)
	    return(TEXT_ADDRESS_PAST_END);  
    }
    /* 
     * Check that the returned position is not for the char 
     * to the right of the one that was actually clicked on.
     */
    if (position == 0) 
	return(position);
    else
	pos = position - 1;

    /* Get the coordinate of the previous character */
    params.VTCOP_offset = pos;      
    @call self::MSG_VIS_TEXT_CONVERT_OFFSET_TO_COORDINATE(&params);
    params.VTCOP_yPos += GetLineHeight(oself, pos);

    /*      We now have the variables set up like this:
     *      ___________________________________________________
     *          |x-params(pos)   |x-point(position) |
     *   . . .  |                |                  |       . . .
     *          |                |    x-coord       |
     *      ---------------------------------------------------
     * coord = passed point
     * point = top, left coordinate of character at "position", which
     *         is closest to "coord"
     * params = contains offset of character which is adjacent to, 
     *          but on the other side of "coord" from "point"
     *
     * If the x coordinate of the adjacent character is less than 
     * or equal to the passed x coordinate, use it.  Else use the 
     * position calculated by the text object.
     */
    if (pos == params.VTCOP_offset &&
	coord.PDF_y.DWF_int <= params.VTCOP_yPos &&
	coord.PDF_x.DWF_int >= params.VTCOP_xPos) 
	{
	    point->PDF_x.DWF_int = params.VTCOP_xPos;
	    point->PDF_x.DWF_frac = 0;
	    return(pos);
	}       
    else {
	/*
	 * Get the real offset of the character - we may actually 
	 * have its right edge in the x offset field 
	 */
	params.VTCOP_offset = position;
	@call self::MSG_VIS_TEXT_CONVERT_OFFSET_TO_COORDINATE(&params);
	return(position);       
    }
    
}

/***************************************************************************
 *                       ModifyReplaceRange                              
 ***************************************************************************
 *
 *  SYNOPSIS:   Modify the replace range to include all/none of the
 *              C_GRAPHIC chars for an embedded graphic and its hotspots.
 *
 *  PARAMETERS: optr oself - HotSPotText object
 *              dword *start, *end - range to be modified
 *              dword insCount - number of chars being inserted,
 *                               or 0 if range is to be deleted
 *                                              
 *  RETURN:     Boolean - TRUE if modified
 *      
 *  SIDE EFFECTS: start and end possibly changed
 *
 *  STRATEGY:
 *      HotSpot graphic chars follow their embedded graphic's 
 *      C_GRAPHIC character in the text stream and are contiguous.
 *
 *      If the selection does not start or end with a C_GRAPHIC char,
 *         return FALSE, because no modification was made.
 *      If the start of the replacement range is to the right of the
 *         embedded graphic, but to the left of a hotspot graphic,
 *         move the start position to the right so it does not include
 *         any of the hotspot graphics for the embedded graphic.
 *      If the end of the replacement range is to the right of the 
 *         embedded graphic, but to the left of a hotspot graphic,
 *         move the end position to the right so it does include all
 *         hotspot graphics.
 *      If the range has been adjusted, return FALSE to prevent replacement.
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      cassie  04/21/94        Initial Revision
 *
 **************************************************************************/
Boolean ModifyReplaceRange(optr oself, dword *start, dword *end, 
			   dword insCount)
{
    dword index, direction;
    VisTextGraphic graphic;
    HotSpotArrayElement *elemPtr;
    Boolean retVal = FALSE;             /* default: no change */
    word count;                         
		
    HotSpotArrayLock(oself, &elemPtr);
    index = 0;                          /* initial adjustment amount */

    /*
     * If the replace range ends on a C_GRAPHIC character, we
     * must move the end of the range out to include all the
     * hotspot graphics for the associated embedded graphic.
     */
    if (HotSpotArrayGetToken(oself, &elemPtr, *end) != NULL_HOT_SPOT_TOKEN) {

	/*      
	 * for all elements immediately adjacent to this one...
	 */     
	do {
	    /* Get the VisTextGraphic token for this position */    
	    @call self::MSG_VIS_TEXT_GET_GRAPHIC_AT_POSITION(
		    &graphic, *end+index);
	    /* Is it a hotspot graphic? Then adjust the end position */
	    if (elemPtr->HSAE_type == (GT_VARIABLE | GT_HOTSPOT)) {
		index++; 
		EC_ERROR_IF((graphic.VTG_type != VTGT_VARIABLE) ||
		(graphic.VTG_data.VTGD_variable.VTGV_type != VTVT_HOTSPOT),
			    HSTEXT_INVALID_GRAPHIC);
	    }
	    /* Else we've reached a non-hotspot graphic, so stop */
	    else {
	    	EC_ERROR_IF((graphic.VTG_type == VTGT_VARIABLE) &&
			    (graphic.VTG_data.VTGD_variable.VTGV_type == 
			     VTVT_HOTSPOT),
			    HSTEXT_INVALID_GRAPHIC);
		break;
	    }
	    /* get the next element */      
	    HotSpotArrayNext(&elemPtr);     
	} while (elemPtr->HSAE_position == *end + index);
    }

    HotSpotArrayUnlock(elemPtr);
    HotSpotArrayLock(oself, &elemPtr);      /* get ptr to first element */
	
    if (index != 0)                 /* if the end position was adjusted */
	retVal = TRUE;              /* TRUE: range was modified */
		
    if (*start == *end && insCount > 0) {
    /*
     * This a true insertion, so adjust both start and end to either
     * precede the embedded grahic, or follow it and its hotspots.
     */
	*start = *end + index;
	*end = *start;
    }       
    else {
    /* 
     * This is either a replace or a delete range operation. The start
     * position must be adjusted if it falls between an embedded graphic
     * and its hotspot characters.
     */     

	*end += index;              /* now adjust the end of the range */
	index = 0;                  /* initial start adjustment amount */
		 
	if (HotSpotArrayGetToken(oself, &elemPtr, *start) 
	    != NULL_HOT_SPOT_TOKEN) 
	{       
	    /*
	     *  We want to move the start position to the left if this is
	     *  a deletion, as the cursor appears to be just to the right of
	     *  the embedded graphic, whereas it may be to the right of
	     *  hotspot graphic chars which come after it.  
	     *
	     *  But if this is a replace, we want to move the start position
	     *  to the right, so that new characters are inserted after all
	     *  hotspot chars for an embedded graphic.
			 */
	    direction = (insCount > 0) ? 1 : -1;
		 
	    /*      
	     * for all graphics immediately adjacent to this one...
	     */     
	    do {
		/* Get the VisTextGraphic token for this position */    
		@call self::MSG_VIS_TEXT_GET_GRAPHIC_AT_POSITION(
			&graphic, *start+index*direction);
						
		/* Is it a hotspot graphic? Then adjust the start position  */
		if (elemPtr->HSAE_type == (GT_VARIABLE | GT_HOTSPOT)) {
		    index++;
		    EC_ERROR_IF((graphic.VTG_type != VTGT_VARIABLE) ||
			    	(graphic.VTG_data.VTGD_variable.VTGV_type 
				 != VTVT_HOTSPOT),
				HSTEXT_INVALID_GRAPHIC);
		}
		/* Else we've reached an embedded graphic, so stop */
		else {
		    EC_ERROR_IF(graphic.VTG_type != VTGT_GSTRING,
				HSTEXT_INVALID_GRAPHIC);
		    break;
		}
		/* get the next/previous element */     
		if (direction == 1)
		    count = HotSpotArrayNext(&elemPtr);
		else
		    count = HotSpotArrayPrev(&elemPtr);             
		    EC_WARNING_IF(!count, 
			HSTEXT_HOT_SPOT_ARRAY_AT_LAST_ELEMENT); 
	    } while (elemPtr->HSAE_position == *start + index*direction);

	    /*
	     * Now adjust the start position, if necessary
	     */
	    if (index != 0) {
		retVal = TRUE;              /* TRUE: range was modified */
		*start = *start + index*direction;
	    }
	}       
    }
    HotSpotArrayUnlock(elemPtr);
    return(retVal);
}

/***************************************************************************
 *              GetEmbeddedGraphicForHotSpot
 ***************************************************************************
 *
 *  SYNOPSIS:   Given a hotspot token, find its embedded graphic.    
 *
 *  PARAMETERS: optr oself - HotSpotText object
 *              word token - token of HotSpot
 *              dword *position - base position in text of embedded graphic
 *              VisTextGraphic *graphic - buffer to fill in 
 *
 *  RETURN:     token of embedded graphic, 
 *              position and graphic filled in 
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      cassie  04/28/94        Initial Revision
 *
 **************************************************************************/
word GetEmbeddedGraphicForHotSpot(optr oself, word token, dword *position,
				  VisTextGraphic *graphic)
{
    word count = 1, gtoken = token;
    HotSpotArrayElement *elemPtr;
	
    HotSpotArrayLock(oself, &elemPtr);
    HotSpotArrayGetPosition(&elemPtr, gtoken);      
    EC_ERROR_IF(elemPtr->HSAE_token == NULL_HOT_SPOT_TOKEN,
		HSTEXT_HOT_SPOT_ARRAY_ELEMENT_NOT_FOUND);  
				
    /* move forward one element so loop can back up to this element */
    HotSpotArrayNext(&elemPtr);

    while (count) {
	/* back up one element */       
	count = HotSpotArrayPrev(&elemPtr);
	*position = elemPtr->HSAE_position;
	gtoken = elemPtr->HSAE_token;

	/* If it's a gstring graphic, we found what we were looking for */
	if (elemPtr->HSAE_type == GT_GSTRING) 
	    break;      
    }
    EC_ERROR_IF(!count, HSTEXT_HOT_SPOT_ARRAY_ELEMENT_NOT_FOUND);  
			
    /* if this is not a gstring graphic we've got problems */
    EC_ERROR_IF(elemPtr->HSAE_type != GT_GSTRING,
		HSTEXT_INVALID_GRAPHIC); 
						
    HotSpotArrayUnlock(elemPtr);

    /* Get the VisTextGraphic for this character */ 
    @call self::MSG_VIS_TEXT_GET_GRAPHIC_AT_POSITION(graphic, *position);
    EC_ERROR_IF(graphic->VTG_type != VTGT_GSTRING,
		HSTEXT_INVALID_GRAPHIC);

    return(gtoken);
}


/***************************************************************************
 *              GetEmbeddedGraphicOffset
 ***************************************************************************
 *
 *  SYNOPSIS:   Given a hotspot token, get the upper left corner of
 *	    	its embedded graphic
 *
 *  PARAMETERS: optr oself - HotSpotText object
 *              word token - token of HotSpot
 *	    	PointDWFixed *offset - buffer to be filled
 *
 *  RETURN:     void
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      cassie  04/28/94        Initial Revision
 *
 **************************************************************************/
void GetEmbeddedGraphicOffset(optr oself, word token, PointDWFixed *offset)
{
    VisTextGraphic graphic;
    dword position;
    VisTextConvertOffsetParams params;

    /*
     * Get the embedded graphic for this hotspot
     */
    if (GetEmbeddedGraphicForHotSpot(oself, token, &position, &graphic) ==
	NULL_HOT_SPOT_TOKEN)
	FatalError(HSTEXT_HOT_SPOT_ARRAY_ELEMENT_NOT_FOUND);

    /*
     * Get the top, left coordinate of the embedded graphic.
     */
    params.VTCOP_offset = position;                 
    @call self::MSG_VIS_TEXT_CONVERT_OFFSET_TO_COORDINATE(&params); 
    params.VTCOP_yPos += GetLineHeight(oself, position) -
		    	 graphic.VTG_size.XYS_height;
    offset->PDF_x.DWF_int = params.VTCOP_xPos;
    offset->PDF_y.DWF_int = params.VTCOP_yPos;
    offset->PDF_x.DWF_frac = 0;
    offset->PDF_y.DWF_frac = 0;
    return;
}


/***************************************************************************
 *              GetLineHeight
 ***************************************************************************
 *
 *  SYNOPSIS:   Given a text position, find the height of the line
 *	    	for that position
 *
 *  PARAMETERS: optr oself - HotSpotText object
 *              dword position - text offset
 *
 *  RETURN:     dword - line height
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      cassie  04/28/94        Initial Revision
 *
 **************************************************************************/
dword GetLineHeight(optr oself, dword position)
{
    VisTextGetLineInfoParameters lineParams;
    VisTextGetLineInfoReturnValues retVal;
    LineInfo line;

    lineParams.VTGLIP_buffer = &line;
    lineParams.VTGLIP_bsize = sizeof(line);
    lineParams.VTGLIP_line = 
	@call self::MSG_VIS_TEXT_GET_LINE_FROM_OFFSET(position);
    @call self::MSG_VIS_TEXT_GET_LINE_INFO(&retVal, &lineParams);

    return((dword)line.LI_blo.WBF_int);
}


/***************************************************************************
 *              GetLineAdjustment
 ***************************************************************************
 *
 *  SYNOPSIS:   Given a text position, find the adjustment (justification)
 *	    	value for that line.
 *
 *  PARAMETERS: optr oself - HotSpotText object
 *              dword position - text offset
 *
 *  RETURN:     word - adjustment
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      cassie  04/28/94        Initial Revision
 *
 **************************************************************************/
word GetLineAdjustment(optr oself, dword position)
{
    VisTextGetLineInfoParameters lineParams;
    VisTextGetLineInfoReturnValues retVal;
    LineInfo line;

    lineParams.VTGLIP_buffer = &line;
    lineParams.VTGLIP_bsize = sizeof(line);
    lineParams.VTGLIP_line = 
	@call self::MSG_VIS_TEXT_GET_LINE_FROM_OFFSET(position);
    @call self::MSG_VIS_TEXT_GET_LINE_INFO(&retVal, &lineParams);

    return(line.LI_adjustment);
}


/***************************************************************************
 *                  GetAndSendTypeChangeNotification
 ***************************************************************************
 *
 *  SYNOPSIS:   Generate a type change notification if text has target,
 *
 *  PARAMETERS:	void (optr oself, dword rangeEnd, dword rangeStart);
 *
 *  RETURN:     nothing
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jenny	10/ 6/94	Initial version
 *	cassie  12/12/94    	pulled out of MSG_META_SET_HYPERLINK and 
 *	    	    	    	modified
 *
 **************************************************************************/
void GetAndSendTypeChangeNotification(optr oself, dword rangeEnd, 
				      dword rangeStart)
{
    VisTextNotifyTypeChange notifyData;
    word typeToken;

    typeToken = @call self::MSG_VIS_TEXT_GET_TYPE(0, 
				&(notifyData.VTNTC_typeDiffs), 
				&(notifyData.VTNTC_type),
				rangeEnd, rangeStart);
    notifyData.VTNTC_typeToken = DWORD_TOKEN(typeToken);

    SendTypeChangeNotification(oself, VTCF_TOKEN, &notifyData);
}


/***************************************************************************
 *               GenerateAndSendFollowHyperlinkNotification
 ***************************************************************************
 *
 *  SYNOPSIS:   Generate a type change notification if text has target,
 *
 *  PARAMETERS:	void (optr oself, dword rangeEnd, dword rangeStart);
 *
 *  RETURN:     nothing
 *      
 *  SIDE EFFECTS:
 *
 *  REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *	cassie  12/12/94    	pulled out of MSG_HSTEXT_FOLLOW_HYPERLINK
 * 	    	    	    	    _NOTIFICATION
 *
 **************************************************************************/
void GenerateAndSendFollowHyperlinkNotification(optr oself, word token)
{
    VisTextNotifyTypeChange   notifyData;
    HotSpotArrayElement *elemPtr;
    dword               rangeEnd, rangeStart, size;
    word    	    	typeToken;

    if (token != CA_NULL_ELEMENT) {
	HotSpotArrayLock(oself, &elemPtr);
	HotSpotArrayGetPosition(&elemPtr, token);      
	EC_WARNING_IF(elemPtr->HSAE_token == NULL_HOT_SPOT_TOKEN,
		HSTEXT_HOT_SPOT_ARRAY_ELEMENT_NOT_FOUND);  
	/* 
	 * If no element with this token was found, it could be that
	 * we are in the midst of the undo of an undo of a hotspot delete,
	 * and the hotspot hasn't actually been deleted yet, but its
	 * element has been (UpdateHotSpotArray was called before 
	 * MSG_HOT_SPOT_MANAGER_DESTROY_HOT_SPOT was received).  We need
	 * to know that below, so set token to the found element's token.
	 */
	token = elemPtr->HSAE_token;
	rangeStart = rangeEnd = elemPtr->HSAE_position;
	rangeEnd++;
	HotSpotArrayUnlock(elemPtr);
    }
    size = @call self::MSG_VIS_TEXT_GET_TEXT_SIZE();
    /*
     * If a hotspot is selected, and it is at a valid position,
     * get the type run which is set on its graphic char.
     */
    if ((token != CA_NULL_ELEMENT) && (rangeEnd < size)) {
	/* get the type information for the hotspot's C_GRAPHIC char */
	typeToken = @call self::MSG_VIS_TEXT_GET_TYPE(0, 
				&(notifyData.VTNTC_typeDiffs), 
				&(notifyData.VTNTC_type),
				rangeEnd, rangeStart);
	notifyData.VTNTC_typeToken = DWORD_TOKEN(typeToken);
    }
    else {
	notifyData.VTNTC_type.VTT_hyperlinkName = CA_NULL_ELEMENT;
	notifyData.VTNTC_type.VTT_hyperlinkFile = CA_NULL_ELEMENT;
	notifyData.VTNTC_type.VTT_context = CA_NULL_ELEMENT;
    }
    /*
     * Send the type change notification so that the hyperlink
     * controller knows whether there is a hyperlink selected 
     */
    SendTypeChangeNotification(oself, VTCF_TOKEN, &notifyData);
}

