/*###########################################################################
	IndexArray-Routinen
/*###########################################################################*/

@include <stdapp.goh>
//@include <Objects\GGadGetC.goh>
@include <gstring.h>
@include <graphics.h>
#include <fileEnum.h>
#include <stdlib.h>
#include <hugearr.h>
#include <Ansi/stdio.h>
#include <Ansi/string.h>
#include <fileEnum.h>
#include <file.h>



@include "dirlist.goh"


@extern chunk ParentBmp;
@extern chunk FolderBmp;
@extern chunk FileBmp;
@extern chunk PictureBmp;
@extern chunk ExecBmp;
@extern chunk GeoDocBmp;
@extern chunk GeoExecBmp;
@extern chunk ArchiveBmp;
@extern chunk ArchiveFolderBmp;


#define GetMem( size ) 	MemAlloc( size, HF_SWAPABLE, HAF_ZERO_INIT)
/* FileToolRoutinen - ausgelagerte Pfad-Bearbeitung */

/* internalMakeParentPath:
   k�rzt einen Pfad auf den Parentpath ein.
   Return: TRUE; wenn kein Parent m�glich ist (i.a. Leerstrung oder "\")
	   FALSE wenn OK                                                 */
Boolean InternalMakeParentPath(char * path, Boolean slashAlso );

/* InternalDirListCompare
	Ausgekoppl�ete Routine zum vergleich von Struktuen*/
int InternalDirListCompare(char *p1st, char *p2nd, int nameOffs, int attrOffs);


/*--------------------- IndexArrayCreatePath ---------------------
	Anlegen eines Pfad-Eintrags ins IndexArray. Stellt sicher da� der
	Eintrag und alle Parents existieren.
	Existiert er schon, wird er nicht nochmal angelegt.
	ruft: IndexArrayExistPath und IndexArrayCreateNewPath
	Return: Index des Eintrages (gefunden oder neu)
 ---------------------------------------------------------------------------*/
extern dword IAEXPORT IndexArrayCreatePath(VMFileHandle vmFile, VMBlockHandle indexArray,
		char * path)
  {
  dword pathIndex, parent;
  IndexArrayBlockHeader * iPtr;
  word size;

  if ( IndexArrayExistPath( vmFile, indexArray, path,
					&pathIndex ) ) return pathIndex;

  pathIndex = IndexArrayCreateNewPath(vmFile, indexArray, path);

  parent = IndexArrayFindParentIndex(vmFile, indexArray, path);

  HugeArrayLock(vmFile, indexArray, pathIndex, (void**)&iPtr, &size);
  iPtr->parentLink = parent;
  HugeArrayDirty(iPtr);
  HugeArrayUnlock(iPtr);
  /*
  Hier neuen Pfad als subdir des Parents eintragen
  */
  if ( parent != IA_NO_PARENT)
	  IndexArrayAppendSubdir(vmFile,indexArray,parent,pathIndex);

  return pathIndex;
  }

/*--------------------- IndexArrayCreateNewPath ---------------------
   Anlegen eines leeren Pfadeintrages ohne Parent-Link und irgentwelche
   File- oder Subdir-Links. Keine Tests ob Parents existieren.
   Return: Index des neu angelegten Eintrages im IndexArray
 ---------------------------------------------------------------------------*/
extern dword IAEXPORT IndexArrayCreateNewPath(VMFileHandle vmFile, VMBlockHandle indexArray,
		char * path)
  {
  word pathLen, size;
  dword count;
  IndexArrayBlockHeader * iPtr;

  pathLen = strlen(path);
  size = sizeof(IndexArrayBlockHeader) - IA_MAX_INDEX_PATH_LEN + pathLen + 1
	+ 8* IA_INITIAL_INDEX_COUNT + 5;

  /*asm push di
  asm mov di, vmFile*/
  count = HugeArrayGetCount(vmFile, indexArray);
  /*asm pop di*/
  HugeArrayAppend(vmFile, indexArray, size, 0 );
  HugeArrayLock(vmFile, indexArray, count, (void**)&iPtr, &size);

  iPtr->fileSizeAtLevel = 0;
  iPtr->filesAtLevel = 0;
  iPtr->fileCount = 0;
  iPtr->fileHiddenCount = 0;
  iPtr->fileMaxCount = IA_INITIAL_INDEX_COUNT;
  iPtr->dirCount = 0;
  iPtr->dirMaxCount = IA_INITIAL_INDEX_COUNT;
  iPtr->pathLen = pathLen;

// dirArrayOffset und FileArrayOffset geben das Offset in dword an
  iPtr->dirArrayOffset = ( sizeof(IndexArrayBlockHeader)
	- IA_MAX_INDEX_PATH_LEN + pathLen + 5 ) >>2;
  iPtr->fileArrayOffset = (iPtr->dirArrayOffset) + IA_INITIAL_INDEX_COUNT;
  strcpy(iPtr->pathName, path);

  HugeArrayDirty(iPtr);
  HugeArrayUnlock(iPtr);
  return count;
  }

/*--------------------- IndexArrayExistPath ---------------------
   Testen ob ein Pfadeintrag schon existiert.
   Return: TRUE, wenn er schon existiert, FALSE wenn nicht
   index enth�lt ggf. den Index des existierenden Pfades
 ---------------------------------------------------------------------------*/
extern Boolean IAEXPORT IndexArrayExistPath(VMFileHandle vmFile, VMBlockHandle indexArray,
		char * path, dword * index)
  {
  word len, size/*, k*/;
  dword count, n;
  IndexArrayBlockHeader * iPtr;

  /*asm push di
  asm mov di, vmFile*/
  count = HugeArrayGetCount(vmFile, indexArray);
  /*asm pop di*/
  if (count == 0) return FALSE;		// Array leer-> ext. nicht
  len = strlen(path);
  HugeArrayLock(vmFile,indexArray,0,(void**)&iPtr,&size);

  n = 0;
  do {
     if ( iPtr->pathLen == len ) if ( !strcmp(iPtr->pathName, path) ) break;
     n++;
     if (count ==n) break;
//     HugeArrayNext((void**)&iPtr);
//asm cli
	  HugeArrayUnlock(iPtr);
	  HugeArrayLock(vmFile,indexArray,n,(void**)&iPtr,&size);
//asm sti
     } while ( 1 );
  HugeArrayUnlock(iPtr);
  if ( n== count )	{
		return FALSE;		// not found
		}
  *index = n;
  return TRUE;
  }


/*--------------------- IndexArrayFindParentIndex ---------------------
   Suchen des Indexes des Parent-Pfades im IndexArray.
   Routine stellt sicher, da� die Parentpfade existieren.
 ---------------------------------------------------------------------------*/
extern dword IAEXPORT IndexArrayFindParentIndex(VMFileHandle vmFile, VMBlockHandle indexArray,
		char * path)
  {
  dword parent;
  int n;
  char * s;
  MemHandle mh;

  n = strlen(path);
  if ( n==0) return IA_NO_PARENT;

  mh = GetMem(n+1);
  s = MemLock(mh);
  strcpy(s,path);

  InternalMakeParentPath(s,TRUE);
  parent = IndexArrayCreatePath(vmFile, indexArray, s);

  MemFree(mh);
  return parent;
  }

/*--------------------- IndexArrayCreateFileEntry ---------------------
   Anlegen eines Eintrages f�r eine Datei in ein IndexArray.
   Routine stellt sicher, da� der Pfad existiert, tr�gt den Index ein
   und updatet die Dateigr��en im Pfad (incl. Parents)
 ---------------------------------------------------------------------------*/
extern void IAEXPORT IndexArrayCreateFileEntry(VMFileHandle vmFile, VMBlockHandle indexArray,
		char * path, dword entryIndex, dword fileSize)
	{
	IndexArrayCreateFileEntryEx(vmFile, indexArray, path, entryIndex, fileSize, FALSE);
	}

extern void IAEXPORT IndexArrayCreateFileEntryEx(VMFileHandle vmFile, VMBlockHandle indexArray,
		char * path, dword entryIndex, dword fileSize, Boolean hidden)
  {
  dword pathIndex;

  pathIndex = IndexArrayCreatePath(vmFile, indexArray, path);
  IndexArrayAppendFileEx(vmFile, indexArray, pathIndex, entryIndex, hidden);
/*  if (fileSize > 0 )*/
	if(!hidden)
	IndexArrayIncrementSize(vmFile, indexArray, pathIndex, fileSize);
  }

/*--------------------- IndexArrayAppendFile ---------------------
   Anh�ngen eines Datei-Eintrages an einen gefundenen Eintrag im Index-Array
 ---------------------------------------------------------------------------*/
extern void IAEXPORT IndexArrayAppendFile(VMFileHandle vmFile, VMBlockHandle indexArray,
		dword pathIndex, dword entryIndex)
	{
	IndexArrayAppendFile(vmFile, indexArray, pathIndex, entryIndex);
	}

extern void IAEXPORT IndexArrayAppendFileEx(VMFileHandle vmFile, VMBlockHandle indexArray,
		dword pathIndex, dword entryIndex, Boolean hidden)
  {
  IndexArrayBlockHeader * iPtr;
  word size, offs;
  dword * arrayPtr;

  HugeArrayLock(vmFile, indexArray, pathIndex, (void**)&iPtr,&size);

  iPtr->fileCount += 1;
  if(hidden)
	{
    iPtr->fileHiddenCount += 1;
	}

  if ( (iPtr->fileCount) > (iPtr->fileMaxCount) )
	{
	// Block resize, neuer Index passt nicht mehr rein.
	iPtr->fileMaxCount += IA_ADDITIONAL_INDEX_COUNT;
	size += 4*IA_ADDITIONAL_INDEX_COUNT;
	HugeArrayDirty(iPtr);
	HugeArrayUnlock(iPtr);
	HugeArrayResize(vmFile, indexArray, pathIndex, size);
	HugeArrayLock(vmFile, indexArray, pathIndex, (void**)&iPtr,&size);
	}

  offs = (iPtr->fileCount) + (iPtr->fileArrayOffset) - 1;
  arrayPtr = (dword*)iPtr;

  if(hidden)
	{
	arrayPtr[offs] = entryIndex;
	}
  else
	{
	word hiddenCount = iPtr->fileHiddenCount;
	while(hiddenCount)
		{
		offs--;
		arrayPtr[offs + 1] = arrayPtr[offs];
		hiddenCount--;
		}
	arrayPtr[offs] = entryIndex;
	}

  HugeArrayDirty(iPtr);
  HugeArrayUnlock(iPtr);
  }


/*--------------------- IndexArrayAppendSubdir ---------------------
    Anh�ngen eines Subdir-Eintrages an einen gefundenen Eintrag im Index-Array
 ---------------------------------------------------------------------------*/
extern void IAEXPORT IndexArrayAppendSubdir(VMFileHandle vmFile, VMBlockHandle indexArray,
		dword pathIndex, dword dirIndex)
  {
  IndexArrayBlockHeader * iPtr;
  word size, offs;
  dword * arrayPtr;

  HugeArrayLock(vmFile, indexArray, pathIndex, (void**)&iPtr,&size);

  iPtr->dirCount += 1;
  if ( (iPtr->dirCount) > (iPtr->dirMaxCount) )
	{
	// Block resize, neuer Index passt nicht mehr rein.
	iPtr->dirMaxCount += IA_ADDITIONAL_INDEX_COUNT;
	size += 4*IA_ADDITIONAL_INDEX_COUNT;
	HugeArrayDirty(iPtr);
	HugeArrayUnlock(iPtr);
	HugeArrayResize(vmFile, indexArray, pathIndex, size);
	HugeArrayLock(vmFile, indexArray, pathIndex, (void**)&iPtr,&size);

	// file-Array nach hinten verschieben
	arrayPtr = (dword*)iPtr;
	memmove(&(arrayPtr[(iPtr->fileArrayOffset)+IA_ADDITIONAL_INDEX_COUNT]),
		&(arrayPtr[iPtr->fileArrayOffset]),4*(iPtr->fileMaxCount) );
	iPtr->fileArrayOffset += IA_ADDITIONAL_INDEX_COUNT;
	}

  offs = (iPtr->dirCount) + (iPtr->dirArrayOffset) - 1;
  arrayPtr = (dword*)iPtr;
  arrayPtr[offs] = dirIndex;
  HugeArrayDirty(iPtr);
  HugeArrayUnlock(iPtr);
  }

/*--------------------- IndexArrayIncrementSize ---------------------
   Updaten der Dateigr��en eines Eintrages im Index-Array.
   Routine ruft sich rekursiv um auch die Parents anzugleichen
 ---------------------------------------------------------------------------*/
extern void IAEXPORT IndexArrayIncrementSize(VMFileHandle vmFile, VMBlockHandle indexArray,
		dword pathIndex, dword fileSize)
  {
  IndexArrayBlockHeader * iPtr;
  word size;
  dword parent;

  HugeArrayLock(vmFile, indexArray, pathIndex, (void**)&iPtr,&size);
  iPtr->fileSizeAtLevel += fileSize;
  iPtr->filesAtLevel += 1;	// Anzahl der Dateien

  parent = iPtr->parentLink;

  HugeArrayDirty(iPtr);
  HugeArrayUnlock(iPtr);

  if ( parent != IA_NO_PARENT )
	IndexArrayIncrementSize(vmFile,indexArray, parent, fileSize);
  }



/* Indizierter Zugriff auf einen Eintrag in einen AndexArrayBlock
   Bei Aufruf: kein Array gelockt
   Rotine Lockt das IndexArray(curentIndex) , sucht den Eintrag entryNr
   (unlockt bei Bedarf das indexArray) und lockt das Element im richtigen
   Array, auf das der Eintrag im Block verweist.
   Liefert in ptr einen void-Zeigre auf das Element und in lockedIndex
		die Index-Nr des Elements
   Return: IA_ET_PARENT | IA_ET_FILE | IA_ET_DIR
	bei IA_ET_PARENT und IA_ET_DIR ist das Index-Array gelockt,
	bei IA_ET_FILE ist das Entry-Array gelockt

   Achtung! in jedem Fall mu� das nunmehr gelockte Array mit
	HugeArrayUnlock(ptr) freigegeben werden! */
extern int IAEXPORT IndexArrayLockEntry( VMFileHandle vmFile, VMBlockHandle indexArray,
	VMBlockHandle entryArray, dword currentIndex, dword entryNr,
	void ** ptr, dword * lockedIndex)
  {
  IndexArrayBlockHeader * iPtr;
/*  FileInZip * fizp; */
  void *vp;
  word size,entry,offs;
  dword parent, index, *arrayPtr;

  HugeArrayLock(vmFile,indexArray,currentIndex,(void**)&iPtr,&size);

  parent = iPtr->parentLink;

  if ( parent == IA_NO_PARENT )
	{
	// es existiert kein Paren -> keine Sonderbehandlung
	entry = entryNr;		// Eintrag entryNr anzuzeigen 0...
	}
  else {
	// es existiert ein Parent
	if ( entryNr == 0 )
	   {
	   // Es ist das Parent-verzeichnis ausgew�hlt
	   *ptr = iPtr;
	   *lockedIndex = currentIndex;
	   return IA_ET_PARENT;
	   }
	else {
	   entry = entryNr -1;	// Eintrag entry anzuzeigen 0....
	   }
	}

  // entry enth�lt die Nummer des Eintrages im Index-Block: 0...

  if (entry >= iPtr->dirCount )
	{
	// Es ist eine Datei-> Zugriff auf EntryArray
	offs = entry - iPtr->dirCount + iPtr->fileArrayOffset;
	arrayPtr = (dword*)iPtr;
	index = arrayPtr[offs];

	HugeArrayUnlock(iPtr);
	HugeArrayLock(vmFile, entryArray, index, (void**)&vp,&size);
	*ptr = vp;
	*lockedIndex = index;
	return IA_ET_FILE;
	}
  else	{
	// Es ist ein Verzeichnis: Zugriff aufs Index_array
	offs = entry + iPtr->dirArrayOffset;
	arrayPtr = (dword*)iPtr;
	index = arrayPtr[offs];
	HugeArrayUnlock(iPtr);
	HugeArrayLock(vmFile, indexArray, index, (void**)&iPtr,&size);
	*ptr = iPtr;
	*lockedIndex = index;
	return IA_ET_DIR;
	}
  }

/*--------------------- DirListEnumSubdir ---------------------
	Durchsuchen eines Verzeichnisses. F�r jede Datei, die auf 'flags'
	passt wird eine Struktur DLStandardEnumType im alloziierten
	Speicher mh zur�ckgegeben
	- flags bestimmt ob Verzeichnisse (DL_EF_DIRS), Dateien (DL_EF_FILES)
	  und Links (DL_EF_LINKS, DL_EF_LINKS_ONLY) gefunden werden sollen
	  Kombination mit | ( z.B. DL_EF_FILES | DL_EF_DIRS) ist zul�ssig
	  : DL_EF_LINKS | DL_EF_LINKS_ONLY == DL_EF_LINKS_ONLY
	Return: Anzahl der gefunden Dateien
 ---------------------------------------------------------------------------*/
extern int IAEXPORT DirListEnumSubdir (MemHandle * mh, word flags)
 {
 /* Beschreibung der Struktur der zur�ckzuliefernden Werte:
    FEAD_value enth�lt das offset, ab dem das geforderte Attribut in die
		Struktur zu schreiben ist
    FEAD_size enth�lt die maximal zur Verf�gung stehende Gr��e f�r das
		geforderte Attribut */
 FileExtAttrDesc stdReturnAttrs[4] = {
	{FEA_NAME,	(void*)DL_SET_NAME_OFFSET, (word)sizeof(FileLongName),0},
	{FEA_FILE_TYPE,	(void*)DL_SET_TYPE_OFFSET, (word)sizeof(GeosFileType),0},
	{FEA_FILE_ATTR,	(void*)DL_SET_ATTR_OFFSET,	1,0},
	{FEA_END_OF_LIST,0,0,0}};
 int count;

 count = DirListExtendedEnumSubdir( mh, flags, stdReturnAttrs,
					sizeof(DLStandardEnumType));
 count = DirListToolAdjustLinkDirs( mh, sizeof(DLStandardEnumType),
				count, flags, DL_SET_ATTR_OFFSET);
 DirListSortEnumSubdirResult(*mh, count);
 return count;
 }

/*--------------------- DirListExtendedEnumSubdir ---------------------
	Durchsuchen eines Verzeichnisses. F�r jede Datei, die auf 'flags'
	passt wird eine Struktur im alloziierten Speicher mh zur�ckgegeben,
	die durch returnDesc und returnSize beschrieben wird.
	- returnDesc wird direkt �ber das Feld FEP_returnAttrs
	  und returnSize �ber FEP_returnSize an FileEnum() weitergeleitet
	- Beschreibung der Belegung von returnDesc: Concepts, File System, S.656
	- flags bestimmt ob Verzeichnisse (DL_EF_DIRS), Dateien (DL_EF_FILES)
	  und Links (DL_EF_LINKS, DL_EF_LINKS_ONLY) gefunden werden sollen
	  Kombination mit | ( z.B. DL_EF_FILES | DL_EF_DIRS) ist zul�ssig
	  : DL_EF_LINKS | DL_EF_LINKS_ONLY == DL_EF_LINKS_ONLY
	Return: Anzahl der gefunden Dateien
 ---------------------------------------------------------------------------*/
extern int IAEXPORT DirListExtendedEnumSubdir(MemHandle * mh, word flags,
		FileExtAttrDesc * returnAttrs, word returnSize)
  {
  dword requestFlags = FA_SUBDIR;
  dword avoidFlags = FA_SUBDIR | FA_LINK;

//  int  count;
  word noFitCount = 0;
  dword	enumFlags;

  FileExtAttrDesc	matchAttrDesc[2]; 	/* Array mit 2 Elementen */
  FileEnumParams	enumParams;

  /*EnumParameter*/
	enumParams.FEP_returnAttrs = (void *) returnAttrs;
	enumParams.FEP_returnSize = returnSize;
	enumParams.FEP_matchAttrs = &matchAttrDesc[0];
	enumParams.FEP_bufSize = FEP_BUFSIZE_UNLIMITED;
	enumParams.FEP_skipCount =0;
	enumParams.FEP_callback = NULL;
	enumParams.FEP_callbackAttrs = NULL;
	enumParams.FEP_searchFlags = FILE_ENUM_ALL_FILE_TYPES;
	if ( flags & DL_EF_DIRS )
		 enumParams.FEP_searchFlags |= FESF_DIRS;

  /* Match-Descriptor: Nur Dateien die den hier �bergebenen Paramtern
	entsprechen (in diesem Fall: bestimmte Attribute gesetzt oder
	zur�ckgesetzt sind) werden gefunden */
    /* Erste Element des Arrays */
	matchAttrDesc[0].FEAD_attr = FEA_FILE_ATTR;	/* was ist zu untersuchen */
	matchAttrDesc[0].FEAD_size = 2;
    /* Belegen der Flags in FEAD_value:
       h�herwertiges word: die Attribute d�rfen nicht gesetzt sein
       niederwertiges word: die Attribute m�ssen gesetzt sein */
	if ( flags & DL_EF_FILES ) requestFlags &= ~FA_SUBDIR;
	if ( flags & DL_EF_DIRS ) avoidFlags &= ~FA_SUBDIR;
	if ( flags & DL_EF_LINKS_ONLY ) {
			avoidFlags &= ~FA_LINK;
			requestFlags |= FA_LINK;
			}
		else if ( flags & DL_EF_LINKS ) avoidFlags &= ~FA_LINK;

	avoidFlags &= 0xFF;
	requestFlags &=0xFF;
	enumFlags = (avoidFlags <<16 ) + requestFlags;
	matchAttrDesc[0].FEAD_value = (void * ) enumFlags;

    /* Zweites Element des Arrays: End of List */
	matchAttrDesc[1].FEAD_attr = FEA_END_OF_LIST;

    return FileEnum ( &enumParams, mh, &noFitCount);
  }

/*--------------------- DirListEnumDirsAndFiles ---------------------
	Durchsuchen eines Verzeichnisses.
	Zun�chst wird das Verzeicnis mit DirListEnumSubdir durchsucht, dann
	werden die gefundenen Eintr�ge vom Typ DLStandardEnumType
	sortiert (Verzeichnisse zuerst)	in einem Speicherblock abgelegt
	und das dazugeh�rige Handle wird zur�ckgeliefert.
	- F�r flags ist nur DL_EF_LINKS oder IAET_LINKS_ONLY g�ltig, andere
	  Flags werden ignoriert

	Return: Anzahl der insgesamt gefunden Eintr�ge (Dateien+Dirs)
		(-1) wenn ein Speicherblock nicht angeleget werden konnte
 ---------------------------------------------------------------------------*/
extern int IAEXPORT DirListEnumDirsAndFiles( MemHandle * mh, int * dirCount, word flags)
  {
  MemHandle localHandle;
  word localFlags, count;
  DLStandardEnumType * source, *dest;
  int n, dcount;

  localFlags = flags & (DL_EF_LINKS | DL_EF_LINKS_ONLY);

  count = DirListEnumSubdir(&localHandle,localFlags | DL_EF_DIRS | DL_EF_FILES);
  if ( count >0 )
	{
	*mh = MemAlloc(count*sizeof(DLStandardEnumType),
		HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT | HAF_LOCK);

	if ( !*mh) return -1;	/* FEHLER! */

	source = MemLock(localHandle);
	dest = MemDeref(*mh);
	dcount = 0;			/* counter f�r Dirs */

	for ( n = 0; n<count; source++,n++)
		{
		if (source->DL_SET_attrs & FA_SUBDIR )
			{
			*dest = *source; dest++;
			dcount++;
			}
		}
	if ( dirCount != 0 ) *dirCount = dcount;

	source = MemDeref(localHandle);
	for ( n = 0; n<count; source++,n++)
		{
		if ( !(source->DL_SET_attrs & FA_SUBDIR ) )
			{
			*dest = *source; dest++;
			}
		}

	MemFree(localHandle);
	MemUnlock(*mh);
	}
  return count;
  }

/*--------------------- DirListSortFileEnumResult ---------------------
	Sortieren eines Suchergebnisses von FileEnum().
	Ziel: alphabetische Darstellung in einer Dateiliste
	- Verzeichnisse vor Dateien anordnen (falls attrOffs != (-1) )
	- Sortierung in alphabetischer Reihenfolge
	mh: von FileEnum gelieferter Block
	structSize, structCount		Gr��e und Anzahl der Strukturen im Block
	nameOffs, attrOffs		Offset der Felder f�r FileName und
					FileAttrs (FA_xxx), f�r den eigentlichen
					Vergleich
	Ist attrOffs == (-1)	-> Typ wird ignoriert (bzw ist nicht vorhanden)
 ---------------------------------------------------------------------------*/
extern void IAEXPORT DirListSortFileEnumResult( MemHandle mh,
				int structSize, int structCount,
				int nameOffs, int attrOffs)
  {
  int first, last, current, min;
  char /** p1st, *p2nd,*/ *tp, *mPtr;
  MemHandle tmh;

  if ( (structCount < 2) || (mh == 0) ) return;
  tmh = GetMem(structSize);
  tp = MemLock(tmh);
  mPtr = MemLock(mh);
  first = 0;
  last = structCount-1;

  while (first < last )
     {
// Nummer des kleinsten Elements in min bereitstellen */
     min = first;
     for ( current = first+1; current <= last; current ++)
	{
	if ( InternalDirListCompare( mPtr+current*structSize,
		      mPtr+min*structSize,nameOffs, attrOffs) < 0 ) min = current;
	}
// Elemente tauschen (wenn sinnvoll) */
     if ( min != first )
	{
	memcpy(tp, mPtr+first*structSize,structSize);
	memcpy(mPtr + first*structSize, mPtr+min*structSize,structSize);
	memcpy(mPtr + min*structSize, tp,structSize);
	}
     first++;   // kleinstes seht vorne-> nicht mehr beachten
     }

  MemUnlock(mh);
  MemFree(tmh);
  }


/*--------------------- DirListToolAdjustLinkDirs ---------------------
	Ausb�glen eines Bugs im System: FileEnum liefert, falls Verzeichnisse
	gefordert werden IMMER ALLE Verzeichnisse, egal ob sie Links sind oder
	nicht.
	-> die nicht ben�tigten Verzeichnisse m�ssen ausgeblendet werden.

	mh: von FileEnum gelieferter Block
	structSize, structCount		Gr��e und Anzahl der Strukturen im Block
	flags				flags, wie sie an die DirListEnumXXXX
					Routinen �bergeben wurden
	attrOffs			Offset des Feldes FileAttrs (FA_xxx),
					f�r den eigentlichen Vergleich
 ---------------------------------------------------------------------------*/
extern int IAEXPORT DirListToolAdjustLinkDirs( MemHandle *mh,
				int structSize, int structCount,
				int flags, int attrOffset)
  {
  MemHandle localMh;
  int	lFlags, newCount, n, attr;
  byte * src, *dest;
  Boolean	lnk, cpyLnk;

  // Parameter auf G�ltigkeit pr�fen
  if ( (structCount < 2) || (mh == 0) || (*mh == 0) ) return structCount;

  // Pr�fen, ob Korrekturbedarf besteht
  if ( !(flags & DL_EF_DIRS) ) return structCount;
			// Keine Verzeichnisse durchsucht

  lFlags = flags & ( DL_EF_LINKS | DL_EF_LINKS_ONLY);
  if ( lFlags == DL_EF_LINKS ) return structCount;
			// Dirs und Links gesucht -> wurden ja gefunden
  cpyLnk = lFlags & DL_EF_LINKS_ONLY;	// TRUE, wenn Links �bernommen werden sollen

  newCount = 0;			/* neue Anzahl */

  if ( structCount >0 )
	{
	localMh = MemAlloc(structCount*structSize,
		HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT | HAF_LOCK);
	if ( !localMh ) return -1;	/* FEHLER! */

	dest = MemDeref(localMh);
	src = MemLock(*mh);

	for ( n = 0; n<structCount; src+=structSize,n++)
	   {
	   attr = (*(src+attrOffset));
	   lnk = attr & FA_LINK;	// TRUE wenn Link
	   if ( !(attr & FA_SUBDIR) )
		{			// Dateien auf jeden Fall �bernehmen
		memcpy(dest,src,structSize);
		dest += structSize;
		newCount++;
		}
	   else
		if ( (lnk && cpyLnk) || ( (!lnk) && (!cpyLnk) ) )
		{			// Verzeichnisse nur, wenn be�tigt
		memcpy(dest,src,structSize);
		dest += structSize;
		newCount++;
		}
	   }

	MemFree(*mh);		// Neuen Speicherblock �bergeben
	*mh = localMh;
	MemUnlock(*mh);
	}

  return newCount;
  }

/*--------------------- InternalDirListCompare ---------------------
   Vergleichen zweier Struktureintr�ge f�r DirListSortFileEnumResult
	p1st, p2nd:	Zeiger auf die Strukturen
	nameOffs	Offset des Datei oder Verzeichnisnamen in der Struktur
	attrOffs	Offset der Dateiattribute (FA_xx) in der Struktur
			(-1) bedeutet: ignorieren!
   Return: (-1) 	Struktur1 "<" Struktur2
			Struktur1 "==" Struktur2
			Struktur1 ">" Struktur2
			Dabei gehen Verzeichnisse immer vor Dateien
 ---------------------------------------------------------------------------*/
int InternalDirListCompare(char *p1st, char *p2nd, int nameOffs, int attrOffs)
  {
  byte a1, a2;    	/* soll FileAttribute aufnehmen */
  char *sp1, *sp2;	/* String Pointer */
  int retVal;
  MemHandle	mh1, mh2;

  if (attrOffs == (-1) )	a1=a2=0;
	else {
		a1 = *(p1st+attrOffs);
		a2 = *(p2nd+attrOffs);
		}

  if ( (a1 & FA_SUBDIR) != (a2 & FA_SUBDIR) )
			return ( a1 & FA_SUBDIR ) ? (-1) : (+1);
				/* Ausdruck ist true, wenn
				   struc 1 ein Verzeichnis ist */
/* es sind zwei Verzeichnisse oder Dateien: Namem vergleichen */
  mh1 = GetMem(strlen(p1st+nameOffs)+2);
  if ( !mh1 ) return strcmp(p1st+nameOffs,p2nd+nameOffs);
  sp1 = MemLock(mh1);

  mh2 = GetMem(strlen(p2nd+nameOffs)+2);
  if ( !mh2 ) {
	MemFree(mh1);
	return strcmp(p1st+nameOffs,p2nd+nameOffs);
	}
  sp2 = MemLock(mh2);

  strcpy(sp1,p1st+nameOffs);
  LocalUpcaseString(sp1,strlen(sp1));
  strcpy(sp2,p2nd+nameOffs);
  LocalUpcaseString(sp2,strlen(sp2));

  retVal = strcmp(sp1,sp2);
  MemFree(mh1);
  MemFree(mh2);

  return retVal;
  }

/*--------------------- internalDropBackslash ---------------------
   FileToolDropBackslash: Schneidet den am Ende befindelichen
   Backslash (oder Slash, falls gefordert) ab. Aber nur, wenn dort
   auch einer ist.
   Return: Neu Pfadl�nge
 ---------------------------------------------------------------------------*/
int InternalDropBackslash(char * path, Boolean slashAlso )
  {
  int n;

  n = strlen(path);
  if ( n==0) return 0;
  n--;

  if ( path[n] == '\\' )
	{
	path[n] = 0;
	return (n);
	}
  if ( !slashAlso) return (n+1);

  if ( path[n] == '/' )
	{
	path[n] = 0;
	return (n);
	}
  return (n+1);
  }

/*--------------------- InternalMakeParentPath ---------------------
   K�rzt einen Pfad auf den Parentpath ein.
   Return: TRUE wenn kein Parent m�glich ist (i.a. Leerstrung oder "\")
	   FALSE wenn OK
   "PAUL" oder "PAUL\" liefert Leersring und OK (FALSE)
 ---------------------------------------------------------------------------*/
Boolean InternalMakeParentPath(char * path, Boolean slashAlso )
  {
  int n, k;
  char c;

  n = InternalDropBackslash(path,slashAlso);
  if ( n==0) return TRUE;

  for ( n=0, k=0; n<strlen(path); n++)
	{
	c = path[n];
	if ( (c=='\\') || ( slashAlso && (c=='/') ) ) k=n;
	}
  path[k] = 0;
  return FALSE;
  }



/* ---------------------------------------------------------------------------
	Verwalten der Icons-Bildchen
 ---------------------------------------------------------------------------*/
/*
	Die Library stellt 10x10 Pixel gro�e Icons (16 Farben) zur Verf�gung,  die
	zur Kennzeichnung von Dateien in Listeneintr�gen verwendet werden k�nnen.
	jede DL_ICON_TYPE_xx-Konstane entspricht einem Icon.

	DirListGetDosIconType() und DirListGetIconType() ermitteln den
			passenden Typ. Dabei steuern die
			DirListExtensionSearchFlags (DLESF_xxx) nach welchen
			Extensions in DOS-Dateien gesucht werden soll
	DirListGetIconOptr() liefert den Optr des Icon-Bilchens.
	DirListWriteIconizedString() schreibt ein Icon-Bildchen und einen
			String in ein gstate.
	DirListParseNameFromPath() liefert das letzte Element eines Pfad-Strings,
			d.h. i.a. den Datei- oder Current-Dir-Namen.
*/


/*--------------------- DirListGetDosIconType ---------------------
	Versucht aus der Extension des �bergebenen DOS-Names einen
	passenden IconTyp zu ermitteln
 ---------------------------------------------------------------------------*/
extern DirListIconType IAEXPORT DirListGetDosIconType( char * name,
		  DirListExtensionSearchFlags flags)
  {
  int p;
  char extension[5];

  p = strlen(name)-4;		/* evt Position Punkt im Namem */
  if ( p < 1 )	return DL_ICON_TYPE_DOS_DOC;	/* Name zu kurz */
  if ( name[p] != '.' ) return DL_ICON_TYPE_DOS_DOC;	/* keine oder zu kuzre Ext. */

  strcpy(extension,&name[p+1]);

  if ( extension[0] > 0x60 ) extension[0] -= 0x20;
  if ( extension[1] > 0x60 ) extension[1] -= 0x20;
  if ( extension[2] > 0x60 ) extension[2] -= 0x20;

  if ( flags & DLESF_GEOS) {
	  if ( !strcmp(extension, "GEO") ) return DL_ICON_TYPE_GEOS_EXEC;

	  if ( ( extension[0] >= '0' ) && ( extension[0] <= '9' ) )
					return DL_ICON_TYPE_GEOS_DOC;
	  }

  if ( flags & DLESF_EXEC) {
	  if ( !strcmp(extension, "COM") ) return DL_ICON_TYPE_DOS_EXEC;
	  if ( !strcmp(extension, "EXE") ) return DL_ICON_TYPE_DOS_EXEC;
	  if ( !strcmp(extension, "BAT") ) return DL_ICON_TYPE_DOS_EXEC;
	  }

  if ( flags & DLESF_PICTURE) {
	  if ( !strcmp(extension, "PCX") ) return DL_ICON_TYPE_DOS_PICTURE;
	  if ( !strcmp(extension, "BMP") ) return DL_ICON_TYPE_DOS_PICTURE;
	  if ( !strcmp(extension, "JPG") ) return DL_ICON_TYPE_DOS_PICTURE;
	  if ( !strcmp(extension, "IMG") ) return DL_ICON_TYPE_DOS_PICTURE;
	  if ( !strcmp(extension, "TIF") ) return DL_ICON_TYPE_DOS_PICTURE;
	  if ( !strcmp(extension, "GIF") ) return DL_ICON_TYPE_DOS_PICTURE;
	  if ( !strcmp(extension, "FLI") ) return DL_ICON_TYPE_DOS_PICTURE;
	  if ( !strcmp(extension, "FLC") ) return DL_ICON_TYPE_DOS_PICTURE;
	  if ( !strcmp(extension, "DIB") ) return DL_ICON_TYPE_DOS_PICTURE;
	  if ( !strcmp(extension, "PIC") ) return DL_ICON_TYPE_DOS_PICTURE;
	  if ( !strcmp(extension, "PIX") ) return DL_ICON_TYPE_DOS_PICTURE;
	  }

  if ( flags & DLESF_ARCHIVE) {
	  if ( !strcmp(extension, "ZIP") ) {
		if ( flags & DLESF_ZIP2FOLDER ) return DL_ICON_TYPE_DOS_ARCHIVE_FOLDER;
			else return DL_ICON_TYPE_DOS_ARCHIVE;
			}
	  if ( !strcmp(extension, "ARJ") ) {
		if ( flags & DLESF_ARJ2FOLDER ) return DL_ICON_TYPE_DOS_ARCHIVE_FOLDER;
			else return DL_ICON_TYPE_DOS_ARCHIVE;
			}
	  if ( !strcmp(extension, "LZH") ) {
		if ( flags & DLESF_LZH2FOLDER ) return DL_ICON_TYPE_DOS_ARCHIVE_FOLDER;
			else return DL_ICON_TYPE_DOS_ARCHIVE;
			}
	  if ( !strcmp(extension, "RAR") ) {
		if ( flags & DLESF_RAR2FOLDER ) return DL_ICON_TYPE_DOS_ARCHIVE_FOLDER;
			else return DL_ICON_TYPE_DOS_ARCHIVE;
			}
	  if ( !strcmp(extension, "ZOO") ) {
		if ( flags & DLESF_ZOO2FOLDER ) return DL_ICON_TYPE_DOS_ARCHIVE_FOLDER;
			else return DL_ICON_TYPE_DOS_ARCHIVE;
			}
	  if ( !strcmp(extension, "ARC") ) {
		if ( flags & DLESF_ARC2FOLDER ) return DL_ICON_TYPE_DOS_ARCHIVE_FOLDER;
			else return DL_ICON_TYPE_DOS_ARCHIVE;
			}
	  if ( !strcmp(extension, "PAC") ) {
		if ( flags & DLESF_PAC2FOLDER ) return DL_ICON_TYPE_DOS_ARCHIVE_FOLDER;
			else return DL_ICON_TYPE_DOS_ARCHIVE;
			}
	  if ( !strcmp(extension, "DWC") ) {
		if ( flags & DLESF_DWC2FOLDER ) return DL_ICON_TYPE_DOS_ARCHIVE_FOLDER;
			else return DL_ICON_TYPE_DOS_ARCHIVE;
			}
	  }

  return DL_ICON_TYPE_DOS_DOC;
  }

/*--------------------- DirListGetIconType ---------------------
	Liefert den zum Dateityp (gft) passenden IconTyp. Ist
	gft == GFT_NOT_GEOS_FILE wird der Name mit DirListGetDosIconType()
	entsprechend den �bergeben flags ausgewertet.
	Ist gft != GFT_NOT_GEOS_FILE, wird name und Flags ignoriert.
 ---------------------------------------------------------------------------*/
extern DirListIconType IAEXPORT DirListGetIconType( GeosFileType gft,
		char * name, DirListExtensionSearchFlags flags)
	{
	if ( gft == GFT_EXECUTABLE ) return DL_ICON_TYPE_GEOS_EXEC;
	if ( gft == GFT_DIRECTORY ) return DL_ICON_TYPE_DIR;
				/* vom System u.U. nicht implementiert!*/
	if ( gft == GFT_NOT_GEOS_FILE )
			return DirListGetDosIconType(name, flags);
	return DL_ICON_TYPE_GEOS_DOC;
	}

/*--------------------- DirListGetIconOptr ---------------------
	Liefert den optr des Icon-Bildchens,das zum �bergebenen IconType
	passt. Ist IconType ung�ltig, wird der optr f�r "DOS-Datei" geliefert
	Um die Bitmap mit GrDrawBitmap...() zu verwenden, mu� sie gelockt und
	dereferenziert werden.
	�bergeben: DL_ICON_TYPE_xx -Konstante
 ---------------------------------------------------------------------------*/
extern optr IAEXPORT  DirListGetIconOptr(DirListIconType iconType)
{
   switch (iconType ) {
   case DL_ICON_TYPE_PARENT:	return (@ParentBmp);
   case DL_ICON_TYPE_DIR:	return (@FolderBmp);
   case DL_ICON_TYPE_DOS_DOC:	return (@FileBmp);
   case DL_ICON_TYPE_DOS_PICTURE:	return (@PictureBmp);
   case DL_ICON_TYPE_DOS_EXEC:	return	(@ExecBmp);
   case DL_ICON_TYPE_GEOS_DOC:	return	(@GeoDocBmp);
   case DL_ICON_TYPE_GEOS_EXEC:	return (@GeoExecBmp);
   case DL_ICON_TYPE_DOS_ARCHIVE:	return (@ArchiveBmp);
   case DL_ICON_TYPE_DOS_ARCHIVE_FOLDER: return (@ArchiveFolderBmp);
   }
   return (@FileBmp);
}

/*--------------------- DirListWriteIconizedString ---------------------
	Vereinfacht die Verwendung von Icons in Listen, indem die DrawRoutinen
	(und damit die geeignete Anordnung der Elemente) zudsammengafasst werden.
	Bitmap und String werden in das �bergebene gstate geschrieben.
	Wird fontID==0 �bergeben, wird der Font nicht ge�ndert.
		Ansonsten wird der Font mit der G��e 12 pt eingestellt
	yPos ist die Verschiebung des Textes in Pixeln nach unten. Der Wert ist an
		den verwendeten Font und die Zeilengr��e anzupassen,
	Ist endGS == TRUE, wird der GString mit GrEndGString() abgeschlossen
 ---------------------------------------------------------------------------*/
extern void IAEXPORT DirListWriteIconizedString( GStateHandle gsh,
	optr iconOptr, char * string, word fontID,word yPos, Boolean endGS)
{
Bitmap *ptrIconBmp;

   MemLock(HandleOf(iconOptr));
    ptrIconBmp = LMemDeref(iconOptr);
    GrMoveTo(gsh,0,1);
    GrDrawBitmapAtCP(gsh,ptrIconBmp, 0);
   MemUnlock(HandleOf(iconOptr));

   if ( fontID != 0 )
	   GrSetFont(gsh,fontID,MakeWWFixed(12));
   GrDrawText(gsh,15,yPos,string,0);

   if ( endGS ) GrEndGString(gsh);
   }

/*--------------------- DirListGetCurrentDirName ---------------------
	Liefert den Namen des CurrentDir. Ist das CurrentDir ein
	Root-Verzeichnis ist der Namensstring leer und der
	Returnwert ist TRUE.
	Der Returnwert ist FALSE, wenn das CurrentDir kein Root-Verzeichnis ist.
 ---------------------------------------------------------------------------*/
extern Boolean IAEXPORT DirListGetCurrentDirName(char * name) {
DiskHandle	dh;
char path[PATH_BUFFER_SIZE+1],fullPath[PATH_BUFFER_SIZE+5];
char *p;
int n;
	dh = FileGetCurrentPath(path,PATH_BUFFER_SIZE);
	p = fullPath;
	FileConstructFullPath(&p,PATH_BUFFER_SIZE,dh,path,TRUE);
	n = strlen(fullPath);
	if ( n>3 ) {
		n--;
		while ( (n!=0) && (fullPath[n]!='\\') ) n--;
		if (fullPath[n] == '\\') n++;
	strcpy(name,&fullPath[n]);
		return FALSE;
		}
	/* es ist ein Root-Verzeichnis! */
	return TRUE;
	}

/*--------------------- DirListParseNameFromPath ---------------------
	�ndert den �bergebenen Zeiger so ab, da� er auf das letzte Element
	des Pfad-Strings (exakt: nach das letzte '\' oder '//', dh. i.a.
	auf den Datei- oder Current-Dir-Namem) zeigt.
	return: L�nge des neuen Strings
 ---------------------------------------------------------------------------*/
extern word IAEXPORT DirListParseNameFromPath ( char ** path)
	{
	int k,n, l;
	char *p;

	p = *path;
	l = strlen(p);
	for ( k=0, n= 0; n < l; n++ )
		if ( (p[n] == '/') || (p[n] == '\\') ) k = n+1;
	p+=k;
	*path = p;
	return strlen(p);
	}


/*###########################################################################
	Double-Click Dynamick List
/*###########################################################################*/


@classdecl DClickGenDynamicListClass;

//(optr dest);
@method DClickGenDynamicListClass, MSG_DCDL_SET_DCLICK_DESTINATION
 {
 pself->DCDLI_destination = dest;
 }

@method DClickGenDynamicListClass, MSG_META_CONTENT_VIEW_SIZE_CHANGED
 {
	word count, itemCount;
	
	@callsuper();

	itemCount = @call oself::MSG_GEN_COUNT_CHILDREN();

	count = 0;
	while(count < itemCount)
	{
		optr childObj;
		word childIdentifier;
		
		childObj = @call oself::MSG_GEN_FIND_CHILD_AT_POSITION(count);
		@call childObj::MSG_GEN_ITEM_SET_INTERACTABLE_STATE(FALSE);
		childIdentifier = @call childObj::MSG_GEN_ITEM_GET_IDENTIFIER();
		if(childIdentifier < pself->GDLI_numItems) 
		{

			@send oself::
					MSG_GEN_DYNAMIC_LIST_QUERY_ITEM_MONIKER(
							oself, childIdentifier);
		}

		count++;
	}
 }

@method DClickGenDynamicListClass, MSG_META_START_MOVE_COPY {
int sel, selCount;

if ( inputState & BI_DOUBLE_PRESS ) do
  {
  selCount = @call oself::MSG_GEN_ITEM_GROUP_GET_NUM_SELECTIONS() ;
  if ( selCount != 1 )
	{
	if ( (pself->DCDLI_dcmsr ) & DCMSR_BEEP )
				UserStandardSound(SST_ERROR);
	if ( !((pself->DCDLI_dcmsr ) & DCMSR_SEND_MSG) )
				break;
	}
  sel = @call oself::MSG_GEN_ITEM_GROUP_GET_SELECTION();
  if ( pself->DCDLI_rightDoublePressMsg ) {
	  @send ,forceQueue {DCDL_CUSTOM_DOUBLE_PRESS_MSG}
		(pself->DCDLI_destination)::
		(pself->DCDLI_rightDoublePressMsg)(oself, sel, selCount);
	  }
  } while(0);		// do - while wegen break
@callsuper();
}

@method DClickGenDynamicListClass, MSG_META_START_SELECT {
int sel, selCount;

if ( inputState & BI_DOUBLE_PRESS ) do
  {
  selCount = @call oself::MSG_GEN_ITEM_GROUP_GET_NUM_SELECTIONS() ;
  if ( selCount != 1 )
	{
	if ( (pself->DCDLI_dcmsr ) & DCMSR_BEEP )
				UserStandardSound(SST_ERROR);
	if ( !((pself->DCDLI_dcmsr ) & DCMSR_SEND_MSG) )
				break;
	}
  sel = @call oself::MSG_GEN_ITEM_GROUP_GET_SELECTION();
  if ( pself->DCDLI_doublePressMsg ) {
	  @send ,forceQueue {DCDL_CUSTOM_DOUBLE_PRESS_MSG}
		(pself->DCDLI_destination)::
		(pself->DCDLI_doublePressMsg)(oself, sel, selCount);
	  }
  } while(0);		// do - while wegen break
@callsuper();
}


/*###########################################################################
	Bargraf Class und dazugeh�rige Klassen
/*###########################################################################*/

@classdecl BargrafClass;

@method BargrafClass, MSG_VIS_OPEN  {

	SizeAsDWord size;

	size = @call oself::MSG_VIS_GET_SIZE();

	pself->BGI_bitmapHandle = GrCreateBitmap(
		BMF_4BIT, 
		DWORD_WIDTH(size), DWORD_HEIGHT(size), ClipboardGetClipboardFile(), 0, 
		&pself->BGI_bitmapGState);

	@callsuper();
}

@method BargrafClass, MSG_VIS_CLOSE  {

	@callsuper();
	
	GrDestroyBitmap(
		pself->BGI_bitmapGState,
		BMD_KILL_DATA);
	pself->BGI_bitmapHandle = 0;
	pself->BGI_bitmapGState = 0;
}


@method BargrafClass, MSG_VIS_RECALC_SIZE  {
	
	word nheight;
	GStateHandle gstate;

	gstate = @call oself::MSG_VIS_VUP_CREATE_GSTATE();

	nheight = @call oself::MSG_SPEC_CONVERT_SIZE(
								 SST_LINES_OF_TEXT|1, gstate) + 5;

	GrDestroyState(gstate);

	if(width & 0x8000)
	{
		width = 0;
	}

	if(height & 0x8000)
	{
		height = nheight;
	}
	else if(height != nheight)
	{
		height = nheight;
	}

	return(MAKE_SIZE_DWORD(width, height));
}

@method BargrafClass, MSG_VIS_SET_SIZE  {

	SizeAsDWord size;
	
	@callsuper();

	size = @call oself::MSG_VIS_GET_SIZE();

	if(pself->BGI_bitmapHandle)
	{
		GrDestroyBitmap(
			pself->BGI_bitmapGState,
			BMD_KILL_DATA);

		pself->BGI_bitmapHandle = GrCreateBitmap(
			BMF_4BIT, 
			DWORD_WIDTH(size), DWORD_HEIGHT(size), ClipboardGetClipboardFile(), 0, 
			&pself->BGI_bitmapGState);
	}

	@call oself::MSG_BARGRAF_UPDATE_VISUAL();
}

@method BargrafClass, MSG_VIS_DRAW  {
//int c,mm;
word options/*, startRest*/;
char buf[100] = "";
Boolean drawBar;
Rectangle rect;
word starty;
GStateHandle bmgstate;
char buf2[UHTA_NULL_TERM_BUFFER_SIZE];

	bmgstate = pself->BGI_bitmapGState;

	@call oself::MSG_VIS_GET_BOUNDS(&rect);
	
	GrSaveState(gstate);
/* Text zusammenstellen */
	options = pself->BGI_options;
	if ( options & BGO_DISPLAY_PREV_TEXT )
		strcpy(buf,pself->BGI_prevText);
	if ( options & (BGO_DISPLAY_VALUE | BGO_DISPLAY_VALUE_AS_PERCENT))
		{
		if( options & BGO_DISPLAY_VALUE_KBYTE)
		{
			UtilHex32ToAscii(buf2, pself->BGI_valToDisp>>10, UHTAF_NULL_TERMINATE|UHTAF_THOUSANDS_SEPARATORS);  
			sprintf(buf, "%s.%01d",buf2,((int)pself->BGI_valToDisp&0x3ff)/100);
		}
		else
		{
			sprintf(&buf[strlen(buf)],  "%lu", pself->BGI_valToDisp);
		}

//
//		LocalFixedToAscii(&buf[strlen(buf)],
//					pself->BGI_valToDisp,pself->BGI_fracDigits);
		}
	if ( options & BGO_DISPLAY_APP_TEXT )
		strcat(buf,pself->BGI_appText);


/* Balken und Text ausgeben */
	drawBar = options & BGO_DO_NOT_DRAW_BAR ? FALSE : (pself->BGI_width > 0) ||
						(options & BGO_DRAW_BAR_IF_ZERO);
//	startRest = drawBar ? pself->BGI_width+1 : 0;
	GrSetTextColor(gstate,CF_INDEX,pself->BGI_textColor,0,0);
	GrSetAreaColor(gstate,CF_INDEX,pself->BGI_backColor,0,0);
	GrSetMixMode(gstate,MM_COPY);

@if 0
	if ( options & BGO_DRAW_XOR_MODE )
		{
		word offset;
	/* Xor-Mode	: l�schen des Objekts mit Hintergrundfarbe,
			: Text ausgeben
			: Balken im XOR-Mode schreiben
			*/
		GrFillRect(gstate,rect.R_left,
			rect.R_top,
			rect.R_right,
			rect.R_bottom);
//		GrDrawText(gstate,
//			rect.R_left+pself->BGI_textOffsX,
//			rect.R_top+pself->BGI_textOffsY,buf,0);
		/* just center the complete text in the view FR 10/24/2000 */
		offset = GrTextWidth(gstate, buf, 0) / 2;
		GrDrawText(gstate,
			rect.R_left + 
				(rect.R_right - rect.R_left) / 2
				- offset,
				rect.R_top+pself->BGI_textOffsY,buf,0);

		if (drawBar) {
			int c;
			c = (pself->BGI_barColor) ^ C_WHITE;
			GrSetMixMode(gstate,MM_XOR);
			GrSetAreaColor(gstate,CF_INDEX,c,0,0);
			GrFillRect(gstate,
				rect.R_left,
				rect.R_top,
				rect.R_left+pself->BGI_width,
				rect.R_bottom);
			}
		}
	else 	
@endif
	{
	/* Draw-Mode	: Balken schreiben
			: Freibreich schreiben
			: Text ausgeben
			*/
		word offset;
		word top, left;
		
		starty=((rect.R_bottom-rect.R_top-1)-IntegerOf(GrFontMetrics(gstate,
			GFMI_ASCENT)))/2-IntegerOf(GrFontMetrics(gstate,
			GFMI_ACCENT))+1;
					offset = GrTextWidth(gstate, buf, 0) / 2;

		left = rect.R_left;
		top = rect.R_top;

		rect.R_right -= rect.R_left;
		rect.R_bottom -= rect.R_top;
		rect.R_left = 0;
		rect.R_top = 0;


		GrSetAreaColor(bmgstate,CF_INDEX,pself->BGI_backColor,0,0);
		GrSetClipRect(bmgstate, PCT_REPLACE,
			rect.R_left,
			rect.R_top,
			rect.R_right,
			rect.R_bottom);
		GrFillRect(bmgstate,
			rect.R_left,
			rect.R_top,
			rect.R_right,
			rect.R_bottom);
		GrSetTextColor(bmgstate,CF_INDEX, C_BLACK,0,0);
		GrDrawText(bmgstate,
			rect.R_left + 
				(rect.R_right - rect.R_left) / 2
				- offset,
				rect.R_top+starty,buf,0);

		GrSetLineColor(bmgstate, CF_INDEX, C_DARK_GRAY, 0, 0);
		GrDrawLine(bmgstate,
			rect.R_left, rect. R_bottom - 1, rect.R_left, rect.R_top);
		GrDrawLine(bmgstate,
			rect.R_left, rect. R_top, rect.R_right - 1, rect.R_top);
		GrSetLineColor(bmgstate, CF_INDEX, C_WHITE, 0, 0);
		GrDrawLine(bmgstate,
			rect.R_left, rect. R_bottom - 1, rect.R_right, rect.R_bottom - 1);
		GrDrawLine(bmgstate,
			rect.R_right - 1, rect. R_top, rect.R_right - 1, rect.R_bottom - 1);

		rect.R_top += 2;
		rect.R_left += 2;
		rect.R_right -= 2;
		rect.R_bottom -= 2;

		if (drawBar ) {
			GrSetAreaColor(bmgstate,CF_INDEX,pself->BGI_barColor,0,0);
			GrSetClipRect(bmgstate, PCT_REPLACE,
				rect.R_left,
				rect.R_top,
				rect.R_left+pself->BGI_width,
				rect.R_bottom);
			GrFillRect(bmgstate,
				rect.R_left,
				rect.R_top,
				rect.R_left+pself->BGI_width,
				rect.R_bottom);
			GrSetTextColor(bmgstate,CF_INDEX,C_WHITE,0,0);
			GrDrawText(bmgstate,
				rect.R_left + 
					(rect.R_right - rect.R_left) / 2
					- offset,
					rect.R_top+starty - 2,buf,0);
			}

//		GrDrawText(gstate,
//			rect.R_left+pself->BGI_textOffsX,
//			rect.R_top+pself->BGI_textOffsY,buf,0);
		/* just center the complete text in the view FR 10/24/2000 */
		GrDrawHugeBitmap(gstate, left, top, 
			ClipboardGetClipboardFile(), pself->BGI_bitmapHandle);
		}

	GrRestoreState(gstate);
	}

@method BargrafClass, MSG_BARGRAF_UPDATE_VISUAL  {
//GStateHandle gstate;		/* temporary gstate to draw to	*/
//WindowHandle win;		/* window handle of view window	*/
dword   dx/*,proz*/;

Rectangle rect;

	if(!@call oself::MSG_VIS_QUERY_WINDOW())
		return;

	@call oself::MSG_VIS_GET_BOUNDS(&rect);

	/* calculating with read dwords now FR 10/29/2000 */
	dx = rect.R_right - rect.R_left - 4;

	if(pself->BGI_maximum < 1000000)
	{
		dword max = pself->BGI_maximum;

		if(max) 
		{
			pself->BGI_width = 	((dx * pself->BGI_value) / max);
			
			if (pself->BGI_options & BGO_DISPLAY_VALUE_AS_PERCENT)
			{
				pself->BGI_valToDisp = (100 * pself->BGI_value) / max;
			}
			else
			{
				pself->BGI_valToDisp = pself->BGI_value;
			}
		}
		else
		{
			pself->BGI_valToDisp = 0;
			pself->BGI_width = 0;
		}
	}
	else
	{
		dword max = pself->BGI_maximum/1024;

		if(max)
		{
			pself->BGI_width = ((dx * (pself->BGI_value/1024)) / max);
			if (pself->BGI_options & BGO_DISPLAY_VALUE_AS_PERCENT)
			{
	 			pself->BGI_valToDisp = (100 * (pself->BGI_value/1024)) / max;
			}
			else
			{
				pself->BGI_valToDisp = pself->BGI_value;
			}
		}
		else
		{
			pself->BGI_valToDisp = 0;
			pself->BGI_width = 0;
		}
	}

@if 0
	dx = MakeWWFixed(rect.R_right - rect.R_left);
	if ( pself->BGI_maximum )
		proz = GrSDivWWFixed(pself->BGI_value,pself->BGI_maximum));
		else proz = 0;
	pself->BGI_width = IntegerOf(GrMulWWFixed(dx,proz));
	if (pself->BGI_width > IntegerOf(dx) ) pself->BGI_width = IntegerOf(dx);

	if (pself->BGI_options & BGO_DISPLAY_VALUE_AS_PERCENT)
		{
		pself->BGI_valToDisp = GrMulWWFixed(MakeWWFixed(100),proz);
		if (pself->BGI_options & BGO_DISPLAY_REMAINING)
			pself->BGI_valToDisp = MakeWWFixed(100)-pself->BGI_valToDisp;
		}
	else 	{
		pself->BGI_valToDisp = pself->BGI_value;
		if (pself->BGI_options & BGO_DISPLAY_REMAINING)
			pself->BGI_valToDisp = pself->BGI_maximum-pself->BGI_valToDisp;
		}
@endif
	@call oself::MSG_VIS_REDRAW_ENTIRE_OBJECT();
	}


@method BargrafClass, MSG_BARGRAF_SET_MAXIMUM {/*(dword max); */
	pself->BGI_maximum = max;
	@call oself::MSG_BARGRAF_UPDATE_VISUAL();
	}
@method BargrafClass, MSG_BARGRAF_SET_VALUE {/*(dword val);*/
	pself->BGI_value = val;
	@call oself::MSG_BARGRAF_UPDATE_VISUAL();
	}
@method BargrafClass, MSG_BARGRAF_INCREMENT_VALUE { /*(dword val);*/
	pself->BGI_value += val;
	@call oself::MSG_BARGRAF_UPDATE_VISUAL();
	}

@method BargrafClass, MSG_BARGRAF_SET_TEXT { /*(char * prevText, char * appText);*/
	if ( prevText ) strcpy(pself->BGI_prevText,prevText);
	if ( appText ) strcpy(pself->BGI_appText,appText);
	@call oself::MSG_BARGRAF_UPDATE_VISUAL();
	}
@method BargrafClass, MSG_BARGRAF_SET_TEXT_OFFSET { /*( int x, int y);*/
	pself->BGI_textOffsX = x;
	pself->BGI_textOffsY = y;
	@call oself::MSG_BARGRAF_UPDATE_VISUAL();
	}
@method BargrafClass, MSG_BARGRAF_SET_COLOR { /*(int barColor, int textColor);*/
					/* pass -1 for no change */
	if ( barColor != (-1) ) pself->BGI_barColor = barColor;
	if ( textColor != (-1) ) pself->BGI_textColor = textColor;
	@call oself::MSG_BARGRAF_UPDATE_VISUAL();
	}

@method BargrafClass, MSG_BARGRAF_SET_OPTIONS { /*(word optToSet, word optToClear);*/
	pself->BGI_options = (pself->BGI_options | optToSet ) & ~optToClear;
	@call oself::MSG_BARGRAF_UPDATE_VISUAL();
	}
@method BargrafClass, MSG_BARGRAF_SET_FRAC_DIGITS { /*(int frac);*/
	pself->BGI_fracDigits = frac;
	@call oself::MSG_BARGRAF_UPDATE_VISUAL();
	}

@method BargrafClass, MSG_BARGRAF_GET_MAXIMUM { /*(dword *max);*/
	if (max) *max = pself->BGI_maximum;
	}
@method BargrafClass, MSG_BARGRAF_GET_VALUE { /*(dword *val);*/
	if ( val ) *val = pself->BGI_value;
	}
@method BargrafClass, MSG_BARGRAF_GET_INFO { /*(int *barColor, int *textColor,
		int * fracDigits, int * options,
		int *textXoffs, int *textYoffs,
		char * prevText, char * appText);*/
				/* pass NULL for no return a info */
	if ( barColor )	*barColor = pself->BGI_barColor;
	if ( textColor ) *textColor = pself->BGI_textColor;
	if ( fracDigits ) *fracDigits = pself->BGI_fracDigits;
	if ( options ) *options = pself->BGI_options;
	if ( textXoffs ) *textXoffs = pself->BGI_textOffsX;
	if ( textYoffs) *textYoffs = pself->BGI_textOffsY;
	if ( prevText) strcpy(prevText,pself->BGI_prevText);
	if ( appText) strcpy(appText,pself->BGI_appText);
	}


/* end of file */


