/***************************************************************************
 *  FILE:  VGridC.GOC                                                      *
 ***************************************************************************/

/*-------------------------------------------------------------------------
 | Library:  VisGridClass
 *-------------------------------------------------------------------------
 |
 | Objective:
 |    Setup to create a grid vis object for handling layout of simple tables
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/09/99  Created
 |
 *-----------------------------------------------------------------------*/

/***************************************************************************
 *      Include files
 ***************************************************************************/

@include <stdapp.goh>
@include <Ansi/string.h>
@include <Ansi/stdio.h>
@include <Objects/vGridc.goh>

void VisGridCalculateSize(optr oself, VisGridInstance *pself) ;


/*=========================================================================*
 *  METHODS FOR CLASS:  VisGridClass
 *=========================================================================*/

    @classdecl VisGridClass ;

@extern method VisGridClass, MSG_VIS_GRID_SET_DESTINATION ;
@extern method VisGridClass, MSG_VIS_GRID_GET_COLUMN_WIDTH ;
@extern method VisGridClass, MSG_VIS_GRID_GET_ROW_HEIGHT ;
@extern method VisGridClass, MSG_VIS_GRID_FIND_COLUMN_X ;
@extern method VisGridClass, MSG_VIS_GRID_FIND_ROW_Y ;
@extern method VisGridClass, MSG_VIS_GRID_SELECT_CELL_MOVE_RIGHT ;
@extern method VisGridClass, MSG_VIS_GRID_SELECT_CELL_MOVE_LEFT ;
@extern method VisGridClass, MSG_VIS_GRID_SELECT_CELL_MOVE_UP ;
@extern method VisGridClass, MSG_VIS_GRID_SELECT_CELL_MOVE_DOWN ;
@extern method VisGridClass, MSG_VIS_GRID_SELECT_CELL_MOVE_HOME ;
@extern method VisGridClass, MSG_VIS_GRID_SELECT_CELL_MOVE_END ;
@extern method VisGridClass, MSG_META_FUP_KBD_CHAR ;
@extern method VisGridClass, MSG_META_KBD_CHAR ;
@extern method VisGridClass, MSG_VIS_OPEN ;
@extern method VisGridClass, MSG_VIS_GRID_INITIAL_CELLS ;
@extern method VisGridClass, MSG_VIS_GRID_RESIZE_COLUMN ;
@extern method VisGridClass, MSG_VIS_GRID_RESIZE_ROW ;


/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_DRAW
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Draw the vis object.  Draw the background, outer rim, inner dividers
 |    and especially call the destination for data to put in the cells.
 |    This code also is optimized to only do callbacks for cells that
 |    are invalidated (so if a database is being used, it doesn't overly
 |    become a performance hit).
 |
 | Inputs:
 |    GStateHandle gstate         -- Where to draw
 |    DrawFlags flags             -- Draw under what conditions
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/09/99  Created
 |    LES  07/22/99  Converted to a new technique of drawing.  The
 |                   VIS_DRAW command just puts in a request for drawing
 |                   the area of the screen that has been exposed.  It
 |                   is then up to the user of the grid to update.
 |                   The routine VisGridUtilityDrawGroup has been added
 |                   to simplify this process.
 |
 *-----------------------------------------------------------------------*/

@method VisGridClass, MSG_VIS_DRAW
{
    word width, height ;
    word *p_height ;
    sword x, y ;
    MemHandle mem ;
    word numWidths ;
    word numHeights ;
    optr arrayWidths ;
    optr arrayHeights ;
    word size ;
    word i ;
    word *p_width ;
@if 0
    word num ;
    word column, row ;
    word *p_widthStart ;
    GridDrawFlags flags ;
@endif
    Rectangle maskBounds ;
    word minColumn, maxColumn ;
    word minRow, maxRow ;

    mem = OptrToHandle(oself) ;

    if (pself->VGI_suspendCount == 0)  {
        GrSaveState(gstate) ;
        GrSetAreaColorMap(gstate, CMT_DITHER);
        GrSetLineColorMap(gstate, CMT_DITHER);
        GrApplyTranslation(
            gstate,
            MakeWWFixed(pself->VI_bounds.R_left),
            MakeWWFixed(pself->VI_bounds.R_top)) ;
        GrGetMaskBounds(gstate, &maskBounds) ;
        minColumn = @call oself::MSG_VIS_GRID_FIND_COLUMN(maskBounds.R_left) ;
        maxColumn = @call oself::MSG_VIS_GRID_FIND_COLUMN(maskBounds.R_right-1) ;
        minRow = @call oself::MSG_VIS_GRID_FIND_ROW(maskBounds.R_top) ;
        maxRow = @call oself::MSG_VIS_GRID_FIND_ROW(maskBounds.R_bottom-1) ;
        numHeights = @call oself::MSG_VIS_GRID_GET_NUM_ROWS() ;
        if (maxRow >= numHeights)
            maxRow = numHeights-1 ;
        numWidths = @call oself::MSG_VIS_GRID_GET_NUM_COLUMNS() ;
        if (maxColumn >= numWidths)
            maxColumn = numWidths-1 ;

        /* ONly draw if we have columns and rows to show */
        if ((numHeights) && (numWidths))  {

           width = pself->VI_bounds.R_right - pself->VI_bounds.R_left-1 ;
           height = pself->VI_bounds.R_bottom - pself->VI_bounds.R_top-1 ;
           GrSetAreaColor(gstate,
               pself->VGI_backgroundColor.CQ_info,
               pself->VGI_backgroundColor.CQ_redOrIndex,
               pself->VGI_backgroundColor.CQ_green,
               pself->VGI_backgroundColor.CQ_blue) ;
           GrFillRect(gstate, 0, 0, width, height) ;
           if (pself->VGI_rimWidth)  {
               GrSetAreaColor(gstate,
                   pself->VGI_rimColor.CQ_info,
                   pself->VGI_rimColor.CQ_redOrIndex,
                   pself->VGI_rimColor.CQ_green,
                   pself->VGI_rimColor.CQ_blue) ;
               GrFillRect(gstate, 0, 0, width, pself->VGI_rimWidth) ;
               GrFillRect(gstate, 0, 0, pself->VGI_rimWidth, height) ;
               GrFillRect(gstate, width-pself->VGI_rimWidth, 0, width, height) ;
               GrFillRect(gstate, 0, height-pself->VGI_rimWidth, width, height) ;
           }
           GrApplyTranslation(
               gstate,
               MakeWWFixed(pself->VGI_rimWidth),
               MakeWWFixed(pself->VGI_rimWidth)) ;
           width -= (pself->VGI_rimWidth<<1) ;
           height -= (pself->VGI_rimWidth<<1) ;
           if (pself->VGI_dividerWidth)  {
               GrSetAreaColor(gstate,
                   pself->VGI_innerDividersColor.CQ_info,
                   pself->VGI_innerDividersColor.CQ_redOrIndex,
                   pself->VGI_innerDividersColor.CQ_green,
                   pself->VGI_innerDividersColor.CQ_blue) ;
               if (pself->VGI_cellWidths)  {
                   x = y = 0 ;
                   arrayWidths = ConstructOptr(mem, pself->VGI_cellWidths) ;
                   numWidths = ChunkArrayGetCount(arrayWidths) ;
                   if (numWidths)  {
                       numWidths-- ;
                       p_width = ChunkArrayElementToPtr(arrayWidths, 0, &size) ;
                       for (i=0; i<numWidths; i++, p_width++)  {
                           x += *p_width ;
                           GrFillRect(
                               gstate,
                               x,
                               y,
                               x+pself->VGI_dividerWidth,
                               height) ;
                           x += pself->VGI_dividerWidth ;
                       }
                   }
               }
               if (pself->VGI_cellHeights)  {
                   x=y=0 ;
                   arrayHeights = ConstructOptr(mem, pself->VGI_cellHeights) ;
                   numHeights = ChunkArrayGetCount(arrayHeights) ;
                   if (numHeights)  {
                       numHeights-- ;
                       p_height = ChunkArrayElementToPtr(arrayHeights, 0, &size) ;
                       for (i=0; i<numHeights; i++, p_height++)  {
                           y += *p_height ;
                           GrFillRect(
                               gstate,
                               x,
                               y,
                               width,
                               y+(pself->VGI_dividerWidth)) ;
                           y += pself->VGI_dividerWidth ;
                       }
                   }
               }
           }
           if ((pself->VGI_cellHeights) && (pself->VGI_cellWidths))  {
               arrayWidths = ConstructOptr(mem, pself->VGI_cellWidths) ;
               numWidths = ChunkArrayGetCount(arrayWidths) ;
               arrayHeights = ConstructOptr(mem, pself->VGI_cellHeights) ;
               numHeights = ChunkArrayGetCount(arrayHeights) ;
               if ((numWidths) && (numHeights))  {
                   @send ,forceQueue (pself->VGI_destination)::
                            {VIS_GRID_DRAW_CELL_GROUP}
                            (pself->VGI_drawGroupMsg)
                            (oself, minColumn, minRow, maxColumn, maxRow) ;
@if 0
                   y=0 ;
                   p_widthStart = ChunkArrayElementToPtr(arrayWidths, 0, &size) ;
                   p_height = ChunkArrayElementToPtr(arrayHeights, 0, &size) ;
                   row = 0 ;
                   while (numHeights)  {
                       x=0 ;
                       num = numWidths ;
                       p_width = p_widthStart ;
                       column = 0 ;
                       while (num)  {
                           GrApplyTranslation(
                               gstate,
                               MakeWWFixed(x),
                               MakeWWFixed(y)) ;
                           if (GrTestRectInMask(gstate, 0, 0, *p_width-pself->VGI_dividerWidth, *p_height-pself->VGI_dividerWidth) != TRRT_OUT)  {
                               GrSaveState(gstate) ;
                               GrSetClipRect(
                                   gstate,
                                   PCT_REPLACE,
                                   0, 0,
                                   *p_width, *p_height) ;
                               if ((row==pself->VGI_selectionY) &&
                                       (column==pself->VGI_selectionX))  {
                                   GrSetAreaColor(
                                       gstate,
                                       pself->VGI_selectionBackgroundColor.CQ_info,
                                       pself->VGI_selectionBackgroundColor.CQ_redOrIndex,
                                       pself->VGI_selectionBackgroundColor.CQ_green,
                                       pself->VGI_selectionBackgroundColor.CQ_blue) ;
                                   GrFillRect(
                                       gstate,
                                       0, 0,
                                       *p_width, *p_height) ;
                               }
                               if ((pself->VGI_destination) && (pself->VGI_drawMsg))  {
                                   GrSaveState(gstate) ;
                                   flags = 0 ;
                                   if ((column==pself->VGI_selectionX) &&
                                       (row==pself->VGI_selectionY))
                                       flags |= GRID_DRAW_FLAG_SELECTED ;
                                   @call (pself->VGI_destination)::{VIS_GRID_DRAW_CELL}(pself->VGI_drawMsg)(
                                       gstate,
                                       column,
                                       row,
                                       *p_width,
                                       *p_height,
                                       oself,
                                       flags) ;
                                   GrRestoreState(gstate) ;
                               }
                               GrRestoreState(gstate) ;
                           }
                           GrApplyTranslation(
                               gstate,
                               MakeWWFixed(-x),
                               MakeWWFixed(-y)) ;
                           x += *(p_width++) + pself->VGI_dividerWidth ;
                           num-- ;
                           column++ ;
                       }
                       numHeights-- ;
                       row++ ;
                       y += *(p_height++) + pself->VGI_dividerWidth ;
                   }
@endif
               }
           }
        }
        GrRestoreState(gstate) ;
    }
    @callsuper() ;
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_META_SUSPEND
 *-------------------------------------------------------------------------
 |
 | Description:
 |    All drawing, updating, and recalculations are put on hold when
 |    suspended.  This makes doing multiple adding/deleting of rows/
 |    columns occur as one action instead of confusing the user.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/11/99  Created
 |
 *-----------------------------------------------------------------------*/

@method VisGridClass, MSG_META_SUSPEND
{
    EC_ERROR_IF(pself->VGI_suspendCount > 200, -1) ;
    pself->VGI_suspendCount++ ;
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_META_UNSUSPEND
 *-------------------------------------------------------------------------
 |
 | Description:
 |    All pending actions waiting to occur from being suspended are done
 |    immediately when unsuspended.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/11/99  Created
 |
 *-----------------------------------------------------------------------*/

@method VisGridClass, MSG_META_UNSUSPEND
{

    EC_ERROR_IF(pself->VGI_suspendCount == 0, -1) ;
    pself->VGI_suspendCount-- ;
    if (pself->VGI_suspendCount==0)  {
        if (pself->VGI_pending & VIS_GRID_PENDING_RESIZE)  {
            VisGridCalculateSize(oself, pself) ;
            pself = ObjDerefVis(oself) ;
        }
        if (pself->VGI_pending & VIS_GRID_PENDING_INVAL)  {
            VisGridCalculateSize(oself, pself) ;
            @call oself::MSG_VIS_INVALIDATE() ;
            pself = ObjDerefVis(oself) ;
        }
        if (pself->VGI_pending & VIS_GRID_PENDING_INVAL_RECT)  {
            @call oself::MSG_VIS_GRID_INVALIDATE_RECTANGLE(&pself->VGI_invalRect) ;
            pself = ObjDerefVis(oself) ;
        }
        pself->VGI_pending = 0 ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  VisGridCalculateSize
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Utility routine called from multiple places to calculate the complete
 |    width and height of the VisGrid.  The answer is stored directly
 |    into the VI_bounds of the Vis object.
 |
 | Inputs:
 |    optr oself                  -- Optr to VisGrid object
 |    VisGridInstance *pself      -- Pointer to VisGrid
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/11/99  Created
 |
 *-----------------------------------------------------------------------*/

void VisGridCalculateSize(optr oself, VisGridInstance *pself)
{
    word width ;
    word height ;
    optr array ;
    word *p_array ;
    MemHandle mem ;
    word size, num ;

    /* Make sure we are locked and split out the mem handle for */
    /* easy array calculations */
    mem = OptrToHandle(oself) ;
    ObjLockObjBlock(mem) ;

    /* Add up all the column widths, dividers, and 2 rims */
    width = pself->VGI_rimWidth << 1 ;
    if (pself->VGI_cellWidths)  {
        array = ConstructOptr(mem, pself->VGI_cellWidths) ;
        num = ChunkArrayGetCount(array) ;
        p_array = ChunkArrayElementToPtr(array, 0, &size) ;
        if (num)  {
            while (num--)
                width += *(p_array++) + pself->VGI_dividerWidth ;
            width -= pself->VGI_dividerWidth ;
        }
    }

    /* Add up all the row heights, dividers, and 2 rims */
    height = pself->VGI_rimWidth << 1 ;
    if (pself->VGI_cellHeights)  {
        array = ConstructOptr(mem, pself->VGI_cellHeights) ;
        num = ChunkArrayGetCount(array) ;
        p_array = ChunkArrayElementToPtr(array, 0, &size) ;
        if (num)  {
            while (num--)
                height += *(p_array++) + pself->VGI_dividerWidth ;
            height -= pself->VGI_dividerWidth ;
        }
    }
    MemUnlock(mem) ;

    /* Sorry, zero is not allowed */
    if (!height)
        height = 1 ;
    if (!width)
        width = 1 ;

    /* Store the answer directly in the VI_bounds */
    pself->VI_bounds.R_bottom = 1+pself->VI_bounds.R_top + height ;
    pself->VI_bounds.R_right = 1+pself->VI_bounds.R_left + width ;
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_RECALC_SIZE
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Determine the size of the VisGrid and return it.  If we are suspended,
 |    just return our current size, but mark the object for resize
 |    calculation.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/11/99  Created
 |
 *-----------------------------------------------------------------------*/

@method VisGridClass, MSG_VIS_RECALC_SIZE
{
    if (!(pself->VGI_flags & VIS_GRID_FLAG_INITIAL_CELLS_MADE))
        @call oself::MSG_VIS_GRID_INITIAL_CELLS() ;

    if (pself->VGI_suspendCount == 0)  {
        VisGridCalculateSize(oself, pself) ;
    } else {
        pself->VGI_pending |= VIS_GRID_PENDING_RESIZE ;
    }
    return MAKE_SIZE_DWORD(
               pself->VI_bounds.R_right-pself->VI_bounds.R_left+1,
               pself->VI_bounds.R_bottom-pself->VI_bounds.R_top+1) ;
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_GRID_ADD_COLUMN
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Like it says, add a new column to the grid.  The new column can be
 |    placed before any of the previously existing columns, or pass
 |    VIS_GRID_LOCATION_PAST_END if you want it appended on the right.
 |
 |    NOTE:  The VisGrid object does no association of columns with any
 |           of the callers data.  Therefore, adding a new column at the
 |           start just shifts the size information down and does not
 |           remember that the second column originally had the first
 |           columns data.  This is managed by the caller.
 |
 | Inputs:
 |    VisGridIndex columnBefore   -- Where to place new column
 |                                   or VIS_GRID_LOCATION_PAST_END to
 |                                   append a new one.
 |    word width                  -- Pixel width of new column.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/11/99  Created
 |
 *-----------------------------------------------------------------------*/

@method VisGridClass, MSG_VIS_GRID_ADD_COLUMN
/*
                          VisGridIndex columnBefore,
                          word width
*/
{
    word *p_new ;
    word size ;
    optr array ;

    if (!(pself->VGI_flags & VIS_GRID_FLAG_INITIAL_CELLS_MADE))
        @call oself::MSG_VIS_GRID_INITIAL_CELLS() ;

    pself->VGI_pending |= VIS_GRID_PENDING_RESIZE ;
    if (pself->VGI_cellWidths)  {
        array = ConstructOptr(OptrToHandle(oself), pself->VGI_cellWidths) ;
        if (columnBefore >= ChunkArrayGetCount(array)) {
            columnBefore = ChunkArrayGetCount(array) ;
            p_new = ChunkArrayAppend(array, 1);
        } else {
            p_new = ChunkArrayElementToPtr(array, columnBefore, &size);
            p_new = ChunkArrayInsertAt(array, p_new, 1);
        }
        *p_new = width ;

        if ((columnBefore <= pself->VGI_selectionX) &&
            (pself->VGI_selectionX != VIS_GRID_SELECTION_NONE))
            pself->VGI_selectionX++ ;

        @call oself::MSG_VIS_GRID_INVALIDATE_CELL_RANGE(
            columnBefore, 0,
            VIS_GRID_LOCATION_PAST_END, VIS_GRID_LOCATION_PAST_END) ;

        @call oself::MSG_VIS_RECALC_SIZE(0, 0) ;
    }
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_GRID_ADD_ROW
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Creates a new row anywhere in the grid.  Pass
 |    VIS_GRID_LOCATION_PAST_END to append a new row.
 |
 |    NOTE:  The VisGrid object does no association of rows with any
 |           of the callers data.  Therefore, adding a new row at the
 |           start just shifts the size information down and does not
 |           remember that the second row originally had the first
 |           row's data.  This is managed by the caller.
 |
 | Inputs:
 |    VisGridIndex rowBefore      -- Where to place new row
 |                                   or VIS_GRID_LOCATION_PAST_END to
 |                                   append a new one.
 |    word height                 -- Pixel height of new row.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/11/99  Created
 |
 *-----------------------------------------------------------------------*/

@method VisGridClass, MSG_VIS_GRID_ADD_ROW
/*
                          VisGridIndex rowBefore,
                          word height
*/
{
    word *p_new ;
    word size ;
    optr array ;

    if (!(pself->VGI_flags & VIS_GRID_FLAG_INITIAL_CELLS_MADE))
        @call oself::MSG_VIS_GRID_INITIAL_CELLS() ;

    pself->VGI_pending |= VIS_GRID_PENDING_RESIZE ;
    if (pself->VGI_cellHeights)  {
        array = ConstructOptr(OptrToHandle(oself), pself->VGI_cellHeights) ;
        if (rowBefore >= ChunkArrayGetCount(array)) {
            rowBefore = ChunkArrayGetCount(array) ;
            p_new = ChunkArrayAppend(array, 1);
        } else {
            p_new = ChunkArrayElementToPtr(array, rowBefore, &size);
            p_new = ChunkArrayInsertAt(array, p_new, 1);
        }
        *p_new = height ;

        if ((rowBefore <= pself->VGI_selectionY) && (pself->VGI_selectionY != VIS_GRID_SELECTION_NONE))
            pself->VGI_selectionY++ ;

        @call oself::MSG_VIS_GRID_INVALIDATE_CELL_RANGE(
            0, rowBefore,
            VIS_GRID_LOCATION_PAST_END, VIS_GRID_LOCATION_PAST_END) ;

        @call oself::MSG_VIS_RECALC_SIZE(0, 0) ;
    }
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_INVALIDATE
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Invalidates the rectangle around the complete VisGrid object.
 |    If the object is suspended, no action occurs until the object
 |    is unsuspended.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/11/99  Created
 |
 *-----------------------------------------------------------------------*/

@method VisGridClass, MSG_VIS_INVALIDATE
{
    if (pself->VGI_suspendCount)  {
        pself->VGI_pending |= VIS_GRID_PENDING_INVAL ;
    } else {
        @callsuper() ;
    }
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_GRID_FIND_COLUMN
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Utility method to convert a X coordinate (relative to the top left
 |    of the grid) to a column index (0 to number columns-1).
 |
 | Inputs:
 |    word x                      -- X coordinate relative to left edge
 |                                   of grid.
 |
 | Outputs:
 |    word column                 -- Column index found.  If past right,
 |                                   will return right most column.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/12/99  Created
 |
 *-----------------------------------------------------------------------*/

@method VisGridClass, MSG_VIS_GRID_FIND_COLUMN
{
    optr array ;
    word num ;
    word index = 0 ;
    word size ;
    word *p_size ;
    word total = pself->VGI_rimWidth ;

    if (pself->VGI_cellWidths)  {
        array = ConstructOptr(OptrToHandle(oself), pself->VGI_cellWidths) ;
        num = ChunkArrayGetCount(array) ;

        /* Walk through the columns looking for a column that straddles */
        /* the x coordinate */
        for (index=0; index<num; index++)  {
            p_size = ChunkArrayElementToPtr(array, index, &size);
            total += *p_size ;
            if (total > x)
                break ;
            total += pself->VGI_dividerWidth ;
        }
    }

    return index ;
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_GRID_FIND_ROW
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Utility method to convert a Y coordinate (relative to the top
 |    of the grid) to a row index (0 to number rows-1).
 |
 | Inputs:
 |    word y                      -- Y coordinate relative to top edge
 |                                   of grid.
 |
 | Outputs:
 |    word                        -- Row index found.  If past bottom,
 |                                   will return bottom most row.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/12/99  Created
 |
 *-----------------------------------------------------------------------*/

@method VisGridClass, MSG_VIS_GRID_FIND_ROW
{
    optr array ;
    word num ;
    word index = 0 ;
    word size ;
    word *p_size ;
    word total = pself->VGI_rimWidth ;

    if (pself->VGI_cellHeights)  {
        array = ConstructOptr(OptrToHandle(oself), pself->VGI_cellHeights) ;
        num = ChunkArrayGetCount(array) ;
        for (index=0; index<num; index++)  {
            p_size = ChunkArrayElementToPtr(array, index, &size);
            total += *p_size ;
            if (total > y)
                break ;
            total += pself->VGI_dividerWidth ;
        }
    }

    return index ;
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_META_START_SELECT
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Message intercepted to handle mouse events that select a cell.
 |
 | Inputs:
 |    MouseReturnParams *retVal   -- Possible flags to return.
 |    sword xPosition             -- x coordinate of mouse click
 |    sowrd yPosition             -- y coordinate of mouse click
 |    word inputState             -- Press/release info
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/13/99  Created
 |
 *-----------------------------------------------------------------------*/

@method VisGridClass, MSG_META_START_SELECT
/*
MouseReturnParams *retVal = bpaxdxcx,
                  sword xPosition = cx,
                  sword yPosition = dx,
                  word inputState = bp);
*/
{
    word column, row ;

    @callsuper() ;

    /* Determine where we were clicked on */
    column = @call oself::MSG_VIS_GRID_FIND_COLUMN(xPosition-pself->VI_bounds.R_left) ;
    row = @call oself::MSG_VIS_GRID_FIND_ROW(yPosition-pself->VI_bounds.R_top) ;

    /* Select that cell */
    @call oself::MSG_VIS_GRID_SELECT_CELL(column, row) ;

    /* Note that we have processed the mouse event */
    retVal->flags |= MRF_PROCESSED ;
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_GRID_DELETE_COLUMN
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Delete column from the grid.  This action will shift all the column
 |    widths down and make the grid one less (while correctly updating
 |    the screen).  Incorrect columns are ignored.
 |
 | Inputs:
 |    word column                 -- Column index to delete
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/13/99  Created
 |
 *-----------------------------------------------------------------------*/

@method VisGridClass, MSG_VIS_GRID_DELETE_COLUMN
{
    optr array ;
    word *p_element ;
    word size ;

    if (!(pself->VGI_flags & VIS_GRID_FLAG_INITIAL_CELLS_MADE))
        @call oself::MSG_VIS_GRID_INITIAL_CELLS() ;

    if (pself->VGI_cellWidths)  {
        array = ConstructOptr(OptrToHandle(oself), pself->VGI_cellWidths) ;

        /* Find the column (if its there) */
        p_element = ChunkArrayElementToPtr(array, column, &size) ;
        if (p_element)  {
            /* We are going to have to invalidate before we delete */
            /* so we get a redraw of the whole space before it is */
            /* smaller. */
            @call oself::MSG_VIS_GRID_INVALIDATE_CELL_RANGE(
                column, 0,
                VIS_GRID_LOCATION_PAST_END, VIS_GRID_LOCATION_PAST_END) ;

            /* Delete the column width in the chunk array */
            ChunkArrayDelete(array, p_element);
            pself = ObjDerefVis(oself) ;

            /* Move the selection over */
            if ((column < pself->VGI_selectionX) &&
                    (pself->VGI_selectionX != VIS_GRID_SELECTION_NONE))  {
                @call oself::MSG_VIS_GRID_SELECT_CELL(
                          pself->VGI_selectionX-1,
                          pself->VGI_selectionY) ;
            } else if (column == pself->VGI_selectionX)  {
                @call oself::MSG_VIS_GRID_SELECT_CELL(
                          VIS_GRID_SELECTION_NONE,
                          VIS_GRID_SELECTION_NONE) ;
            }
            @call oself::MSG_VIS_RECALC_SIZE(0, 0) ;
        }
    }
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_GRID_DELETE_ROW
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Delete row from the grid.  This action will shift all the row
 |    heights up and make the grid one less (while correctly updating
 |    the screen).  Incorrect rows are ignored.
 |
 | Inputs:
 |    word row                    -- Row index to delete
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/13/99  Created
 |
 *-----------------------------------------------------------------------*/
@method VisGridClass, MSG_VIS_GRID_DELETE_ROW
{
    optr array ;
    word *p_element ;
    word size ;

    if (!(pself->VGI_flags & VIS_GRID_FLAG_INITIAL_CELLS_MADE))
        @call oself::MSG_VIS_GRID_INITIAL_CELLS() ;

    if (pself->VGI_cellHeights)  {
        array = ConstructOptr(OptrToHandle(oself), pself->VGI_cellHeights) ;

        /* Find the row, and if not found, just ignore */
        p_element = ChunkArrayElementToPtr(array, row, &size) ;
        if (p_element)  {
            /* We are going to have to invalidate before we delete */
            /* so we get a redraw of the whole space before it is */
            /* smaller. */
            @call oself::MSG_VIS_GRID_INVALIDATE_CELL_RANGE(
                0, row,
                VIS_GRID_LOCATION_PAST_END, VIS_GRID_LOCATION_PAST_END) ;

            /* Delete and shift */
            ChunkArrayDelete(array, p_element);
            pself = ObjDerefVis(oself) ;

            /* Now update the selected location */
            if ((row < pself->VGI_selectionY) &&
                    (pself->VGI_selectionY != VIS_GRID_SELECTION_NONE))  {
                @call oself::MSG_VIS_GRID_SELECT_CELL(
                    pself->VGI_selectionX,
                    pself->VGI_selectionY-1) ;
            } else if (row == pself->VGI_selectionY)  {
                @call oself::MSG_VIS_GRID_SELECT_CELL(
                          VIS_GRID_SELECTION_NONE,
                          VIS_GRID_SELECTION_NONE) ;
            }

            /* NOw how big are we? */
            @call oself::MSG_VIS_RECALC_SIZE(0, 0) ;
        }
    }
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_GRID_INVALIDATE_CELL_RANGE
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Redraws a whole range of cells.
 |
 | Inputs:
 |    word startColumn, startRow  -- Top left location
 |    word endColumn, endRow      -- Bottom right location
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/12/99  Created
 |
 *-----------------------------------------------------------------------*/
@method VisGridClass, MSG_VIS_GRID_INVALIDATE_CELL_RANGE
/*  (word startColumn,
     word startRow,
     word endColumn,
     word endRow) ; */
{
    Rectangle rect ;

    if (!(pself->VGI_flags & VIS_GRID_FLAG_INITIAL_CELLS_MADE))
        @call oself::MSG_VIS_GRID_INITIAL_CELLS() ;

    rect.R_left = @call oself::MSG_VIS_GRID_FIND_COLUMN_X(startColumn) ;
    rect.R_top = @call oself::MSG_VIS_GRID_FIND_ROW_Y(startRow) ;

    if (endColumn < VIS_GRID_LOCATION_PAST_END)
        endColumn++ ;
    rect.R_right = @call oself::MSG_VIS_GRID_FIND_COLUMN_X(endColumn) ;

    if (endRow < VIS_GRID_LOCATION_PAST_END)
        endRow++ ;
    rect.R_bottom = @call oself::MSG_VIS_GRID_FIND_ROW_Y(endRow) ;

    if (((startColumn==0) && (endColumn == VIS_GRID_LOCATION_PAST_END)) ||
        ((startRow==0) && (endRow == VIS_GRID_LOCATION_PAST_END)))  {
         if (startColumn==0)
             rect.R_left -= pself->VGI_rimWidth ;
         if (startRow==0)
             rect.R_top -= pself->VGI_rimWidth ;
         if (endColumn == VIS_GRID_LOCATION_PAST_END)
             rect.R_right += pself->VGI_rimWidth ;
         if (endRow == VIS_GRID_LOCATION_PAST_END)
             rect.R_bottom += pself->VGI_rimWidth ;
    }

    @call oself::MSG_VIS_GRID_INVALIDATE_RECTANGLE(&rect) ;
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_GRID_INVALIDATE_RECTANGLE
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Redraws a rectangular region of the grid using the grid's
 |    coordinates.  If the grid is suspended, all INVALIDATE_RECTANGLE
 |    calls are combined into a bigger invalidation rectangle but does
 |    not occur until unsuspended.
 |
 | Inputs:
 |    Rectangle *p_rect           -- Pointer to rectangle to invalidate
 |                                   (in grid based coordinates)
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/12/99  Created
 |
 *-----------------------------------------------------------------------*/
@method VisGridClass, MSG_VIS_GRID_INVALIDATE_RECTANGLE
{
    GStateHandle gstate ;

    if (pself->VGI_suspendCount == 0)  {
        /* Not suspended, invalidate now */
        gstate = @call oself::MSG_VIS_VUP_CREATE_GSTATE() ;
        GrInvalRect(
            gstate,
            pself->VI_bounds.R_left+p_rect->R_left,
            pself->VI_bounds.R_top+p_rect->R_top,
            pself->VI_bounds.R_left+p_rect->R_right,
            pself->VI_bounds.R_top+p_rect->R_bottom) ;
        GrDestroyState(gstate) ;
    } else {
        /* Suspended, either store as the next rectangle to invalidate,
           or combine with previous region and take bigger (enclosing)
           rectangle. */
        if (pself->VGI_pending & VIS_GRID_PENDING_INVAL_RECT)  {
            /* Take the maximum bounds of rectangular regions */
            if (p_rect->R_left < pself->VGI_invalRect.R_left)
                pself->VGI_invalRect.R_left = p_rect->R_left ;
            if (p_rect->R_right > pself->VGI_invalRect.R_right)
                pself->VGI_invalRect.R_right = p_rect->R_right ;
            if (p_rect->R_top < pself->VGI_invalRect.R_top)
                pself->VGI_invalRect.R_top = p_rect->R_top ;
            if (p_rect->R_bottom > pself->VGI_invalRect.R_bottom)
                pself->VGI_invalRect.R_bottom = p_rect->R_bottom ;
        } else {
            /* First time the invalidation rectangle is defined. */
            /* just copy it. */
            pself->VGI_invalRect = *p_rect ;
            pself->VGI_pending |= VIS_GRID_PENDING_INVAL_RECT ;
        }
    }
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_GRID_SELECT_CELL
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Changes which cell is selected, correctly undrawing the old location
 |    and redrawing the new location.  If already the current cell,
 |    no action happens.
 |    Pass VIS_GRID_SELECTION_NONE for both row and column to make the
 |    selection disappear.
 |
 | Inputs:
 |    word column, row            -- Cell column and row to select
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  04/12/99  Created
 |
 *-----------------------------------------------------------------------*/
@method VisGridClass, MSG_VIS_GRID_SELECT_CELL
/* (word column, word row) ; */
{
    optr parent, view ;
    Boolean isParent ;
    sword left, right, top, bottom ;

    if (!(pself->VGI_flags & VIS_GRID_FLAG_INITIAL_CELLS_MADE))
        @call oself::MSG_VIS_GRID_INITIAL_CELLS() ;

    if ((column != pself->VGI_selectionX) ||
        (row != pself->VGI_selectionY))  {
        if ((pself->VGI_selectionX != VIS_GRID_LOCATION_PAST_END) &&
            (pself->VGI_selectionY != VIS_GRID_LOCATION_PAST_END))  {
            @call oself::MSG_VIS_GRID_INVALIDATE_CELL_RANGE(
                    pself->VGI_selectionX,
                    pself->VGI_selectionY,
                    pself->VGI_selectionX,
                    pself->VGI_selectionY) ;
        }
        pself->VGI_selectionX = column ;
        pself->VGI_selectionY = row ;
        if ((column != VIS_GRID_LOCATION_PAST_END) &&
                (row != VIS_GRID_LOCATION_PAST_END))
            @call oself::MSG_VIS_GRID_INVALIDATE_CELL_RANGE(
                    pself->VGI_selectionX,
                    pself->VGI_selectionY,
                    pself->VGI_selectionX,
                    pself->VGI_selectionY) ;

        /* Find the GenView holding all this (if any) */
        parent = @call oself::MSG_VIS_FIND_PARENT() ;
        isParent = @call parent::MSG_META_IS_OBJECT_IN_CLASS(&GenViewClass) ;
        while (parent && (!isParent))  {
            parent = @call parent::MSG_VIS_FIND_PARENT() ;
            isParent = @call parent::MSG_META_IS_OBJECT_IN_CLASS(&GenViewClass) ;
        }

        if (parent)  {
            view = parent ;
            left = @call oself::MSG_VIS_GRID_FIND_COLUMN_X(
                       pself->VGI_selectionX) ;
            right = @call oself::MSG_VIS_GRID_FIND_COLUMN_X(
                       pself->VGI_selectionX+1) ;
            top = @call oself::MSG_VIS_GRID_FIND_ROW_Y(
                       pself->VGI_selectionY) ;
            bottom = @call oself::MSG_VIS_GRID_FIND_ROW_Y(
                       pself->VGI_selectionY+1) ;
            if ((bottom >= top) && (right >= left))  {
                @call view::MSG_GEN_VIEW_MAKE_RECT_VISIBLE(
                          0 /*MRVF_ALWAYS_SCROLL*/,
                          0,
                          0 /*MRVF_ALWAYS_SCROLL*/,
                          0,
                          bottom,
                          right,
                          top,
                          left) ;
            }
        }
    }
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_GRID_GET_SELECTED_CELL
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Get the selected column and row (if any)
 |
 | Inputs:
 |    word *p_column              -- Pointer to place column
 |    word *p_row                 -- Pointer to place row
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  07/22/99  Created
 |
 *-----------------------------------------------------------------------*/
@method VisGridClass, MSG_VIS_GRID_GET_SELECTED_CELL
{
    /* Return the data */
    *p_column = pself->VGI_selectionX ;
    *p_row = pself->VGI_selectionY ;

    /* Ensure that if either are none, both are none */
    if ((pself->VGI_selectionX == VIS_GRID_SELECTION_NONE) ||
            (pself->VGI_selectionX == VIS_GRID_SELECTION_NONE))
        *p_column = *p_row = VIS_GRID_SELECTION_NONE ;
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_GRID_GET_COLOR
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Return a color set being used for the given attribute.
 |
 | Inputs:
 |    VisGridColorItem item       -- Item color type to get
 |    ColorQuad *p_color          -- Color to use
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  07/22/99  Created
 |
 *-----------------------------------------------------------------------*/
@method VisGridClass, MSG_VIS_GRID_GET_COLOR
{
    switch(item)  {
        case VIS_GRID_COLOR_ITEM_BACKGROUND:
            *p_color = pself->VGI_backgroundColor ;
            break ;
        case VIS_GRID_COLOR_ITEM_RIM:
            *p_color = pself->VGI_rimColor ;
            break ;
        case VIS_GRID_COLOR_ITEM_DIVIDERS:
            *p_color = pself->VGI_innerDividersColor ;
            break ;
        case VIS_GRID_COLOR_ITEM_SELECTION_BACK:
            *p_color = pself->VGI_selectionBackgroundColor ;
            break ;
    }
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_GRID_SET_COLOR
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Change a color set.
 |
 | Inputs:
 |    VisGridColorItem item       -- Item color type to set
 |    ColorQuad *p_color          -- Color to use
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  07/22/99  Created
 |
 *-----------------------------------------------------------------------*/
@method VisGridClass, MSG_VIS_GRID_SET_COLOR
{
    switch(item)  {
        case VIS_GRID_COLOR_ITEM_BACKGROUND:
            pself->VGI_backgroundColor = *p_color ;
            break ;
        case VIS_GRID_COLOR_ITEM_RIM:
            pself->VGI_rimColor = *p_color ;
            break ;
        case VIS_GRID_COLOR_ITEM_DIVIDERS:
            pself->VGI_innerDividersColor = *p_color ;
            break ;
        case VIS_GRID_COLOR_ITEM_SELECTION_BACK:
            pself->VGI_selectionBackgroundColor = *p_color ;
            break ;
    }
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_GRID_GET_DESTINATION
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Get who we are talking to
 |
 | Outputs:
 |    optr                        -- Yep, the destination object
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  07/22/99  Created
 |
 *-----------------------------------------------------------------------*/
@method VisGridClass, MSG_VIS_GRID_GET_DESTINATION
{
    return pself->VGI_destination ;
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_GRID_GET_DRAW_MESSAGE
 *-------------------------------------------------------------------------
 | Description:
 |    Get what message is sent to the destination to draw one cell.
 | Outputs:
 |    Message                     -- Message to be sent
 *-----------------------------------------------------------------------*/
@method VisGridClass, MSG_VIS_GRID_GET_DRAW_MESSAGE
{
    return pself->VGI_drawMsg ;
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_GRID_SET_DRAW_MESSAGE
 *-------------------------------------------------------------------------
 | Description:
 |    Set what message is sent to the destination to draw one cell.
 | Inputs:
 |    Message mess                -- Message to be sent
 *-----------------------------------------------------------------------*/
@method VisGridClass, MSG_VIS_GRID_SET_DRAW_MESSAGE
{
    pself->VGI_drawMsg = mess ;
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_GRID_GET_NUM_COLUMNS
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Return the number of columns
 |
 | Outputs:
 |    word                        -- Number of columns
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  07/27/99  Created
 |
 *-----------------------------------------------------------------------*/
@method VisGridClass, MSG_VIS_GRID_GET_NUM_COLUMNS
{
    return ChunkArrayGetCount(
               ConstructOptr(OptrToHandle(oself),
               pself->VGI_cellWidths)) ;
}

/*-------------------------------------------------------------------------
 | Method:  VisGridClass::MSG_VIS_GRID_GET_NUM_ROWS
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Return the number of rows
 |
 | Outputs:
 |    word                        -- Number of rows
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  07/27/99  Created
 |
 *-----------------------------------------------------------------------*/
@method VisGridClass, MSG_VIS_GRID_GET_NUM_ROWS
{
    return ChunkArrayGetCount(
               ConstructOptr(OptrToHandle(oself),
               pself->VGI_cellHeights)) ;
}


/***************************************************************************
 *  END OF FILE:  VGridC.GOC                                                      *
 ***************************************************************************/
