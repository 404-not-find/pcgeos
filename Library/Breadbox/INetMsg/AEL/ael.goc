/**************************************************************************
*
*   Copyright (C) 1999  Breadbox Computer Company
*                       All Right Reserved
*
*   PROJECT:    AEL Test Application
*   FILE:       AELTest.goc
*   AUTHOR:     FR, 26th April, 1999
*
*   DESCRIPTION:
*       This is the AEL Test Application main file.
*
**************************************************************************/


/**************************************************************************
*   INCLUDES
**************************************************************************/

@include <StdApp.goh>

@include <Ansi/stdio.h>
@include <Ansi/string.h>

@include "INetMsg/AEL.goh"


/**************************************************************************
*   LOCAL TYPES
**************************************************************************/

/* routine to append a line to an AELDataBlock pointer,
   returns 1 for failure
 */
word AppendDataToBlock(AELDataHandle handle, char*data);
/* appends a boundary to the block, preceded by the "--" string */
void AppendBoundaryToBlock(AELDataHandle handle, char* boundary);

void AppendContentTypeToBlock(AELDataHandle handle, AELContentType content,
                                 char* name, char* id, char* boundary,
                                 word number, word total);

/* checks if the session is a UUencode session */
Boolean isSessionUU(AELAttachmentParameters *params,
                    AELAttachmentItem *item);

/* get the session error flag */
AELError getSessionError(AELHandle sessionHandle);

/* routines to return a text version of a content or encoding value */
char* getContentText(AELContentType content);
char* getEncodingText(AELEncoding enc);

char* getMimeNameFromItem(AELAttachmentItem* item);
char* getMimeBoundaryFromItem(AELAttachmentItem* item);
char* getMimeIDFromItem(AELAttachmentItem* item);
char* getMimeBoundaryFromParameters(AELAttachmentParameters* params);

/* helper EOF function */
Boolean eof (FileHandle fh);

/* uuencode function */
void uuencode(char* data, char* dest, char length, Boolean insertLF);
/* QP encoding function */
char toQP(char* data, char* dest);
/* base 64 encoding function */
int to64 (char* data, char* dest, word length);

/* set a session's error based on the file error received */
void fillThreadFileError(AELSession* session);

/* AEL data recycling functions */
/* put block back for recycling */
/* get block out of recycling chain */
AELDataHandle GetRecycledBlock(AELSession* session);
/* verify session and data validity, and lock session */
AELSession* verifyAndLockSession(AELHandle handle, char* data);
/* get a data block for a session*/
AELDataHandle getDataBlock(AELSession* session);
/* append the first multipart headers in a MIME message */
void appendFirstMultipartHeaders(AELSession *session, AELDataHandle holder,
                                 AELAttachmentParameters* params, char* scratch);

/* append the content-type and content-transfer-encoding headers to a block */
void appendMIMEContentHeaders(AELSession *session,
                              AELAttachmentItem* item,
                              AELDataHandle holder,
                              char* scratch);

/* append the first item headers in a MIME message */
void appendMIMEItemHeaders(AELSession *session, AELDataHandle holder,
                           AELAttachmentItem* item, char* scratch);

/* chain a file into UUencoded, plain, or QP/Base64 blocks */
void chainUUencodedFile(FileHandle fhandle, char* scratch, AELDataHandle holder);
void chainPlainFile (FileHandle fhandle, char* scratch, AELDataHandle holder,
                     AELAttachmentItem *item, AELSession *session);

void chainBase64orQPFile(FileHandle fhandle, char* scratch, AELDataHandle holder,
                     AELAttachmentItem *item, AELSession *session);

/* append UUencoded, plain, or QP/Base64 data to a block from input data */
void appendUUencodedDataToBlock(char* data, char*scratch, word length,
                                AELDataHandle holder);
void appendPlainDataToBlock(char* data, char*scratch, word length,
                            AELDataHandle holder);
void appendBase64orQPDataToBlock(char* data, char*scratch, word length,
                                 AELDataHandle holder, AELAttachmentItem *item);


/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  SwatBreak
 *-------------------------------------------------------------------------

   Description:
      Used to put conditional breakpoints in the code - the function does
      nothing, the reason++ line is just to stop the compiler from
      complaining.  I pass the reason parameter as a brief explanation
      of where the function is called from.

   Inputs:
      char *reason                 -- Null terminated text reason

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  04/21/99  Created.
 *-----------------------------------------------------------------------*/
EC(
    void SwatBreak(char* reason)
    {
        reason++;
    }
)

/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  eof
 *-------------------------------------------------------------------------

   Description:
      Used to test if the end of a file is reached.  Returns logical
      true/false value, according to the machine.  Does not check if
      the handle passed is NULL.

   Inputs:
      FileHandle fh                     - non-NULL file handle

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  04/21/99  Created.
 *-----------------------------------------------------------------------*/
Boolean eof (FileHandle fh)
{
 dword curpos = FilePos (fh, 0, FILE_POS_RELATIVE);
 dword eofpos = FilePos (fh, 0, FILE_POS_END);
 FilePos(fh, curpos, FILE_POS_START);
 return (curpos == eofpos);
}

/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  output64chunk
 *-------------------------------------------------------------------------

   Description:
      Used to output 4 Base64 characters from 3 binary characters.
      The pads parameter tells the routine if 0, 1, or 2 of the input
      characters should be ignored (starting with c3 and working back
      through the parameter list).

   Inputs:
      char* dest                        - output destination
      char c1, c2, c3                   - characters to be Base64 encoded
      char pads                         - how many padding characters are
                                          needed

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
void output64chunk(char* dest, char c1, char c2, char c3, char pads)
{
 static char basis_64[] =
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

 dest[0] = basis_64[c1>>2];
 dest[1] = basis_64[((c1 & 0x3)<< 4) | ((c2 & 0xF0) >> 4)];

 switch (pads)
 {
  case 2:
   dest[2] = '=';
   dest[3] = '=';
   break;
  case 1:
   dest[2] = basis_64[((c2 & 0xF) << 2) | ((c3 & 0xC0) >>6)];
   dest[3] = '=';
   break;
  case 0:
   dest[2] = basis_64[((c2 & 0xF) << 2) | ((c3 & 0xC0) >>6)];
   dest[3] = basis_64[c3 & 0x3F];
   break;
  default:
   EC(SwatBreak("Bad pads value!"));
   break;
 }

}

/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  to64
 *-------------------------------------------------------------------------

   Description:
      Used to output n characters from 3n/4 (length) binary characters.
      The destination buffer should have 2*length bytes available for
      safety.  Length should be a multiple of 54 bytes (1 line of text),
      except for the last block of data.

   Inputs:
      char* data                        - input location
      char* dest                        - output destination
      word length                       - how many bytes to copy from input

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
int to64 (char* data, char* dest, word length)
{
 char c1, c2;
 word count=0;
 word current=0;
 word output_offset = 0;

 while (current < length)
 {
  c1 = data[current];
  current++;

  if (current == length) /* did we reach the end of the data? */
  {
   output64chunk(dest+output_offset, c1, 0, 0, 2);
  }
  else
  {
   c2 = data[current];
   current++;

   if (current == length)
    output64chunk(dest+output_offset, c1, c2, 0, 1);
   else
   {
    output64chunk(dest+output_offset, c1, c2, data[current], 0);
    current++;
   }
  }
  output_offset +=4; /* 4 chars are always written at a time */
  count += 4;
  if (count > 71)
  {
   dest[output_offset] = '\n';
   output_offset++;
   count = 0;
  }
 }

 if (count)
 {
  dest[output_offset] = '\n';
  output_offset++;
  count++;
 }

 dest[output_offset] = '\0';
 return output_offset;
}


/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  outdec
 *-------------------------------------------------------------------------

   Description:
      Used to output 4 UUencoded characters from 3 binary characters.

   Inputs:
      char* dest                        - output destination
      char one, two, three              - characters to be UUencoded

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
void outdec(char one, char two, char three, char* dest)
{

#define ENC(c) (((c) & 077) + ' ')

 dest[0] = ENC(one >> 2);
 dest[1] = ENC(((one << 4) & 060) | ((two >> 4) & 017));
 dest[2] = ENC(((two << 2) & 074) | ((three >> 6) & 03));
 dest[3] = ENC(three & 077);
}

/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  uuencode
 *-------------------------------------------------------------------------

   Description:
      Used to output n characters from 3n/4 (length) binary characters.
      The destination buffer should have 2*length bytes available for
      safety.  Length should be 45 bytes, except for the last block of data.

   Inputs:
      char* data                        - input location
      char* dest                        - output destination
      word length                       - how many bytes to copy from input
      Boolean insertLF                  - should we insert the LF character?

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
void uuencode(char* data, char* dest, char length, Boolean insertLF)
{
 int i, output_offset;
 int n = length - length%3;

 /* 1 (up to) 45 character line can be handled */
 dest[0] = ENC(length);
 output_offset = 1;

 for (i = 0; i < n; i += 3, output_offset+=4)
  outdec(data[i], data[i+1], data[i+2], dest+output_offset);

 switch (length%3)
 {
  case 2:
   outdec(data[i], data[i+1], 0, dest+output_offset);
   dest[output_offset+3] = '=';
   output_offset+=4;
   break;
  case 1:
   outdec(data[i], 0, 0, dest+output_offset);
   dest[output_offset+2] = '=';
   dest[output_offset+3] = '=';
   output_offset+=4;
   break;
  case 0:
   /* do nothing */
   break;
 }

 /* should we insert a '\n' character? */
 if (insertLF)
 {
  dest[output_offset] = '\n';
  output_offset++;
 }

 /* terminate string */
 dest[output_offset] = '\0';
}

/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  toQP
 *-------------------------------------------------------------------------

   Description:
      Used to output Quoted-Printable data.  The destination buffed
      3*length of input data bytes available for safety.  Length should
      be a multiple of 54 bytes (1 line of text), except for the last
      block of data.  The function returns 1 for failure, 0 for success.

   Inputs:
      char* data                        - input NULL-terminated string
      char* dest                        - output destination

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
char toQP(char* data, char* dest)
{
 word length = strlen(data);
 word i;
 word output_offset=0;
 word line_count = 0; /* should stay under 76 characters */
 char c;

 if (NULL == data || NULL == dest) return 1;

 for (i=0; i < length; i++)
 {
  c = data[i];

  /* translate c as appropriate */
  if ('\n' == c)
  {
   /* note: we assume that '\r' characters are filtered out!!!  so we
      only handle '\n' characters.
    */
   sprintf(dest+output_offset, "=0D=0A");
   output_offset += 6;
   line_count+=6;
  }
  else if ( (c>=33 && c<=60) || (c>=62 && c<=126) )
  {
   /* 33-60 and 62-126 are legal to print directly, no translation. */
   /* 61 is excluded, because it is the '=' character, which is special */
   dest[output_offset] = c;
   output_offset++;
   line_count++;
  }
  else
  {
   /* c is a special character, encode into =XX format */
   if (c >= 0x10) sprintf (dest+output_offset, "=%X", c);
   else sprintf (dest+output_offset, "=0%X", c);
   output_offset += 3;
   line_count+=3;
  }
  if (line_count > 70) /* allow for 6 chars max ('\n') for one cycle */
  {
   line_count = 0;
   sprintf(dest+output_offset, "=\n");
   output_offset+=2;
  }
 }
 dest[output_offset] = '\0';
 output_offset++;
 return 0; /* success! */
}

/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  AELAppendCharToLastLineInBlock
 *-------------------------------------------------------------------------

   Description:
      Used to append a single character to a data block.  It does NOT
      check if there is room for that character, and it ASSUMES that
      one or more data lines are already in the data block.  It will
      fail gracefully, however.

   Inputs:
      AELDataBlock *block               - pointer to the data block
      char c                            - character to append

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
void AELAppendCharToLastLineInBlock(AELDataBlock *block, char c)
{
 word count, size;
 char* line = block->ADB_lines;
 AELDataBlock* next_block;

 if (NULL != block->ADB_next)
 {
  next_block = (AELDataBlock*) MemLock(block->ADB_next);
  AELAppendCharToLastLineInBlock(next_block, c);
  MemUnlock(block->ADB_next);
  return;
 }

 /* advance to the unused space */
 for (count = 0; count < block->ADB_numLines; count++)
 {
  /* how much forward do we have to move? */
  size = strlen(line);

  /* get out of here, if we would go outside the block's bounds */
  if (line+size+1 >= block->ADB_lines+AEL_ADB_SIZE) return;

  /* move forward by "size" bytes */
  line += size+1;
 }

 /* move back one, so we are on top of the '\0' character */
 if (line != block->ADB_lines) line--;

 /* now, line points to the correct spot in ADB_lines */

 /* we are OK, so go ahead and copy the char */
 line[0] = c;
 line[1] = '\0';
 block->ADB_numBytes++;

 return;
}

/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  AppendDataToBlock
 *-------------------------------------------------------------------------

   Description:
      Used to append data to a data block.  This function has two stages:
      1) Verify space is available and the current block is the last one
         in the chain.  If either is not true, check if the current block
         is the last one, and allocate a new block after it if so.  Then,
         call AppendDataToBlock recursively on the new block with the old
         data.  After the recursive call is done, return.

      2) This stage is reached if the current block has room for the
         data to be copied into it.  We advance to the insertion point
         in the block, and then copy the new data, updating the ADB_numBytes
         and ADB_numLines counters for the data stored in ADB_lines.  We
         skip '\r' (LF) characters when they are followed by '\n' (CR)
         characters.  Also, we replace all '\n' characters with a '\0'
         NULL character, and we increment the ADB_numLines counter when
         that happens.  Thus, we ensure that all data store in the block
         will not contain CR or unnecessary LF characters, while also
         preserving the byte count, and the concept of line-by-line
         output.

   Inputs:
      AELDataHandle handle              - handle of the data block
      char* data                        - NULL-terminated text data string

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
word AppendDataToBlock(AELDataHandle handle, char* data)
{
 word count, bytes, size;
 AELDataBlock *block;
 char* line;

 bytes = strlen(data)+1;

 /* never allow input of more than AEL_ADB_SIZE-1 bytes */
 if (bytes >= AEL_ADB_SIZE-1) return 1;

 /* lock the handle down */
 block = (AELDataBlock*) MemLock(handle);

 /* if the chain extends past this block, or if we would overflow the buffer */
 if (block->ADB_next != NULL || block->ADB_numBytes+bytes > AEL_ADB_SIZE)
 {
  /* we need to go to the next block, and create it if it doesn't exist */
  if (NULL == block->ADB_next)
  {
   block->ADB_next = MemAlloc(sizeof(AELDataBlock), HF_SWAPABLE, HAF_ZERO_INIT);
   /* did we allocate the memory OK? */
   if (NULL == block->ADB_next) 
   {
    MemUnlock(handle);      
    return 1;
   }
  }

  AppendDataToBlock(block->ADB_next, data);
  MemUnlock(handle);
  return 0;
 }

 line = block->ADB_lines; /* advance to the unused space */
 for (count = 0; count < block->ADB_numLines; count++)
 {
  size = strlen(line);
  /* get out of here, if we would go outside the block's bounds */
  if (line+size+1 >= block->ADB_lines+AEL_ADB_SIZE) 
  {
   MemUnlock(handle);
   return 1;
  }

  /* move forward by n bytes */
  line += size+1;
 }

 /* now, line points to the correct spot in ADB_lines */

 /* check if the new data would overflow the ADB_lines buffer (shouldn't
    happen).
    If so, get out of the routine.
  */
 if (1+bytes+line >= block->ADB_lines+AEL_ADB_SIZE) 
 {
  MemUnlock(handle);
  return 1;
 }

 /* we are OK, so go ahead and copy the string */
 do
 {
  /* completely ignore the LF character */
  if ('\r' == *data)
  {
   data++;
   if (bytes > 0) bytes--;
   continue;
  }

  /* copy character */
  *line = *data;

  /* increment the lines counter if needed, and clear the CR char */
  if ('\n' == *data || '\0' == *data)
  {
   block->ADB_numLines++;
   *line = '\0';
  }

  /* a CR at the end of the string is ignored */
  if ('\n' == *data && '\0' == *(data+1))
  {
   block->ADB_numBytes+= bytes-1;
   break;
  }

  /* break at end of string */
  if ('\0' == *data)
  {
   block->ADB_numBytes+= bytes;
   break;
  }

  /* move 1 char forward */
  data++;
  line++;
 }
 while (1);

 /* lock the handle down */
 MemUnlock(handle);
 return 0;
}

/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  AppendContentTypeToBlock
 *-------------------------------------------------------------------------

   Description:
      Used to append the content-type line to a data block.  It does NOT
      check if there is room for line.  It will fail gracefully, but without
      returning an error code.  Note that the content-type line has the
      following components: content, name, id, boundary, number, and total.
      All but number and total should be set to NULL to be ignored; number
      and total should be set to 0 to be ignored.  The id, name, and
      boundary will be printed in quotes.

   Inputs:
      AELDataHandle handle              - pointer to the data block
      AELContentType content            - content type code
      char* name                        - NULL-terminated name
      char* id                          - NULL-terminated id
      char* boundary                    - NULL-terminated boundary
      word number                       - number of part
      word total                        - total parts

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
void AppendContentTypeToBlock(AELDataHandle handle, AELContentType content,
                                 char* name, char* id, char* boundary,
                                 word number, word total)
{
 char text[81]; /* we don't go over 80 characters per line */
 AELDataBlock* block = (AELDataBlock*) MemLock(handle);

 /* put the content type in first */
 sprintf (text, "Content-Type: %s", getContentText(content));
 AppendDataToBlock(handle, text);

 /* do we have a name? */
 if (name != NULL)
 {
  /* continue last line */
  AELAppendCharToLastLineInBlock(block, ';');
  sprintf (text, "\tname=\"%s\"", name);
  AppendDataToBlock(handle, text);
 }
 /* do we have an ID? */
 if (id != NULL)
 {
  /* continue last line */
  AELAppendCharToLastLineInBlock(block, ';');
  sprintf (text, "\tid=\"%s\"", id);
  AppendDataToBlock(handle, text);
 }
 /* do we have a boundary? */
 if (boundary != NULL)
 {
  /* continue last line */
  AELAppendCharToLastLineInBlock(block, ';');
  sprintf (text, "\tboundary=\"%s\"", boundary);
  AppendDataToBlock(handle, text);
 }
 /* do we have a number? */
 if (number > 0)
 {
  /* continue last line */
  AELAppendCharToLastLineInBlock(block, ';');
  sprintf (text, "\tnumber=%d", number);
  AppendDataToBlock(handle, text);
 }
 /* do we have a total? */
 if (total > 0)
 {
  /* continue last line */
  AELAppendCharToLastLineInBlock(block, ';');
  sprintf (text, "\ttotal=%d", total);
  AppendDataToBlock(handle, text);
 }
 MemUnlock(handle) ;
}

/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  isSessionUU
 *-------------------------------------------------------------------------

   Description:
      Used to check if a session is for a UU-encoded item (session wrapper is
      AEL_WRAPPER_NONE, and encoding of item is AEL_ENCODING_UU).

   Inputs:
      AELAttachmentParameters *params   - pointer to the AEL attachment
                                          parameters
      AELAttachmentItem *item           - pointer to the AEL attachment
                                          item

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
Boolean isSessionUU(AELAttachmentParameters *params,
                    AELAttachmentItem *item)
{
 if (params->AAP_wrapper == AEL_WRAPPER_NONE &&
     item->AAI_encoding == AEL_ENCODING_UU)
  return TRUE;
 else return FALSE;
}

/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  getSessionError
 *-------------------------------------------------------------------------

   Description:
      Used to get the session error.  Does NOT check if the session handle
      is NULL.

   Inputs:
      AELHandle sessionHandle           - session handle

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
AELError getSessionError(AELHandle sessionHandle)
{
 AELError err = ((AELSession*) MemLock(sessionHandle))->AS_error;
 MemUnlock(sessionHandle);
 return err;
}

/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  getEncodingText
 *-------------------------------------------------------------------------

   Description:
      Used to get the content-transfer-encoding text.  Will return ""
      for an invalid encoding type.

   Inputs:
      AELEncoding enc                   - encoding type code

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
char* getEncodingText(AELEncoding enc)
{
 switch (enc)
 {
  case AEL_ENCODING_NONE: return "7bit";
  case AEL_ENCODING_UU: return "uuencode";
  case AEL_ENCODING_QP: return "quoted-printable";
  case AEL_ENCODING_BASE64: return "base64";
 }
 return "";
}

/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  getContentText
 *-------------------------------------------------------------------------

   Description:
      Used to get the content-type text.  Will return "text/plain"
      for an invalid content type.

   Inputs:
      AELContentType content            - content type code

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
char* getContentText(AELContentType content)
{
 switch (content)
 {
  case AEL_CONTENT_JPG: return "image/jpg";
  case AEL_CONTENT_GIF: return "image/gif";
  case AEL_CONTENT_BINARY: return "application/binary";
  case AEL_CONTENT_TEXT_HTML: return "text/html";
  case AEL_CONTENT_TEXT_PLAIN: return "text/plain";
  case AEL_CONTENT_TEXT_RICH: return "text/richtext";
  case AEL_CONTENT_MULTIPART: return "multipart/mixed";
  case AEL_CONTENT_PARTIAL: return "message/partial";
 }
 return "text/plain";
}

/*-------------------------------------------------------------------------
 | Routine:  getMimeNameFromItem
 *-------------------------------------------------------------------------

   Description:
      Used to get the item's name.  Will return NULL for a 0-length
      string, since item->AAI_name can not be NULL.  Does NOT check
      if item is NULL.

   Inputs:
      AELAttachmentItem *item              - attachment item

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
char* getMimeNameFromItem(AELAttachmentItem* item)
{
 if (strlen(item->AAI_name) > 0)
  return item->AAI_name;
 else return NULL;
}

/*-------------------------------------------------------------------------
 | Routine:  getMimeBoundaryFromItem
 *-------------------------------------------------------------------------

   Description:
      Used to get the item's boundary.  Will return NULL for a 0-length
      string, since item->AAI_mimeBoundary can not be NULL.  Does NOT check
      if item is NULL.

   Inputs:
      AELAttachmentItem *item              - attachment item

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
char* getMimeBoundaryFromItem(AELAttachmentItem* item)
{
 if (strlen(item->AAI_mimeBoundary) > 0)
  return item->AAI_mimeBoundary;
 else return NULL;
}

/*-------------------------------------------------------------------------
 | Routine:  getMimeIDFromItem
 *-------------------------------------------------------------------------

   Description:
      Used to get the item's ID.  Will return NULL for a 0-length
      string, since item->AAI_mimeID can not be NULL.  Does NOT check
      if item is NULL.

   Inputs:
      AELAttachmentItem *item              - attachment item

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
char* getMimeIDFromItem(AELAttachmentItem* item)
{
 if (strlen(item->AAI_mimeID) > 0)
  return item->AAI_mimeID;
 else return NULL;
}

/*-------------------------------------------------------------------------
 | Routine:  getMimeBoundaryFromParameters
 *-------------------------------------------------------------------------

   Description:
      Used to get the session's boundary.  Will return NULL for a 0-length
      string, since params->AAP_mimeBoundary can not be NULL.
      Does NOT check if params is NULL.

   Inputs:
      AELAttachmentParameters *params        - pointer to AEL session parameters

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
char* getMimeBoundaryFromParameters(AELAttachmentParameters* params)
{
 if (strlen(params->AAP_mimeBoundary) > 0)
  return params->AAP_mimeBoundary;
 else return NULL;
}

/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  AppendBoundaryToBlock
 *-------------------------------------------------------------------------

   Description:
      Used to append the boundary line to a data block.  It does NOT
      check if there is room for line.  It will fail gracefully, but without
      returning an error code.  The boundary line is two '-' characters,
      followed by the boundary itself.

   Inputs:
      AELDataHandle handle              - pointer to the data block
      char* boundary                    - NULL-terminated boundary

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
void AppendBoundaryToBlock(AELDataHandle handle, char* boundary)
{
 /* boundary length should never be more than 77 */
 char text[80];
 /* do nothing with an invalid string */
 if (NULL == boundary || strlen(boundary) > 77) return;

 sprintf (text, "--%s", boundary);
 AppendDataToBlock(handle, text);
}

/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  AELCreateSession
 *-------------------------------------------------------------------------

   Description:
      This function creates a new session, and it copies the passed
      AEL session parameters into it.  It will return NULL if errors
      occur. If the passed parameters were invalid, the session's
      error code may be set to indicate the problem.

   Inputs:
      AELAttachmentParameters *params        - pointer to AEL session parameters

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
AELHandle  _pascal _export AELCreateSession(AELAttachmentParameters *params)
{
 AELHandle handle = NULL;
 AELSession *session = NULL;

 /* allocate handle */
 handle = MemAlloc(sizeof(AELSession), HF_SWAPABLE, HAF_ZERO_INIT);

 /* insufficient memory */
 if (NULL == handle) return NULL;

 session = (AELSession*) MemLock(handle);
 session->AS_params = *params;
 session->AS_freeBlocks = NULL;
 session->AS_error = AEL_ERROR_NONE;
 session->AS_current = 0;
 session->AS_newItem = TRUE;
 session->AS_newPart = TRUE;
 session->AS_newSession = TRUE;
 session->AS_currentPart = 0;
 /* allocate scratch */
 session->AS_scratchHandle = MemAlloc(AEL_ADB_SIZE, HF_SWAPABLE, HAF_ZERO_INIT);

 /* if memory could not be allocated, return NULL for error */
 if (NULL == session->AS_scratchHandle)
 {
  MemUnlock(handle);
  MemFree(handle);
  return NULL;
 }

 /* check validity of parameters */
 if (params != NULL)
 {
  /* We don't allow the SPLIT wrapper at the top level */
  if (AEL_WRAPPER_SPLIT == params->AAP_wrapper)
   session->AS_error = AEL_ERROR_WRAPPER_MISMATCH;

  /* more than one item is passed for uuencoding, we don't allow that */
  if (AEL_WRAPPER_NONE == params->AAP_wrapper && 1 < params->AAP_numItems)
   session->AS_error = AEL_ERROR_TOO_MANY_UU;

  /* too many items specified */
  if (AEL_MAX_ITEMS < params->AAP_numItems)
   session->AS_error = AEL_ERROR_TOO_MANY_ITEMS;
 }
 else session->AS_error = AEL_ERROR_NULL_PARAMS; /*parameters must be passed*/

 MemUnlock(handle);

 return handle;
}

/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  AELDestroySession
 *-------------------------------------------------------------------------

   Description:
      This function destroys a session, and it deletes all the recycled
      blocks in the session.

   Inputs:
      AELHandle handle                       - handle of AEL session

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
void  _pascal _export AELDestroySession(AELHandle handle)
{
 /* we start with no current data block */
 AELDataHandle current = NULL;
 /* lock down session from handle */
 AELSession *session = (AELSession*) MemLock(handle);

 /* free all the recycled memory blocks */
 while (NULL != (current = GetRecycledBlock(session))) MemFree(current);

 /* free scratch handle */
 if (NULL != session->AS_scratchHandle) MemFree(session->AS_scratchHandle);

 /* unlock and free handle */
 MemUnlock(handle);
 MemFree(handle);
 handle = NULL;
}

/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  GetRecycledBlock
 *-------------------------------------------------------------------------

   Description:
      This function returns a recycled block from a session, and it
      sets the session's recycled block pointer to point to the next one in
      the chain.  A NULL will be returned if no blocks ara available for
      recycling.

   Inputs:
      AELSession *session                    - pointer to AEL session

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
AELDataHandle GetRecycledBlock(AELSession* session)
{
 AELDataHandle holder;
 AELDataBlock *block;
 int i;
 /* we return NULL if the session doesn't have any recycled blocks waiting */
 if (NULL == session->AS_freeBlocks) return NULL;

 /* get the first available data block, and let the session point to the
    next one in the chain
  */
 holder = session->AS_freeBlocks;
 block = (AELDataBlock*) MemLock(holder);
 session->AS_freeBlocks = block->ADB_next;
 /* clear everything... */
 block->ADB_numBytes = 0;
 block->ADB_numLines = 0;
 block->ADB_errorStatus = AEL_ERROR_NONE;
 for (i=0; i < AEL_ADB_SIZE; i++) block->ADB_lines[i] = '\0';
 MemUnlock(holder);
 return holder;
}

/**************************************************************************
 *   METHOD DEFINITION
 **************************************************************************/

/*-------------------------------------------------------------------------
 | Routine:  AELRecycleDataBlocks
 *-------------------------------------------------------------------------

   Description:
      This function recycles a chain of blocks from a session, and it
      attaches the chain to the end of the recycled blocks chain already
      in the session.

   Inputs:
      AELHandle handle                       - handle of AEL session
      AELDataHandle rec_block                - first block in recycled chain

   Revision History:
      Who  Date:     Comments:
      ---  --------  ---------
      TZZ  06/27/99  Created.
 *-----------------------------------------------------------------------*/
void _pascal _export AELRecycleDataBlocks(AELHandle handle, AELDataHandle rec_block)
{
 AELDataHandle current = NULL, temp = NULL;
 AELDataBlock *block = NULL;

 /* don't do anything if the block is NULL */
 if (NULL == rec_block) return;

 current = ((AELSession*) MemLock(handle))->AS_freeBlocks;
 MemUnlock(handle);
 while (current != NULL)
 {
  block = (AELDataBlock*) MemLock(current);
  temp = block->ADB_next;
  /* if we reach the end, we attach the recycled blocks, but temp is
     STILL NULL!  Thus, the loop will end gracefully when current
     gets temp's value.
   */
  if (temp == NULL)
   block->ADB_next = rec_block;
  MemUnlock(current);
  current = temp;
 }
}

AELSession* verifyAndLockSession(AELHandle handle, char* data)
{
 AELSession *session = NULL;

 /* verify handle, data, length, and return NULL if they are not good.
    We can't even set an error here, so we just return NULL.
  */

 if (NULL == handle ||
     NULL == data)
  return NULL;


 /* lock the session handle */
 session = (AELSession*) MemLock(handle);

 /* if an error has already been found, unlock session and return NULL */
 if (session->AS_error != AEL_ERROR_NONE)
 {
  MemUnlock(handle);
  return NULL;
 }

 return session;
}

AELDataHandle getDataBlock(AELSession* session)
{
 AELDataHandle holder;
 /* allocate new AELDataBlock, unless we can get it
    from the recycled blocks
  */
 holder = GetRecycledBlock(session);
 if (NULL == holder) holder = MemAlloc(sizeof(AELDataBlock),
                                       HF_SWAPABLE,
                                       HAF_ZERO_INIT);

 return holder;
}

void appendMIMEContentHeaders(AELSession *session,
                              AELAttachmentItem* item,
                              AELDataHandle holder,
                              char* scratch)
{
 AppendContentTypeToBlock(holder,
                             item->AAI_type,
                             getMimeNameFromItem(item),
                             getMimeIDFromItem(item),
                             getMimeBoundaryFromItem(item),
                             session->AS_currentPart,
                             item->AAI_mimeSplitParts
                            );
 /* print the content-transfer-encoding header */
 sprintf (scratch, "Content-Transfer-Encoding: %s",
                   getEncodingText(item->AAI_encoding));
 AppendDataToBlock(holder, scratch);
 /* append 2 empty lines */
 scratch[0] = '\0';
 AppendDataToBlock(holder, scratch);
// AppendDataToBlock(holder, scratch);
 AppendBoundaryToBlock(holder, getMimeBoundaryFromItem(item));
}

void appendFirstMultipartHeaders(AELSession *session, AELDataHandle holder,
                                 AELAttachmentParameters* params, char* scratch)
{
 /* make this false after the first time it's run */
 session->AS_newSession = FALSE;
 /* print the MIME version */
 AppendDataToBlock(holder, "Mime-Version: 1.0");

 /* print the multipart content type, since this is a multipart
   MIME message
  */
 AppendContentTypeToBlock(holder,
                             AEL_CONTENT_MULTIPART,
                             NULL, /* no MIME name for a multipart */
                             NULL, /* no MIME ID for a multipart */
                             getMimeBoundaryFromParameters(params),
                             0, /* no parts here */
                             0  /* no parts here */
                            );
 /* print the MIME warning, for non-MIME mail readers - this can be expanded */
 /* append 2 empty lines */
 scratch[0] = '\0';
// AppendDataToBlock(holder, scratch);
 AppendDataToBlock(holder, scratch);
 AppendDataToBlock(holder, "THIS IS A MIME MESSAGE");
}

void appendMIMEItemHeaders(AELSession *session, AELDataHandle holder,
                           AELAttachmentItem* item, char* scratch)
{
 /* ONCE per item or part,
    increment the current part for a split message, if it's 0
 */
 if (0 == session->AS_currentPart &&
    AEL_WRAPPER_SPLIT == item->AAI_wrapper)
  session->AS_currentPart = 1;

 /* print the content type */
 appendMIMEContentHeaders(session, item, holder, scratch);
}

void chainUUencodedFile(FileHandle fhandle, char* scratch, AELDataHandle holder)
{
 int i = 0;
 /* chain the UUencoded data blocks from the file */
 /* set up loop to go through the file at 45 byte multiples (UU standard) */
 while (!eof(fhandle))
 {
  i = FileRead(fhandle, scratch, 45, 0);
  /* did we read some data? */
  if (i > 0)
  {
   /* terminate the string */
   scratch[i] = '\0';
   /* we reuse the same buffer to save space */
   uuencode(scratch, scratch+100, i, FALSE);
   AppendDataToBlock(holder, scratch+100);
  }
 }
}

void chainPlainFile (FileHandle fhandle, char* scratch, AELDataHandle holder,
                     AELAttachmentItem *item, AELSession *session)
{
 int i=0;

 while (!eof(fhandle))
 {
  /* do we have to split the file in chunks? */
  if (item->AAI_mimeSplitPartSize > 0)
   i = FileRead(fhandle, scratch, item->AAI_mimeSplitPartSize, 0);
  else i = FileRead(fhandle, scratch, AEL_ADB_SIZE-100, 0);

  if (i > 0) /* check if a valid number of characters were read */
  {
   if (item->AAI_mimeSplitPartSize > 0)
    appendMIMEContentHeaders(session, item, holder, scratch);

   /* terminate the string */
   scratch[i] = '\0';
   AppendDataToBlock(holder, scratch);
   /* append boundary if this item is a split file, unless the
      file is done - the last boundary will be appended later */
   if (item->AAI_mimeSplitPartSize > 0 && !eof(fhandle))
   {
    AppendBoundaryToBlock(holder, getMimeBoundaryFromItem(item));
    session->AS_currentPart++;
   }
  } /* end of valid read check */
 }
}

void chainBase64orQPFile(FileHandle fhandle, char* scratch, AELDataHandle holder,
                     AELAttachmentItem *item, AELSession *session)
{
 int i=0;
 /* the data for Base64 and QP encoding should be in multiples of 54 bytes,
   except for the last block of data! */

 /* set up loop to go through file at 54 byte blocks */
 while (!eof(fhandle))
 {
  /* do we have to split the file in chunks? */
  if (item->AAI_mimeSplitPartSize > 0)
   i = FileRead(fhandle, scratch, item->AAI_mimeSplitPartSize, 0);
  else i = FileRead(fhandle, scratch, 54, 0);

  if (i > 0)
  {
   if (item->AAI_mimeSplitPartSize > 0)
    appendMIMEContentHeaders(session, item, holder, scratch);

   /* Terminate the string */
   scratch[i] = '\0';

   if (item->AAI_encoding == AEL_ENCODING_QP)
   {
    toQP(scratch, scratch+500);
    AppendDataToBlock(holder, scratch+500);
   }
   else if (item->AAI_encoding == AEL_ENCODING_BASE64)
   {
    to64(scratch, scratch+500, i);
    AppendDataToBlock(holder, scratch+500);
   } /* end of data appending block */

   /* append boundary if this item is a split file, unless the
      file is done - the last boundary will be appended later */
   if (item->AAI_mimeSplitPartSize > 0 && !eof(fhandle))
   {
    AppendBoundaryToBlock(holder, getMimeBoundaryFromItem(item));
    session->AS_currentPart++;
   }
  } /* end of if i>0 block */
 } /* end of file handle loop for QP/Base64 */
}

void appendUUencodedDataToBlock(char* data, char*scratch, word length,
                                AELDataHandle holder)
{
 int i=0;
/* set up loop to go through data at 45 byte multiples (UU standard) */
 if (length >= 45)
 {
  for (i=0; i < length; i+=45)
  {
   uuencode(data+(i*45), scratch, (i < length) ? (45):(length%45), FALSE);
   AppendDataToBlock(holder, scratch);
  }
 }
 else
 {
  uuencode(data, scratch, length, FALSE);
  AppendDataToBlock(holder, scratch);
 }
}

void appendPlainDataToBlock(char* data, char*scratch, word length,
                            AELDataHandle holder)
{
 /* do not do anything that might overflow the scratch buffer (6K of
    input data?  no way!)
  */
 if (length >= AEL_ADB_SIZE) return;

 /* just copy the text.  embedded binary data is the user's problem */
 memcpy(scratch, data, length);
 scratch[length] = '\0';
 AppendDataToBlock(holder, scratch);
}

void fillThreadFileError(AELSession* session)
{
 switch (ThreadGetError())
 {
  case ERROR_FILE_NOT_FOUND:
   session->AS_error = AEL_ERROR_FILE_NOT_FOUND;
   break;
  case ERROR_PATH_NOT_FOUND:
   session->AS_error = AEL_ERROR_PATH_NOT_FOUND;
   break;
  case ERROR_TOO_MANY_OPEN_FILES:
   session->AS_error = AEL_ERROR_TOO_MANY_OPEN_FILES;
   break;
  case ERROR_ACCESS_DENIED:
   session->AS_error = AEL_ERROR_FILE_ACCESS_DENIED;
   break;
  default:
   session->AS_error = AEL_ERROR_FILE_NOT_FOUND;
   break;
 }
}

void appendBase64orQPDataToBlock(char* data, char*scratch, word length,
                                 AELDataHandle holder, AELAttachmentItem *item)
{
 int i=0;

 /* the data for Base64 encoding should be in multiples of 54 bytes,
    except for the last block of data! */

 /* quoted-printable data should be passed in 1 54 byte line ONLY */
 if (item->AAI_encoding == AEL_ENCODING_QP)
 {
  toQP(data, scratch);
  AppendDataToBlock(holder, scratch);
 }
 else if (item->AAI_encoding == AEL_ENCODING_BASE64)
  for (i=0; i < length; i+=54)
  /* set up loop to go through data at 54 byte multiples */
  {
   {
    to64(data+(54*i), scratch, (i < length)? (54):(length%54));
    AppendDataToBlock(holder, scratch);
   }
  }
}

AELDataHandle  _pascal _export AELProcessData(AELHandle handle, char* data, word length,
                             Boolean endOfItem, Boolean endOfPart)
{
 AELSession *session = NULL;
 AELDataHandle holder;
 AELAttachmentParameters *params;
 AELAttachmentItem *item;
 FileHandle fhandle;
 char* scratch;

 _asm push ds
 GeodeLoadDGroup(GeodeGetCodeProcessHandle()) ;

 /* verify the session and lock it, if possible */
 session = verifyAndLockSession(handle, data);
 /* return NULL if the session didn't work out */
 if (NULL == session) {
  _asm pop ds
  return NULL;
 }

 holder = getDataBlock(session);
 /* did we allocate the data block OK? */
 if (NULL == holder)
 {
  MemUnlock(handle);
  _asm pop ds
  return NULL;
 }

 /* at this point, we have the holder AELDataHandle locked, and the
    data block AELDataBlock allocated inside it */

 /* get a pointer to the parameters struct in the session */
 params = &(session->AS_params);

 if (session->AS_current > params->AAP_numItems)
 {
  session->AS_error = AEL_ERROR_INTERNAL;
  MemUnlock(handle);
  _asm pop ds
  return NULL;
 }

 /* get pointer to the current attachment item we are processing */
 item = params->AAP_items+session->AS_current;

 /* now we can do the real work... */

 scratch = (char*) MemLock(session->AS_scratchHandle);

 /* clear scratch - not to be used */
 /* for (i=0; i < AEL_ADB_SIZE; i++) scratch[i] = '\0'; */

 /* are we just starting a new item or part? */
 if (session->AS_newItem || session->AS_newPart)
 {
  if (session->AS_newItem) session->AS_newItem = FALSE;
  if (session->AS_newPart) session->AS_newPart = FALSE;

  /* if we are just beginning the message, put in lines to that effect */
  if (session->AS_current == 0)
  {
   if (isSessionUU(params, item))
   {
    sprintf(scratch, "begin 666 %s", item->AAI_name);
    AppendDataToBlock(holder, scratch);
   }
   else /* first lines in a MIME message, no message/partial possible */
    /* is this a multipart MIME message, and these are the first headers? */
    if (params->AAP_numItems > 1 && session->AS_newSession)
     appendFirstMultipartHeaders(session, holder, params, scratch);
  }

  /* now, put the information for the item into the message */
  if (isSessionUU(params, item))
  {
   /* do nothing for a UUencoded message, it has no item headers */
  }
  else
  {
   /* print the top-level boundary, if applicable */
   if (params->AAP_numItems > 1)
    AppendBoundaryToBlock(holder, getMimeBoundaryFromParameters(params));

   /* regardless of whethere the message is multipart or not, we have
     the correct message headers already in place.  Now, we do the item
     or part headers.
    */
   appendMIMEItemHeaders(session, holder, item, scratch);
  }
 }

 /* special processing for files done here */
 if (item->AAI_isFile)
 {
  fhandle = FileOpen(item->AAI_path,(FILE_ACCESS_R | FILE_DENY_NONE));
  if (NULL == fhandle) /* was the file opened OK? */
   fillThreadFileError(session);
  else /* process the file */
  {
   if (isSessionUU(params, item))
    chainUUencodedFile(fhandle, scratch, holder);
   else if (item->AAI_encoding == AEL_ENCODING_NONE)
    chainPlainFile(fhandle, scratch, holder, item, session);
   else /* QP or Base64 */
     chainBase64orQPFile(fhandle, scratch, holder, item, session);
   FileClose(fhandle, 0);
  }
 }
 else /* put data directly into the block(s) here, no files involved */
 {
  if (isSessionUU(params, item)) /* put UUencoded data into the block */
   appendUUencodedDataToBlock(data, scratch, length, holder);
  else if (item->AAI_encoding == AEL_ENCODING_NONE) /* put plain data in block */
   appendPlainDataToBlock(data, scratch, length, holder);
  else /* put QP or Base64 data in block */
   appendBase64orQPDataToBlock(data, scratch, length, holder, item);
 }

 /* insert end-of-item or end-of-part boundary line into block */
 if ((endOfItem || endOfPart) && item->AAI_wrapper != AEL_WRAPPER_NONE)
 {
  AppendBoundaryToBlock(holder, getMimeBoundaryFromItem(item));
 }


 /* EVERY cycle, increment the part number, if necessary and applicable */
 if (endOfPart && session->AS_currentPart < item->AAI_mimeSplitParts)
  session->AS_currentPart++;

 /* do any special processing needed by the endOfPart flag */
 if (endOfPart) session->AS_newPart = TRUE;

 /* do any special processing needed by the endOfItem flag */
 if (endOfItem)
 {
  /* mark that next time, we need to start a new item */
  session->AS_newItem = TRUE;
  /* advance to next attachment item */
  session->AS_current++;
  /* set the part to be 0 */
  session->AS_currentPart = 0;

  /* insert end-of-message lines into block, if needed */
  if (session->AS_current >= params->AAP_numItems)
  {
   if (isSessionUU(params, item))
   {
    /* close with UUencoding standard "end" string */
    AppendDataToBlock(holder, "end");
   }
   else
   {
    /* append last MIME boundary, if this message had more than one items */
    if (params->AAP_numItems > 1)
     AppendBoundaryToBlock(holder, getMimeBoundaryFromParameters(params));
   }
  }
 }
 MemUnlock(handle);
 MemUnlock(session->AS_scratchHandle);
 _asm pop ds
 return holder;
}

