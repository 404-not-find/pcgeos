/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) GlobalPC 1998 -- All Rights Reserved

PROJECT:	Backup Restore Library
MODULE:		routines
FILE:		utils.goc

AUTHOR:		Edwin Yu, Nov 23, 1998

ROUTINES:
	Name			Description
	----			-----------
	CheckBackupDirectory   create %root%/backup directory if not exist
	CreateBackupFolder      create %root%/backup/GroupID directory

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Edwin	12/2/98   	Initial version.

DESCRIPTION:

    (1) Index file strucure:

        --- word (counter, used to assign a unique ID to backup groups)
        --- IndexEntry
        --- IndexEntry
        --- IndexEntry
        ....

            IndexEntries:
              - word, groupID
              - BackupType
              - date
              - description


    (2) Content file structure:

        --- ContentEntry
        --- ContentEntry
        --- ContentEntry
        ...

            ContentEntry
              - word, groupID
              - word, pathToken
              - char[], relativePath

	$Id: $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
@include "bckrst.goh"
@include <geoMisc.h>        /* itoa */
#include <ANSI/string.h>

/* const char backup_dir[] = "d:\\Perforce\\gbuild\\backup"; */
/* const char backup_parentDir[] = "d:\\Perforce\\gbuild";   */
const char backup_dir[PATH_LENGTH] = "c:\\backup";
const char backup_parentDir[] = "c:\\";

void ConvertDateTime(char *date, TimerDateAndTime *currentDateTime);
Boolean CheckGroupFolderDirectory(FileHandle *contenet, const char *path);
word FileContentReadSingleFile(GroupID id, char *buffer, word *token);
char *MakeSurePathExist(ContentEntry *entry);
Boolean AllocateChunkArray(MemHandle *mem, ChunkHandle *chunk);
Boolean VerifyIndexEntry(IndexEntry *entry);
Boolean VerifyContentEntry(ContentEntry *entry);
Boolean FileIndexDeleteEntry(FileHandle index, word i);
Boolean RecursiveDeleteDirs (const char *relativePath);

/*######################################################################
                        FileIndex operations
 #####################################################################*/

/***********************************************************************
 *	FileIndexRegisterNewBackupGroup
 ***********************************************************************
 *
 * SYNOPSIS:	    Internal.  Update the Index file.
 *                  Add an entry to the backup Index file about the
 *                  a new group ID.
 *                  Close the index file after done.
 * PARAMETERS:	    (description of the backup, backup Type)
 *                  Return a unique ID that identifies the new backup
 *                  group.
 * SIDE EFFECTS:    
 *
 * STRATEGY:        Add a new entry to the %root%/backup/index file in
 *                  the form of:
 *                         GroupID/Backup_Type/Date/Description
 *                  
 *
 * REVISION HISTORY:
 *	Name		Date		Description
 *	----		----		-----------
 *	edwin   	12/2/98   	Initial Revision
 *	
 ***********************************************************************/
GroupID FileIndexRegisterNewBackupGroup
(const char *description, BackupType backupType, FileHandle index)
{
    dword size;
    IndexEntry entry;
    char cnt[2];
    TimerDateAndTime currentDateTime;

    size = FileSize(index);
    memset((void*)&entry, (int)0, (size_t)sizeof(entry));
    /*
     *  Update the counter in the index file.
     */
    if (!size) {
	/*
	 *  It's a new file.  Initialize the counter.
	 */
	*((word *)cnt) = 0;
	FileWrite(index, cnt, sizeof(word), 0);
	entry.IE_groupID = 0;
    }
    else {
	/*
	 *  Index file already has entries in there.  Simple add
	 *  a new entry.
	 */
	FilePos(index, 0, FILE_POS_START);
	FileRead(index, cnt, sizeof(word), 0);
	entry.IE_groupID =  *((word *)cnt) = *((word *)cnt) + 1;
	FilePos(index, 0, FILE_POS_START);
	FileWrite(index, cnt, sizeof(word), 0);
    }
    /*
     * backup group type.  It can be:
     * (1) a single file (2) complete document directory
     * (3) system configuration files, or (4) full system backup
     */
    entry.IE_type = backupType;
    /*
     *  Convert the date
     */
    TimerGetDateAndTime(&currentDateTime);
    ConvertDateTime(entry.IE_date, &currentDateTime);
    /*
     *  description of the backup group.
     */
    if (description)
	strncpy(entry.IE_description, description, LEN_DESCRIPTION);
    /*
     *  Write to the index file.
     */
    FilePos(index, 0, FILE_POS_END);
    FileWrite(index, (char *)&entry, sizeof(entry), 0);
    EC_ERROR_IF((FileSize(index)-sizeof(word)) % sizeof(IndexEntry) !=0, -1);
    FileClose(index, 0);

    return *((word*)cnt);
} /* End of FileIndexRegisterNewBackupGroup */


/***********************************************************************
 *	FileIndexReadBackupGroups
 ***********************************************************************
 *
 * SYNOPSIS:	    Internal.
 *                  Read the index file and extract all backup group
 *                  entries into a chunk array.
 * PARAMETERS:
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name		Date		Description
 *	----		----		-----------
 *	edwin   	12/8/98   	Initial Revision
 *	jfh		03/12/00		added doc w email type
 *
 ***********************************************************************/
#define BUF_ENTRY     4
optr FileIndexReadBackupGroups
(word *num, FileHandle index, word *maxFileLen, BackupType type)
{
    word numBytesRead, i, len, token, totalAllocatedNum = 0;
    char dataBuf[sizeof(IndexEntry)*BUF_ENTRY], path[PATH_LENGTH];
    IndexEntry *entry;
    IndexEntryInMem *elt;
    MemHandle mem = NULL;
    ChunkHandle chunk = NULL;
    BackupType checkType;


    *num = *maxFileLen = NULL;
    /*
     *  Read INDEX file for counter info, do error checking.
     */
    if(FileSize(index) < 2) {                 /* no entries in the file */
	return NULL;
	}
    FilePos(index, 2, FILE_POS_START);       /* skip the counter word */

    if( AllocateChunkArray(&mem, &chunk) == FALSE) {
	return NULL;
    }
    /*
     *  Read INDEX file for BUF_ENTRY number of entries at a time.
     */
    while ((numBytesRead = FileRead(index, dataBuf,
				    sizeof(IndexEntry)*BUF_ENTRY,
				    FALSE)) > 0) {
	/*
	 *  Process each entry and append to a chunk array.
	 */
	for(i=0,len=0; numBytesRead >= sizeof(IndexEntry); i++, len=0) {
	    entry = (IndexEntry *)(dataBuf + (i * sizeof(IndexEntry)));
         /* show doc dirs w/ email as doc dirs */
	    checkType = entry->IE_type;
	    if(checkType == BT_DOC_W_EMAIL)
		   checkType = BT_DOCUMENT_DIR;
	    if (VerifyIndexEntry(entry) == FALSE  ||
		(checkType != type && checkType != BT_ALL_TYPE))  {
		numBytesRead -= sizeof(IndexEntry);
		continue;
	    }
	    if (entry->IE_type == BT_SINGLE_FILE) {
		/*
		 *  If the group is a single file backup, read the
		 *  file name as well.
		 */
		len = FileContentReadSingleFile(entry->IE_groupID,
						path, &token);
		if (len > *maxFileLen)
		    *maxFileLen = len;
	    }
	    else
		path[0] = '\0';
	    elt = ChunkArrayAppendHandles(mem, chunk, 
					  sizeof(IndexEntryInMem) + 
					  LEN_DATE + 
					  strlen(entry->IE_description) +
					  strlen(path) + 1);
	    totalAllocatedNum++;
	    /*
	     *  Copy the array information for the application.
	     */
	    EC( ECCheckBounds( elt ); )
	    (*num)++;
	    elt->IEIM_groupID        = entry->IE_groupID;
	    elt->IEIM_type           = entry->IE_type;
	    elt->IEIM_descriptionLen = strlen(entry->IE_description);
	    if (elt->IEIM_descriptionLen > LEN_DESCRIPTION)
		elt->IEIM_descriptionLen = LEN_DESCRIPTION;
	    /* copy date */
	    strncpy(((char*)elt)+sizeof(IndexEntryInMem),
		    entry->IE_date, LEN_DATE);
	    /* copy description */
	    strncpy(((char*)elt)+(sizeof(IndexEntryInMem)) + LEN_DATE,
		    entry->IE_description, elt->IEIM_descriptionLen);
	    if (elt->IEIM_type == BT_SINGLE_FILE) {
		/* copy file name */
		elt->IEIM_pathToken = token;
		elt->IEIM_fileLen = len;
		strncpy(((char*)elt)+(sizeof(IndexEntryInMem)) + LEN_DATE +
			elt->IEIM_descriptionLen, path, strlen(path));
	    }
	    numBytesRead -= sizeof(IndexEntry);
	}
    }
    MemUnlock(mem);
    FileClose(index, 0);
    if (totalAllocatedNum == 0) {
	/* There is no point of allocating a memory with 0 elements */
	MemFree(mem);
	mem = chunk = NULL;
    }
    return ConstructOptr(mem, chunk);
} /* End of FileIndexReadBackupGroups */


/***********************************************************************
 *	FileIndexDelete
 ***********************************************************************
 *
 * SYNOPSIS:	    Internal.
 *                  Delete a backup group.
 * PARAMETERS:      index - index file
 *                  GroupID - id of the group to be deleted
 *                  diskHandleOrPathToken - standard path token of the
 *                  relativepath - of the file to be deleted.  The path
 *                                 includes the path name.
 *
 *                  (Optional arg.  Pass NULL if no status report)
 *
 *                  statusCallback - callback routine.
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name		Date		Description
 *	----		----		-----------
 *	edwin   	12/8/98   	Initial Revision
 *	
 ***********************************************************************/
Boolean FileIndexDeleteBackupGroup
(FileHandle index, GroupID id, word i, void (*statusCallback)(void))
{
    DiskHandle dhand;
    char absPath[PATH_LENGTH], *ptr, groupid[13];
    Boolean ok = TRUE;
    FileEnumParams   FE_params;   /* FileEnum parameters. */
    MemHandle        FE_buffer;   /* The return block of enum results.*/
    word             FE_numExtra; /* The number of files found beyond
                                   * what we asked for.               */
    FilePushDir();
    /*
     *  cd to the root BACKUP/GroupID directory
     */
    strcpy(absPath, backup_dir);
    strcat(absPath, "\\");
    itoa(id, groupid);
    strcat(absPath, groupid);
    dhand = FileSetCurrentPath(0, absPath);

    if (dhand) {
	if (FileDelete("content"))
	    ok = FALSE;
	/*
	 * Enumerate all types of files in the current directory.
	 */
	FE_params.FEP_searchFlags   = FILE_ENUM_ALL_FILE_TYPES;
	FE_params.FEP_matchAttrs    = 0;
	FE_params.FEP_returnAttrs   = (void *)FESRT_NAME_AND_ATTR;
	FE_params.FEP_returnSize    = PATH_LENGTH;
	FE_params.FEP_bufSize       = 1;
	FE_params.FEP_skipCount     = 0;
	FE_params.FEP_callback      = 0;
	FE_params.FEP_callbackAttrs = 0;
	FE_params.FEP_cbData1       = 0;
	FE_params.FEP_cbData2       = 0;
	FE_params.FEP_headerSize    = 0;
	FE_buffer                   = 0;
	FE_numExtra                 = 0;
	while (1) {
	    if ( FileEnum( &FE_params, &FE_buffer, &FE_numExtra ) ) {
		/*
		 *  delete the file.
		 */
		EC( ECCheckMemHandle( FE_buffer ); )
		    ptr = MemLock(FE_buffer);
		    if (FileDelete(ptr+1))
			ok = FALSE;
		    /* FE_params.FEP_skipCount++; */
		    MemFree( FE_buffer );
	    } else {
		break; /*  No more files. */
	    }
	}
    }
    FilePopDir();
    /*
     *  Remove the directory.
     */
    itoa(id, groupid);
    FileDeleteDir(groupid);
    /*
     *  Remove the index entry
     */
    FileIndexDeleteEntry(index, i);

    return ok;
}


/***********************************************************************
 *	FileContentRegisterNewFile
 ***********************************************************************
 *
 * SYNOPSIS:	    Internal.  
 *                  Add an entry to the content file under the group
 *                  folder about the new file.
 * PARAMETERS:	    FileHandle - of the content file
 *                  Group ID - of the backup group
 *                  diskHandle - of the source
 *                  relativePath - of source file, path includes name.
 *                  Return a unique ID that identifies the new backup
 *                  group.
 * SIDE EFFECTS:    
 *
 * STRATEGY:        Add a new entry to the %root%/backup/index file in
 *                  the form of:
 *                         GroupID/Backup_Type/Date/Description
 *                  
 *
 * REVISION HISTORY:
 *	Name		Date		Description
 *	----		----		-----------
 *	edwin   	12/2/98   	Initial Revision
 *	
 ***********************************************************************/
Boolean FileContentRegisterNewFile
(FileHandle content, GroupID id, word diskHandleOrPathToken, 
const char *relativePath, char *groupId)
{
    ContentEntry entry;
    FileHandle file;
    char *fileName, cha;

    memset((void*)&entry, (int)0, (size_t)sizeof(entry));
    /*
     *  gropu id
     */
    entry.CE_groupID = id;
    /*
     *  Path token
     */
    entry.CE_pathToken = diskHandleOrPathToken;
    /*
     *  File Size
     */
    fileName = strrchr(relativePath, '\\');
    if (fileName) {
	FilePushDir();
	cha = *fileName;
	*fileName = '\0';
	FileSetCurrentPath(diskHandleOrPathToken,relativePath);
	file = FileOpen(fileName+1, FILE_ACCESS_R | FILE_DENY_W);
	if (file) {
	    entry.CE_fileSize = FileSize(file);
	    FileClose(file,0);
	}
	*fileName = cha;
	FilePopDir();
    }
    /*
     *  relative path name
     */
    strncpy(entry.CE_relativePath, relativePath, PATH_LENGTH);
    /*
     *  Assign a unique file name under the backup/groupID directory.
     */
    strcpy(entry.CE_uniqName, "\\");
    strcat(entry.CE_uniqName, groupId);
    /*
     *  Write to the content file.
     */
    FilePos(content, 0, FILE_POS_END);
    FileWrite(content, (char *)&entry, sizeof(entry), 0);
    FileClose(content, 0);

    return TRUE;
} /* End of FileContentRegisterNewFile */


word
FileContentReadSingleFile(GroupID id, char *buffer, word *token)
{
    FileHandle content;
    DiskHandle dhand;
    char groupid[13], path[PATH_LENGTH]; /* , *endOfPath; */
    ContentEntry entry;
    word len = 0;
    /*
     *  Check the existence of the content file.
     */
    strcpy(path, backup_dir);
    strcat(path, "\\");
    itoa(id, groupid);
    strcat(path, groupid);
    dhand = FileSetCurrentPath(0,path);
    content = FileOpen("content", FILE_ACCESS_R | FILE_DENY_W);
    if (dhand && content) {
	if(FileRead(content, &entry, sizeof(ContentEntry), FALSE)) {
	    if (VerifyContentEntry(&entry) == TRUE) {
		*token = entry.CE_pathToken;
		strcpy(buffer, entry.CE_relativePath);
#if 0 /* don't show full path */
		/* Get the length of the full path */
		endOfPath = path;
		FileConstructFullPath(&endOfPath, PATH_LENGTH, *token, 
				      buffer, TRUE);
		len = strlen(path);
#else
		len = strlen(buffer);
#endif
	    }
	}
	FileClose(content, 0);
    }
    else {
	buffer[0] = '\0';
    }
    return len;
}


void ConvertDateAndTime(const char *fileName, char *buffer)
{
    FileDateAndTime dateAndTime;

    buffer[0] = '\0';
    
    if (FileGetPathExtAttributes(fileName,
				 FEA_MODIFICATION,
				 &dateAndTime,
				 sizeof(FileDateAndTime))) {
	strncpy(buffer,	"00000000000000", LEN_DATE);
    }
    else {
	word date;
	/* Month */
	date = FDATExtractMonth(dateAndTime);
	if (date < 10) {
	    strcpy(buffer, "0");
	    itoa(date,buffer+1);
	}
	else
	    itoa(date,buffer);

	/* Day */
	date = FDATExtractDay(dateAndTime);
	if (date < 10) {
	    strcat(buffer, "0");
	    itoa(date,buffer+3);
	}
	else
	    itoa(date,buffer+2);
	
	/* Year */
	date = FDATExtractYearAD(dateAndTime);
	itoa(date, buffer+4);
	
	/* Hour */
	date = FDATExtractHour(dateAndTime);
	if (date < 10) {
	    strcat(buffer, "0");
	    itoa(date,buffer+9);
	}
	else
	    itoa(date,buffer+8);

	/* Minute */
	date = FDATExtractMinute(dateAndTime);
	if (date < 10) {
	    strcat(buffer, "0");
	    itoa(date,buffer+11);
	}
	else
	    itoa(date,buffer+10);
	strcat(buffer, ":");

	/* Second */
	date = FDATExtractSecond(dateAndTime);
	if (date < 10) {
	    strcat(buffer, "0");
	    itoa(date,buffer+13);
	}
	else
	    itoa(date,buffer+12);
    }
}

/***********************************************************************
 *	FileContentReadBackupGroup
 ***********************************************************************
 *
 * SYNOPSIS:	    Internal.
 *                  Read the content file and list all the files in
 *                  that backup group.
 * PARAMETERS:      
 * SIDE EFFECTS:    
 *
 * STRATEGY:        
 *
 * REVISION HISTORY:
 *	Name		Date		Description
 *	----		----		-----------
 *	edwin   	1/25/99   	Initial Revision
 *   jfh		02/27/00		added email - Just shows top folder
 *                               of each account
 ***********************************************************************/
optr FileContentReadBackupGroup
(word *num, FileHandle content, word *maxFileLen)
{
word			numBytesRead, i, j, k;
char			dataBuf[sizeof(ContentEntry)*BUF_ENTRY], *temp;
ContentEntry	*entry;
IndexEntryInMem	*elt;
MemHandle		mem = NULL;
ChunkHandle	chunk = NULL;
char			oldEmailAcct[50], newEmailAcct[50], emailString[100];
Boolean		slash, append;


    oldEmailAcct[0] = 0;
    *num = *maxFileLen = NULL;

    if( AllocateChunkArray(&mem, &chunk) == FALSE) {
	return NULL;
    }
    /*
     *  Read CONTENT file for BUF_ENTRY number of entries at a time.
     */
    while ((numBytesRead = FileRead(content, dataBuf,
				    sizeof(ContentEntry)*BUF_ENTRY,
				    FALSE)) > 0) {
	  /*
	   *  Process each entry and append to a chunk array.
	   */
	  for(i=0; numBytesRead >= sizeof(ContentEntry); i++) {
	    entry = (ContentEntry *)(dataBuf + (i*sizeof(ContentEntry)));
	    if (VerifyContentEntry(entry) == FALSE) {

		numBytesRead -= sizeof(ContentEntry);
		continue;
	    }
	    /* show only the first mail entry for each acct */
	    if (entry->CE_pathToken == SP_PRIVATE_DATA) {
		  /* get the account name */
		  slash = FALSE;
		  k = 0;
            /* start with j=1 since the 1st char is \ */
		  for (j = 1; j < strlen(entry->CE_relativePath); j++)  {
			if (entry->CE_relativePath[j] != '\\') {
			   if (slash == TRUE)  {
				 newEmailAcct[k] = entry->CE_relativePath[j];
				 k++;
				 }
			   }
			else  {
			   if (!slash) slash = TRUE;
			   else {
                     newEmailAcct[k] = 0;
				 break;
				 }
			   }
			}
		  /* is it a new acount? */
		  if (strcmp(oldEmailAcct, newEmailAcct)) {
			/* yes */
			strcpy(emailString, "Email Account: ");
			strcat(emailString, newEmailAcct);
			/* reset the old acct */
			strcpy(oldEmailAcct, newEmailAcct);
			append = TRUE;
			}
		  else append = FALSE;

		  } /* end of PRIVDATA if */
	    else append = TRUE;

	    /* append to the array */
	    if (append) {
		  elt = ChunkArrayAppendHandles(mem, chunk,
					  sizeof(IndexEntryInMem) +
					  LEN_DATE + 1 +
					  strlen(entry->CE_relativePath));
		  /*
		   *  Copy the array information for the application.
		   */
		  EC( ECCheckBounds( elt ); )
		  (*num)++;
		  elt->IEIM_groupID        = entry->CE_groupID;
		  if (entry->CE_pathToken == SP_PRIVATE_DATA) 
			elt->IEIM_type           = BT_EMAIL_ACCT;
		  else
			elt->IEIM_type           = BT_SINGLE_FILE;
		  elt->IEIM_descriptionLen = 0;
		  if (elt->IEIM_descriptionLen > LEN_DESCRIPTION)
		   elt->IEIM_descriptionLen = LEN_DESCRIPTION;
		  /* copy date */
		  temp = strrchr(entry->CE_uniqName, '\\');
		  if (temp) {
		   /* assume current dir is in the backup\groupID\ */
		   temp++;
		   ConvertDateAndTime(temp,
				   ((char*)elt)+sizeof(IndexEntryInMem));
		  }
		  else {
		   strncpy(((char*)elt)+sizeof(IndexEntryInMem),
			"00000000000000", LEN_DATE);
		  }
		  /* copy file name */
		  elt->IEIM_pathToken = entry->CE_pathToken;

		  /* show mail acct */
		  if (entry->CE_pathToken == SP_PRIVATE_DATA) {
			elt->IEIM_fileLen = strlen(emailString);
			strncpy(((char*)elt)+(sizeof(IndexEntryInMem)) + LEN_DATE,
				 emailString, strlen(emailString));
			} /* end of PRIVDATA if */
		  else  {/* a regular doc folder entry */
			elt->IEIM_fileLen = strlen(entry->CE_relativePath);
			strncpy(((char*)elt)+(sizeof(IndexEntryInMem)) + LEN_DATE,
			   entry->CE_relativePath,
			   strlen(entry->CE_relativePath));
			}
		  } /* end of append if */
	    numBytesRead -= sizeof(ContentEntry);
	    }  /* end of read contents for */
       } /* end of while */
    MemUnlock(mem);
    FileClose(content, 0);
    return ConstructOptr(mem, chunk);
} /* End of FileIndexReadBackupGroups */

/***********************************************************************
 *	CreateEmailFolders
 ***********************************************************************
 *
 * SYNOPSIS:	    Internal.
 *
 * PARAMETERS:
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 *
 * REVISION HISTORY:
 *	Name		Date		Description
 *	----		----		-----------
 *	jfh   	3/18/00   	Initial Revision
 *
 ***********************************************************************/
void CreateEmailFolders (char *mailFolder)
{
 char	mailAcct[150];


    /* create default email folders */
    FilePushDir();
    strcpy(mailAcct, mailFolder);
    FileSetStandardPath(SP_PRIVATE_DATA);
    FileCreateDir(mailFolder);
    FileSetCurrentPath(SP_PRIVATE_DATA, mailFolder);
    FileCreateDir("Drafts");
    FileCreateDir("Inbox");
    FileCreateDir("Outbox");
    FileCreateDir("Sent");
    FileCreateDir("Trash");
    strcat(mailAcct, "\\Inbox");
    FileSetCurrentPath(SP_PRIVATE_DATA, mailAcct);
    FileCreateDir("Attach");
    strcpy(mailAcct, mailFolder);
    strcat(mailAcct, "\\Outbox");
    FileSetCurrentPath(SP_PRIVATE_DATA, mailAcct);
    FileCreateDir("Attach");
    FilePopDir();
}

/***********************************************************************
 *	FileContentRestore
 ***********************************************************************
 *
 * SYNOPSIS:	    Internal.
 *
 * PARAMETERS:	    (description of the backup, backup Type)
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:
 *
 *
 * REVISION HISTORY:
 *	Name		Date		Description
 *	----		----		-----------
 *	edwin   	12/2/98   	Initial Revision
 *   jfh		02/27/00		added email
 *   jfh		03/18/00		added email folder creation (empty folders
 *						aren't backed up and the email app needs
 *						to see all the default folders
 ***********************************************************************/
Boolean FileContentRestore
(FileHandle content, word diskHandleOrPathToken,
 const char *relativePath, char *absPath, void (*statusCallback)(void))
{
Boolean		ok = FALSE, contLoop = TRUE;
word			numBytesRead, i, max, j;
char			*dataBuf,  *fileName, *temp;
ContentEntry	*entry;
MemHandle		mem;
Boolean		ignore, deletedOldMail = FALSE;
char			mailFolder[150], prevMailFolder[150];
char			*mailPtr, *mailName;
word			fileError;


    if ((mem = MemAlloc(sizeof(ContentEntry)*BUF_ENTRY+1,
		   HF_DYNAMIC, HAF_STANDARD_NO_ERR)) == NULL) {
	return FALSE;
	}
    dataBuf = (char *)MemLock(mem);
    /*  Construct absolute path of the backup copy */
    fileName = absPath + strlen(absPath);
    prevMailFolder[0] = 0;
    /*
	*  Read CONTENT file for entries.
	*/
    FILEBATCHCHANGENOTIFICATIONS();  /* hold off all notification */
    while (contLoop == TRUE && (numBytesRead = FileRead(content, dataBuf,
				    sizeof(ContentEntry)*BUF_ENTRY,
				    FALSE)) > 0) {
	if (numBytesRead < sizeof(ContentEntry)) {
	    /*
		*  File is not ContentEntry algined.  Damaged?
		*/
	    EC_ERROR(-1);
	    break;
	} else {
	    max = numBytesRead / sizeof(ContentEntry);
	    for (i = 0; i < max; i++) {
		entry=(ContentEntry*)(dataBuf+(i*sizeof(ContentEntry)));
		if (diskHandleOrPathToken == SP_DOCUMENT) {
		    /* Restore single file: simply find the match */
		    if (diskHandleOrPathToken == entry->CE_pathToken &&
			(strcmp(relativePath,
				entry->CE_relativePath) == 0)) {
			/* Found a match, restore! */
			fileName[0] = '\0';
			temp = MakeSurePathExist(entry);
			strcpy(fileName, temp);
			fileError = 0; /* take this line out & get an internal error 0223*/
			fileError = FileCopy(absPath,
					 entry->CE_relativePath,
					 0, entry->CE_pathToken);
			if (!fileError) {
			    if (statusCallback) /* notify app for ui update */
				ProcCallFixedOrMovable_pascal(statusCallback);
			    ok = TRUE;
			    contLoop = FALSE; /* Found. Stop looping */
			}
			break;
		    }
		}
		else if (diskHandleOrPathToken == SP_PRIVATE_DATA) {
		   /* we want to restore an email accout folder */
		   /* ignore all but privdata... */
		   if (entry->CE_pathToken == SP_PRIVATE_DATA) {
			 /* so delete the account folder... */
			 strcpy(mailFolder, "mail\\");
			 strcat(mailFolder, relativePath);
			 mailPtr = &mailFolder;
			 if ((entry->CE_pathToken == SP_PRIVATE_DATA) && !deletedOldMail &&
			    (!strncmp(mailPtr, (entry->CE_relativePath)+1, strlen(mailPtr)))) {
			    RecursiveDeleteDirs(mailPtr);
			    deletedOldMail = TRUE;
			    CreateEmailFolders(mailFolder);
			    }
			 /* ignore files outside the selected acct folder */
			 if (!strncmp(mailPtr, (entry->CE_relativePath)+1, strlen(mailPtr))) {
			    fileName[0] = '\0';
			    temp =  MakeSurePathExist(entry);
			    strcpy(fileName, temp);
			    /* ignore msglist.000 files */
			    ignore = FALSE;
			    if (entry->CE_pathToken == SP_PRIVATE_DATA) {
				  mailName = strrchr(entry->CE_relativePath, '\\');
				  if (!strcmp(mailName+1, "msglist"))  ignore = TRUE;
				  }
			    if (!ignore)
				  FileCopy(absPath,
					entry->CE_relativePath,
					0, entry->CE_pathToken);
			    if (statusCallback) {/* notify app for ui update */
				  ProcCallFixedOrMovable_pascal(statusCallback);
			       }
			    } /* end in selected acct folder if */
			 ok = TRUE;
			 } /* end of CE_pathToken if */
		   }  /* end of diskHandleOrPathToken if */
		else {
		    /* Restore every file. */
		    /* since we're restoring all - if mail was backed up
			* then we want to delete all the mail folders */
	   /*	    if ((entry->CE_pathToken == SP_PRIVATE_DATA) && !deletedOldMail) {
			  strcpy(mailFolder, "mail");
			  mailPtr = &mailFolder;
			  RecursiveDeleteDirs(mailPtr);
			  deletedOldMail = TRUE;
			  }         */
		   if (entry->CE_pathToken == SP_PRIVATE_DATA) {
			 /* check the account folder name... */
			 strcpy(mailFolder, "mail\\");
			 for (j = 6; j < strlen(entry->CE_relativePath); j++) {
			    if (entry->CE_relativePath[j] != '\\') {
				  mailFolder[j-1] = entry->CE_relativePath[j];
				  }
			    else {
				  mailFolder[j-1] = 0;
				  break;
				  }
			    }
			 mailPtr = &mailFolder;
			 /* if this is a 2nd (etc) account then reset the del flag */
			 if (strcmp(prevMailFolder, mailFolder))  {
			    /* ok  this is different */
			    deletedOldMail = FALSE;
			    strcpy(prevMailFolder, mailFolder);
			    }
			 if ((entry->CE_pathToken == SP_PRIVATE_DATA) && !deletedOldMail &&
			    (!strncmp(mailPtr, (entry->CE_relativePath)+1, strlen(mailPtr)))) {
			    RecursiveDeleteDirs(mailPtr);
			    deletedOldMail = TRUE;
			    CreateEmailFolders(mailFolder);
			    }
			 }

		    fileName[0] = '\0';
		    temp =  MakeSurePathExist(entry);
		    strcpy(fileName, temp);
		    /* ignore msglist.000 files */
		    ignore = FALSE;
		    if (entry->CE_pathToken == SP_PRIVATE_DATA) {
			  mailName = strrchr(entry->CE_relativePath, '\\');
			  if (!strcmp(mailName+1, "msglist"))  ignore = TRUE;
			  }
		    if (!ignore)
			  FileCopy(absPath,
				entry->CE_relativePath,
				0, entry->CE_pathToken);
		    if (statusCallback) {/* notify app for ui update */
			ProcCallFixedOrMovable_pascal(statusCallback);
			}
		    ok = TRUE;
		}
	    }
	}
    }
    FILEFLUSHCHANGENOTIFICATIONS();
    MemFree(mem);
    FileClose(content, 0);
    return ok;

}

/* 2/2&3/00 jfh added code to make this rtn go more than one layer deep */
char *MakeSurePathExist(ContentEntry *entry)
{
 char *fileName, path[PATH_LENGTH], newFolder[PATH_LENGTH],
			  okPath[PATH_LENGTH], morePath[PATH_LENGTH];
 word len, folders, i, slash;
 Boolean	firstPass;


    fileName = strrchr(entry->CE_relativePath, '\\');
    if (fileName != entry->CE_relativePath) {
	  /* this file is not under the standard path */
	  len = fileName - entry->CE_relativePath;
	  strncpy(path, entry->CE_relativePath, len);
	  path[len] = '\0';

	  /* how many layers of folders are there */
	  folders = 0;
	  for (i = 0; i < strlen(path); i++) {
		if (path[i] == '\\') {
		   folders++;
		   }
		}

	  /* add the folder(s) if not there */
	  FilePushDir();
	  firstPass = TRUE;
	  while (folders) {
		slash = 0;
	     i = 0;
		/* get the topmost folder */
		while ((slash < 2) && (i < strlen(path))) {
		   if (path[i] == '\\') slash++;
		   if ((slash < 2) && (i < strlen(path))){
			 newFolder[i] = path[i];
			 i++;
			 }
		   }
		newFolder[i] = 0;
		/* and save the rest of the path */
		strcpy (morePath, &path[i]);
		if (firstPass) {
		   if (!FileSetCurrentPath(entry->CE_pathToken, newFolder)) {
			 FileSetCurrentPath(entry->CE_pathToken, ".");
			 FileCreateDir(newFolder);
			 }
		   strcpy(okPath, newFolder);
		   firstPass = FALSE;
		   }
		else {
		   strcpy(path, okPath);
		   strcat(path, newFolder);
		   if (!FileSetCurrentPath(entry->CE_pathToken, path)) {
			 FileSetCurrentPath(entry->CE_pathToken, okPath);
			 FileCreateDir(path);
			 }
		   strcat(okPath, newFolder);
		   }
		strcpy(path, morePath);
		folders--;
		}
	  FilePopDir();
	  }
    return entry->CE_uniqName;
}


/***********************************************************************
 *	FileContentGetInfo
 ***********************************************************************
 *
 * SYNOPSIS:	    Internal.  
 *                  Get file(s) info from the backup group.  If no
 *                  file name is given, get info for the whole file 
 *                  group.
 *
 * PARAMETERS:	    content - file handle
 *                  numFiles - to be returned, number of files in the
 *                             backup group.
 *                  totalSize - to be returned, total size of the all 
 *                              files in the group.
 *                  relativePath - file name
 *                  token        - path token of the file
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *                  
 *
 * REVISION HISTORY:
 *	Name		Date		Description
 *	----		----		-----------
 *	edwin   	12/2/98   	Initial Revision
 *	jfh		02/28/00		add email
 * jfh		12/23/00		fixed endless loop bug generated by change
 *                      to VerifyContentEntry()
 ***********************************************************************/
Boolean FileContentGetInfo
	  (FileHandle content, word *numFiles, dword *totalSize,
	   const char *relativePath, word diskHandleOrPathToken)
{
word			numBytesRead, i;
char			*dataBuf;
ContentEntry	*entry;
MemHandle		mem;
Boolean		contLoop = TRUE;
char			mailFolder[50];
char			*mailPtr, *mailName;


    if ((mem = MemAlloc(sizeof(ContentEntry)*BUF_ENTRY+1,
			HF_DYNAMIC, HAF_STANDARD_NO_ERR)) == NULL) {
		 return FALSE;
	 }
    dataBuf = (char *)MemLock(mem);
    /*
     *  Read CONTENT file for entries.
     */
	 while (contLoop == TRUE && (numBytesRead = FileRead(content, dataBuf,
					 sizeof(ContentEntry)*BUF_ENTRY,
				    FALSE)) > 0) {
/*	for (i = 0; numBytesRead >= sizeof(ContentEntry); i++) {
		 entry=(ContentEntry*)(dataBuf+(i*sizeof(ContentEntry)));
		 if (VerifyContentEntry(entry) == FALSE) {
		numBytesRead -= sizeof(ContentEntry);
		continue;
		 }

	 12/23/00 jfh - the above is strange.  The only way you could get out
	 of the for loop was to have VerifyContentEntry return FALSE BUF_ENTRY
	 times.  When dm changed VerifyContentEntry for localization, it stopped
	 returning FALSE and the for loop became eternal.

	 So I've added a check to bail if i gets above BUF_ENTRY, but that doesn't
	 deal with the localization issue in VerifyContentEntry.
*/

		 for (i = 0; (numBytesRead >= sizeof(ContentEntry)) && (i < BUF_ENTRY); i++) {
			 entry=(ContentEntry*)(dataBuf+(i*sizeof(ContentEntry)));
			 if (VerifyContentEntry(entry) == FALSE) {
				 numBytesRead -= sizeof(ContentEntry);
				 continue;
			 }

			 if (diskHandleOrPathToken == SP_DOCUMENT) {
				 /* a single file */
				 if (diskHandleOrPathToken == entry->CE_pathToken &&
							  (strcmp(relativePath, entry->CE_relativePath) == 0)) {
					 (*numFiles)++;
					 (*totalSize) += entry->CE_fileSize;
					 contLoop = FALSE;
					 break;
				 }
			 }

			 else if (diskHandleOrPathToken == SP_PRIVATE_DATA) {
				 /* a single mail acct folder */
				 strcpy(mailFolder, "mail\\");
				 strcat(mailFolder, relativePath);
				 mailPtr = &mailFolder;
				 /* ignore files outside the selected acct folder */
				 if (!strncmp(mailPtr, (entry->CE_relativePath)+1, strlen(mailPtr))) {
					 (*numFiles)++;
					 (*totalSize) += entry->CE_fileSize;
					 numBytesRead -= sizeof(ContentEntry);
				 }
			 }

			 else {
				 /*
				  *  Accumulate the number of files and file size.
				  */
				 (*numFiles)++;
				 (*totalSize) += entry->CE_fileSize;
				 numBytesRead -= sizeof(ContentEntry);
			 }

		 } /* end of for loop */
	 } /* end of while loop */

	 MemFree(mem);
	 FileClose(content, 0);
    return TRUE;
} /* FileContentGetInfo */


/***********************************************************************
 *	BackupGroupAddFile
 ***********************************************************************
 *
 * SYNOPSIS:	    Internal.
 *                  Add a single file to a backup group.
 *                  Construct and return the full path of dest file,
 *                  used by the FileCopy.
 * PARAMETERS:	    id - group id to which the file is backed up to
 *                  dest - buffer to be filled with absolute path of
 *                         the copy of the backup file
 *                  diskHandleOrPathToken - disk/path token of the source
 *                  relativePath - path of the source file.
 * SIDE EFFECTS:    
 *
 * STRATEGY:	    Add a new entry to the %root%/backup/groupID/index2
 *                  file in the form of:
 *                     GroupID/File_Name/Path_Token/RelativePath
 *
 * REVISION HISTORY:
 *	Name		Date		Description
 *	----		----		-----------
 *	edwin   	12/2/98   	Initial Revision
 *	
 ***********************************************************************/
Boolean BackupGroupAddFile
(GroupID id, char *dest, word diskHandleOrPathToken, const char *relativePath,
 const char *fileName)
{
    char groupId[FILE_LONGNAME_LENGTH + 1];
    FileHandle content;
    word subId;

    itoa(id, groupId);
    strcpy(dest, backup_dir);
    strcat(dest, "\\");
    strcat(dest, groupId);
    /*
     *  Make sure the content file exists under the groupId folder.
     */
    if (CheckGroupFolderDirectory(&content, dest) == FALSE) {
	return FALSE;
	}
    /*
     *  Assign a unique file name under the backup/groupID directory.
     *  Construct the destination path for the copy of the source file,
     *  in the form of  BACKUP\groupID\uniqueFileName
     */
    strcat(dest, "\\");
    subId = FileSize(content) / sizeof(ContentEntry);
    itoa(subId, groupId);
    strcat(dest, groupId);
    /*
     *  Add a new entry to the content file under the groupID subdirectory
     */
    if (FileContentRegisterNewFile
	(content, id, diskHandleOrPathToken, relativePath, groupId) ==FALSE) {
	return FALSE;
	}
    return TRUE;
} /* End of BackupGroupAddFile */


/*#####################################################################
                        Utility Routines
 #####################################################################*/

/***********************************************************************
 *	CheckBackupDirectory
 ***********************************************************************
 *
 * SYNOPSIS:	    Internal.  
 *                  Create the backup directory and the index file if
 *                  not exists.
 *
 *                  Return TRUE if the root BACKUP is ok, FALSE o.w.
 * PARAMETERS:	    *index - return parameter for the index file handle
 * SIDE EFFECTS:    
 *
 * STRATEGY:	    (1) Check the existence of the root BACKUP dir.
 *                      Create it if not exists.
 *                  (2) Check the existence of the index file.
 *                      Create it if not exists.
 *
 * REVISION HISTORY:
 *	Name		Date		Description
 *	----		----		-----------
 *	edwin   	12/2/98   	Initial Revision
 *	
 ***********************************************************************/
Boolean CheckBackupDirectory(FileHandle *index)
{
    DiskHandle dhand;
    char *backupDir;
    *index = 0;
    /*
     *  cd to the root BACKUP directory
     */
    dhand = FileSetCurrentPath(0, backup_dir);
    if (!dhand) {
	/*
	 *  the root BACKUP directory doesn't exist, create it.
	 */
	dhand = FileSetCurrentPath(0, backup_parentDir);
	if (!dhand) {
	    return FALSE;  /* can't find the global tree */
	  }
	backupDir = strrchr(backup_dir, '\\');
	if (!backupDir || !backupDir[1]) {
	    return FALSE;
	  }
	FileCreateDir(backupDir+1);
	dhand = FileSetCurrentPath(0, backup_dir);
	if (!dhand) {
	    EC_ERROR(-1);
	    return FALSE;  /* can't find the backup directory */
	}
    }
    /*
     *  Check the existence of the index file.
     */
    *index = FileOpen("index", FILE_ACCESS_RW | FILE_DENY_NONE);
    if (! (*index)) {
	*index = FileCreate("index",
			   ((FILE_CREATE_TRUNCATE | FCF_NATIVE) | 
			    (FILE_DENY_NONE | FILE_ACCESS_RW)), 
			   0);
	if (!(*index)) {
	    EC_ERROR(-1);
	    return FALSE;  /* can't create the index file */
	}
    }

    return TRUE;
} /* End of CheckBackupDirectory */


/***********************************************************************
 *	CheckGroupFolderDirectory
 ***********************************************************************
 *
 * SYNOPSIS:	    Internal.  
 *                  Open the content file under the group folder.
 *                  Create the content file if not exists.
 *
 *                  Return TRUE if the content file is ok, FALSE o.w.
 * PARAMETERS:	    *content - return parameter for the content file handle
 *                  *path - path of the group folder
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name		Date		Description
 *	----		----		-----------
 *	edwin   	12/4/98   	Initial Revision
 *	
 ***********************************************************************/
Boolean CheckGroupFolderDirectory(FileHandle *content, const char *path)
{
    DiskHandle dhand;
    *content = 0;
    /*
     *  cd to the root BACKUP/GroupID directory
     */
    dhand = FileSetCurrentPath(0, path);
    if (!dhand) {
	EC_ERROR(-1);
	return FALSE;  /* can't find the backup group directory */
    }
    /*
     *  Check the existence of the content file.
     */
    *content = FileOpen("content", FILE_ACCESS_RW | FILE_DENY_NONE);
    if (! (*content)) {
	*content = FileCreate("content",
			   ((FILE_CREATE_TRUNCATE | FCF_NATIVE) | 
			    (FILE_DENY_NONE | FILE_ACCESS_RW)), 
			   0);
	if (!(*content)) {
	    EC_ERROR(-1);
	    return FALSE;  /* can't create the index file */
	}
    }
    return TRUE;
} /* End of CheckGroupFolderDirectory */


/***********************************************************************
 *	CreateBackupFolder
 ***********************************************************************
 *
 * SYNOPSIS:	    Internal.
 *                  Create a backup folder inside the backup directory.
 *                  ASSUME: current dir is the backup_dir
 * PARAMETERS:	    description - memo for the backup
 *                  backupType - type of the backup
 *                  index - file handle of the opened index file.
 *
 *                  Return group id.  Return GROUPID_INVALID if fails.
 * SIDE EFFECTS:    
 *
 * STRATEGY:        (1) Add a new entry to the /BACKUP/index file
 *                  (2) Create a subdirectory under the /BACKUP/ with
 *                      with name of the GroupID.
 *
 * REVISION HISTORY:
 *	Name		Date		Description
 *	----		----		-----------
 *	edwin   	12/2/98   	Initial Revision
 *	
 ***********************************************************************/
GroupID	CreateBackupFolder
(const char *description, BackupType backupType, FileHandle index)
{
    GroupID id;
    char groupid[13];
    word err;
    /*
     *  Add new entry to the %root%/BACKUP/index file.
     */
    EC_ERROR_IF(index == 0, -1);
    id = FileIndexRegisterNewBackupGroup(description, backupType, index);
    if (id == GROUPID_INVALID) {
	EC_ERROR(-1);
	return id;  /* can't update the index file */
    }
    /*
     *  Index file has been updated successfully.  Now create a folder.
     */
    itoa(id, groupid);
    err = FileCreateDir(groupid);

    if (err) {
	/*
	 *  can't create the backup group file folder.
	 */
	 /*	FileIndexDeleteBackupGroup(id); */
	EC_ERROR(-1);
	return GROUPID_INVALID;
    }

    return id;
} /* End of CreateBackupFolder */


/***********************************************************************
 *	GetIndexOfBackups
 ***********************************************************************
 *
 * SYNOPSIS:	    Internal.
 *                  Check the existence of the INDEX file in BACKUP.
 * PARAMETERS:      Return the index file of the root BACKUP directory
 *                  if exists.  Index file is opened for READ only.
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:        (1)
 *                  (2)
 *
 * REVISION HISTORY:
 *	Name		Date		Description
 *	----		----		-----------
 *	edwin   	12/8/98   	Initial Revision
 *	
 ***********************************************************************/
FileHandle GetIndexOfBackups(FileAccessFlags flags)
{
    DiskHandle dhand;
    FileHandle index = 0;
    /*
     *  cd to the root BACKUP directory
     */
    dhand = FileSetCurrentPath(0, backup_dir);
    if (dhand) {
	/*
	 *  Check the existence of the index file.
	 */
	index = FileOpen("index", flags);
    }
    return index;
}


/***********************************************************************
 *	GetContentOfBackups
 ***********************************************************************
 *
 * SYNOPSIS:	    Internal.
 *                  Check the existence of the CONTENT file in BACKUP.
 * PARAMETERS:      Return the content file of the root BACKUP/groupID
 *                  directory if exists.  Content file is opened for
 *                  READ only.
 * SIDE EFFECTS:    
 *
 * STRATEGY:        
 *
 * REVISION HISTORY:
 *	Name		Date		Description
 *	----		----		-----------
 *	edwin   	12/10/98   	Initial Revision
 *	
 ***********************************************************************/
FileHandle GetContentOfBackup(GroupID id, char *absPath)
{
    DiskHandle dhand;
    FileHandle content = 0;
    char groupid[13];
    /*
     *  cd to the root BACKUP/GroupID directory
     */
    strcpy(absPath, backup_dir);
    strcat(absPath, "\\");
    itoa(id, groupid);
    strcat(absPath, groupid);

    dhand = FileSetCurrentPath(0, absPath);
    if (dhand) {
	/*
	 *  Check the existence of the index file.
	 */
	content = FileOpen("content", FILE_ACCESS_R | FILE_DENY_W);
    }
    return content;
}


void  ConvertDateTime(char *date, TimerDateAndTime *currentDateTime)
{
    char temp[10];
    int len;
    /*
     *  Month
     */
    if (currentDateTime->TDAT_month < 10) {
	date[0] = '0';
	date[1] = currentDateTime->TDAT_month + '0';
    }
    else {
	date[0] = '1';
	date[1] = currentDateTime->TDAT_month -10 + '0';
    }
    /*
     *  Day
     */
    itoa(currentDateTime->TDAT_day, temp);
    len = strlen(temp);
    if (len == 1) {
	date[2] = '0';
	date[3] = 0;
    }
    if (len < 3) {
	strncat(date+2, temp, 2);
    }
    /*
     *  Year
     */
    itoa(currentDateTime->TDAT_year, temp);
    len = strlen(temp);
    if (len < 5) {
	strncpy(date+4, temp, 4);
    }
    /*
     *  hour
     */
    itoa(currentDateTime->TDAT_hours, temp);
    len = strlen(temp);
    if (len == 1) {
	date[8] = '0';
	date[9] = 0;
    }
    if (len < 3) {
	strncat(date+8, temp, 2);
    }
    /*
     *  minute
     */
    itoa(currentDateTime->TDAT_minutes, temp);
    len = strlen(temp);
    if (len == 1) {
	date[10] = '0';
	date[11] = 0;
    }
    if (len < 3) {
	strncat(date+10, temp, 2);
    }
    /*
     *  second
     */
    itoa(currentDateTime->TDAT_seconds, temp);
    len = strlen(temp);
    if (len == 1) {
	date[12] = '0';
	date[13] = 0;
    }
    if (len < 3) {
	strncat(date+12, temp, 2);
    }


    return;
}


Boolean AllocateChunkArray(MemHandle *mem, ChunkHandle *chunk)
{
    LMemBlockHeader *header;
    /*
     *  Chunk array is not created.  Let's create one.
     */
    *mem = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
    if (*mem) {
	header = (LMemBlockHeader *)MemLock(*mem);
	header->LMBH_flags |= LMF_RETURN_ERRORS;
	*chunk = ChunkArrayCreate(*mem,0,0,0);
	if (!(*chunk)) {
	    EC_ERROR(-1); /* not enough memory */
	    MemFree(*mem);
	    *mem = *chunk = NULL;
	    return FALSE;
	}
    }
    else {
	EC_ERROR(-1); /* not enough memory */
	*mem = *chunk = NULL;
	return FALSE;
    }
    return TRUE;
}


Boolean VerifyIndexEntry(IndexEntry *entry)
{
    word i;
    char c;
    for (i = 0; i < LEN_DATE; i++) {
	c = entry->IE_date[i];
	if (c < '0' || c > '9')
	    return FALSE;
    }
    for (i = 0; i < LEN_DESCRIPTION; i++) {
	c = entry->IE_description[i];
	if (c == '\0') {
	    break;
	    }
	if (c < 32 || c > 126) {
	    return FALSE;
	    }
    }
    return TRUE;
}

Boolean VerifyContentEntry(ContentEntry *entry)
{

/* 12/23/00 jfh - I'm not sure what this routine really does. dm made
	the below 2 changes on 12/3 and 12/21 for the Brazilian Portuguese
	version, but it no longer returns FALSE for non-printable US characters.
	See my comments in FileContentGetInfo() above.
 */

    word i;
//    char c;
	 unsigned char c;

	 for (i = 0; i < PATH_LENGTH; i++) {
		 c = entry->CE_relativePath[i];
		 if (c == '\0')  {
			 break;
	    }
//	    if (c < 32 || c > 126) {
		 if (!LocalIsPrintable(c)) {
			 return FALSE;
	    }
    }
    return TRUE;
}

word FileIndexGetEntry(FileHandle index, GroupID id, BackupType *type)
{
    /*
     *  I don't expect a lot of backup groups.  Let's do linear search.
     */
    word numBytesRead, i, count = 0;
    char *dataBuf;
    IndexEntry *entry;
    MemHandle mem;
    *type = 0;

    FilePos(index, sizeof(word), FILE_POS_START);
    if ((mem = MemAlloc(sizeof(IndexEntry)*BUF_ENTRY+1,
			HF_DYNAMIC, HAF_STANDARD_NO_ERR)) == NULL) {
	return -1;
	}
    dataBuf = (char *)MemLock(mem);
    /*
     *  Read INDEX file for entries.
     */
    while ((numBytesRead = FileRead(index, dataBuf,
				    sizeof(IndexEntry)*BUF_ENTRY,
				    FALSE)) > 0) {
	for (i = 0; numBytesRead >= sizeof(IndexEntry); i++) {
	    entry=(IndexEntry*)(dataBuf+(i*sizeof(IndexEntry)));
	    if (VerifyIndexEntry(entry) == FALSE) {
		numBytesRead -= sizeof(IndexEntry);
		count++;
		continue;
	    }
	    if (entry->IE_groupID == id) {
		/*
		 *  Found it!
		 */
		*type = entry->IE_type;
		MemFree(mem);
		FilePos(index, i*sizeof(IndexEntry)+sizeof(word), 
			FILE_POS_START);
		return count;
	    }
	    numBytesRead -= sizeof(IndexEntry);
	    count++;
	}
    }
    MemFree(mem);
    return -1;
}


Boolean FileIndexDeleteEntry(FileHandle index, word i)
{
    MemHandle mem;
    char *dataBuf;
    word numBytesRead;
    dword size;

    EC_ERROR_IF((FileSize(index)-sizeof(word)) % sizeof(IndexEntry) !=0, -1);

    FilePos(index, (i+1)*sizeof(IndexEntry) + sizeof(word), FILE_POS_START);
    if ((mem = MemAlloc(sizeof(IndexEntry)*BUF_ENTRY+1,
			HF_DYNAMIC, HAF_STANDARD_NO_ERR)) == NULL) {
	return FALSE;
	}

    dataBuf = (char *)MemLock(mem);
    /*
     *  Read INDEX file for entries.
     */
    while ((numBytesRead = FileRead(index, dataBuf,
				    sizeof(IndexEntry)*BUF_ENTRY,
				    FALSE)) > 0) {
	FilePos(index, i*sizeof(IndexEntry) + sizeof(word), FILE_POS_START);
	FileWrite(index, (char *)dataBuf, numBytesRead, 0);
	i += BUF_ENTRY;
	FilePos(index, (i+1)*sizeof(IndexEntry) + sizeof(word), 
		FILE_POS_START);
    }
    size = FileSize(index);
    FileTruncate(index, size-sizeof(IndexEntry), FALSE);
    EC_ERROR_IF((FileSize(index)-sizeof(word)) % sizeof(IndexEntry) !=0, -1);
    MemFree(mem);

    return TRUE;
}

/***********************************************************************
 *	RecursiveDeleteDirs
 ***********************************************************************
 *
 * SYNOPSIS:	    Recursively delete the files and directories
 *                  of the mail folder of a single mail account
 *                  folder.
 * PARAMETERS:	    path - the folder having files to delete
 *
 *                  If operation is successful,
 *                  return TRUE, else FALSE.
 * SIDE EFFECTS:
 *
 * STRATEGY:        For each file in sub-directories, do
 *                  (1) delete it
 *                  The proecess is done recursively.
 *
 * REVISION HISTORY:
 *	Name		Date		Description
 *	----		----		-----------
 *	jfh   	02/27/00   	Initial Revision
 *
 ***********************************************************************/
Boolean RecursiveDeleteDirs (const char *relativePath)
{
FileEnumParams   *FE_params;   /* FileEnum parameters. */
MemHandle        mem, mem2, FE_buffer; /* The return block of enum results.*/
word             FE_numExtra; /* The number of files found beyond
							* what we asked for.               */
char             *ptr, *subdir;
Boolean          ok = FALSE;


    /*
	*  Allocate memory.
	*/
    if ((mem = MemAlloc(PATH_LENGTH+1,
			HF_DYNAMIC, HAF_STANDARD_NO_ERR)) == NULL)
	return FALSE;
    if ((mem2 = MemAlloc(sizeof(FileEnumParams),
			 HF_DYNAMIC, HAF_STANDARD_NO_ERR)) == NULL) {
	MemFree(mem);
	return FALSE;
    }
    /*
	*  Set current dir.  return if error.
	*/
    if (FileSetCurrentPath(SP_PRIVATE_DATA, relativePath) == NULL) {
	MemFree(mem2);
	MemFree(mem);
	return FALSE;
    }
    /*
	* Enumerate all types of files in the current directory.
	*/
    FE_params = MemLock(mem2);
    FE_params->FEP_searchFlags   = FILE_ENUM_ALL_FILE_TYPES | FESF_DIRS;
    FE_params->FEP_matchAttrs    = 0;
    FE_params->FEP_returnAttrs   = (void *)FESRT_NAME_AND_ATTR;
    FE_params->FEP_returnSize    = PATH_LENGTH;
    FE_params->FEP_bufSize       = 1;
    FE_params->FEP_skipCount     = 0;   /* counter in FileEnum */
    FE_params->FEP_callback      = 0;
    FE_params->FEP_callbackAttrs = 0;
    FE_params->FEP_cbData1       = 0;
    FE_params->FEP_cbData2       = 0;
    FE_params->FEP_headerSize    = 0;
    FE_buffer                   = 0;
    FE_numExtra                 = 0;
    subdir = (char *)MemLock(mem);
    while (1) {
	if ( FileEnum( FE_params, &FE_buffer, &FE_numExtra )) {
	    /*
		*  Store and print the file/directory name.
		*/
	    ptr = MemLock(FE_buffer);
	    strcpy(subdir, relativePath);
	    strcat(subdir, "\\");
	    strcat(subdir, ptr+1);

	    if (ptr[0] & FA_SUBDIR) {
		/*
		 *  if it's a sub directory.  Recursively search down.
		 */
		ok = RecursiveDeleteDirs(subdir);
		if (ok == FALSE) {
		    /*
			*  Can't be deleted..
		     */
	   /*	    UserStandardDialog((char *)0, (char *)0, (char *)0,
				  0,
				  "Arrrgggghhhhhh",
				  (CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
				  (GIT_NOTIFICATION <<
				CDBF_INTERACTION_TYPE_OFFSET));  */
		    ok = TRUE;
		}  /* end of can't be deleted if */
		/*
		 *  Set back to the current directory.
		 */
   		FileSetCurrentPath(SP_PRIVATE_DATA, relativePath);
	    }  /* end of it's a subdir if */
	    else { /* it is a file */
		/*
		 *  delete the file.
		 */
		FilePushDir();
		FileSetStandardPath(SP_PRIVATE_DATA);
		FileDelete(subdir);
		FilePopDir();
	    }  /* end of it's a file else */
   //	    FE_params->FEP_skipCount++;
	    MemFree( FE_buffer );
	} /* end of fileenum if */
	else {
	    ok = TRUE;
	    break; /*  No more files. */
	}
    }  /* end of while */

    /* now delete the folder itself */
    FilePushDir();
    FileSetStandardPath(SP_PRIVATE_DATA);
    FileDeleteDir(relativePath);
    FilePopDir();

    MemFree(mem2);
    MemFree(mem);

    return ok;
} /* End of RecursiveDeleteDirs */

