COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) GeoWorks 1989 -- All Rights Reserved

PROJECT:	PC GEOS
MODULE:		
FILE:		graphicsLineStyle.asm

AUTHOR:		Steve Scholl, Oct 12, 1989

ROUTINES:
	Name			Description
	----			-----------

	
REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Steve	10/12/89		Initial revision


DESCRIPTION:
	Contains utility routines for the graphics stuff
		

	$Id: graphicsLineStyles.asm,v 1.1 97/04/05 01:13:28 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

GraphicsDashedLine segment resource




COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		GetLinePoints
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Generates all the points of a line using Bresenhams algorithm 
		and returns them in a buffer.

CALLED BY:	

PASS:
		cx - number of bytes in buffer
		es:di - segment and offset to put points
		ds:si - segment and offset of 2 points defining line

RETURN:		
		if created points fit in buffer
		points in buffer
		di - offset after last point created
		si - advanced one point
		cx - # bytes remaining in buffer
		dx - number of points created
		bx - unchanged
		
		if created points won't fit in buffer
		si - unchanged
		di - unchanged
		cx - number of bytes needed (will be bigger than passed cx)
		dx - number of points that would be created
		bx - unchanged

		stc - means hit a SEPARATOR
		cx - unchanged
		di - unchanged
		if hit pair of SEPARATORS ( ie termination)
			bl - 2
		if hit only one SEPARATOR
			bl - 3
			si - offset to point after SEPARATOR		
		
DESTROYED:	
		nothing

PSEUDO CODE/STRATEGY:
	The number of points generated by Bresenhams algorithm is equal to
	max(deltaX,deltaY)+1. I mult this number by 4 to get the total size
	needed to store the points, if there isn't enough room I exit. 

	If both point of the line are the same, then deltaX = deltaY = 0.
	The above equation results in allocating room for only one point.
	However, we must always return at least two points. There is a 
	check for this special case when the number of points is determined.
	Also, GenerateLinePointsX and GenerateLinePointsY will not handle
	this case. So I just stick one of the points in the buffer twice
	istead of calling a Generate routine.

KNOWN BUGS/SIDE EFFECTS/IDEAS:
	Certain lines are simply too much for this routine to handle.
	The largest delta of the line may not be more than 4000h, if
	it is the points won't fit in a 64k block so you will get a fatal
	error.

	
REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	srs	10/12/89		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
GLP_StackFrame	struct
	GLP_bufferSize		dw	?	;size of passed buffer
	GLP_numPointsCreated	dw	?	;pretty clear huh
	GLP_x1			dw	?	;
	GLP_y1			dw	?	;
	GLP_x2			dw	?	;
	GLP_y2			dw	?	;
	GLP_bump		dw	?	;see X and Y routines
	GLP_incr1		dw	?	;bresenham value
	GLP_incr2		dw	?	;bresenham value
	GLP_d			dw	?	;decision value
	GLP_adjustDI		dw	?	;see X and Y routines
	GLP_offsetToLastCreated	dw	?	;see X and Y routines
GLP_StackFrame	ends

GLP_Local 	equ	[bp - (size GLP_StackFrame) ]

GLP_hitSeparator:
	mov	dl,2				;assume  hit only 1 separator
	lodsw					;check for second separator
	cmp	ax,SEPARATOR
	jne	GLP_oneSeparator		;jmp if only 1 separator
	inc	dl				;flag terminiation
GLP_oneSeparator:
	sub	si,2				;offset to point after 1st SEP
						;only needed for 1 SEP case
	pop	cx				;recover bytes in buffer
	mov	sp,bp				;destroy stack frame
	pop	bp
	pop	ax,bx				;undestroyed
	mov	bl,dl				;return exit flag
	stc					;flag hit separator
	retn

GLP_xNotOrdered:
	xchg	ax,cx
	jmp	short GLP_xOrdered
GLP_yNotOrdered:
	xchg	bx,dx
	jmp	short GLP_yOrdered

GLP_lineIsPoint:				;both points of line same
	mov	ax,2				;will create two points
	jmp	short	GLP_15


GetLinePoints		proc	near
	push	ax,bx				;don't destroy
	push	bp				;create stack frame
	mov	bp,sp
	sub	sp,size GLP_StackFrame
	push	cx				;passed buffer size

			;GET POINTS DEFINING LINE
	lodsw	
	mov	GLP_Local.GLP_x1,ax
	mov	dx,ax				;save x1
	lodsw
	mov	GLP_Local.GLP_y1,ax
	mov	bx,ax				;bx - y1
	lodsw
	mov	GLP_Local.GLP_x2,ax
	mov	cx,ax				;cx - x2
	cmp	cx,SEPARATOR
	je	GLP_hitSeparator
	lodsw
	mov	GLP_Local.GLP_y2,ax
	xchg	ax,dx				;ax - x1, dx - y2

	cmp	ax,cx				;x1 to x2
	jg	GLP_xNotOrdered
GLP_xOrdered label near
	cmp	bx,dx				;y1 to y2
	jg	GLP_yNotOrdered
GLP_yOrdered label near

	sub	cx,ax				;calc delta x
	sub	dx,bx				;calc delta y
	mov	ax,cx				;assume delta x is larger
	cmp	ax,dx
	ja	GLP_10				;jmp if delta x is larger
	mov	ax,dx				;larger delta in ax
GLP_10:
	tst	ax				
	je	GLP_lineIsPoint			;jmp if both line points same
	inc	ax				;total number of points in line
GLP_15 label near
EC <	cmp	ax,4000h	>
EC <	ERROR_A GRAPHICS_LINE_TOO_LONG_IN_GET_LINE_POINTS	>
	mov	GLP_Local.GLP_numPointsCreated,ax
	shl	ax,1				;calc bytes in line
	shl	ax,1
	pop	bx				;passed buffer size
	cmp	ax,bx				;size needed to buffer size
	ja	GLP_ptsWontFit
	sub	bx,ax				;number of bytes left in buffer
	mov	GLP_Local.GLP_bufferSize,bx	;new buffer size

	cmp	cx,dx				;cmp deltas
	ja	GLP_20				;jmp if delta x bigger
	tst	dx
	je	GLP_storeTwoPoints		;jmp if both line points same
	call	GenerateLinePointsY
	jmp	short	GLP_40
GLP_20:
	call	GenerateLinePointsX
GLP_40:
	mov	cx,GLP_Local.GLP_bufferSize	;return this
	sub	si,size Point			;offset to new first point
GLP_45:
	mov	dx,GLP_Local.GLP_numPointsCreated;return this
	mov	sp,bp				;destroy stack frame
	pop	bp
	pop	ax,bx
	clc					;flag no SEPARATOR
	ret

GLP_ptsWontFit:
	mov	cx,ax				;return pts needed
	sub	si,2*(size Point)		;return orig si
	jmp	short GLP_45


GLP_storeTwoPoints:
	mov	ax,GLP_Local.GLP_x1
	stosw					;store x1
	mov	bx,ax
	mov	ax,GLP_Local.GLP_y1
	stosw					;store y1
	xchg	ax,bx
	stosw					;store x1 again
	mov	ax,bx
	stosw					;store y1 again
	jmp	short	GLP_40
GetLinePoints		endp



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		GenerateLinePointsX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Half of bresenham line algorithm. For lines that are mostly
		horizontal ( ie < 45 degrees ). Generates the points on a
		line and sticks them in a buffer

CALLED BY:	INTERNAL
		GetLinePoints

PASS:		
		ss:bp - GLP_StackFrame
		GLP_x1
		GLP_x2	
		GLP_y1
		GLP_y2
		cx - ABS(delta x)
		dx - ABS(delta y)
		es:di	- segment and offset to put points

RETURN:		
		points in buffer
		di - pointing after last point

DESTROYED:	
		GLP_x1
		GLP_x2
		GLP_y1
		GLP_y2
		ax,bx,cx,dx

PSEUDO CODE/STRATEGY:
	This routine pretty much follows the pattern of most Bresenham routine,
	with one exception (of course). For mostly horizontal lines, the points
	are always generated from smaller y toward larger y, but I wish to 
	return the points in whatever order they were passed. So, before I
	start generating points, di maybe changed to point to the position
	of the last point to be created. In this case I also set 
	GLP_adjustDI to -8 ( 8 is size of two points) instead of 0. 
	This value is added to di after every point is stored and 
	results in di moving backwards through the buffer instead of forward.
	
	Register Usage In Main Loop
		dx - decision variable
		ax - x
		cx - final x
		bx - y
		si - incr1	

KNOWN BUGS/SIDE EFFECTS/IDEAS:
		does no error checking for buffer overflow		
		doesn't work when both deltas are 0

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	srs	10/12/89		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
		public	GenerateLinePointsX

GLPX_notOrdered:
	xchg	ax,GLP_Local.GLP_x2		;reorder x for Bresenham
	xchg	bx,GLP_Local.GLP_y2		;match x switch in y
	mov	si,cx				;delta x
	shl	si,1
	shl	si,1
	add	si,di				;offset of last pt	
	mov	GLP_Local.GLP_offsetToLastCreated,si
	mov	di,si				;pt di to last
	mov	GLP_Local.GLP_adjustDI,-8	;see header
	jmp	short	GLPX_ordered

GenerateLinePointsX		proc	near
	push	si				;don't destroy
	clr	GLP_Local.GLP_adjustDI		;assume forward order
	mov	bx,GLP_Local.GLP_y1
	mov	ax,GLP_Local.GLP_x1
	cmp	ax,GLP_Local.GLP_x2		
	jg	GLPX_notOrdered

GLPX_ordered label near
		;INIT BRESENHAM VARIABLES
	sal	dx,1				;incr1 = 2dy
	mov	GLP_Local.GLP_incr1,dx
	sub	dx,cx				;d = 2dy-dx
	mov	GLP_Local.GLP_d,dx
	sub	dx,cx				;incr2 = 2(dy-dx)
	mov	GLP_Local.GLP_incr2,dx


		;STORE INITIAL POINTS
	stosw					;store init x
	xchg	ax,bx				;y1,x1
	stosw					;store init y
	xchg	ax,bx				;x1,y1
	add	di,GLP_Local.GLP_adjustDI

		;SET Y BUMP
	mov	si,1				;assume line goes down
	cmp	bx,GLP_Local.GLP_y2		;cmp y1 to y2
	jle	GLPX_10				;jmp if assumption correct
	neg	si				;line goes up
GLPX_10:
		;INITIALIZE LOOP REGISTERS
	mov	GLP_Local.GLP_bump,si
	mov	dx,GLP_Local.GLP_d		;decision variable
	mov	si,GLP_Local.GLP_incr1
	mov	cx,GLP_Local.GLP_x2		;final x value

GLPX_20:	;MAIN LOOP
	tst	dx				;check decision variable
	jg	GLPX_changeInY			;jmp if change in y
	add	dx,si				;add incr1 to decision
	inc	ax				;advance x

GLPX_30:	;STORE NEW POINT
	stosw					
	xchg	ax,bx
	stosw
	xchg	ax,bx
	add	di,GLP_Local.GLP_adjustDI

	cmp	ax,cx				;x to final x
	jne	GLPX_20				;jmp if haven't reached final x

	tst	GLP_Local.GLP_adjustDI
	je	GLPX_90				;jmp if return di correct
	mov	di,GLP_Local.GLP_offsetToLastCreated
	add	di,4				;pt past last point
GLPX_90:
	pop	si				;undestroyed
	ret

GLPX_changeInY:
	add	dx,GLP_Local.GLP_incr2		;adjust decision variable
	inc	ax				;advance x
	add	bx,GLP_Local.GLP_bump		;advance y
	jmp	short	GLPX_30			;jmp to store new point

GenerateLinePointsX		endp



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		GenerateLinePointsY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Half of bresenham line algorithm. For lines that are mostly
		veritcal ( ie >= 45 degrees ). Generates the points on a
		line and sticks them in a buffer

CALLED BY:	INTERNAL
		GetLinePoints

PASS:		
		ss:bp - GLP_StackFrame
		GLP_x1
		GLP_x2	
		GLP_y1
		GLP_y2
		cx - ABS(delta x)
		dx - ABS(delta y)
		es:di	- segment and offset to put points

RETURN:		
		GLP_reorder
		points in buffer
		di - pointing after last point

DESTROYED:	
		GLP_x1
		GLP_x2
		GLP_y1
		GLP_y2
		ax,bx,cx,dx

PSEUDO CODE/STRATEGY:
	This routine pretty much follows the pattern of most Bresenham routine,
	with one exception (of course). For mostly horizontal lines, the points
	are always generated from smaller y toward larger y, but I wish to 
	return the points in whatever order they were passed. So, before I
	start generating points, di maybe changed to point to the position
	of the last point to be created. In this case I also set 
	GLP_adjustDI to -8 ( 8 is size of two points) instead of 0. 
	This value is added to di after every point is stored and 
	results in di moving backwards through the buffer instead of forward.
	
	Register Usage In Main Loop
		dx - decision variable
		ax - y
		cx - final y
		bx - x
		si - incr1	

KNOWN BUGS/SIDE EFFECTS/IDEAS:
		does no error checking for buffer overflow		
		doesn't work when both deltas are 0

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	srs	10/12/89		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
		public	GenerateLinePointsY

GLPY_notOrdered:
	xchg	ax,GLP_Local.GLP_y2		;reorder y for bresenham
	xchg	bx,GLP_Local.GLP_x2		;match y switch in x
	mov	si,dx				;delta y
	shl	si,1
	shl	si,1
	add	si,di				;offset of last pt	
	mov	GLP_Local.GLP_offsetToLastCreated,si
	mov	di,si				;pt di to last
	mov	GLP_Local.GLP_adjustDI,-8	;see header
	jmp	short	GLPY_ordered

GenerateLinePointsY		proc	near
	push	si				;don't destroy
	clr	GLP_Local.GLP_adjustDI		;assume forward order
	mov	bx,GLP_Local.GLP_x1
	mov	ax,GLP_Local.GLP_y1
	cmp	ax,GLP_Local.GLP_y2		
	jg	GLPY_notOrdered

GLPY_ordered label near
		;INIT BRESENHAM VARIABLES
	sal	cx,1				;incr1 = 2dx
	mov	GLP_Local.GLP_incr1,cx
	sub	cx,dx				;d = 2dx-dy
	mov	GLP_Local.GLP_d,cx
	sub	cx,dx				;incr2 = 2(dx-dy)
	mov	GLP_Local.GLP_incr2,cx


			;STORE INITIAL POINTS
	xchg	ax,bx				;x1,y1
	stosw					;store init x
	xchg	ax,bx				;y1,x1
	stosw					;store init y
	add	di,GLP_Local.GLP_adjustDI

			;SET X BUMP
	mov	si,1				;assume line goes right
	cmp	bx,GLP_Local.GLP_x2		;cmp x1 to x2
	jle	GLPY_10				;jmp if assumption correct
	neg	si				;line goes left
GLPY_10:
			;INITIALIZE LOOP REGISTERS
	mov	GLP_Local.GLP_bump,si
	mov	dx,GLP_Local.GLP_d		;decision variable
	mov	si,GLP_Local.GLP_incr1
	mov	cx,GLP_Local.GLP_y2		;final y value

GLPY_20:	;MAIN LOOP
	tst	dx				;check decision variable
	jg	GLPY_changeInX			;jmp if change in x
	add	dx,si				;add incr1 to decision
	inc	ax				;advance y

GLPY_30:	;STORE NEW POINT
	xchg	ax,bx				;x1,y1
	stosw					
	xchg	ax,bx				;y1,x1
	stosw
	add	di,GLP_Local.GLP_adjustDI

	cmp	ax,cx				;y to final y
	jne	GLPY_20				;jmp if haven't reached final x

	tst	GLP_Local.GLP_adjustDI
	je	GLPY_90				;jmp if return di correct
	mov	di,GLP_Local.GLP_offsetToLastCreated
	add	di,4				;pt past last point
GLPY_90:
	pop	si				;undestroyed
	ret

GLPY_changeInX:
	add	dx,GLP_Local.GLP_incr2		;adjust decision variable
	inc	ax				;advance y
	add	bx,GLP_Local.GLP_bump		;advance x
	jmp	short	GLPY_30			;jmp to store new point

GenerateLinePointsY		endp




COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		PolyDashedLineLow
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Produces a buffer of line dashes in SEPARATOR format from
		a buffer of lines in SEPARATOR format

CALLED BY:	INTERNAL
		DrawPolylineLow

PASS:		
		es - window
		ds- gstate segment
		dx:si - segment and offset of poly line points in 
			terminated SEPARATOR format
		cx - number of points
		bp - number of disjoint polylines
		
RETURN:		
		dx -segment of dashed segments in terminated SEPARATOR
		di - offset past last item in dashes seg block
		bx - handle of dashed segments block
		
		bx = 0 if no dashes produced
			may be caused by skipDistance
			may be caused because dash block too big to alloc
DESTROYED:	
		ax,cx,si
		ds,es - unchanged

PSEUDO CODE/STRATEGY:
	The passed buffer must be in terminated SEPARATOR format.

	For example, this sequence represents two disjoint polylines, the
	first with two lines in it and the second with one.

	x1,y1,x2,y2,x3,y3,$,
	x4,x5,$$
	
	The resulting sequence would look something like this
	where the notation x12a,y12a means a point on the line x1,y1 to x2,y2

	x1,y1,x12a,y12a,$,		;a dash starting at x1,y1
	x12b,y12b,x12c,y12c,$,		;a dash somewhere between x1,y1 x2,y2
	x12d,y12d,x2,y2,x23a,y23b,$,	;a dash that includes the corner x2,y2
	x23b,y23b,x23c,y23c,$,		;a dash somewhere between x2,y2 x3,y3
	x23d,y23d,x3,y3,$,		;a dash ending at x3,y3
	x4,y4,x45a,y45a,$		;a dash starting at x4,y4
	x45b,y45b,x5,y5,$,$		;final dash ending at x5,y5

	Of course the number of dashes between any two point depends on
	the distance between the two points, the values in the dash array
	and the width of the line. All this, and more, will be explained 
	below.




	BASIC PLAN - for one source line segment is as follows.

	Pass the line segment from the source to GetLinePoints
	which returns a buffer which contains all the  
	points that would be on the line if it were drawn in GR_SOLID mode.
	These points will be referred to as bresPoints (as in Bresenham).
	Then use the dash pair array to choose pairs of points to make up
	the dashes.

	The dash pair array consists of pairs on ON,OFF distances. With ON
	meaning the number of pixels to be on and OFF meaning the number
	of pixels to be off. Really? However, to speed up the actual
	calculations of the dashes the dash pair array is converted to
	dash pair array of bytes offsets. 
	
	Consider the following list of points returned from GetLinePoints. 
	and a dash pair array containing 3,3.

	  ON	   ON	      ON	OFF	   OFF	     OFF	ON
	x1,y1, x12a,y12a, x12b,y12b, x12c,y12c, x12d,y12d, x12e,y12e, x12f,y12f

	To cover 3 pixels the first dash should be the line segment 
	x1,y1,x12b,y12b. But after we have copied x1,y1 our pointer refers
	to x12a,y12a, so we only need to add 4 bytes (1 point) to our pointer
	to get to x12b,y12b. So the ON value in the dashPairArrayOfByteOffsets
	is ((dashPairArrayON-2)*4). After copying x12b,y12b our pointer
	refers to x12c,y12c. The next ON line segment starts with x12f,y12f
	which is 12 bytes (3 points) further into the list. So the OFF value
	in the dashPairArrayOfByteOffsets is (dashPairArrayOFF * 4). 

	So the dashPairArrayOfByteOffsets in our example would contain 4,12

	The creation of the dashPairArrayOfByteOffsets is done in (surprise)
	CreateDashArrayOfByteOffsets.

	Both the DAPOBO and the bresPoints returned by GetLinePoints are stored
	in a DashIntermediateStruct (DIS) and passed to ConvertPointsToDashes
	which fills a block with the dash segments.


	WEIRD FEATURES

	dashSkipDistance - to understand the dashSkipDistance (dSD) we need
		a different view of the dashPairArray. Currently we have
		two views	

		3,3	- the dashPairArray
		4,12	- the dashArrayOfByteOffsets

		Now we will look at it as a bit mask. Where a 1 means the
		corresponding bresPoint is ON and 0 means it is OFF.

		111000 - bitmask dash array

		The dashSkipDistance specifies which element of the bitmask
		corresponds to the first bresPoint. In a sense it sets the
		phase of the dashes.

		dashSkipDistance	bitmask dash array
			0			111000111000
			1			11000111000
			2			1000111000
			3			000111000111
			4			00111000111
			5			0111000111

		The dSD must refer to a position in the first dash pair
		
		Since I pass the dashArrayOfByteOffsets to 
		ConvertPointsToDashes I multiply the dashSkipDistance
		by 4 also so that everything is in byte offsets. See
		the PSEUDO CODE/STRATEGY section of ConvertPointsToDashes
		for more info.

	DASH BUFFER SIZE - for one line segment
	
	#dashArrayPts - number of points specified in the dash pair array
		   	in the above example 3,3 #dashArrayPts = 6

	#bresPoints   - number of points returned by GetLinePoints
	
	#arraysUsed = #bresPoints / #dashArrayPts - the number of times the
		     dash array is repeated in the bresPoints. 1 is added to
		     this value for forced round up. Another 1 must be added
		     because the skipDistance could result in almost an entire
		     other array used.

	#ONSegsPerArray - number of ON segments in dash pair array, same as
		          number of pairs

	#dashes = #arraysUsed * #ONSegsPerArray

	#bytesPerDash = each dash had two points and a SEPARATOR 

	subTotal = #dashes * #bytesPerDash


	MULTIPLE DISJOINT POLYLINES - things get a bit more complicated.
	
	#bresPoints becomes the total number of points in all lines.

	#arraysUsed - Each disjoint polyline will be affected by the skip
		      distance. This could cause an extra array to be used
		      for each disjoint section. So the number of disjoint
		      sections must be added to #arrays used.

	#corners - if the dash is on at the junction of of two segments of
		   a polyline a corner point must be included in the dash.
		   The number of corners for the whole thing =
		   totalNumberOfLineSegments - numberOfDisjoint sections.
		   Trust me.

	#bytesForCorners = #corners * 4
	
	newSubTotal = (#dashes * #bytesPerDash) + #bytesForCorners 

	total = newSubTotal + 2 bytes for last SEPARATOR

	Whew.


	Other things are a little weird with multiple line segments. 
	The size of the DashIntermediateStruct ( which contains the
	bresPoints ) must be determined. It must be large enough to hold
	the bresPoints for the longest line segment, so that we don't have
	to continually realloc it. A loop early in the routine repeatedly
	calls GetLinePoints with a zero size buffer. GetLinePoints dutifully
	returns with the size of the buffer needed for that line. This loop
	is also used to determine the total number of bresPoints and other
	useful information.

	The meat of the routine consist of a loop which first calls
	GetLinePoints to fill the DIS and then a call to 
	ConvertPointsToDashes. 

	And no, I don't know why I always capitalized SEPARATOR.


	RETURNING A HANDLE OF 0

	But wait. If the skip distance ends up in the off portion of the
	first pair and the line length is so short that it is all used
	up in the off portion, then there is nothing to return, so 
	bx is set to zero.

KNOWN BUGS/SIDE EFFECTS/IDEAS:

	The main portion of the DashIntermediateStruct in the bresPoints
	if one of the line segments passed has more than
	(64k - Size DashIntermeditateStruct)/4 points in it then your will
	get a fatal error DIS_BLOCK_TOO_BIG
	This currently equals 16374 points. The number
	of points on a line is equal to the max(deltaX,deltaY)+1.

	RETURNING A HANDLE OF 0 - MORE INFO

	The dashes block, (its size calculation is explained above)
	may also become to big. Since it is very difficult for the
	application programmer to tell when this is going to happen, 
	bx is returned as 0 instead of a fatal error.	???

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	srs	10/14/89		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
		public	PolyDashedLineLow

PDLL_StackFrame	struct
	PDLL_numPassedSegments	dw	?
	PDLL_numPassedDisjointPolylines	dw	?
	PDLL_offsetToPolyLine	dw	?
	PDLL_segOfPolyLine	dw	?
	PDLL_gstate		dw	?
	PDLL_window		dw	?
	PDLL_sizeBresBuffer	dw	?
	PDLL_disHandle		dw	?
	PDLL_disSeg		dw	?
	PDLL_dashesHandle	dw	?
	PDLL_dashesSeg		dw	?
	PDLL_endOfDashes	dw	?	;offset past last dash
	PDLL_numONSegs		dw	?
	PDLL_numBresPoints	dw	?
PDLL_StackFrame ends

PDLL_Local	equ [bp - ( size PDLL_StackFrame )]


PDLL___10:			;new largest bres buffer
	mov	di,cx
	jmp	short PDLL_5

PolyDashedLineLow		proc	far
	push	es				;don't destroy
	mov	ax,bp				;save num disjoint polylines
	push	bp				;create stack frame
	mov	bp,sp
	sub	sp,size PDLL_StackFrame
	mov	PDLL_Local.PDLL_numPassedDisjointPolylines,ax
	dec	cx				;now number of segments
	mov	PDLL_Local.PDLL_numPassedSegments,cx
	mov	PDLL_Local.PDLL_gstate,ds	;save gstate
	mov	PDLL_Local.PDLL_offsetToPolyLine,si
	mov	PDLL_Local.PDLL_segOfPolyLine,dx
	mov	PDLL_Local.PDLL_window,es	;save window
	mov	ds,dx				;segment of line points
	clr	di				;largest bytes needed
	clr	ax				;total points

PDLL_1:		;DETERMINE SIZE OF BRES BUFFER
	clr	cx				;pass empty buf 
	call	GetLinePoints			;get size needed
	jc	PDLL_7				;jmp if hit SEPARATOR
	add	ax,dx				;total points
	cmp	di,cx
	jb	PDLL___10			;jmp if new largest bytes need
PDLL_5 label near
	add	si,size Point
	jmp	short	PDLL_1

PDLL_7:		;HIT A SEPARATOR OR TERMINATOR
	cmp	bx,LINE_SEPARATOR
	je	PDLL_1				;jmp if only one SEPARATOR

	mov	PDLL_Local.PDLL_numBresPoints,ax
	mov	PDLL_Local.PDLL_sizeBresBuffer,di

		;ALLOC DashIntermediateStruct
	mov	ax,di				;bytes needed
	add	ax, size DashIntermediateStruct
EC <	ERROR_C	GRAPHICS_DIS_BLOCK_TOO_BIG	>
	mov	cx,ALLOC_DYNAMIC_NO_ERR or ( mask HAF_LOCK shl 8 )
	call	MemAllocFar
	mov	PDLL_Local.PDLL_disHandle,bx
	mov	PDLL_Local.PDLL_disSeg,ax
	mov	es,ax				;segment of DIS

	call	CreateDashArrayOfByteOffsets

	mov	ax,es				;segment of DIS
	mov	ds,ax

			;ALLOC BUFFER FOR DASHES
	mov	ax,PDLL_Local.PDLL_numBresPoints
	clr	dx				;no high order bits for div
	div	bx				;num pts/ num array pts
	inc	ax				;forced round up
	add	ax,PDLL_Local.PDLL_numPassedDisjointPolylines
						;ax = num arrays used for lines
	mov	bx,PDLL_Local.PDLL_numONSegs
	mul	bx				;ax = number of dashes
	mov	bx,BYTES_PER_ON_SEGMENT
	mul	bx				;ax = size needed
	jc	PDLL_100			;jmp if too big
	add	ax,2				;last separator
	jc	PDLL_100			;jmp if too big
	mov	cx,PDLL_Local.PDLL_numPassedSegments
	sub	cx,PDLL_Local.PDLL_numPassedDisjointPolylines
	shl	cx,1				;a corner, 4 bytes per
	shl	cx,1
	add	ax,cx
	jc	PDLL_100			;jmp if too big
	mov	cx,ALLOC_DYNAMIC_NO_ERR or ( mask HAF_LOCK shl 8 )
	call	MemAllocFar			;dest buffer
	mov	PDLL_Local.PDLL_dashesSeg,ax
	mov	PDLL_Local.PDLL_dashesHandle,bx


		;MEAT O' ROUTINE

	mov	si,PDLL_Local.PDLL_offsetToPolyLine
PDLL_40:
	mov	bl,LINE_INITIAL

PDLL_50:
	mov	ds,PDLL_Local.PDLL_segOfPolyLine
	mov	es,PDLL_Local.PDLL_disSeg
	mov	di,DIS_bresPoints
	mov	cx,PDLL_Local.PDLL_sizeBresBuffer
	call	GetLinePoints
	mov	cx,es				;seg of DIS
	mov	ds,cx
	mov	cx,dx				;number of points
	mov	es,PDLL_Local.PDLL_dashesSeg
	call	ConvertPointsToDashes
	cmp	bl,LINE_NORMAL
	je	PDLL_50
	cmp	bl,LINE_SEPARATOR
	je	PDLL_40

	;ALL DONE

	cmp	di,4				;jmp if dash block contains
	je	PDLL_100			;only two SEPARATORS
PDLL_90:
	mov	bx,PDLL_Local.PDLL_disHandle
	call	MemFree
	mov	bx,PDLL_Local.PDLL_dashesHandle	;return dashed handle
	mov	ds,PDLL_Local.PDLL_gstate	;return gstate
	mov	sp,bp				;destroy stack frame
	pop	bp
	mov	dx,es				;return block segment
	pop	es				;undestoyed
	ret

PDLL_100:	;RETURNING NULL BLOCK
	mov	bx,PDLL_Local.PDLL_dashesHandle
	call	MemFree				;destroy empty block
	clr	PDLL_Local.PDLL_dashesHandle	;return 0 in handle
	jmp	short 	PDLL_90

PolyDashedLineLow		endp




COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		CreateDashArrayOfByteOffsets
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Converts the dash array in the graphic state
		to an array of number of bytes to skip for each ON and OFF

CALLED BY:	INTERNAL
		PolyDashedLineLow

PASS:		
		ss:bp - PDLL_StackFrame
		PDLL_gstate
		PDLL_disSeg
		PDLL_window
		es - segment of DIS		
RETURN:		
		DIS_dashArrayOfByteOffsets
		DIS_numDashArrayElements
		DIS_dashSkipByteOffset
		PDLL_numONSegs
		ds - gstate
		bx - total number of points in ON,OFF pairs
		es - unchanged

DESTROYED:	
		ax,bx,cx,di,si		

PSEUDO CODE/STRATEGY:
	See PSEUDO CODE/STRATEGY of PolyDashedLineLow

KNOWN BUGS/SIDE EFFECTS/IDEAS:
	none	

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	srs	10/22/89		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
		public	CreateDashArrayOfByteOffsets
CreateDashArrayOfByteOffsets		proc	near
	mov	di,DIS_dashArrayOfByteOffsets	;offset to store 
	mov	ds,PDLL_Local.PDLL_gstate	;seg of orig dash array
	mov	al,ds:GS_numOfDashPairs
	clr	ah				;make num elements a word
	mov	PDLL_Local.PDLL_numONSegs,ax
	shl	al,1				;convert to num elements
	mov	es:DIS_numDashArrayElements,ax
	mov	cl,al				;save num elements
	mov	al,ds:GS_dashSkipDistance	;skip distance into first pair
	clr	ah				;make it a word
	call	ScaleDashValue
	shl	ax,1				;convert distance to bytes
	shl	ax,1
	mov	es:DIS_dashSkipByteOffset,ax
	clr	ch				;element counter
	clr	bx				;total points in dash array
	mov	si, GS_dashPairArray		;offset of orig dash array

CDANB_10:		;CREATE DASH ARRAY WITH NUM BYTES
	lodsb					;get element
	clr	ah				;make it a word
	call	ScaleDashValue
	tst	ax				;force to be at least one
	jnz	CDANB_15
	inc	ax
CDANB_15:
	add	bx,ax				;total array points
	test	ch,0001h			;element counter
	jnz	CDANB_20			;jmp if OFF value
	sub	ax,2				
CDANB_20:
	shl	ax,1				;convert to number of bytes
	shl	ax,1
	stosw					;store modified element
	inc	ch				;element counter
	cmp	ch,cl
	jl	CDANB_10
	ret
CreateDashArrayOfByteOffsets		endp





COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		ScaleDashValue
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Adjust the dash values based on the current scale factors
		and the current line width

CALLED BY:	INTERNAL
		CreateDashArrayOfByteOffsets
PASS:		
		ax	- value to scale
		ds - gstate
RETURN:		
		ax	- scaled value
DESTROYED:	
		nothing

PSEUDO CODE/STRATEGY:
	The dash values represent numbers of line widths. So we
	must multiply by the scaled line width.
	
KNOWN BUGS/SIDE EFFECTS/IDEAS:
	none		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	srs	10/23/89	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
		public	ScaleDashValue
ScaleDashValue		proc	near
	push	bx,dx
	mov	bx,ds:GS_scaledLineWid
	clr	dx				;no high bytes
	mul	bx
	pop	bx,dx
	ret
ScaleDashValue		endp

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		ConvertPointsToDashes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Creates a block of dash line segments from the points
		for one line segment

CALLED BY:	INTERNAL
		PolyDashedLineLow

PASS:		
		es:di - segment and offset to store dashes
		ds - segment of DashIntermediateStruct
		DIS_bresPoints - offset to points
		DIS_dashArrayOfByteOffsets
		DIS_numDashArrayElements
		cx - number of bres points, must be at least 2 points
		bl - status
			LINE_INITIAL - begining of new polyline
				DIS_dashSkipByteOffset
			LINE_NORMAL
				DIS_currentStatus
				DIS_destOffset
				DIS_offsetTo1stPtNextStatus
				DIS_offsetToNextArrayElement
			LINE_SEPARATOR
				DIS_currentStatus
				DIS_destOffset
			LINE_TERMINATOR
				DIS_currentStatus
				DIS_destOffset

RETURN:		
		es - chock full o points
		di - destOffset
		ds - updated DIS
		bl - polyline status
			LINE_INITIAL
				never returned
			LINE_NORMAL
				DIS_currentStatus
				DIS_destOffset
				DIS_offsetTo1stPtNextStatus
				DIS_offsetToNextArrayElement
			LINE_SEPARATOR
				DIS_destOffset
			LINE_TERMINATOR
				nothin else

DESTROYED:	
		ax,bh,cx,dx

PSEUDO CODE/STRATEGY:
	The basic operation of this routine, the choosing of bresPoints 
	to define the dash endpoints is describe in the 
	PSEUDO CODE/STRATEGY section of PolyDashedLineLow. So it will not
	be described here.

	The bresPoints choosen for each dash are referred to as ON and LAST ON.
	After every LAST ON point a SEPARATOR is also written to the dash
	buffer.
			
	The state of the dashed line is kept in the DashIntermediateStruct
	(DIS). The important fields are
		DIS_currentStatus
		DIS_offsetTo1stPtNextStatus
		DIS_destOffset
		DIS_offsetToNextArrayElement
	Data kept in these fields is used to flow dashes around the corners
	between connected line segments. 
		DIS_currentStatus
			ON - if last dash point stored was ON
			OFF - if last dash point stored was LAST ON
		DIS_offsetTo1stPtNextStatus
			byte offset to the bresPoint that will be the next
			dash point stored. The point referred to may be
			either a ON or a LAST ON depending on the currentStatus
		DIS_destOffset
			offset to store next dash point at
		DIS_offsetToNextArrayElement
			offset to the element in the dashArrayOfByteOffsets
			to use after the point referred to by 
			DIS_offsetTo1stPtNextStatus has been used

	bl is passed to and returned by this routine. It reflects the
	status of the line segments being dashed.

	LINE_INITIAL - 	means that this is the first lineSegment of one
			or more line segments. The first time that this
			routine is called and any time after it has
			been called with LINE_SEPARATOR it must be called
			with LINE_INITIAL to set the DIS state information.
			The skipDistance is also applied when this status
			is passed. CPTD returns LINE_NORMAL when called with
			this status.


	LINE_NORMAL - 	means dashing any but the first line segment of a 
			polyline. CPTD dashes the line normal, sets the
			DIS state info so that the next line can be dashed
			correctly and returns LINE_NORMAL

	LINE_SEPARATOR-	means one and only one SEPARATOR was encountered in
			the polyline points. No line segment is being passed. 
			CPTD must close off any open (ie ON) dashes. The only 
			valid state variable upon exit is DIS_destOffset. Must
			be followed by a call with LINE_INITIAL set. 
			LINE_SEPARATOR is returned

	LINE_TERMINATOR means two consecutive SEPARATORs were encountered. No
			line segment is passed. CPTD must close off any open
			(ie ON) dashes and then write another SEPARATOR to
			the dash buffer to terminate it. LINE_TERMINATOR
			is returned. Calling CPTD again with the same dashes
			block is a bad thing.

	Implementing the dashSkipDistance (dSD) is a bit ugly. Make sure
	you've read the PSEUDO CODE/STRATEGY section of PolyDashedLineLow
	before reading this. We need to know if the dSD causes the first
	bresPoint to be part of an ON dash or an OFF dash. The important
	values in this determination are the first ON and the first OFF
	values in the dashArrayOfByteOffsets and the dSD, which was
	made into a byte offset before we got it. We need to compare the
	distance covered by the skip verses the distance covered by the 
	first ON and OFF. Unfortunately we modified the ON (subtracted 2) 
	before converting it into a byte offset. So we add 8 to it so that
	all are values in byte offsets. (nice huh). We can then tell
	whether the skip makes the first bresPoint ON or OFF. If it
	is ON we copy the first bresPoint to the dashes buffer. We then
	pass what's left of the ON or OFF dash to the regular routine where
	is is treated as offsetTo1stPtNextStatus. Sorry.
	


	Register Usage
		bx - offset into dash array
		ax - offset past last element in dash array
		si - offset into bresPoints
		cx - offset to last point in bresPoints
		dl - current status
		di - offset into dash buffer
		ds - segment of DIS
		es - segment of dash buffer

KNOWN BUGS/SIDE EFFECTS/IDEAS:
	none

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	srs	10/14/89		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

CPTD___30:	;HIT SEPARATOR OR TERMINATOR
	mov	di,ds:DIS_destOffset
	tst	dl				;cmp dl,STATUS_OFF
	je	CPTD___40			;jmp if OFF
	mov	ax,SEPARATOR			;
	stosw					;close current dash
CPTD___40:
	cmp	bl,LINE_SEPARATOR
	je	CPTD___50			;jmp if just a SEPARATOR
	mov	ax,SEPARATOR
	stosw					;terminate buffer
CPTD___50:
	mov	ds:DIS_destOffset,di
	pop	si
	retn


CPTD___10:	;LINE_INITIAL PASSED
	clr	di				;offset to store at
	mov	bx,DIS_dashArrayOfByteOffsets
	mov	ax,ds:[bx]			;get first element
	add	ax,8				;convert to distance offset
	sub	ax,ds:DIS_dashSkipByteOffset
	jle	CPTD___15			;jmp if offset into OFF

		;SKIP DISTANCE ENDS IN ON
	add	bx,2				;offset to OFF element
	movsw
	movsw
	mov	dl,STATUS_ON
	sub	ax,8				;convert back 
	jge	CPTD_5				;jmp if ax positive
	add	si,ax				;overflow test at CTPD_5
	jmp	short CPTD_6			;will fail with ax neg
						;so skip test

CPTD___15:	;SKIP DISTANCE ENDS IN OFF
	clr	dl				;mov	dl,STATUS_OFF
	add	ax,ds:[bx+2]			;add OFF to get byte offset
						;to next ON point
	add	bx,4				;offset to next ON incr element
	cmp	ds:DIS_numDashArrayElements,2
	ja	CPTD_5				;jmp if more than one pair
	mov	bx,DIS_dashArrayOfByteOffsets	;next ON is first ON
	jmp	short CPTD_5

CPTD___20:
	mov	bx,DIS_dashArrayOfByteOffsets	;first element
	jmp	short CPTD_40


ConvertPointsToDashes		proc	near
	push	si				;don't destroy
	mov	si,DIS_bresPoints		;offset to bres points

	dec	cx				;num bres points -1
	shl	cx,1
	shl	cx,1				;offset from 1st pt to last
	add	cx,si				;offset to last point

	tst	bl				;cmp bl,LINE_INITIAL
	je	CPTD___10			;jmp if use first pair offset

	mov	dl,ds:DIS_currentStatus

	cmp	bl,LINE_NORMAL
	jg	CPTD___30			;jmp if hit SEPARATOR or term

	mov	bx,ds:DIS_offsetToNextArrayElement
	mov	ax,ds:DIS_offsetTo1stPtNextStatus
	mov	di,ds:DIS_destOffset

CPTD_5 label near
	add	si,ax				;add remaining 
	jc	CPTD_90				;jmp if overshot 64k
CPTD_6 label near
	mov	ax,ds:DIS_numDashArrayElements
	shl	ax,1				;number of element bytes
	add	ax,DIS_dashArrayOfByteOffsets	;offset past last element

	tst	dl				;cmp dl,STATUS_OFF
	jne	CPTD_40				;jmp if ON

	cmp	si,cx
	ja	CPTD_90				;jmp if remaining
						;caused over shot
CPTD_10:		;COPY ON
	movsw					;copy x of ON
	movsw					;copy y of ON
	mov	dl,STATUS_ON

	add	si,ds:[bx]			;add ON byte offset
	add	bx,2				;advance dash array index
	cmp	bx,ax
	jae	CPTD___20			;jmp if hit end of dash array
CPTD_40 label near
	cmp	si,cx
	ja	CPTD_100			;jmp if overshot bresPoints

	;COPY LAST ON

	movsw					;copy x of LAST ON
	movsw					;copy y of LAST ON
	mov	es:[di],SEPARATOR
	add	di,2				;past SEPARATOR

	clr	dl				;mov dl,STATUS_OFF

	add	si,ds:[bx]			;add OFF byte offset
	jc	CPTD_110			;jmp if overshot 64k
	add	bx,2				;advance dash array index
	cmp	bx,ax
	jae	CPTD_120			;jmp if hit end of dash array
CPTD_60:
	cmp	si,cx
	jbe	CPTD_10				;jmp if more bresPoints
CPTD_90:
	mov	ax,si				;over shot pointer
CPTD_95:
	sub	ax,cx				;bytes over shot
	mov	ds:DIS_currentStatus,dl
	mov	ds:DIS_offsetTo1stPtNextStatus,ax
	mov	ds:DIS_offsetToNextArrayElement,bx
	mov	bl,LINE_NORMAL
	mov	ds:DIS_destOffset,di
	pop	si				;undestroyed
	ret

CPTD_100:	;MUST COPY LAST BRES TO MAKE CORNER
	mov	ax,si				;save over shot pointer
	mov	si,cx				;pt to last bres
	movsw					;x of corner
	movsw					;y of corner
	jmp	short CPTD_95


CPTD_110:	;SI OVERSHOT 64K
	add	bx,2				;advance dash array index
	cmp	bx,ax
	jb	CPTD_90				;jmp if not end of dash array
	mov	bx,DIS_dashArrayOfByteOffsets	;first element
	jmp	short	CPTD_90			;

CPTD_120:
	mov	bx,DIS_dashArrayOfByteOffsets	;first element
	jmp	short CPTD_60

ConvertPointsToDashes		endp


if	0

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		GrGetLinePointsHigh
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Temporary routine to help test GetLinePoints

CALLED BY:	
PASS:		
		di	- x1
		si 	- y1
		cx	- x2
		dx	- y2
RETURN:		
		cx - number of points
		bx - handle of block
DESTROYED:	
		ax,dx,di,si,es

PSEUDO CODE/STRATEGY:
		

KNOWN BUGS/SIDE EFFECTS/IDEAS:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	srs	10/12/89		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
		public	GetLinePointsHigh
GetLinePointsHigh		proc	far
	push	dx			;y2
	push	cx			;x2
	push	si			;y1
	push	di			;x1
	mov	si,sp			;si offset to x1
	mov	ax,ss
	mov	ds,ax			;pt ds:si to points on stack
	clr	cx			;zero size dest buffer
	call	GetLinePoints
	mov	ax,cx
	push	cx				;bytes alloced
	mov	cx,ALLOC_DYNAMIC_NO_ERR or (mask HAF_LOCK shl 8)
	call	MemAllocFar
	pop	cx				;bytes alloced
	push	bx				;save handle of block
	mov	es,ax				;segment of alloced block
	clr	di				;offset to store at
	call	GetLinePoints
	pop	bx				;recover handle
	call	MemUnlock
	mov	cx,dx				;return number created
	add	sp,8
	ret
GetLinePointsHigh		endp

endif

if	0

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		ReorderBuffer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Reverses the order the points in the buffer.

CALLED BY:	INTERNAL
		GetLinePoints
PASS:		es - segment of buffer
		si - offset to first point
		di - offset past last point

RETURN:		
		points reordered
		di - unchanged
DESTROYED:	

PSEUDO CODE/STRATEGY:
		none

KNOWN BUGS/SIDE EFFECTS/IDEAS:
		must be at least two points in buffer

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	srs	10/12/89	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
		public	ReorderBuffer
ReorderBuffer		proc	near
	push	di,ds			;don't destroy
	mov	ax,es			;make ds seg of buffer to
	mov	ds,ax
	sub	di,4			;pt at last x

RB_10:
			;X SWITCH
	lodsw				;get beg x
	mov	bx,es:[di]		;get end x
	stosw				;store beg x at end place
	mov	ds:[si-2],bx		;store end x at beg place
			;Y SWITCH
	lodsw				;get beg y
	mov	bx,es:[di]		;get end y
	stosw				;store beg y at end place
	mov	ds:[si-2],bx		;store end y at beg place
	sub	di,8			;pt at next end pt	
	cmp	di,si			;cmp end ptr to beg ptr
	jg	RB_10			;jmp if more points to switch
	pop	di,ds
	ret
ReorderBuffer		endp
endif

if 0


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		DrawPolyDashedLine
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Draws a dashed line, eventually will draw a poly dashed line

CALLED BY:	

PASS:		
		ds - gstate segment
		es - window segment
		dx:si - segment and offset of poly line points
		cx - number of points
		di	- offset to attributes to use
RETURN:		
		es - unchanged

		
DESTROYED:	

PSEUDO CODE/STRATEGY:
		

KNOWN BUGS/SIDE EFFECTS/IDEAS:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	srs	10/15/89		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
		public	DrawPolyDashedLine
DrawPolyDashedLine		proc	far
	push	es			;save window
	push	di			; save attributes offset
	call	PolyDashedLineLow
	pop	di
	mov	dx,es			;segment of separator format
	pop	es			;recover window
	push	bx
	clr 	si
	call	DrawSeparatorFormat
	pop	bx
	call	MemFree
	ret
DrawPolyDashedLine		endp
endif

GraphicsDashedLine ends




