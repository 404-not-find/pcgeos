/***********************************************************************
 *
 *	Copyright (c) GeoWorks 1992 -- All Rights Reserved
 *
 * PROJECT:	GEOS
 * FILE:	CInclude/Objects/FlatFile/ffDbaseC.goh
 *
 * AUTHOR:  	Jeremy Dashe: Jan 24, 1992
 *
 * REVISION HISTORY:
 *	Date	 Name	Description
 *	----	 ----	-----------
 *	1/24/92	 jeremy	Initial version
 *
 * DESCRIPTION:
 *	Class description for the flat file database object.
 *
 * 	$Id: ffDbaseC.goh,v 1.1 97/04/04 15:50:57 newdeal Exp $
 *
 ***********************************************************************/
@optimize

#include <geos.h>

@include <ssheet.goh>
@include <ffile.goh>
@include <impex.goh>
@include <Objects/uiInputC.goh>
@include <Objects/FlatFile/ffDbase.goh>
#include <Objects/FlatFile/ffKbd.h>


@class	FlatFileDatabaseClass, SpreadsheetClass;

/*
 * MSG_FFD_SUCCESSFUL_FIELD_CREATION_OR_MODIFICATION_TEMPLATE --
 *
 * This message is used to cast the success message that gets sent to 
 * MSG_FFD_CREATE_NEW_FIELD_WITH_RESPONSE to a message with no parameters
 * and no return value
 */
@message void MSG_FFD_SUCCESSFUL_FIELD_CREATION_OR_MODIFICATION_TEMPLATE();

/*
 * MSG_FFD_RESULT_OF_FIELD_CREATION_TEMPLATE --
 *
 * This message is used to cast the second message that gets sent to
 * MSG_FFD_CREATE_NEW_FIELD_WITH_RESPONSE to a message with a boolean
 * parameter, the column number of the field, and no return value. The
 * Boolean parameter indicates whether the attempted field creation
 * was successful.
 */
@message void MSG_FFD_RESULT_OF_FIELD_CREATION_TEMPLATE(
					FFFieldCreationResult fieldResult,
					byte colNum);

/*
 * MSG_FFD_RESULT_OF_FIELD_MODIFICATION_TEMPLATE --
 *
 * This message is used to cast the second message that gets sent to
 * MSG_FFD_CHANGE_FIELD_ATTRIBUTES_WITH_RESPONSE to a message with two
 * boolean parameters, the column number of the field, and no return
 * value. The first parameter is an enumerated value indicating the
 * outcome  of the attempted field modification, and the second indicates 
 * whether or not the name was changed.
 */
@message void MSG_FFD_RESULT_OF_FIELD_MODIFICATION_TEMPLATE(
					FFFieldCreationResult fieldResult,
					byte colNum,
					Boolean nameChanged);

/*
 * MSG_FFD_INIT_CELL_PARAMS
 *
 * This message serves to set the document handle in the
 * spreadsheet's cellparams structure. If you call MSG_FFD_INIT_SINGLE_
 * RECORD_LAYOUT before calling MSG_FFD_ATTACH_UI, you must call this
 * message first.
 */
@message void MSG_FFD_INIT_CELL_PARAMS(FileHandle documentHandle,
				       VMBlockHandle floatControllerVMBlock);

/*
 * MSG_FFD_LOAD_FLOAT_FORMAT_BLOCK --
 *	This message loads up a NotifyFloatFormatChange data block
 *	with the document file's handle and the block stored in
 *	FFI_floatControlBlock.
 */
@message void MSG_FFD_LOAD_FLOAT_FORMAT_BLOCK(MemHandle floatFormatDataBlock,
					      FormatIdType fieldFormat);

/*
 * MSG_FFD_NOTIFY_MAP_CONTROL --
 *
 * Sends a notification data block to map controller
 *
 */

@message void MSG_FFD_NOTIFY_MAP_CONTROL();

/*
 * MSG_FFD_FLUSH_MAP_CONTROL --
 *
 * Sends no data block to map controller
 *
 */

@message void MSG_FFD_FLUSH_MAP_CONTROL();

/*
 * MSG_FFD_ATTACH_FILE --
 *
 * Attach a (new) file to the flatfile
 *
 */
@message void MSG_FFD_ATTACH_FILE(VMBlockHandle ssMapBlock,
				  VMFileHandle fileHandle);

/*
 * MSG_FFD_ATTACH_UI --
 *
 * Attach UI to the flatfile
 *
 */
@message void MSG_FFD_ATTACH_UI(MemHandle setupData, FileHandle fileHandle);

@message void MSG_FFD_CHANGE_COMPUTED_FIELD(MemHandle textHandle);

@message byte MSG_FFD_GET_NUMBER_OF_FIELDS(optr dList,
					   FieldListQuery whichList);

/*
 * MSG_FFD_GET_NUMBER_OF_LAYOUTS --
 *
 * Returns the number of layouts in the database.
 *
 */
@message byte MSG_FFD_GET_NUMBER_OF_LAYOUTS();

@message void MSG_FFD_REQUEST_FIELD_MONIKER(optr dList,
					    word entryNum,
					    FieldListQuery whichList);

/*
 * MSG_FFD_REQUEST_FIELD_MONIKER_DISABLED
 *
 *	Insert the appropriate moniker from the given database list into
 *	the given dynamic list and make it disabled.
 */
@message void MSG_FFD_REQUEST_FIELD_MONIKER_DISABLED
		(optr dynList, word entryNum, FieldListQuery whichList);

/*
 * MSG_FFD_REQUEST_FIELD_NOTES --
 *	This message sends a field list element's notes to a text display.
 */
@message void MSG_FFD_REQUEST_FIELD_NOTES(word entryNum,
					  FieldListQuery whichList,
					  optr notesDisplay);

@message void MSG_FFD_EXPRESSION_BUILDER_GET_FIELD_NAME(MemHandle childBlock,
							ChunkHandle textEditor,
							word fieldID);

/*
 * MSG_FFD_CREATE_NEW_FIELD --
 *	This message adds a field to the database and adds it to the
 *	database_name_list.
 *	
 *	If the name was successfully added to the database, TRUE
 *	is returned; otherwise, FALSE is returned.
 */
@message Boolean MSG_FFD_CREATE_NEW_FIELD(MemHandle fieldInfoHandle,
					  FieldID _far *colNum);
/*
 * MSG_FFD_CREATE_NEW_FIELD_WITH_RESPONSE --
 *	This message adds a field to the database and adds it to the
 *	database_name_list, then sends back messages based on the
 *	success or failure of adding the new field.
 *
 *	successMessage must have no parameters and no return
 *	value. It is sent if the insert was successful.
 *
 *	resultMessage has two parameters: a Boolean (indicating
 *	whether the insert was successful or not) and a byte for
 *	the new column number.
 */
@message void MSG_FFD_CREATE_NEW_FIELD_WITH_RESPONSE(MemHandle fieldInfoHandle,
						     optr outputOD,
						     Message successMessage,
						     Message resultMessage);

/*
 * MSG_FFD_CHANGE_FIELD_ATTRIBUTES --
 *	This message changes the attributes of an existing field in
 *	the database.  Pass a handle to a FFFieldPropertiesMessageBlock
 *	with the new information and a column number to blast the
 *	changes into.
 *
 *	If the changes were successfully made to the field, TRUE is
 *	returned; otherwise, FALSE is returned.
 */
@message Boolean MSG_FFD_CHANGE_FIELD_ATTRIBUTES(MemHandle fieldInfoHandle,
						 byte colNum);

/*
 * MSG_FFD_CHANGE_FIELD_ATTRIBUTES_WITH_RESPONSE --
 *	This message changes the attributes of an existing field in
 *	the database and in the database_name_list.  The
 *	database_name_list is affected only if the name
 *	changed.
 *
 *	Pass a handle to a FFFieldPropertiesMessageBlock
 *	with the new information and a column number to blast the
 *	changes into.  Two passed messages will be sent back based on
 *	the success or failure of the attribute change:
 *
 *	successMessage has no parameters and no return
 *	value. It is sent if the modification was successful.
 *
 *	resultMessage has two parameters: a Boolean (indicating
 *	whether the modification was successful or not) and a byte for
 *	the old column number.
 */
@message void MSG_FFD_CHANGE_FIELD_ATTRIBUTES_WITH_RESPONSE(
					      MemHandle fieldInfoHandle,
					      byte colNum,
					      optr outputOD,
					      Message successMessage,
					      Message resultMessage);

/*
 * MSG_FFD_FIELD_DEPENDED_UPON --
 * 	This method checks whether or not a specific field
 *   	has dependents.  If it does, TRUE is returned.  If it
 *    	does not have any dependents, FALSE is returned.
 */
@message Boolean MSG_FFD_FIELD_DEPENDED_UPON(FieldID colNum);

/*
 * MSG_FFD_DELETE_FIELD --
 *	This message deletes a field from the database and from the
 *	database_name_list.  Pass the column number of the field to
 * 	delete.
 *
 *    	TRUE is returned if the field was deleted successfully,
 *    	FALSE is returned otherwise.
 */
@message Boolean MSG_FFD_DELETE_FIELD(byte colNum);

/*
 * MSG_FFD_DELETE_CURRENT_RECORD --
 *	Deletes the current record (SSI_curRow) from the database.
 * 	Leaves SSI_curRow alone, unless it was the last record in
 *	the database, in which case it gets decremented to reflect
 * 	the *new* last record in the datbase.
 */
@message void MSG_FFD_DELETE_CURRENT_RECORD();

/*
 * MSG_FFD_ADD_NAME_TO_LAYOUT_LIST --
 *	This message adds a name to the layout_name_list, and creates
 * 	a screen field and label on the screen.
 *
 *	NOTE: redundant names CAN be added.  Beware.
 *
 *	The appropriate list notifications will be made.
 */
@message void MSG_FFD_ADD_NAME_TO_LAYOUT_LIST(byte colNum, word width);

/*
 * MSG_FFD_ADD_NAME_TO_NOT_IN_LAYOUT_LIST --
 *	This message adds a name to the not_in_layout_name_list.  Pass
 * 	the column number of the field to add.
 *
 *	NOTE: redundant names CAN be added.  Beware.
 *
 *	The appropriate list notifications will be made.
 */
@message void MSG_FFD_ADD_NAME_TO_NOT_IN_LAYOUT_LIST(byte colNum);

/*
 * MSG_FFD_DELETE_NAME_FROM_LAYOUT_LIST --
 *	This message removes a name from the layout_name_list and
 * 	deletes the associated screen fields. Pass the old column
 * 	number.
 *
 *	The appropriate list notifications will be made.
 */
@message void MSG_FFD_DELETE_NAME_FROM_LAYOUT_LIST(byte colNum,
					    FieldListQuery whichList);

/*
 * MSG_FFD_DELETE_NAME_FROM_NOT_IN_LAYOUT_LIST --
 *	This message deletes a name to the not_in_layout_name_list.  Pass
 * 	the old column number of the field to delete.
 *
 *	The appropriate list notifications will be made.
 */
@message void MSG_FFD_DELETE_NAME_FROM_NOT_IN_LAYOUT_LIST(byte colNum);

/*
 * MSG_FFD_CHANGE_NAME_IN_LAYOUT_LIST --
 *	This message changes a name in the layout_name_list and
 * 	changes its screen label as well.  Pass the column number of the
 * 	changed name.  The field will be repositioned in the list, and
 * 	appropriate list notifications will be made.
 */
@message void MSG_FFD_CHANGE_NAME_IN_LAYOUT_LIST(byte colNum);

/*
 * MSG_FFD_CHANGE_NAME_IN_NOT_IN_LAYOUT_LIST --
 *	This message changes a name from the layout_name_list or the
 * 	not_in_layout_name_list.  Pass the column number of the
 * 	changed name.  The field will be repositioned in the list, and
 * 	appropriate list notifications will be made.
 */
@message void MSG_FFD_CHANGE_NAME_IN_NOT_IN_LAYOUT_LIST(byte colNum);

/*
 * MSG_FFD_SET_RECORD_ORDER_FOR_LAYOUT
 *	This message sets the record order for the given layout.
 *	Options are top->bottom, then left->right (ROO_TOP_TO_BOTTOM)
 *	or left->right, then top->bottom (ROO_LEFT_TO_RIGHT)
 */
@message void MSG_FFD_SET_RECORD_ORDER_FOR_LAYOUT(byte layoutNum,
						RecordOrderOption recordOrder);

/*
 * MSG_FFD_SET_RECORD_ORDER_FOR_CURRENT_LAYOUT
 *	This message sets the record order for the current layout.
 *	Options are top->bottom, then left->right (ROO_TOP_TO_BOTTOM)
 *	or left->right, then top->bottom (ROO_LEFT_TO_RIGHT)
 */
@message void MSG_FFD_SET_RECORD_ORDER_FOR_CURRENT_LAYOUT(
					RecordOrderOption recordOrder);

/*
 * MSG_FFD_GET_RECORD_ORDER_FOR_LAYOUT
 *	This message returns the record order for the given layout.
 */
@message RecordOrderOption MSG_FFD_GET_RECORD_ORDER_FOR_LAYOUT(byte layoutNum);

/*
 * MSG_FFD_GET_RECORD_ORDER_FOR_CURRENT_LAYOUT
 *	This message returns the record order for the current layout.
 */
@message RecordOrderOption MSG_FFD_GET_RECORD_ORDER_FOR_CURRENT_LAYOUT();

/*
 * MSG_FFD_CHANGE_SCREEN_FIELD_ATTRIBUTES
 *	This message changes the attributes for a field's screen
 * 	representation.  Pass the column number.
 */
@message void MSG_FFD_CHANGE_SCREEN_FIELD_ATTRIBUTES(FieldID colNum,
						     FieldDataType dataType);

/*
 * MSG_FFD_NOTIFY_ATTRIBUTE_CHANGES --
 *	This message tells the database that a field's attributes might have
 *	changed.
 *	Currently, the only thing that happens is that the Treasure Chest
 *	is told to updates its notes field.
 */
@message void MSG_FFD_NOTIFY_ATTRIBUTE_CHANGES();

/* MSG_FFD_ADD_FIELD_TO_LAYOUT
 *
 *	Creates a label (text GrObject), rectangle GrObject
 *	and a field (text GrObject), and adds them to the 
 *	GrObjBody.
 *	It then draws them on the current layout.
 *	Note: the index passed is the index into the sorted LAYOUT_NAME_LIST,
 *	NOT an absolute column number.
 */
@message void MSG_FFD_ADD_FIELD_TO_LAYOUT(byte index, word width);

/* MSG_FFD_ADD_EXISTING_GROBJ_TO_LAYOUT --
 *
 *	- Adds the passed TextGuardian to the 
 *	  GrObjBody of the current layout. 
 *	- Adds it to the record layout chunk
 *	  array for the current layout.
 *	- Redraws it with its new name.
 *	- Copies over the latest copy of the layout's sorted
 *	  list from the instance data into the header of the
 *	  chunk array. This is so that when we switch layouts,
 *	  we can just copy the sorted list from the chunk array
 *	  into the instance data (instead of having to re-sort
 *	  every time we switch layouts: slow.......)
 *    	- Re-attach its associated label.
 *
 *	Note: the index passed is the index into the sorted LAYOUT_NAME_LIST,
 *	NOT an absolute column number.
 */
@message void MSG_FFD_ADD_EXISTING_GROBJ_TO_LAYOUT(FieldID index,
						   optr fieldOptr,
						   optr labelOptr);
 
/* MSG_FFD_GET_DOCUMENT_HANDLE --
 *	This message returns the VMFileHandle for this database.
 */
@message VMFileHandle MSG_FFD_GET_DOCUMENT_HANDLE();

/* MSG_FFD_DELETE_FIELD_FROM_LAYOUT
 *
 *	Delete field from the layout's chunk array, and
 *	remove the associated GrObject from the GrObjBody.
 *	Note: the index passed is the index into the sorted LAYOUT_NAME_LIST,
 *	NOT an abolute column number.
 */
@message void MSG_FFD_DELETE_FIELD_FROM_LAYOUT(byte index);

/* MSG_FFD_DELETE_CHUNK_ELEMENT_FROM_LAYOUT
 *
 *	Delete field from the layout's chunk array.
 *	If the field is in the current layout name list, it is removed
 *	and a list notification is dispatched.
 *	Note: the index passed is the field's absolute column number.
 */
@message void MSG_FFD_DELETE_CHUNK_ELEMENT_FROM_LAYOUT(FieldID colNum);

/*
 * MSG_FFD_DELETE_FIELDS_BUT_ASK_FIRST --
 *	This message deletes fields from the database after getting
 *	permission from the user.  It clears all the data, deletes the
 *	field names, updates all the lists in the instance data,
 *	notifies controllers of the change, updates all computed
 *	fields which reference the deleted fields and deletes the fields
 *	from all layouts.
 */
@message void MSG_FFD_DELETE_FIELDS_BUT_ASK_FIRST(MemHandle fieldIDListHandle,
						  FieldListQuery list,
						  word numItems);

/*
 * MSG_FFD_GET_COLUMN_FIELD_NAME --
 *	This message retrieves the field name for a given column.
 *	If textBuffer is non-NULL, the name will be strcpy()'d into
 *	the area pointed to by the textBuffer.  Else, a block will be
 *	allocated as sharable, the name copied into the block, the block
 *	will be unlocked, and the block's handle returned.
 */
@message MemHandle MSG_FFD_GET_COLUMN_FIELD_NAME(word columnNum,
						 TCHAR *textBuffer);

/*
 * MSG_FFD_GET_INDEXED_FIELD_NAME --
 * 	This message returns a MemHandle to the text of a field in one
 *	of the indexed lists (or fills a passed textBuffer -- see
 *	MSG_FFD_GET_COLUMN_FIELD_NAME for details) based on whichList
 *	is being requested.  The main, alphabetized list of every
 *	field in the database is selected by DATABASE_NAME_LIST; the list
 *	of fields in the current layout is used with LAYOUT_NAME_LIST; and
 *	the fields in the database which are not in the current layout
 *	are available though the NOT_IN_LAYOUT_NAME_LIST.
 */
@message MemHandle MSG_FFD_GET_INDEXED_FIELD_NAME(word fieldNum,
						  FieldListQuery whichList,
						  TCHAR *textBuffer);

/*
 * MSG_FFD_REQUEST_UNIQUE_FIELD_NAME --
 *
 * 	This method provides the caller with a unique field
 *	name.
 *
 *    	The caller can provide a candidate name, which
 *    	will be used as the base of the new, unique name.  For
 *    	example, if "Foo" is passed as the candidate, and no
 *    	other fields exist with this name, "Foo" will be returned.
 *    	Then, if "Foo" is used again as the candidate, then
 *    	"Foo_2" will be returned, and so on.
 *
 *	If the candidate field ends with an underscore and a number,
 *	the number will be incremented until the name is accepted.
 *	For example, if "Foo_2" is provided as the candidate, the
 *	result will be "Foo_3".
 *
 *    	If no candidate name is provided, "Field_1" will be
 *    	used (with the number incremented accordingly).
 *	    	
 *    	As an added bonus, if an optr to a text object is
 *    	provided, the new name will be loaded into the field
 *    	and will be selected.
 *
 *    	If an error occurred (like the candidate name being un-
 *    	acceptable), FALSE will be returned.  Otherwise, TRUE
 *    	is returned.
 *
 */
@message Boolean MSG_FFD_REQUEST_UNIQUE_FIELD_NAME(optr textObject,
						TCHAR *candidate,
						TCHAR *newFieldName);

/*
 * MSG_FFD_REQUEST_UNIQUE_FIELD_NAME_WITH_RESPONSE --
 *
 * 	This method calls MSG_FFD_REQUEST_UNIQUE_FIELD_NAME then
 *	calls a message passed in resultMsg to a destination passed
 *	in resultDest.  The message (below) takes no arguments.
 */
@message void MSG_FFD_REQUEST_UNIQUE_FIELD_NAME_WITH_RESPONSE(
					        optr textObject,
						TCHAR *candidate,
						TCHAR *newFieldName,
						optr resultDest,
					        Message resultMsg);

@prototype void MSG_FFD_RESULT_OF_REQUEST_UNIQUE_FIELD_NAME();

/*
 * MSG_FFD_ADD_PAGE_NUMBER_TO_LAYOUT --
 *
 * DESCRIPTION: - Can only be called when in multi-record layout
 *	    	  design mode.
 *	    	- Creates a label (multText GrObject)
 *		  and a field (text GrObject), and adds them to the 
 *		  GrObjBody of the current layout. 
 *	    	- Tells the label to say "Page", and the field
 *	    	  to be a FDT_PAGE_NUMBER.  This is a non-data-holding
 *	    	  data type that appears as a "#" in design mode, and
 *	    	  as the current page number in data-entry mode.
 */
@message void MSG_FFD_ADD_PAGE_NUMBER_TO_LAYOUT();

/*
 * MSG_FFD_NOTIFY_CLIPBOARD_PASTE --
 * 	This message is sent when objects have been pasted 
 * 	into from the clipboard into a GrObj body.
 *
 *	If fields have been pasted into the single record layout, we
 * 	attempt to hook them up to the database by loading them into
 * 	the current layout, or duplicating them if they are already in
 * 	the current layout.
 *
 *	If fields have been pasted into a multi-record layout,
 *    	then the user is warned that they won't be hooked up.
 */
@message void MSG_FFD_NOTIFY_CLIPBOARD_PASTE(optr grObjBody);

/*
 * MSG_FFD_ADD_PASTED_FIELD_TO_LAYOUT --
 *	This message is called by field guardian GrObjects that
 *	have been pasted into a layout, and want to let the database
 *	know about it.
 *
 *	The column number indicates which field of the current
 *	database this object is supposed to represent.  If the field
 *      is not yet in the current layout, the new GrObject will
 *	represent it.
 *
 *	If the field is already in the current layout, a new field
 *	created in the database that has all the same attributes as
 *	the original, and is named with MSG_FFD_REQUEST_UNIQUE_FIELD_NAME
 *	using the original field name as the name candidate.
 */
@message void MSG_FFD_ADD_PASTED_FIELD_TO_LAYOUT(optr guardianOptr,
						 optr labelOptr,
						 FieldID colNum);

/*
 * MSG_FFD_GET_COLUMN_MIN_OR_MAX_STRING
 *
 *  	Get min or max value for specified column, and convert it
 *	to a text string. Requested column must represent
 *	either an integer or a real number.
 *	Text buffer must be of size FLOAT_TO_ASCII_NORMAL_BUF_LEN
 *
 *	If the number was not valid (like the cell was empty,
 *	for example), FALSE will be returned.  Otherwise,
 *	TRUE will be.
 */
@message Boolean MSG_FFD_GET_COLUMN_MIN_OR_MAX_STRING(word columnNum, 
						      TCHAR *textBuffer, 
						      MinOrMaxValue minOrMax);

/*
 * MSG_FFD_MOVE_FIELDS_INTO_LAYOUT_LIST --
 *	This message moves fields from the not_in_layout_list
 *	into the layout_list.  Pass the indices of the
 *	fields WRT to the not_in_layout_list.
 */
@message void MSG_FFD_MOVE_FIELDS_INTO_LAYOUT_LIST(MemHandle fieldIDListHandle,
						   word numItems);

/*
 * MSG_FFD_MOVE_FIELDS_OUT_OF_LAYOUT_LIST --
 *	This message moves fields from the layout_list
 *	into the not_in_layout_list.  Pass the indices of the
 *	fields WRT to the layout_list.
 */
@message void MSG_FFD_MOVE_FIELDS_OUT_OF_LAYOUT_LIST(
						MemHandle fieldIDListHandle,
						word numItems);

/*
 * MSG_FFD_EDIT_FIELD_PROPERTIES --
 * 	This message loads up a request to edit a field's
 *	properties from a particular field list and sends it
 *    	off to the field properties UI controller pointed to
 *    	by the editFieldOptr.
 */
@message void MSG_FFD_EDIT_FIELD_PROPERTIES(FieldListQuery whichList,
					    word fieldID,
					    optr editFieldOptr);

/*
 * MSG_FFD_SET_CUR_COL
 *	This message sets the current column (in the instance data)
 * 	to the given column number.
 *
 */
@message void MSG_FFD_SET_CUR_COL(byte colNumber);

/*
 * MSG_FFD_GET_CUR_COL
 *	Returns current column.
 *
 */
@message byte MSG_FFD_GET_CUR_COL();

/*
 * MSG_FFD_GET_NEXT_COL
 *	Returns column for next field. Returns -1 if we're already
 *	at the last field.
 *
 */
@message byte MSG_FFD_GET_NEXT_COL();

/*
 * MSG_FFD_SET_CUR_ROW
 *	This message sets the current row (in the instance data)
 * 	to the given row number.
 *
 */
@message void MSG_FFD_SET_CUR_ROW(word rowNumber);

/*
 * MSG_FFD_GET_CUR_ROW
 *	Returns current row.
 *
 */
@message word MSG_FFD_GET_CUR_ROW();

/*
 * MSG_FFD_GET_NUM_FIELDS
 *	Returns number of fields in the database. 
 *
 */
@message byte MSG_FFD_GET_NUM_FIELDS();

/*
 * MSG_FFD_GET_NUM_RECORDS --
 *	Returns number of records in the database. 
 *
 */
@message word MSG_FFD_GET_NUM_RECORDS();

/*
 * MSG_FFD_GET_NUM_MARKED_RECORDS --
 *	Returns number of marked records in the database. 
 *
 */
@message word MSG_FFD_GET_NUM_MARKED_RECORDS();

/*
 * MSG_FFD_GET_SHOW_ONLY_MARKED --
 *	Returns the status of "show only marked" flag. 
 *
 */
@message Boolean MSG_FFD_GET_SHOW_ONLY_MARKED();

/*
 * MSG_FFD_GET_NUM_LAYOUTS
 *	Returns number of layouts in the database. 
 *
 */
@message byte MSG_FFD_GET_NUM_LAYOUTS();

/*
 * MSG_FFD_GET_INDEXED_COL_NUM
 *	Returns column number of the field at the given position
 *	in the list of sorted fields. 
 *	For instance, if you want to know which column of data
 *	corresponds to the first alphabetical field, 
 *	send index = 0.
 */
@message byte MSG_FFD_GET_INDEXED_COL_NUM(byte index);

/*
 * MSG_FFD_GET_DATA_TYPE_AND_FLAGS
 *	Returns the data type and flags of the given field.
 */
@message FieldDataType MSG_FFD_GET_DATA_TYPE_AND_FLAGS(byte fieldNum,
					     FieldDataTypesFlags *flags);

/*
 * MSG_FFD_VALIDATE_SCREEN_FIELD --
 *	This message is sent when a field's text object is to be
 *	entered into the database.  It grabs the text from the field,
 *	and sends it off to MSG_FFD_STORE_FIELD_DATA_IN_TEMP_ROW_CELL.
 *	If the text is illegal for some reason, the appropriate error
 *	value will be returned.  Otherwise, FFFV_FIELD_OK or one of
 *	the other benign values is returned.
 */
@message FFFieldValidationType MSG_FFD_VALIDATE_SCREEN_FIELD(optr textOptr,
							    FieldID colNum,
							    Boolean formatText);

/*
 * MSG_FFD_VALIDATE_SCREEN_FIELD_WITH_MESSAGE --
 * 	This message validates a screen field via the
 *    	FFDValidateScreenFieldWithMessage function and displays an
 *    	error message if something went wrong.  The return
 *    	value from MSG_FFD_VALIDATE_SCREEN_FIELD is returned.
 */
@message FFFieldValidationType MSG_FFD_VALIDATE_SCREEN_FIELD_WITH_MESSAGE(
							    optr textOptr,
							    FieldID colNum,
							    Boolean formatText);

/*
 * MSG_FFD_DISPLAY_VALIDATION_ERROR --
 *
 * 	This message puts up an error message describing an
 *   	invalid value in a field, unless for some reason we
 *    	should not put up an error.
 */
@message void MSG_FFD_DISPLAY_VALIDATION_ERROR(FieldID colNum,
					       FFFieldValidationType retval);

/*
 * MSG_FFD_NOTIFY_FIELD_NAVIGATION --
 * 	This message is sent when a field intercepts some random navigation
 *	key combination.
 */
@message void MSG_FFD_NOTIFY_FIELD_NAVIGATION(optr textOptr, FieldID colNum,
					      ShortcutCode shortcut);

/*
 * MSG_FFD_STORE_FIELD_DATA_IN_TEMP_ROW_CELL
 *	This message stores given data in given field in the temporary
 *	row.
 *
 *	Type checking is done for numeric types.  If the text cannot be
 *	validly converted to a FloatNum, FALSE will be returned.  Otherwise,
 *	TRUE is returned.
 */
@message Boolean MSG_FFD_STORE_FIELD_DATA_IN_TEMP_ROW_CELL(word colNum,
							   char *data);

/*
 * MSG_FFD_SET_TEMP_DATA_ROW_FOR_NEW_RECORD --
 * 	This method loads up the TEMP_DATA_ROW's fields (well,
 *    	the ones used by the current layout, anyway) with
 *    	default computed values or blanks, as the case may be.
 */
@message void MSG_FFD_SET_TEMP_DATA_ROW_FOR_NEW_RECORD();


/*
 * MSG_FFD_STORE_CURRENT_ROW
 *	Moves data from the temporary row (TEMP_DATA_ROW) into
 *	the current row.
 */
@message void MSG_FFD_STORE_CURRENT_ROW();

/*
 * MSG_FFD_CHECK_FIELD_DATA_TYPE
 * 	Checks the user entry for this field against defined data type
 *	for the field. Returns TRUE if the data's OK, FALSE otherwise.
 *	Also, if data can be converted to a FloatNum (i.e. it's an integer,
 *	real, date or time), then the FloatNum representation is stored 
 *	at the given address.
 */
@message Boolean MSG_FFD_CHECK_FIELD_DATA_TYPE(word column, 
					       MemHandle dataHandle,
                 			       dword floatAddress);

/*
 * MSG_FFD_CHECK_FIELD_DATA_BETWEEN_MIN_AND_MAX
 *	Checks whether the given data (in dataHandle's block) is
 *	between the min and max for the given column.
 *	Returns	FIELD_IN_RANGE if data's OK
 *		FIELD_BELOW_MIN if value < min
 *		FIELD_ABOVE_MAX if value > max
 * 	
 */
@message FieldRangeCheck MSG_FFD_CHECK_FIELD_DATA_BETWEEN_MIN_AND_MAX(
						            word column, 
					       	    	    FloatNum dataValue);

/*
 * MSG_FFD_EDIT_EXPRESSION --
 *
 *	This message handles when an expression or computed expression
 *	is be edited.  Given a token stream and an Expression Builder
 *	OD, this message translates the token stream into a string and
 *	gives the string to the expression builder.
 *
 *	MSG_FFD_PARSE_EXPRESSION deals with parsing the new string and
 *	dealing with errors.
 *
 * 	If the resultDestinationOptr is non-NULL, it will be sent the
 *	passed resultMessage.
 *
 *	The resultMessage's one argument is a MemHandle to the resulting
 *	token stream (so it's up to the resultDestination to determine if
 *	the stream changed or not).
 */
@message void MSG_FFD_EDIT_EXPRESSION(MemHandle tokenStreamHandle,
				      optr expressionBuilderOptr,
				      optr resultDestinationOptr,
				      Message resultMessage);

/*
 * MSG_FFD_PARSE_EXPRESSION --
 *	This message handles when an expresion builder is done
 *	building a string out and wants it to be parsed and translated
 *	into a token stream.
 *
 *	The parse library is called to parse the string. and any
 *	errors that might occur are displayed.  If an error does
 *	occur, the expression builder pointed to by the
 *	expressionBuilderOptr instance datum is requested to
 *	highlight (select) the offending part of the string.
 *
 *	Otherwise, the expression builder is called to shut itself
 *	down, and the resultDestinationOptr will be sent the passed
 *	resultMessage with a token stream's MemHandle.
 */
@message void MSG_FFD_PARSE_EXPRESSION(MemHandle stringHandle);

/*
 * MSG_PARSE_RETURN_TEMPLATE --
 *	This is a template for the return message discussed in
 *	MSG_FFD_EDIT_EXPRESSION above.  tokenStreamHandle is a
 *	MemHandle to a token stream determined by parsing an
 *	expression string, and numTokens is the number of tokens
 *	(well, bytes, really) in the stream.
 */
@prototype void MSG_FFD_PARSE_RETURN_TEMPLATE(MemHandle tokenStreamHandle,
					      word numTokens);

/*
 * MSG_FFD_PARSE_PARSE_STRING --
 *
 *	
 */
@message Boolean MSG_FFD_PARSE_PARSE_STRING (MemHandle stringHandle,
					     MemHandle tokenBufferHandle,
					     word tokenBufferSize,
					     word *numTokens,
					     VisTextRange *errorOffsetPtr);

/*
 * MSG_FFD_INIT_SINGLE_RECORD_LAYOUT
 *	This routine initializes the structure for the given 
 *	layout of given layout type. Note that if you initializing
 *	a multi-record layout, you will want to call MSG_FFD_INIT_
 *	MULTI_RECORD_LAYOUT as well. This method stores the GrObjBody location 
 *	in the database, and initializes the record layout structure.
 *	If you want the first available layout number, set layoutNum = -1.
 *	Returns layoutNum.
 */
@message byte MSG_FFD_INIT_SINGLE_RECORD_LAYOUT(byte layoutNum,
					 VMBlockHandle grObjBodyVMBlock,
					 ChunkHandle grObjBodyChunk,
					 optr grObjBodyOptr,
					 LayoutType layoutType);

/*
 * MSG_FFD_INIT_MULTI_RECORD_LAYOUT
 *	This routine initializes the structure for the given 
 *	multi-record layout.
 *	This method stores the GrObjBody location in the database, 
 *	and initializes the multi-record layout structure.
 */
@message void MSG_FFD_INIT_MULTI_RECORD_LAYOUT(byte layoutNum,
					      	MemHandle mrGrObjBodyHandle,
				 		ChunkHandle mrGrObjBodyChunk,
			        	        optr ffGrObjHeadOptr);

/* MSG_FFD_LOAD_FIELD_WITH_PAGE_NUMBER --
 * 	This message loads a text field with the current page
 *      number in multi-record mode.
 */
@message void MSG_FFD_LOAD_FIELD_WITH_PAGE_NUMBER(optr fieldOptr);

/* MSG_FFD_NOTIFY_LAYOUT_SIZE_GREW --
 *	This message is sent out by the database object to notify
 *	subclassed database objects that the single record layout
 *	(and possibly the page layout) has changed to a new size.
 *
 *	NOTE: this message is handled only by subclasses; it's ignored
 *	      by the database itself.
 */
@message void MSG_FFD_NOTIFY_LAYOUT_SIZE_GREW(LayoutSize srBounds,
					      PageSizeReport psr);

/*
 * MSG_FFD_CREATE_NEW_LAYOUT
 *	This routine creates a new layout, and displays it.
 *	It creates both the single-record and multi-record layouts
 *	(which together make up this layout), but displays the
 *	single-record layout. 
 *
 *	The new layout number is returned.
 */
@message byte MSG_FFD_CREATE_NEW_LAYOUT(MemHandle singleRecordGrObjBodyHandle,
					MemHandle multiRecordGrObjBodyHandle,
					ChunkHandle ffGrObjBodyChunk, 
					optr ffGrObjHeadOptr);

/*
 * MSG_FFD_SET_SINGLE_RECORD_BOUNDS --
 * 	This message sets the single record bounds for the current
 *    	layout.  Note that the actual view is not modified, only
 *    	flat file's data.
 */
@message void MSG_FFD_SET_SINGLE_RECORD_BOUNDS(LayoutSize bounds);


/*
 * MSG_FFD_GET_SINGLE_RECORD_BOUNDS
 *
 *	Returns the size of the record layout boundary for the current
 *	layout.
 */
@message void MSG_FFD_GET_SINGLE_RECORD_BOUNDS(LayoutSize *bounds);


/*
 * MSG_FFD_REDRAW_MULTI_RECORD
 *
 * 	This message simply invalidates the current multi-record
 *	box so it redraws.
 */
@message void MSG_FFD_REDRAW_MULTI_RECORD();

/*
 * MSG_FFD_GET_MULTI_RECORD_BOUNDS
 *
 *	Returns the size of the page layout boundary for the current
 *	layout.
 */
@message void MSG_FFD_GET_MULTI_RECORD_BOUNDS(LayoutSize *bounds);


/*
 * MSG_FFD_SET_MULTI_RECORD_BOUNDS
 *
 *	Sets the size of the page layout boundary for the current
 *	layout. Note the view is not updated, only flat file's data.
 */
@message void MSG_FFD_SET_MULTI_RECORD_BOUNDS(LayoutSize bounds);

/*
 * MSG_FFD_SET_MULTI_RECORD_WITHIN_MARGINS --
 *
 *	This message makes sure the current multi-record area is not
 *	above or to the left of the top and left margins.  It will
 *	move the repeater box if it needs to.
 *
 *	Warning: the size of the repeater box is left alone, so you
 *	         should make sure the size is ok before calling this
 *	    	 message.
 */
@message void MSG_FFD_SET_MULTI_RECORD_WITHIN_MARGINS(PageSizeReport *psr);

/*
 * MSG_FFD_GET_PAGE_BOUNDS
 *
 *	Returns the size of the page bounds for the current
 *	layout.
 */
@message void MSG_FFD_GET_PAGE_BOUNDS(PageSizeReport *psr);


/*
 * MSG_FFD_SET_PAGE_BOUNDS
 *
 *	Sets the size of the page bounds for the current
 *	layout. Note the view is not updated, only flat file's data.
 */
@message void MSG_FFD_SET_PAGE_BOUNDS(PageSizeReport *psr);

/*
 * MSG_FFD_DRAW_MARGINS --
 *	This message draws a margin border if we're currently
 * 	in multi-record design mode.
 */
@message void MSG_FFD_DRAW_MARGINS(GStateHandle gstate);

/*
 * MSG_FFD_GRAB_TARGET_ON_FIRST_FIELD
 * Finds the first visible field in the current layout (according
 * to the tab order) and has it grab the target
 */
@message void MSG_FFD_GRAB_TARGET_ON_FIRST_FIELD();

/*
 * MSG_FFD_GET_CURRENT_LAYOUT
 *	Returns the current layout number.
 */
@message byte MSG_FFD_GET_CURRENT_LAYOUT();

/*
 * MSG_FFD_GET_LAYOUT_TYPE
 *	Returns the LayoutType of the given layout.  If curLayout is set to
 *	TRUE, the current layout's type is returned.  Otherwise, layoutNum's
 *	type is returned.
 */
@message LayoutType MSG_FFD_GET_LAYOUT_TYPE(byte layoutNum, Boolean curLayout);

/*
 * MSG_FFD_SET_LAYOUT_TYPE
 *	Sets the LayoutType for the given layout.
 */
@message void MSG_FFD_SET_LAYOUT_TYPE(byte layoutNum, LayoutType layoutType);

/*
 * MSG_FFD_GET_CURRENT_LAYOUT_INDEX
 *	Returns the current layout number's index into the list
 *	of sorted layout names.
 */
@message byte MSG_FFD_GET_CURRENT_LAYOUT_INDEX();

/*
 * MSG_FFD_GET_LAYOUT_NAME
 *
 *	This message retrieves the layout name for a given layout.
 *	If textBuffer is non-NULL, the name will be strcpy()'d into
 *	the area pointed to by the textBuffer.  Else, a block will be
 *	allocated as sharable, the name copied into the block, the block
 *	will be unlocked, and the block's handle returned.
 */
@message MemHandle MSG_FFD_GET_LAYOUT_NAME(word layoutNum,
					   TCHAR *textBuffer);

/*
 * MSG_FFD_GET_LAYOUT_NOTES
 *
 *	This message retrieves the layout notes for a given layout.
 *	If textBuffer is non-NULL, the notes will be strcpy()'d into
 *	the area pointed to by the textBuffer.  Else, a block will be
 *	allocated as sharable, the notes copied into the block, the block
 *	will be unlocked, and the block's handle returned.
 */
@message MemHandle MSG_FFD_GET_LAYOUT_NOTES(byte layoutNum,
					   TCHAR *textBuffer);

/*
 * MSG_FFD_STORE_LAYOUT_NOTES
 *
 *	This message stores the layout notes for a given layout.
 */
@message void MSG_FFD_STORE_LAYOUT_NOTES(byte layoutNum,
					      TCHAR *textBuffer);

/*
 * MSG_FFD_GET_CURRENT_LAYOUT_NAME
 *
 *	This message retrieves the layout name for the current layout.
 *	If textBuffer is non-NULL, the name will be strcpy()'d into
 *	the area pointed to by the textBuffer.  Else, a block will be
 *	allocated as sharable, the name copied into the block, the block
 *	will be unlocked, and the block's handle returned.
 */
@message MemHandle MSG_FFD_GET_CURRENT_LAYOUT_NAME(TCHAR *textBuffer);

/*
 * MSG_FFD_GET_INDEXED_LAYOUT_NAME
 *
 *	This message retrieves the layout name for the layout at the
 *	given index in the list of sorted layout names.
 *	If textBuffer is non-NULL, the name will be strcpy()'d into
 *	the area pointed to by the textBuffer.  Else, a block will be
 *	allocated as sharable, the name copied into the block, the block
 *	will be unlocked, and the block's handle returned.
 */
@message MemHandle MSG_FFD_GET_INDEXED_LAYOUT_NAME(byte layoutNameIndex,
					           TCHAR *textBuffer);

/*
 * MSG_FFD_GET_LAYOUT_NUM_FROM_INDEX
 *
 *	Given an index into the list of sorted layout names, this message
 *	returns the absolute column number.
 */
@message byte MSG_FFD_GET_LAYOUT_NUM_FROM_INDEX(byte layoutNameIndex);

/*
 * MSG_FFD_SWITCH_TO_LAYOUT
 *
 *	This message detaches the current GrObjBody, and attaches the
 * 	one corresponding to the given layout (with the current layoutType
 *	display). 
 *
 *	Set the `printing' flag if you do not want the view to be reset.
 */
@message void MSG_FFD_SWITCH_TO_LAYOUT(byte layoutNum,
				       optr ffGrObjHeadOptr,
				       LayoutType layoutType,
				       Boolean printing);

/*
 * MSG_FFD_SWITCH_TO_INDEXED_LAYOUT
 *
 *	Switches to the layout of the given index (the index is an index
 *	into the sorted list of layout names). Checks the layout type
 *	of the requested layout, and displays it.
 */
@message LayoutType MSG_FFD_SWITCH_TO_INDEXED_LAYOUT(byte index,
					optr ffGrObjHeadOptr);

/*
 * MSG_FFD_RENAME_LAYOUT
 *
 *	Renames the given layout. The layout number passed represents
 *	the absolute column number of the layout.
 *	Returns FALSE if the name is already used; TRUE if no
 *	problems encountered.
 */
@message Boolean MSG_FFD_RENAME_LAYOUT(byte layoutNum,
				       TCHAR *newLayoutName);

/*
 * MSG_FFD_DELETE_LAYOUT
 *
 *	Deletes the given layout after prompting the user for confirmation. 
 *	The layout number passed represents the absolute column number 
 *	of the layout.
 *
 *	You must, at all times, have at least one layout. So, if you
 *	try to delete the last layout, the routine will return 
 *	ATTEMPTED_TO_DELETE_LAST_LAYOUT. If the user chose not to delete
 *	this routine returns NO_DELETE_DONE.
 *	Otherwise, it will return DELETE_OK.
 *
 *	If you delete the current layout, the "new" current layout will
 *	be the one after the current one in the sorted list of layout
 *	names. If you delete the current layout, and it's also the last
 *	layout (alphabetically), the "new" current layout becomes
 *	the one before the current one.
 */
@message FFDeleteLayoutResult MSG_FFD_DELETE_LAYOUT(byte layoutNum,
				       	optr ffGrObjHeadOptr);

/*
 * MSG_FFD_SET_DOCUMENT_HANDLE
 *	This routine sets the current document's file handle in the
 *	instance data for the flat file object. We need this so that
 *	we can later get optrs to the GrObjBody and GrObjects
 *	(given their VM blocks & chunk handles
 */
@message void MSG_FFD_SET_DOCUMENT_HANDLE(VMFileHandle documentFileHandle);

/*
 * MSG_FFD_SET_GROBJ_AM
 *	This routine sets the Attribute Manager's optr in the instance 
 *	data for the flat file object. 
 */
@message void MSG_FFD_SET_GROBJ_AM(optr grObjAMOptr);

/*
 * MSG_FFD_GET_GROBJ_BODY_FOR_LAYOUT
 *
 *   	Given the layout number and type, returns the GrObjBody 
 */
@message optr MSG_FFD_GET_GROBJ_BODY_FOR_LAYOUT(byte layoutNum,
						LayoutType layoutType);

/*
 * MSG_FFD_GET_GROBJ_BODIES_FOR_CURRENT_LAYOUT
 *
 *   	Returns the GrObjBody for the current layout. If the
 *	current layout is in Data Entry mode and displaying
 *	multi-records, then the pointer to grobjBody2 is
 *	filled in. Note: if both grobj bodies are filled in
 *	then the one returned by the routine is that for
 *	the multi-record layout; the one pointed to by
 *	grobjBody2 is that for the single-record layout.
 */
@message optr MSG_FFD_GET_GROBJ_BODIES_FOR_CURRENT_LAYOUT(optr *grobjBody2);

/*
 * MSG_FFD_SET_CURRENT_MODE --
 *	This message changes the current mode to any of the available
 *	data entry or design modes (enumerated in the ModeTypes).
 *
 *	If the mode is changing from a design mode to a data entry
 *	mode, all decoration GrObjects in the layout are made
 *	uneditable and non-selectable, and all data entry objects are
 *	made editable but not selectable.
 *
 *	If the mode is changing to a design mode, all objects are made
 *	editable, selectable, etc.
 */
@message void MSG_FFD_SET_CURRENT_MODE(ModeType newMode);

/*
 * MSG_FFD_SET_CURRENT_MODE_TO_DESIGN --
 *	This message changes the current mode to design mode through
 *	MSG_FFD_SET_CURRENT_MODE.
 */
@message void MSG_FFD_SET_CURRENT_MODE_TO_DESIGN();

/*
 * MSG_FFD_SET_CURRENT_MODE_TO_DATA_ENTRY --
 *	This message changes the current mode to data entry mode through
 *	MSG_FFD_SET_CURRENT_MODE.
 */
@message void MSG_FFD_SET_CURRENT_MODE_TO_DATA_ENTRY();

/*
 * MSG_FFD_GET_CURRENT_MODE --
 *	Returns the current mode type.
 */
@message ModeType MSG_FFD_GET_CURRENT_MODE();

/*
 * MSG_FFD_LOAD_FIELD_WITH_NAME --
 *	This message loads a text field with its own name.  Pass the OD
 *	of the field, and the column to find the name.
 */
@message void MSG_FFD_LOAD_FIELD_WITH_NAME(optr fieldOptr, FieldID colNum);

/*
 * MSG_FFD_LOAD_FIELD_WITH_UNFORMATTED_TEXT --
 *	This message loads a text field with the unformatted text
 *	that was typed into it.  Pass the OD of the field and its column
 *	number.
 */
@message void MSG_FFD_LOAD_FIELD_WITH_UNFORMATTED_TEXT(optr fieldOptr,
						       FieldID colNum);

/*
 * MSG_FFD_DISPLAY_USER_DEFINED_FORMAT --
 *	This message formats a float number to a user defined format.
 *	Pass a pointer to the text buffer to be filled with the formatted
 *	number, a pointer to the number, and the display format.
 */
@message void MSG_FFD_DISPLAY_USER_DEFINED_FORMAT(TCHAR *fieldText,
						  FloatNum *floatNum,
						  FormatIdType displayFormat);

/*
 * MSG_FFD_VERIFY_SCREEN_FIELDS --
 * 	This method runs through the text objects in the
 *	current layout, making sure that all of the fields
 *	that should have information in them actually do.
 *
 *	If all fields were successfully entered into the row,
 *	then TRUE is returned.  Otherwise, FALSE is.
 */
@message Boolean MSG_FFD_VERIFY_SCREEN_FIELDS();

/*
 * MSG_FFD_TRANSFER_TEMP_ROW_TO_SCREEN_FIELDS --
 * 	This method runs through the current layout's fields
 *   	and loads the field's text objects with data from the
 *    	TEMP_DATA_ROW's corresponding fields.
 */
@message Boolean MSG_FFD_TRANSFER_TEMP_ROW_TO_SCREEN_FIELDS();

/*
 * MSG_FFD_DISPLAY_TEMP_ROW_COMPUTED_FIELDS --
 *
 * 	This method runs through the current layout's computed
 *	fields and loads their text objects with data from the
 *    	TEMP_DATA_ROW's corresponding fields.
 */
@message void MSG_FFD_DISPLAY_TEMP_ROW_COMPUTED_FIELDS();

/*
 * MSG_FFD_GET_DATA_TYPE_AND_LENGTH --
 * 	This method returns the data type and length for a given field
 *	in a given record.
 */
@message void MSG_FFD_GET_DATA_TYPE_AND_LENGTH(word fieldNum,
					       word row,
					       FieldDataType *dataType,
					       word *dataLength);

/*
 * MSG_FFD_LOAD_TEMP_ROW_FROM_ANOTHER_ROW --
 *	This method loads up the TEMP_DATA_ROW with fields from another
 *	database record.
 *
 *	NOTE: only fields in the current layout are loaded!
 */
@message void MSG_FFD_LOAD_TEMP_ROW_FROM_ANOTHER_ROW(word recordToLoad);

/*
 * MSG_FFD_STORE_TEMP_ROW_INTO_ANOTHER_ROW --
 *	This method stores data from the TEMP_DATA_ROW into another row.
 *
 *	NOTE: only fields in the current layout are stored!
 */
@message void MSG_FFD_STORE_TEMP_ROW_INTO_ANOTHER_ROW(word rowToStoreInto);

/*
 * MSG_FFD_LOAD_CURRENT_RECORD_TO_SCREEN --
 * 	This method loads the TEMP_DATA_ROW with field info from
 *	the current record, then loads the current layout's screen
 *	fields with the info for the user's editing pleasure.
 *
 */
@message void MSG_FFD_LOAD_CURRENT_RECORD_TO_SCREEN();

/*
 * MSG_FFD_EDIT_NEW_RECORD --
 *	This method clears the TEMP_DATA_ROW's fields (the
 *   	ones used by the the current layout, anyway), loads up
 *    	the fields that have computed defaults, loads up the
 *    	screen's fields from the temp row, and sets the
 *    	FFI_editingNewRecord flag.
 *	If you just want to load a clean record into the current
 *	GrObjBody, pass moveGrObjBody = FALSE.
 *	If you are in multi-record mode, and it's possible that
 *	the GrObjBody may have to move, send moveGrObjBody = TRUE,
 *	and the message handler will find the appropriate position.
 *
 *	If you pass newRecordType = NRT_LOAD_FROM_TEMP_VISUAL_UPDATE_ROW,
 *	then the data for this new record will be loaded from 
 *	TEMP_DATA_ROW_FOR_VISUAL_UPDATES.
 *	If you just want a regular new record, pass newRecordType =
 *	NRT_REGULAR.
 *
 *	If you want the first field in the record to grab the target,
 *	pass fieldGrabTarget = TRUE. If you don't want the target to
 *	be mucked with, pass fieldGrabTarget = FALSE.
 *
 *    	This is the method to call when the user wants to create
 *    	a new record.
 */
@message void MSG_FFD_EDIT_NEW_RECORD(Boolean moveGrObjBody,
					NewRecordType newRecordType,
					Boolean fieldGrabTarget);

/*
 * MSG_FFD_EDIT_EXISTING_RECORD --
 *	This method loads the TEMP_DATA_ROW's fields (the
 *   	ones used by the the current layout, anyway) with data
 *	from a record and loads up the screen's fields with the
 *	data.
 *	If you just want to load the existing record into the current
 *	GrObjBody, pass moveGrObjBody = FALSE.
 *	If you are in multi-record mode, and it's possible that
 *	the GrObjBody may have to move, send moveGrObjBody = TRUE,
 *	and the message handler will find the appropriate position.
 *
 *	If you want the first field in the record to grab the target,
 *	pass fieldGrabTarget = TRUE. If you don't want the target to
 *	be mucked with, pass fieldGrabTarget = FALSE.
 *
 *	For documentation on editRecordType, see
 *	MSG_FFD_EDIT_NEW_RECORD's newRecordType. 
 *
 *    	This is the method to call when the user wants to edit
 *    	an existing record.
 */
@message void MSG_FFD_EDIT_EXISTING_RECORD(word recordToEdit, Boolean
					   moveGrObjBody,
					   Boolean fieldGrabTarget,
					   EditRecordType editRecordType);

/*
 * MSG_FFD_REVERT_CURRENT_RECORD --
 *
 *	Revert the currently being edited field to it's last saved
 *	contents.  If editing a new record then all fields reset.
 */
@message Boolean MSG_FFD_REVERT_CURRENT_RECORD();

/*
 * MSG_FFD_COMMIT_TEMP_DATA_ROW_TO_DATABASE --
 * 	This method saves the information in the TEMP_DATA_ROW's
 *    	fields (the fields used by the current layout, anyway)
 *    	to the current layout's row, unless the
 *    	FFI_editingNewRecord flag is set.  If this is set,
 *    	then a new row will be saved, the total number of
 *    	records will be incremented, the current record will
 *    	be set to the new record, and the FFI_editingNewRecord
 *    	flag will be cleared.
 *
 *     	If the displayErrorMessages flag is set, errors
 *    	are displayed in a UserStandardDialog() error box.
 *
 *	If we're in multi-record data entry mode, then if the
 *	screen needs to redrawn, we do so by moving to each record
 *	on the screen successively. In the process, the current 
 *	record will be committed. If the current record is a new
 *	record that has been dirtied, we don't want to commit
 *	this record permanently to the database yet, but we do 
 *	want to store it somewhere so it can be read back in.
 *	If this is the case, set CommitRecordType = CRT_VISUAL_UPDATE_COMMIT.
 *	If you just want to commit the record as usual, set 
 *	CommitRecordType = CRT_REGULAR_COMMIT.
 *
 */
@message InsertResult MSG_FFD_COMMIT_TEMP_DATA_ROW_TO_DATABASE
					(Boolean displayErrorMessages,
					 CommitRecordType commitRecordType);

/*
 * MSG_FFD_CURRENTLY_EDITING_A_RECORD --
 *	This message returns TRUE if either FFI_editingNewRecord or
 *	FFI_dirtyRecord is TRUE.
 */
@message Boolean MSG_FFD_CURRENTLY_EDITING_A_RECORD();

/*
 * MSG_FFD_IS_THIS_A_NEW_RECORD --
 *	This message returns TRUE if FFI_editingNewRecord is TRUE,
 *	FALSE otherwise.
 */
@message Boolean MSG_FFD_IS_THIS_A_NEW_RECORD();

/*
 * MSG_FFD_SORT_INFO_SHADOW_SAVE --
 *
 *	Save the current sort context.
 */
@message void MSG_FFD_SORT_INFO_SHADOW_SAVE ();

/*
 * MSG_FFD_SORT_INFO_SHADOW_RESTORE --
 *
 *	Restore the previously save sort context.
 */
@message void MSG_FFD_SORT_INFO_SHADOW_RESTORE ();

/*
 * MSG_FFD_SORT_INFO_SHADOW_DELETE --
 *
 *	Remove the previously save sort context.
 */
@message void MSG_FFD_SORT_INFO_SHADOW_DELETE ();

/*
 * MSG_FFD_SORT_INFO_SORT
 *
 *	Stably sort the database on the given field (indexed from the
 *	DATABASE_NAME_LIST list) in the appropriate order
 *	(ascending/descending). 
 *
 */
@message sbyte MSG_FFD_SORT_INFO_SORT ();

/*
 * MSG_FFD_SORT_INFO_GET_NUM_ITEMS
 *
 *	Get the number of entries in the sort keys/sub-total fields list.
 */
@message byte MSG_FFD_SORT_INFO_GET_NUM_ITEMS ();

/*
 * MSG_FFD_SORT_INFO_ADD_ITEM
 *
 *	Insert an item onto the end sort keys/sub-total fields list.
 */
@message byte MSG_FFD_SORT_INFO_ADD_ITEM (word item);

/*
 * MSG_FFD_SORT_INFO_DELETE_ITEM
 *
 *	Delete an item from the sort keys/sub-total fields list.
 */
@message byte MSG_FFD_SORT_INFO_DELETE_ITEM (word itemIndex);

/*
 * MSG_FFD_SORT_INFO_DELETE_ALL_ITEMS
 *
 *	Remove all entries from the sort keys/sub-total fields list.
 */
@message void MSG_FFD_SORT_INFO_DELETE_ALL_ITEMS ();

/*
 * MSG_FFD_SORT_INFO_ITEM_SEARCH --
 *
 *	Search for a reference to the given DATABASE_NAME_LIST index in the
 *	sort key information list.
 */
@message Boolean MSG_FFD_SORT_INFO_ITEM_SEARCH (byte dbIndex,
						byte *sortIndex);

/*
 * MSG_FFD_SORT_INFO_QUERY_ITEM
 *
 *	Get the DATABASE_NAME_LIST list index stored in the sort-keys/sub-total
 *	fields list at the given index.  Inform the caller of the sort
 *	direction of the field also.
 */
@message sword MSG_FFD_SORT_INFO_QUERY_ITEM (word itemIndex,
					     sbyte *sortAscending);

/*
 * MSG_FFD_SORT_INFO_LIST_MONIKER_QUERY
 *
 *	Provide the given list with the moniker for the requested item.
 */
@message void MSG_FFD_SORT_INFO_LIST_MONIKER_QUERY (optr dynList,
						    word itemIndex);

/*
 * MSG_FFD_SORT_INFO_LIST_REQUEST_NOTES
 *
 *	Supply the given text object with the notes text associated with
 *	given sort-key/sub-total fields list item.
 */
@message void MSG_FFD_SORT_INFO_LIST_REQUEST_NOTES (optr textObj,
						    word itemIndex);

/*
 * MSG_FFD_SORT_INFO_GET_SORT_DIRECTION
 *
 *	Retrieve the sort direction (ordering) of the given item in the
 *	sort-key/sub-total fields list.
 */
@message sbyte MSG_FFD_SORT_INFO_GET_SORT_DIRECTION (word itemIndex);

/*
 * MSG_FFD_SORT_INFO_SET_SORT_DIRECTION
 *
 *	Set the sort direction (ordering) of the given item in the
 *	sort-key/sub-total fields list to that provided.
 */
@message void MSG_FFD_SORT_INFO_SET_SORT_DIRECTION (word itemIndex,
						    sbyte sortAscending);

/*
 * MSG_FFD_SORT_INFO_INCREASE_PRIORITY
 *
 *	Increase the relative sort priority of the given sort
 *	key/sub-totals item (i.e. move it up in the list).
 */
@message Boolean MSG_FFD_SORT_INFO_INCREASE_PRIORITY (word itemIndex);

/*
 * MSG_FFD_SORT_INFO_DECREASE_PRIORITY
 *
 *	Decrease the relative sort priority of the given sort
 *	key/sub-totals list item (i.e. move it down in the list);
 */
@message Boolean MSG_FFD_SORT_INFO_DECREASE_PRIORITY (word itemIndex);

/*
 * MSG_FFD_SORT_INFO_SET_SORT_OPTIONS
 *
 *	Set the sorting options data.
 */
@message void MSG_FFD_SORT_INFO_SET_SORT_OPTIONS
			(FFDSortOptions sortOptions);

/*
 * MSG_FFD_SORT_INFO_GET_SORT_OPTIONS
 *
 *	Get the sorting options data.
 */
@message FFDSortOptions MSG_FFD_SORT_INFO_GET_SORT_OPTIONS ();

/*
 * MSG_FFD_SORT_INFO_NUKE_FIELD
 *
 *	Delete any item from the sort keys/sub-total fields list that
 *	references the given field/column.
 */
@message void MSG_FFD_SORT_INFO_NUKE_FIELD (byte columnNum);

/*
 * MSG_FFD_FNO_INFO_SHADOW_SAVE
 *
 *	Save the current field navigation order information.
 */
@message void MSG_FFD_FNO_INFO_SHADOW_SAVE ();

/*
 * MSG_FFD_FNO_INFO_SHADOW_RESTORE
 *
 *	Remove the currently saved field navigation order information.
 */
@message void MSG_FFD_FNO_INFO_SHADOW_RESTORE ();

/*
 * MSG_FFD_FNO_INFO_SHADOW_DELETE
 *
 *	Restore the current field navigation order information.
 */
@message void MSG_FFD_FNO_INFO_SHADOW_DELETE ();

/*
 * MSG_FFD_FNO_INFO_GET_NUM_ITEMS
 *
 *	Return the count of items in the field navigation order list.
 */
@message sword MSG_FFD_FNO_INFO_GET_NUM_ITEMS ();

/*
 * MSG_FFD_FNO_INFO_ADD_ITEM
 *
 *	Add the given item index to the end of the current database's
 *	field navigation order list.
 */
@message sword MSG_FFD_FNO_INFO_ADD_ITEM (FieldID fieldID);

/*
 * MSG_FFD_FNO_INFO_DELETE_ITEM
 *
 *	Remove the given item from the current database's field navigation
 *	order list.
 *	Note:	Use MSG_FFD_FNO_INFO_NUKE_FIELD to delete based on the
 *		fieldID. 
 */
@message sword MSG_FFD_FNO_INFO_DELETE_ITEM (word itemIndex);

/*
 * MSG_FFD_FNO_INFO_DELETE_ALL_ITEMS
 *
 *	Delete all of the entries in the field navigation order list.
 */
@message void MSG_FFD_FNO_INFO_DELETE_ALL_ITEMS ();

/*
 * MSG_FFD_FNO_INFO_QUERY_ITEM
 *
 *	Retrieve the DATABASE_NAME_LIST index value stored at the given
 *	index in the field navigation order list.
 */
@message sword MSG_FFD_FNO_INFO_QUERY_ITEM (word itemIndex);

/*
 * MSG_FFD_FNO_INFO_LIST_MONIKER_QUERY
 *
 *	Supply the given dynamic list with the moniker for the requested
 *	item from the field navigation order list.
 */
@message void MSG_FFD_FNO_INFO_LIST_MONIKER_QUERY (optr dynList,
						   word itemIndex);
/*
 * MSG_FFD_FNO_INFO_GET_FIELD
 *
 *	Retrieve the field in the database that closest to the given
 *	field (according to the search criteria mandated by the given
 *	field order movement command) that is in the current layout
 *	based *	on the currently defined field navigation order context.
 */
@message sword MSG_FFD_FNO_INFO_GET_FIELD
			(FieldID fieldID,
			 FieldOrderMovementCommand movementCmd);

/*
 * MSG_FFD_FNO_INFO_GET_NEXT_FIELD
 *
 *	Retrieve the FieldID of the field in the current layout that
 *	logically follows the given field (as specified by the user).
 *	If you want the field that follows the fieldID, set
 *	the forwardFlag to TRUE.  If you want the preceding
 *	field, set the forwardFlag to FALSE.
 */
@message sword MSG_FFD_FNO_INFO_GET_NEXT_FIELD (FieldID fieldID,
						Boolean forwardFlag);

/*
 * MSG_FFD_FNO_INFO_INCREASE_PRIORITY
 *
 *	Move the given field navigation order list item 'up' one spot in
 *	the list.
 */
@message Boolean MSG_FFD_FNO_INFO_INCREASE_PRIORITY (word itemIndex);

/*
 * MSG_FFD_FNO_INFO_DECREASE_PRIORITY
 *
 */
@message Boolean MSG_FFD_FNO_INFO_DECREASE_PRIORITY (word itemIndex);

/*
 * MSG_FFD_FNO_INFO_NUKE_FIELD
 *
 *	Delete any item from the sort keys/sub-total fields list that
 *	references the given field/column.
 */
@message void MSG_FFD_FNO_INFO_NUKE_FIELD (FieldID fieldID);

/*
 * MSG_FFD_GET_SUBSET_TOKEN_STREAM --
 *
 *	This message returns a MemHandle to the current subset token stream
 *	handle stored in FFI_VAR_SUBSET_TOKEN_STREAM.
 *
 *	It is the caller's responsibility to free the block.
 */
@message MemHandle MSG_FFD_GET_SUBSET_TOKEN_STREAM();

/*
 * MSG_FFD_SUBSET_APPLY
 *
 *	Create a marked subset in the database by applying the given
 *	tokenized expression to each record.  The expression is
 *	copied into the FFI_SUBSET_TOKEN_STREAM vardata.
 */
@message Boolean MSG_FFD_SUBSET_APPLY (MemHandle tokenStreamHandle,
				       word numTokens);

/*
 * MSG_FFD_GET_FIRST_MARKED_RECORD --
 *
 *	This message returns the first marked record in the database.
 *	If no marked records exist, it will return NOT_A_RECORD.
 */
@message word MSG_FFD_GET_FIRST_MARKED_RECORD();
 
/*
 * MSG_FFD_SUBSET_MARK_ALL --
 *
 *	Mark all records as being in the current subset.
 */
@message void MSG_FFD_SUBSET_MARK_ALL ();

/*
 * MSG_FFD_SUBSET_UNMARK_ALL --
 *
 *	Clear out all record marks.
 */
@message void MSG_FFD_SUBSET_UNMARK_ALL ();

/*
 * MSG_FFD_SUBSET_INVERT_MARKS --
 *
 *	Invert the current record marking (subset).
 */
@message void MSG_FFD_SUBSET_INVERT_MARKS ();

/*
 * MSG_FFD_SUBSET_SHOW_ALL_RECORDS --
 *
 *	Instruct the database to show only marked records or to show all of
 *	the records in the database.
 */
@message Boolean MSG_FFD_SUBSET_SHOW_ALL_RECORDS();

/*
 * MSG_FFD_SUBSET_SHOW_ONLY_MARKED_RECORDS --
 *
 *	Instruct the database to show only marked records the records in
 *	the database. 
 */
@message Boolean MSG_FFD_SUBSET_SHOW_ONLY_MARKED_RECORDS();

/*
 * MSG_FFD_SUBSET_DELETE_MARKED_RECORDS --
 *
 *	Instruct the database to delete all marked records from the
 *	database.
 */
@message void MSG_FFD_SUBSET_DELETE_MARKED_RECORDS ();

/*
 * MSG_FFD_SUBSET_AUTO_APPLY_MARK --
 *
 *	Instructs the database to apply the current record marking (subset)
 *	expression to each newly created record.
 *	If applyFlag == FALSE it will refrain from applying things.
 *	Otherwise it will.
 */
@message void MSG_FFD_SUBSET_AUTO_APPLY_MARK (Boolean applyFlag);

/*
 * MSG_FFD_SUBSET_CLEAR_MARKS_FIRST --
 *
 *	Instructs the database to clear out any and all preexisting record
 *	marks prior to applying a record marking expression.
 *	If applyFlag == FALSE it will refrain from applying things.
 *	Otherwise it will.
 */
@message void MSG_FFD_SUBSET_CLEAR_MARKS_FIRST (Boolean applyFlag);

/*
 * MSG_FFD_SUBSET_GET_OPTIONS --
 *
 *	Retrieve the current settings of the various record marking
 *	options.
 */
@message FFDSubsetOptionsInfo MSG_FFD_SUBSET_GET_OPTIONS ();

/*
 * MSG_FFD_GET_MAX_LENGTH 
 *
 * 	Returns the user-defined maximum length for the given column
 *	number. If datatype = Text/Anything, it returns the maximum
 *	length defined by the user. Else returns MAX_TEXT_FIELD_LENGTH.
 */
@message word MSG_FFD_GET_MAX_LENGTH (byte colNum);

/*
 * MSG_FFD_RECORD_CONTROL --
 *
 *	Perform the specified FFRecordControlRequest with the given data.
 */
@message Boolean MSG_FFD_RECORD_CONTROL (FFRecordControlRequest rcpRequest,
					 word data);

/*
 * MSG_FFD_GET_NUMBER_OF_PAGES --
 *	This message returns the total number of pages printable from
 *	the current layout.
 */
@message word MSG_FFD_GET_NUMBER_OF_PAGES();
 	
/*
 * MSG_FFD_GO_TO_PAGE --
 *	This message causes the current layout to display the requested page
 *	of records.  Note that this might mean different things in single
 *	and multi-record mode.
 */
@message void MSG_FFD_GO_TO_PAGE(word newPage, Boolean redraw);
 	
/*
 * MSG_FFD_IMPORT_TRANSFER_FILE --
 *
 *	Perform file import operation.
 */
@message void MSG_FFD_IMPORT_TRANSFER_FILE (ImpexTranslationParams *itParams);

/*
 * MSG_FFD_EXPORT_TRANSFER_FILE --
 *
 *	Perform file export operation.
 */
@message void MSG_FFD_EXPORT_TRANSFER_FILE (ImpexTranslationParams *itParams,
					    word begRecord, word endRecord);

/*
 * MSG_FFD_EXPORT_TO_CLIPBOARD --
 *
 *	Export file to clipboard.
 */
@message void MSG_FFD_EXPORT_TO_CLIPBOARD (word begRecord, word endRecord);

/*
 * MSG_FFD_CREATE_DATA_BLOCK_AND_SEND_NOTIFICATION --
 *
 *	Creates a data block and sends it off to the map controller.
 */
@message void MSG_FFD_CREATE_DATA_BLOCK_AND_SEND_NOTIFICATION ();

/*
 * MSG_FFD_FIELD_ORGANIZER_ENABLE_DISABLE --
 *
 *	Enable/disable the given Field Organizer based on the current
 *	layout mode type.
 */
@message void MSG_FFD_FIELD_ORGANIZER_ENABLE_DISABLE
			(optr fieldOrganizer, VisUpdateMode updateMode);

/*
 * MSG_FFD_DATA_RECALCULATE --
 *
 *	Recalculates all calculated fields
 */
@message void MSG_FFD_DATA_RECALCULATE();

/*
 * Instance data defaults
 */
	@default VI_typeFlags = ( VTF_IS_COMPOSITE | VTF_IS_INPUT_NODE );

/*
 * Information we want to store for the flatfile
 */
	@instance	VMBlockHandle	FFI_mapBlock;

/*
 * These instance data are used to remember to whom and how a token stream is
 * to be sent.
 */
 	@instance   	optr	FFI_tokenStreamDestOptr;
 	@instance   	Message	FFI_tokenStreamDestMsg = 0;

/*
 * This instance data is used to make the FlatFile object a target/focus
 * node, so that keyboard/mouse messages are sent to the GrObjBody
 * below it.
 */
	@instance	HierarchicalGrab FFI_targetExcl = {0, 0};
        @instance       HierarchicalGrab FFI_focusExcl = {0, 0};

/*
 * The expressionBuilderOptr is used to remember which expression
 * builder is being used.
 */
 	@instance   	optr	FFI_expressionBuilderOptr;

/*
 * optr to the GrObjHead; we need to store this because we'll be
 * sending a messages to it when changing modes (from Design to
 * Data Entry and vice versa)
 */
	@instance	optr	FFI_grObjHeadOptr;

/*
 * optr to the GrObj's AttributeManager 
 */
	@instance	optr	FFI_grObjAM;

/*
 * Automatic field generation number, incremented whenever a new field
 * is created.
 */
        @instance   	word	FFI_automaticFieldNumber = 1;

/*
 * Flag: has the currently loaded record been changed?
 * NOTE! FFI_editingNewRecord takes precidence over FFI_dirtyRecord.
 */
 	@instance   	byte	FFI_dirtyRecord = FALSE;

/*
 * Flag: are we editing a new record?
 */
 	@instance   	byte	FFI_editingNewRecord = FALSE;

/* bit array for columns occupied by fields in the database */
	@instance 	byte	FFI_columnsTaken[COLUMNS_TAKEN_ARRAY_SIZE] = 
						{0, 0, 0, 0, 0, 0, 0, 0,
						 0, 0, 0, 0, 0, 0, 0, 0,
						 0, 0, 0, 0, 0, 0, 0, 0,
						 0, 0, 0, 0, 0, 0, 0, 0}; 
/* bit array for layout columns occupied by fields in the database;
   the first one is marked taken because that's where the sorted list
   of layout names is stored */
	@instance	byte FFI_layoutColumnsTaken[COLUMNS_TAKEN_ARRAY_SIZE] =
						{0, 0, 0, 0, 0, 0, 0, 0,
						 0, 0, 0, 0, 0, 0, 0, 0,
						 0, 0, 0, 0, 0, 0, 0, 0,
						 0, 0, 0, 0, 0, 0, 0, 0}; 

/* The highest number of layouts ever created. A newly created layout is
   called "Layout x" (Layout 0, Layout 1, etc.) This is used to keep track
   of the highest layout number created so far, so that we can use it
   to name the next layout */

	@instance	word	FFI_highestLayoutNumber = 0;

	@instance 	ModeType FFI_currentMode = MT_DESIGN;
	@instance	byte	FFI_currentLayout = 0;
	@instance	byte	FFI_currentLayoutType = LT_SINGLE_RECORD;
	@instance	byte	FFI_numLayouts = 0;
/*
 * The number of the page we're currently displaying in multi-record
 * data entry mode
 */
	@instance	word	FFI_currentPage = 0;

/*
 * Current layout size.
 */
 	@instance   	LayoutSize FFI_pageSize = {0, 0};

	@instance	word	FFI_totalNumRecordsInDatabase = 0;
	@instance	word	FFI_numMarkedRecords = 0;
	@instance	word	FFI_numRecords = 0;
 	@instance   	word	FFI_currentMarkedRecord = 0;

	@instance	byte	FFI_currentTopRecordInMultiRecDisplay = -1;

	@instance 	byte	FFI_numFields = 0;
	@instance	FieldID	FFI_databaseNameList[MAX_NUM_FIELDS+1] =
			 { 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff };

/*
 * FFI_notInLayoutNameList is the list of database fields that are not
 * in the current layout (and FFI_numInNotInLayoutNameList is its
 * corresponding number).  The fields in this array with the fields in
 * the FFI_layoutNameList array MUST equal the total number of defined
 * fields in the database.
 */
	@instance 	byte	FFI_numInNotInLayoutNameList = 0;
	@instance	FieldID	FFI_notInLayoutNameList[MAX_NUM_FIELDS+1] =
			 { 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff };

/*
 * FFI_layoutNameList is the list of fields that are in the current
 * layout (and FFI_numInLayoutNameList is its corresponding number).
 * The fields in this array with the fields in the FFI_notInLayoutNameList
 * array MUST equal the total number of defined fields in the database.
 */
	@instance 	byte	FFI_numInLayoutNameList = 0;
	@instance	FieldID	FFI_layoutNameList[MAX_NUM_FIELDS+1] =
			 { 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff };

	@instance	VMFileHandle	documentHandle;

       /*
	* The GFDI_floatControlBlock instance datum holds the block
	* of our file that contains float controller definitions.
	*/
       @instance    	VMBlockHandle 	FFI_floatControlBlock;
       @instance    	word	    	FFI_floatControlCount = 0;


/*
 * Store the current tool for design mode, so that when we go to 
 * data entry and back, we can reset it
 */
	@instance	ClassStruct	*FFI_designModeGrObjTool;

	/* Record order: Top->Bottom & Left->Right, or Left->Right &
			 Top->Bottom */
	@instance	RecordOrderOption	FFI_recordOrder =
							ROO_TOP_TO_BOTTOM;

	/* Currently defined sort.	*/
	@instance	FFDBSortInfo	FFI_sortInfo =
		{
		-1,
		SIAF_ALL_ASCENDING,
		@FFDSO_NO_OPTIONS,
		{ -1, -1, -1, -1, -1, -1 }
		};

	/* Currently defined field navigation order.	*/
	@instance	FFDBFieldNavigationOrderInfo	FFI_fieldOrderInfo =
		{ -1,	{  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
			   0xff,0xff,0xff,0xff,0xff,0xff,0xff } };

	/*
	 * Counter used for force the delivery of GCN notifications in the
	 * presence of duplicate status data.
	 */
	@instance	word	FFI_nonce = 0;

	/*
	 * Subset information.
	 *
	 *	showOnlyMarked	== TRUE iff only displaying marked records.
	 *			   FALSE otherwise.
	 *	autoApplyMark	== TRUE iff currently defined record
	 *			   marking expression should be applied
	 *			   upon creation of any new record.
	 *			   FALSE otherwise.
	 *	clearMarksFirst	== TRUE iff any and all existing marks
	 *			   should (logically) be cleared prior to
	 *			   apply the current record marking.
	 */
	@instance	Boolean	FFI_showOnlyMarked	= FALSE;
	@instance	Boolean FFI_autoApplyMark	= FALSE;
	@instance	Boolean FFI_clearMarksFirst	= TRUE;


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Variable Data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

	/*
	 * FFI_VAR_SUBSET_TOKEN_STREAM --
	 *
	 *	This is used to hold the token stream of the currently
	 *	defined marked record (subset) expression.
	 *	Note that the stream is variably sized.  It's just defined
	 *	as a byte so that the type information will be given to the
	 *	debugger.
	 */
	@vardata	byte		FFI_VAR_SUBSET_TOKEN_STREAM;

	/*
	 * FFI_VAR_SORT_INFO_SHADOW_DATA --
	 *
	 *	This is used to hold a copy of the current sort context
	 *	while the user is defining a new sort (this facillitates
	 *	a true Cancel operation).
	 */
	@vardata	FFDBSortInfo	FFI_VAR_SORT_INFO_SHADOW_DATA;

	/*
	 * FFI_VAR_FNO_INFO_SHADOW_DATA --
	 *
	 *	This is used to hold a copy of the current field navigation
	 *	order context while the user is defining a new ordering
	 *	(this facillitates a true Cancel operation).
	 */
	@vardata	FFDBFieldNavigationOrderInfo
					FFI_VAR_FNO_INFO_SHADOW_DATA;

@endc
