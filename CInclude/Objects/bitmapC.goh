/***********************************************************************
 *
 *	Copyright (c) GeoWorks 1991 -- All Rights Reserved
 *
 * PROJECT:	PC GEOS
 * FILE:	bitmapC.goh
 * AUTHOR:	jimmy: November 1993
 *
 * DECLARER:	UI
 *
 * DESCRIPTION:
 *	This file defines classes for the bitmap library
 *
 *	$Id: bitmapC.goh,v 1.1 97/04/04 15:52:39 newdeal Exp $
 *
 ***********************************************************************/
@optimize

@deflib bitmap

#include <geos.h>
#include <graphics.h>

/***********************************************************************
	some standard C stuff for the few exported routines
************************************************************************/
extern	void _pascal	ToolGrabMouse(optr	tool);
extern	void _pascal	ToolReleaseMouse(optr tool);
extern	void _pascal	ToolSendAllPtrEvents(optr	tool);		
/*************************************************************************
	NOT SUPPORTED
 extern	void _pascal	ToolCallBitmap(	optr 	tool,
					word	message,
					void	*params,
					void	*retVal);
			params is a pointer to a structure for parameters
				to the particular message
			retVal is a pointer to a structure for the return
			values of the particular message
**************************************************************************/

extern	void _pascal	DrawBitmapToGState(GStateHandle 	gstate,
					   VMFileHandle 	vmFile,
					   VMBlockHandle 	vmBlock,
					   word			xcoord,
					   word			ycoord);

#if defined(__HIGHC__)
pragma Alias(ToolGrabMouse, "TOOLGRABMOUSE");
pragma Alias(ToolReleaseMouse, "TOOLRELEASEMOUSE");
pragma Alias(ToolSendAllPtrEvents, "TOOLSENDALLPTREVENTS");
/* pragma Alias(ToolCallBitmap, "TOOLCALLBITMAP"); NOT SUPPORTED */
pragma Alias(DrawBitmapToGState, "DRAWBITMAPTOGSTATE");
#endif

#define BITMAP_TEXT 	0

/***********************************************************************
		VisBitmapToolControlClass
***********************************************************************/
typedef struct {
	ClassStruct	*VBNCT_toolClass;
} VisBitmapNotifyCurrentTool;

typedef struct {
	BMFormat	VBNCF_format;
	word		VBNCF_xdpi;	/* pixels per inch */
	word		VBNCF_ydpi;	/* pixels per inch */
	word		VBNCF_width;	/* width of the bitmap (points) */
	word		VBNCF_height;	/* height of the bitmap (points) */
} VisBitmapNotifyCurrentFormat;


/***********************************************************************
	 GenApplication GCN lists to be placed on:
		GAGCNLT_SELF_LOAD_OPTIONS
***********************************************************************/
@class VisBitmapToolControlClass, GenControlClass;


@message	void MSG_VBTC_SET_TOOL(word identifier = cx);

@message	Boolean MSG_VBTC_GET_TOOL_CLASS(optr *retVal = dxcx,
					word identifier = cx) = carry;
	
@vardata word 	ATTR_VIS_BITMAP_TOOL_CONTROL_POSITION_FOR_ADDED_TOOLS;

typedef WordFlags VBTCFeatures;
#define VBTCF_ALL_FEATURES	0x03ff
#define VBTCF_SELECTION		0x0200
#define VBTCF_PENCIL		0x0100
#define VBTCF_ERASER		0x0080
#define VBTCF_LINE		0x0040
#define VBTCF_RECT		0x0020
#define VBTCF_DRAW_RECT		0x0010
#define VBTCF_ELLIPSE		0x0080
#define VBTCF_DRAW_ELLIPSE	0x0040
#define VBTCF_FLOOD_FILL	0x0002
#define VBTCF_FATBITS		0x0001

#define WORKING_VBTC_FEATURES	(VBTCF_ALL_FEATURE & ~VBTCF_DRAW_RECT & \
					~VBTCF_DRAW_ELLIPSE)

#define VBTC_DEFAULT_FEATURES		WORKING_VBTC_FEATURES
#define VBTC_DEFAULT_TOOLBOX_FEATURES	WORKING_VBTC_FEATURES

@endc /* VisBitmapToolControlClass */

/***********************************************************************
		VisBitmapFormatControlClass
***********************************************************************/
@class VisBitmapFormatControlClass, GenControlClass;
@message 	void MSG_VBFC_SET_FORMAT();
@message	void MSG_VBFC_ESTIMATE_BITMAP_SIZE();

typedef ByteFlags VBFCFeatures;
#define VBFCF_ALL_FEATURES	0x1f
#define VBFCF_MONO		0x10
#define VBFCF_4BIT		0x08
#define VBFCF_72_DPI		0x04
#define VBFCF_300_DPI		0x02
#define VBFCF_CUSTOM_DPI	0x01

#define VBFC_DEFAULT_FEATURES   	VBFCF_ALL_FEATURES
#define VBFC_DEFAULT_TOOLBOX_FEATURES	VBFCF_ALL_FEATURES
@endc	/* VisBitmapFormatControlClass */

typedef struct {
	word		VBEBP_token;
	word		VBEBP_ax;
	word		VBEBP_bx;
	word		VBEBP_cx;
	word		VBEBP_dx;
	Rectangle	VBEBP_invalRect;
	word		VBEBP_maskColor;
	void		*VBEBP_routine;
	void		*VBEBP_maskRoutine;
} VisBitmapEditBitmapParams;

typedef struct {
	VMFileHandle	VBSTGSP_vmFile;
	word		VBSTGSP_vmBlock;
	Point		VBSTGSP_location;
} VisBitmapSetTransferGStringParams;




/***********************************************************************
		VisBitmapToolItemClass
***********************************************************************/
@class	VisBitmapToolItemClass, GenItemClass;
@message optr MSG_VBTI_GET_TOOL_CLASS() = cx.dx;
@message void MSG_VBTI_SELECT_SELF_IF_MATCH(optr toolClass = cx:dx);

	@instance	ClassStruct *VBTII_toolClass;

@endc /* VisBitmapToolItemClass */

/***********************************************************************
		VisBitmap Class
***********************************************************************/
@class VisBitmapClass, VisClass;

/***********************************************************************
				METHODS
***********************************************************************/

/***********************************************************************
		MSG_VIS_BITMAP_SET_VM_FILE

 Set the default file handle with which the bitmap object is associated.

	If the VisBitmap's object block is within a VM file, then that
	file is used (and sending this message won't affect anything).

Pass:	a VMFileHandle
***********************************************************************/
@message void MSG_VIS_BITMAP_SET_VM_FILE(VMFileHandle vmFile = cx);


/***********************************************************************
	MSG_VIS_BITMAP_GET_VM_FILE 

 Return the file handle where the bitmap stores its bitmap data
***********************************************************************/
@message VMFileHandle MSG_VIS_BITMAP_GET_VM_FILE() = ax;

/***********************************************************************
	MSG_VIS_BITMAP_CREATE_BITMAP

	Allocates a bitmap and initizes it. Also allocates a
	backup bitmap if VBUF_USES_BACKUP_BITMAP is set in the VisBitmap's
	instance data.

PASS:		 width. height of bitmap in pixels to be allocated
		 gstring to initialize bitmap with (0 for none)

RETURN:	nothing
***********************************************************************/
@message void MSG_VIS_BITMAP_CREATE_BITMAP(word		witdh = cx,
				      	   word		height = dx,
				      	   Handle	gstring = bp);

/***********************************************************************
XXX	MSG_VIS_BITMAP_CREATE_TOOL

	Creates a tool of the passed class.

	PASS:	segment and offset class pointer of desired tool type

	RETURN:	^lcx:dx = new tool
************************************************************************/
@message optr MSG_VIS_BITMAP_CREATE_TOOL(optr toolClass = cx:dx) = cx:dx;


/************************************************************************
XXX	MSG_VIS_BITMAP_CREATE_BACKUP_BITMAP

	Creates a backup bitmap if needed. No need to send this message
	if you sent a MSG_VIS_BITMAP_CREATE_BITMAP already

PASS:		nothing

RETURN:	nothing
************************************************************************/
@message void MSG_VIS_BITMAP_CREATE_BACKUP_BITMAP();

/************************************************************************
	  not yet implemented
************************************************************************/
typedef ByteFlags VisBitmapBecomeDormatFlags;
#define	VBBDF_KILL_MAIN_GSTATE		0x40
#define	VBBDF_KILL_SCREEN_GSTATE	0x20
#define	VBBDF_KILL_BACKUP_GSTATE 	0x10
#define	VBBDF_KILL_BACKUP_THREAD	0x08
#define	VBBDF_KILL_BACKUP_BITMAP	0x04
#define	VBBDF_KILL_TOOL 		0x02
#define	VBBDF_KILL_TRANSFER_GSTRING 	0x01

/************************************************************************
XXX	MSG_VIS_BITMAP_BECOME_DORMANT

	Destroys any possible data structures related to editing
	the VisBitmap, presumably to free up memory when it is expected
	that it won't be used.

	The VisBitmap is written in an "allocate as necessary" style,
	meaning that gstates and backup bitmaps, etc., are generated on
	an as needed basis. Ergo, this message has no opposite.

PASS:		nothing

RETURN:		nothing
************************************************************************/
@message void MSG_VIS_BITMAP_BECOME_DORMANT();

/************************************************************************
XXX	MSG_VIS_BITMAP_RESIZE_REAL_ESTATE

	Resizes the bitmap's dimensions and draws itself through a gstate
	into the newly resized bitmap

	PASS:		ss:bp = RectAndGState:

			RAG_gstate = gstate to transform original bitmap
					through before drawing to newly resized
					bitmap

			RAG_rect = new bitmap coordinates (in old
					bitmap coordinates)

	RETURN:		nothing
************************************************************************/
typedef	struct {
	DWFixed		RDWF_left;
	DWFixed		RDWF_top;
	DWFixed		RDWF_right;
	DWFixed		RDWF_bottom;
} RectDWFixed;

typedef	struct {
	Rectangle	RAG_rect;
	GStateHandle	RAG_gstate;
} RectAndGState;
@message void MSG_VIS_BITMAP_RESIZE_REAL_ESTATE(RectAndGState rag = ss:bp);


typedef struct {
	word	BS_height;
	word	BS_width;
} BitmapSize;
/************************************************************************
XXX	MSG_VIS_BITMAP_GET_BITMAP_SIZE_IN_PIXELS

	Return the size of the bitmap in pixels

	PASS:		nothing

	RETURN:		cx,dx = width,height of bitmap in points
************************************************************************/
@message void MSG_VIS_BITMAP_GET_BITMAP_SIZE_IN_PIXELS(
						BitmapSize *retVal = dxcx);


/************************************************************************
XXX	MSG_VIS_BITMAP_GET_BITMAP_SIZE_IN_POINTS

	Return the size of the bitmap in points

	PASS:		nothing

	RETURN:		width,height of bitmap in points
************************************************************************/
@message void MSG_VIS_BITMAP_GET_BITMAP_SIZE_IN_POINTS(
						BitmapSize *retVal = dxcx);


/************************************************************************
XXX	MSG_VIS_BITMAP_MOVE_INSIDE_VIS_BOUNDS
;
;	Move the bitmap around inside its vis bounds. If any area in
;	the bitmaps coordinates outside the bitmap is exposed, the
;	bitmap is expanded.
;
;	PASS:		cx,dx = x,y to move bitmap relative to vis bounds
;
;	RETURN:		nothing
;
************************************************************************/
@message void MSG_VIS_BITMAP_MOVE_INSIDE_VIS_BOUNDS(	word xpos = cx,
							word ypos = dx);

/************************************************************************
XXX	MSG_VIS_BITMAP_CONTORT

	(For lack of a better name) this method takes an arbitrary
	gstate and translates the bitmap through it. It resizes
	itself to accomodate any size changes that may occur as
	a result.

	PASS:		bp = gstate to contort through

	RETURN:		nothing

************************************************************************/
@message void MSG_VIS_BITMAP_CONTORT(GStateHandle gstate = bp);


/************************************************************************
XXX	MSG_VIS_BITMAP_VIS_BOUNDS_MATCH_BITMAP_BOUNDS

	Sets the VisBitmap's vis bounds to match its bitmap bounds

	PASS:		nothing

	RETURN:		nothing

************************************************************************/
@message void MSG_VIS_BITMAP_VIS_BOUNDS_MATCH_BITMAP_BOUNDS();


/************************************************************************
XXX	MSG_VIS_BITMAP_BITMAP_BOUNDS_MATCH_VIS_BOUNDS

	Sets the VisBitmap's bitmap bounds to match its vis bounds

	PASS:		nothing

	RETURN:		nothing

************************************************************************/
@message void MSG_VIS_BITMAP_BITMAP_BOUNDS_MATCH_VIS_BOUNDS();


/************************************************************************
XXX	MSG_VIS_BITMAP_BACKUP_GSTRING_TO_BITMAP

	Writes the last edit (stored in a temporary gstring) into a bitmap

PASS:
	gstate of gstring to draw
	gstate to draw to
	mem handle to free after drawing (0 for none)

RETURN:
	nothing
	
************************************************************************/
@message void MSG_VIS_BITMAP_BACKUP_GSTRING_TO_BITMAP(	
						GStateHandle 	source = cx,
						GStateHandle 	dest = bp,
						MemHandle 	mem = dx);


/************************************************************************
XXX	MSG_VIS_BITMAP_DRAW_BITMAP_TO_GSTATE

	Draw the main bitmap to the passed gstate

PASS:		bp = gstate
		cx,dx - coordinates to draw the bitmap at

RETURN:	nothing

************************************************************************/
@message void MSG_VIS_BITMAP_DRAW_BITMAP_TO_GSTATE(	
						GStateHandle 	gstate = bp,
						word		xcoord = cx,
						word		ycoord = dx);
							


/************************************************************************
XXX	MSG_VIS_BITMAP_CREATE_SCRATCH_GSTRING

	Creates a gstring for tools to write temporary changes to.

PASS:		nothing

RETURN:		bp = gstring
		dx = mem handle allocated fromm gstring

************************************************************************/
typedef struct {
	Handle		SGS_gstring;
	MemHandle	SGS_memhandle;
} ScratchGString;
@message ScratchGString MSG_VIS_BITMAP_CREATE_SCRATCH_GSTRING() = bp:dx;


@if BITMAP_TEXT


/************************************************************************
XXX	MSG_VIS_BITMAP_PREPARE_VTFB

	Prepares the VisTextForBitmaps for editing

PASS:		x and y coordinates for desired location of VTFB

RETURN:	nothing

************************************************************************/
@message void MSG_VIS_BITMAP_PREPARE_VTFB(	word	xpos = cx,
						word	xpos = dx);


/************************************************************************
XXX	MSG_VIS_BITMAP_GET_VTFB_OD

	Returns the OD of the VisBitmap's VisTextForBitmaps. If none exists,
	one is instantiated, and its OD is returned.

PASS:		nothing

RETURN:	optr to VTFB
************************************************************************/
@message optr MSG_VIS_BITMAP_GET_VTFB_OD() = cx:dx;

@endif


/************************************************************************
XXX	MSG_VIS_BITMAP_GET_SCREEN_GSTATE

	Returns a gstate for drawing to the screen

	PASS:		nothing

	RETURN:		screen gstate

************************************************************************/
@message GStateHandle MSG_VIS_BITMAP_GET_SCREEN_GSTATE() = bp;


typedef	ByteEnum VisBitmapMouseManagerRequestTypes;
#define VBMMRT_GRAB_MOUSE 		0
#define VBMMRT_SEND_ALL_PTR_EVENTS 	1
#define VBMMRT_RELEASE_MOUSE 		2

/************************************************************************
XXX	MSG_VIS_BITMAP_MOUSE_MANAGER

	Handles mouse related requests from the tools

	PASS:		bp = VisBitmapMouseManagerRequestTypes

	RETURN:		nothing

************************************************************************/
@message void MSG_VIS_BITMAP_MOUSE_MANAGER(
				VisBitmapMouseManagerRequestTypes types = bp);



typedef struct {
	optr	VBGEGSP_requestor;
	word	VBGEGSP_finishMsg;
	optr	VBGEGSP_undoTitle;
} VisBitmapGetEditingGStatesParams;

/************************************************************************
XXX	MSG_VIS_BITMAP_GET_EDITING_GSTATES

	Inform the bitmap that an edit is about to begin.

	PASS:		ss:[bp] - VisBitmapGetEditingGStatesParams

	RETURN:		cx - edit ID to be passed to VisBitmapEditBitmap
			bp - screen gstate

************************************************************************/
typedef struct {
	word		EGS_unused_ax;
	word		EGS_editID;
	word		EGS_unused_dx;
	GStateHandle	EGS_gstate;
} EditingGStates;

@message void MSG_VIS_BITMAP_GET_EDITING_GSTATES(
			EditingGStates	*retVal = axcxdxbp,
			VisBitmapGetEditingGStatesParams params = ss:bp);
				


/************************************************************************
XXX	MSG_VIS_BITMAP_NOTIFY_CURRENT_EDIT_FINISHED

	Informs the bitmap that the tool is done editing.

	PASS:		cx - edit ID returned by MSG_VIS_BITMAP_GET_EDITING_GSTATES

	RETURN:		nothing

************************************************************************/
@message void MSG_VIS_BITMAP_NOTIFY_CURRENT_EDIT_FINISHED(word editID = cx);


/************************************************************************
XXX	MSG_VIS_BITMAP_FORCE_CURRENT_EDIT_TO_FINISH

	Force the current tool to end any editing.

PASS:		nothing
RETURN:	nothing
************************************************************************/
@message void 	MSG_VIS_BITMAP_FORCE_CURRENT_EDIT_TO_FINISH();


@if BITMAP_TEXT

/************************************************************************
XXX	MSG_VIS_BITMAP_CHECK_TEXT_HEIGHT

	Determines whether or not the text object would grow out of the
	bitmap's bounds if it were resized to the passed height; if so,
	the maximum height for which the text object will not run out
	of bounds is returned.

	PASS:		cx = top of text object IN DOCUMENT COORDINATES
		dx = proposed height of text object

	RETURN:		dx= height text object should use in resizing
************************************************************************/
@message word MSG_VIS_BITMAP_CHECK_TEXT_HEIGHT( word docTop = cx,
						word height = dx) = dx;


/************************************************************************
XXX	MSG_VIS_BITMAP_CREATE_VTFB

	Creates a VisTextForBitmaps object for the VisBitmap to use.

	PASS:		nothing

	RETURN:		^lcx:dx = newly created VisTextForBitmaps object
************************************************************************/
@message optr 	MSG_VIS_BITMAP_CREATE_VTFB() = cx:dx;

@endif

/************************************************************************
XXX	MSG_VIS_BITMAP_WRITE_CHANGES

	Takes any edits that are stored in the temporary workspace and
	writes them into the bitmap (so that they can no longer be undone).

	PASS:		nothing

	RETURN:		nothing
************************************************************************/
@message void MSG_VIS_BITMAP_WRITE_CHANGES();


/************************************************************************
XXX	MSG_VIS_BITMAP_UNDO

	Undoes the last user edit so that it will not be written into the
	main (permanent) bitmap.  Calling this method a second time will
	reinstate the user edits (undo the undo).


	PASS:		nothing

	RETURN:		nothing
************************************************************************/
@message void 	MSG_VIS_BITMAP_UNDO();


/************************************************************************
XXX	MSG_VIS_BITMAP_GET_MAIN_GSTATE

	Returns the gstate handle to the object's main bitmap

	PASS:		nothing

	RETURN:		bp = gstate
************************************************************************/
@message GtateStateHandle MSG_VIS_BITMAP_GET_MAIN_GSTATE() = bp;

typedef struct {
	VMBlockHandle	VMB_vmBlock;
	VMFileHandle	VMB_vmFile;
} VMBitmap;

/************************************************************************
XXX	MSG_VIS_BITMAP_GET_MAIN_BITMAP

	Returns the bitmap handle to the object's main bitmap

	PASS:		nothing

	RETURN:		cx = vm file handle
			dx = vm block handle
************************************************************************/
@message void MSG_VIS_BITMAP_GET_MAIN_BITMAP(VMBitmap *retVal = dxcx);


/************************************************************************
XXX	MSG_VIS_BITMAP_GET_BACKUP_GSTATE

	Returns the gstate handle to the object's backup bitmap

	PASS:		nothing

	RETURN:		bp = gstate (0 for no backup bitmap)
************************************************************************/
@message GStateHandle MSG_VIS_BITMAP_GET_BACKUP_GSTATE() = bp;


/************************************************************************
XXX	MSG_VIS_BITMAP_GET_BACKUP_BITMAP

	Returns the bitmap handle to the object's backup bitmap

	PASS:		nothing

	RETURN:		cx = vm file handle 
			dx = vm block handle (0 for no backup bitmap)
************************************************************************/
@message void MSG_VIS_BITMAP_GET_BACKUP_BITMAP(VMBitmap  *retVal = dxcx);


/************************************************************************
XXX	MSG_VIS_BITMAP_CLIP_GSTATE_TO_VIS_BOUNDS

	Set the clip rect of the passed gstate to the vis bounds
	of the bitmap.

	PASS		bp - gstate

	RETURN		bp - gstate with clip rect set
************************************************************************/
@message GStateHandle MSG_VIS_BITMAP_CLIP_GSTATE_TO_VIS_BOUNDS(
						GStateHandle gstate = bp) = bp;


/************************************************************************
XXX	MSG_VIS_BITMAP_COPY_SELECTION

	Returns a gstring representing the selected area

	PASS:		cx - vm file handle
			dx - vm block handle

	RETURN:		nothing
************************************************************************/
@message void MSG_VIS_BITMAP_COPY_SELECTION(	VMFileHandle vmFile = cx,
						VMBlockHandle vBlock = dx);

/************************************************************************
XXX	MSG_VIS_BITMAP_SPAWN_SELECTION_ANTS

	Starts a continual timer which instucts the bitmap to hilight the
	selected region.

	PASS:		nothing

	RETURN:		nothing

************************************************************************/
@message void MSG_VIS_BITMAP_SPAWN_SELECTION_ANTS();

/************************************************************************
XXX	MSG_VIS_BITMAP_KILL_SELECTION_ANTS

	Kills the timer which instucts the bitmap to hilight the
	selected region.

	PASS:		nothing

	RETURN:		nothing

************************************************************************/
@message void MSG_VIS_BITMAP_KILL_SELECTION_ANTS();

/************************************************************************
XXX	MSG_VIS_BITMAP_DRAW_SELECTION_ANTS

	Stroke the selection path with the current ant mask

	PASS:		nothing

	RETURN:		nothing
************************************************************************/
@message void MSG_VIS_BITMAP_DRAW_SELECTION_ANTS();

/************************************************************************
XXX	MSG_VIS_BITMAP_MAKE_SURE_NO_SELECTION_ANTS

	Ensure that there are no selection ants currently on screen.
	This method doesn't kill the timer (MSG_VIS_BITMAP_KILL_SELECTION_ANTS
	does), only erases the current ants momentarily.

	PASS:		nothing
	
	RETURN:		nothing
************************************************************************/
@message void MSG_VIS_BITMAP_MAKE_SURE_NO_SELECTION_ANTS();

/************************************************************************
XXX	MSG_VIS_BITMAP_ADVANCE_SELECTION_ANTS

	Change the selection ant mask to give the illusion of marching ants.

	PASS:		nothing

	RETURN:		nothing
************************************************************************/
@message void MSG_VIS_BITMAP_ADVANCE_SELECTION_ANTS();



/************************************************************************
	MSG_VIS_BITMAP_SET_AREA_COLOR

	Sets the area color for the object

	PASS:		redAndRgbFlag is a color bitwise or'd with either
			CF_INDEX or (CF_RGB << 8)

			green and blue are just colors

	RETURN:		ch = CF_RGB
			cl, dh, dl = red, blue, green

			(i.e., if you passed the color as an index, it
			is converted to RGB)
************************************************************************/
typedef struct {
	byte	CQR_green;
	byte	CQR_blue;
	byte	CQR_red;
	byte	CQR_rgb;
} ColorQuadR;

@message void	MSG_VIS_BITMAP_SET_AREA_COLOR( 	ColorQuadR *retVal = dxcx,
						word	redAndRgbFlag = cx,
						byte	green = dl,
						byte	blue = dh);


/************************************************************************
XXX	MSG_VIS_BITMAP_SET_LINE_COLOR

	Sets the line color for the object

	PASS:		redAndRgbFlag is a color bitwise or'd with either
			CF_INDEX or CF_RGB

			green and blue are just colors


	RETURN:		ch = CF_RGB
			cl, dh, dl = red, blue, green

			(i.e., if you passed the color as an index, it
			is converted to RGB)
************************************************************************/
@message void	MSG_VIS_BITMAP_SET_LINE_COLOR( 	ColorQuadR *retVal = dxcx,
						word	redAndRgbFlag = cx,
						byte	green = dl,
						byte	blue = dh);

/************************************************************************
XXX	MSG_VIS_BITMAP_SET_BACK_COLOR

	Sets the background color for the object

	PASS:		redAndRgbFlag is a color bitwise or'd with either
			CF_INDEX or CF_RGB

			green and blue are just colors



	RETURN:		ch = CF_RGB
			cl, dh, dl = red, blue, green

			(i.e., if you passed the color as an index, it
			is converted to RGB)
************************************************************************/
@message void	MSG_VIS_BITMAP_SET_BACK_COLOR( 	ColorQuadR *retVal = dxcx,
						word	redAndRgbFlag = cx,
						byte	green = dl,
						byte	blue = dh);

/************************************************************************
XXX	MSG_VIS_BITMAP_SET_LINE_WIDTH

	Sets the line width for the object

	PASS:		cx = line width

	RETURN:		nothing
************************************************************************/
@message void MSG_VIS_BITMAP_SET_LINE_WIDTH(word lineWidth = cx);


@if BITMAP_TEXT

/************************************************************************
XXX	MSG_VIS_BITMAP_SET_TEXT_COLOR

	Sets the text color in the bitmap's text object

	PASS:		redAndRgbFlag is a color bitwise or'd with either
			CF_INDEX or CF_RGB

			green and blue are just colors


	RETURN:		nothing
************************************************************************/
@message void	MSG_VIS_BITMAP_SET_TEXT_COLOR( 	ColorQuadR *retVal = dxcx,
						word	redAndRgbFlag = cx,
						byte	green = dl,
						byte	blue = dh);

@endif

/************************************************************************
XXX	MSG_VIS_BITMAP_SET_GSTATE_STUFF

	Sets the area color for the object

	PASS:		ss:bp = pointer to VisBitMapGraphicsStateStuff record

	RETURN:		nothing
************************************************************************/
@message void MSG_VIS_BITMAP_SET_GSTATE_STUFF(
				VisBitmapGraphicsStateStuff *stuff = ss:bp);


/************************************************************************
XXX	MSG_VIS_BITMAP_APPLY_GSTATE_STUFF

	Applies the data in the object's BitmapGStateStuff instance data
	to the passed gstate.

	PASS:		bp = gstate

	RETURN:		nothing
************************************************************************/
@message void MSG_VIS_BITMAP_APPLY_GSTATE_STUFF(GSstate gstate = bp);


/************************************************************************
XXX	MSG_VIS_BITMAP_CREATE_GSTRING_TRANSFER_FORMAT

	Generates a gstring representing the current selection

	PASS:		bp - vm file handle
			cx,dx - origin or gstring

	RETURN:		carry set if successful
				ax - vm block handle of transfer item
				cx,dx - wdith, height of transfer
************************************************************************/
typedef struct {
	VMBlockHandle	GSTFS_vmBlock;
	word		GSTFS_unused;
	word		GSTFS_width;
	word		GSTFS_height;
} GStringTransferFormatStruct;

@message Boolean MSG_VIS_BITMAP_CREATE_GSTRING_TRANSFER_FORMAT(
				GStringTransferFormatStruct *retVal = axbpcxdx,
				VMFileHandle	vmFile = bp,
				word		xCoord = cx,
				word		yCoord = dx) = carry;


/************************************************************************
XXX	MSG_VIS_BITMAP_SET_TRANSFER_GSTRING

	Sets the passed gstring to be the VisBitmap's "transfer gstring",
	(the gstring that floats on top of the bitmap during pasting
	operations).

	PASS:		ss:[bp] - VisBitmapSetTransferGStringParams

	RETURN:		nothing

************************************************************************/
@message void MSG_VIS_BITMAP_SET_TRANSFER_GSTRING(
			VisBitmapSetTransferGStringParams params = ss:bp);


/************************************************************************
XXX	MSG_VIS_BITMAP_NOTIFY_CURRENT_TOOL_CHANGE

	Sends a tool-related notification.

	PASS:		nothing

	RETURN:		nothing

************************************************************************/
@message void MSG_VIS_BITMAP_NOTIFY_CURRENT_TOOL_CHANGE();


/************************************************************************
XXX	MSG_VIS_BITMAP_NOTIFY_CURRENT_FORMAT_CHANGE

	Sends a format-related notification.

	PASS:		nothing

	RETURN:		nothing
************************************************************************/
@message void MSG_VIS_BITMAP_NOTIFY_CURRENT_FORMAT_CHANGE();


/************************************************************************
XXX	MSG_VIS_BITMAP_NOTIFY_SELECT_STATE_CHANGE

	Sends a select state-related notification.

	PASS:		nothing

	RETURN:		nothing

************************************************************************/
@message void MSG_VIS_BITMAP_NOTIFY_SELECT_STATE_CHANGE();


/************************************************************************
XXX	MSG_VIS_BITMAP_CREATE_TRANSFER_FORMAT
 
 Save the VisBitmap's bitmap in the passed VM file so that it can be
 later extracted by MSG_VIS_BITMAP_REPLACE_WITH_TRANSFER_FORMAT.

 Context:	Probably sent to a vis bitmap object some kind of managing
		object (ie, a grobj BitmapGuardian)
 Source:	Some kind of "paste" operation 
 Destination:  VisBitmap
 Interception: Unlikely


 Pass:		cx - VM file handle in which to create transfer data
			
 Return:	ax - vm block

 Destroyed:	nothing 
************************************************************************/
@message VMBlockHandle MSG_VIS_BITMAP_CREATE_TRANSFER_FORMAT(
					VMFileHandle vmFile = cx) = ax;


/************************************************************************
XXX	MSG_VIS_BITMAP_REPLACE_WITH_TRANSFER_FORMAT
 
 Replace the VisBitmap's bitmap with the one passed in the VM chain

 Context:	Probably sent to a vis bitmap object some kind of managing
		object (ie, a grobj BitmapGuardian)
 Source:	Some kind of "paste" operation 
 Destination:  VisBitmap
 Interception: Unlikely

 Pass:		cx - vm file handle of transfer file
		dx - vm block handle (same as that returned by 
 			MSG_VIS_BITMAP_CREATE_TRANSFER_FORMAT)
			
 Return:	nothing

 Destroyed:	ax
************************************************************************/
@message void MSG_VIS_BITMAP_REPLACE_WITH_TRANSFER_FORMAT(
					VMFileHandle vmFile = cx,
					VMBlockHandle vmBlock = dx);


/************************************************************************
XXX	MSG_VIS_BITMAP_SET_FORMAT_AND_RESOLUTION
 
 Set the bitmap's BMFormat and resolution, converting the existing
 bitmap if necessary.

 Context:	User requests change
 Source:	UI (perhaps a VisBitmapFormatControl?)
 Destination:  VisBitmap
 Interception: Unlikely


 Pass:		cl - BMFormat
		dx - x dpi
		bp - y dpi
			
 Return:	nothing

 Destroyed:	ax
************************************************************************/
@message void MSG_VIS_BITMAP_SET_FORMAT_AND_RESOLUTION( BMFormat format = cl,
							word	xdpi = dx,
							word	ydpi = bp);

/************************************************************************
XXX	MSG_VIS_BITMAP_EDIT_BITMAP
 
 Call a graphics routine on all of the VisBitmap's relevant gstates
 (screen, bitmap, backup bitmap, etc.)

 Context:	Some object (likely a tool) wants to edit the bitmap.
 Source:	VisBitmap having received a
		MSG_VIS_BITMAP_REQUEST_EDITING_GSTATES to ensure that all
		relevant gstates have been allocated.
 Destination:  VisBitmap
 Interception: Subclass could intercept if additional gstates need updating
		during editing.

 Pass:		ss:[bp] - VisBitmapEditBitmapParams

		ss:[bp].VBEBP_routine protocol should look like:

			PASS:	di - gstate
				ax,bx,cx,dx - as passed with
					      MSG_VIS_BITMAP_EDIT_BITMAP in
					      VisBitmapEditBitmapParams

			RETURN:	nothing

 Return:	nothing

 Destroyed:	ax
************************************************************************/
@message void MSG_VIS_BITMAP_EDIT_BITMAP(
				VisBitmapEditBitmapParams params = ss:bp);


/************************************************************************
XXX	MSG_VIS_BITMAP_DISPLAY_INTERACTIVE_FEEDBACK
 
 Call a graphics routine on all of the VisBitmap's relevant gstates
 to refect an edit-in-progress.

 Context:	Some object (likely a tool) is editing the bitmap and
		wants to inform the user about the current state of the
		edit
 Source:	Unrestricted (likely a drag-type tool)
 Destination:  VisBitmap

 Interception: Subclass could intercept if additional gstates need updating
		during editing.
 Pass:		ss:[bp] - VisBitmapEditBitmapParams

		ss:[bp].VBEBP_routine protocol should look like:

			PASS:	di - gstate
				ax,bx,cx,dx - as passed with
					      MSG_VIS_BITMAP_EDIT_BITMAP in
					      VisBitmapEditBitmapParams

			RETURN:	nothing

 Return:	nothing

 Destroyed:	ax
************************************************************************/
@message void MSG_VIS_BITMAP_DISPLAY_INTERACTIVE_FEEDBACK(
				VisBitmapEditBitmapParams params = ss:bp);


/************************************************************************
XXX	MSG_VIS_BITMAP_INITIATE_FATBITS
 
 Initiates a window containing fatbits for the main bitmap.

 Context:	User wants to edit fatbits
 Source:	Unrestricted (likely a fatbits tool)
 Destination:  VisBitmap
 Interception: Unlikely

 Pass:		cx,dx - bitmap location about which to center fatbits
		bp - 	ImageBitSize

 Return:	nothing

 Destroyed:	ax
************************************************************************/
@message void MSG_VIS_BITMAP_INITIATE_FATBITS( 	word xpos = cx,
						word ypos = dx,
						ImageBitSize bitsize = bp);


/************************************************************************
XXX	MSG_VIS_BITMAP_SET_VIS_BOUNDS	

 	Sets the vis bounds of the object.  It is sent from the VisBitmapClass
 object to itself when it senses that its Vis bounds should change.
 App writers may want to subclass the VisBitmap to examine the passed
 rectangle, modify it, and set the bounds itself

 Pass:	ss:[bp] - A Rectangle structure containing (desired)
		new Vis Bounds
 Return: nothing
 Destroyed: nothing
************************************************************************/
@message void MSG_VIS_BITMAP_SET_VIS_BOUNDS(Rectangle rect = ss:bp);

		
/************************************************************************
XXX	MSG_VIS_BITMAP_INVALIDATE_IF_TRANSPARENT

	Visually invalidates the bitmap if its VBUF_TRANSPARENT bit is
	set.

	PASS:		nothing

	RETURN:		nothing

************************************************************************/
@message void MSG_VIS_BITMAP_INVALIDATE_IF_TRANSPARENT();

/************************************************************************
XXX	MSG_VIS_BITMAP_GET_TRANSFER_BITMAP

	Returns the VM block handle and position of the bitmap's
	transfer gstring, if any. The VM block is within the VM file
	accessible by MSG_VIS_BITMAP_GET_VM_FILE

	PASS:		nothing

	RETURN:		bp - VM block handle (0 for none)
			cx,dx - position of transfer bitmap in bitmap coords

************************************************************************/
typedef struct {
	word		TBS_unused;
	VMBlockHandle	TBS_vmBlock;
	word		TBS_xCoord;
	word		TBS_yCoord;
} TransferBitmapStruct;

@message void MSG_VIS_BITMAP_GET_TRANSFER_BITMAP(
				TransferBitmapStruct *retVal = axbpcxdx);

/************************************************************************
XXXMSG_VIS_BITMAP_DRAW_BACKUP_BITMAP_TO_GSTATE	message
;
;	For jon's use only
;
************************************************************************/

/************************************************************************
XXX	MSG_VIS_BITMAP_SET_FATBITS_MODE	

  Notifies the VisBitmap to turn on or turn off fatbits mode. This is
  normal sent by the fatbits object itself, to turn on fatbits on a
  start select, and to turn it off on an end select.

	PASS:		cx - nonzero for fatbits mode

	RETURN:		nothing
************************************************************************/
@message void MSG_VIS_BITMAP_SET_FATBITS_MODE(word fatbitsFlag = cx);

/************************************************************************
XXX	MSG_VIS_BITMAP_DESTROY_SCREEN_GSTATE


	PASS:		nothing

	RETURN:		nothing
************************************************************************/
@message void MSG_VIS_BITMAP_DESTROY_SCREEN_GSTATE();

/************************************************************************
XXX	MSG_VIS_BITMAP_GET_INTERACTIVE_DISPLAY_GSTATE

	Returns the gstate the bitmap should use to display interactive
	feedback in the bitmap (this will either be the main bitmap, or
	the copy stored in vardata

	PASS:		nothing

	RETURN:		^hbp - GStateHandle to draw to

************************************************************************/
@message GStateHandle MSG_VIS_BITMAP_GET_INTERACTIVE_DISPLAY_GSTATE() = bp;

/************************************************************************
XXX	MSG_VIS_BITMAP_GET_INTERACTIVE_DISPLAY_BITMAP

	Returns the bitmap that the fatbits window should use when drawing.

	PASS:		nothing

	RETURN:		cx - vm file handle
			dx - vm block handle to bitmap

************************************************************************/
@message void MSG_VIS_BITMAP_GET_INTERACTIVE_DISPLAY_BITMAP(
						VMBitmap *retVal = dxcx);

/************************************************************************
XXX
				INSTANCE DATA

************************************************************************/
typedef ByteFlags VisBitmapUndoFlags;
#define	VBUF_HAD_SELECTION_BEFORE_LAST_ACTION	0x40
#define	VBUF_MOUSE_EVENTS_IN_BITMAP_COORDS	0x20
#define	VBUF_ANTS_DRAWN				0x10
#define	VBUF_TRANSPARENT 			0x08
#define	VBUF_LAST_EDIT_UNDONE 			0x04
#define	VBUF_USES_BACKUP_BITMAP 		0x02
#define	VBUF_UNDOABLE 				0x01


typedef struct {
	word		VBK_bitmap;
	GStateHandle	VBK_gstate;
} VisBitmapKit;

	@instance VisBitmapUndoFlags	VBI_undoFlags;
	@instance VMFileHandle		VBI_vmFile;
	@instance VisBitmapKit		VBI_mainKit;
/*	noreloc VBI_mainKit */
	@instance VisBitmapKit		VBI_backupKit;
/*	noreloc VBI_backupKit */

typedef struct {
	GStateHandle	VBEK_screen;
	GStateHandle	VBEK_bitmap;
	GStateHandle 	VBEK_gstring;
	LMemBlockHeader	VBEK_memBlock;
} VisBitmapEditingKit;

	@instance VisBitmapEditingKit	VBI_editingKit;
/*	noreloc VBI_editingKit */

/***********************************************************************
	VBI_gStateStuff contains some graphics state information
	that should be used whenever writing to the main bitmap
	


	BitMapGraphicsStateStuff contains some preferred GStateHandle settings
	for the bitmap. The colors are stored in the following format:

		high byte of high word - flag:
			enum of type ColorFlag:
				CF_INDEX (0)
					low byte of high word = index
					low word = garbage
				CF_RGB (1)
					low byte of high word = red
					high byte of low word = blue
					low byte of low word = green

***********************************************************************/
typedef struct {
	dword VBGSS_areaColor;
	dword VBGSS_lineColor;
	dword VBGSS_backColor;
	word  VBGSS_lineWidth;
} VisBitmapGraphicsStateStuff;

	@instance VisBitmapGraphicsStateStuff	VBI_gStateStuff;

/*********************************************************************
	VBI_screenGState will contain a graphics state with a
	window on the screen when the user is making edits that must
	show up both in the bitmap and on the screen (this will
	usually be the case).
*********************************************************************/

	@instance GStateHandle	VBI_screenGState;
/*	noreloc	VBI_screenGState */
	@instance GStateHandle 	VBI_transferGString;
/*	noreloc	VBI_transferGString */
	@instance Point 	VBI_transferGStringPos;
	@instance Handle	VBI_transferBitmap; /* lptr ? */
	@instance Point		VBI_transferBitmapPos;

	@instance GStateHandle	VBI_lastEdit;
/*	noreloc VBI_lastEdit */

/*********************************************************************
	Handle to the process thread that updates the backup
	bitmap. Ya know what I mean.
*********************************************************************/
	@instance ThreadHandle	VBI_backupThread;
/*	noreloc VBI_backupThread */

/*********************************************************************
	VBI_visText contains the pointer to the VisText object
	associated with this VisBitmap
*********************************************************************/
@if BITMAP_TEXT
	@instance optr		VBI_visText;
@endif

	@instance optr		VBI_tool;
	@instance optr 		VBI_mouseGrab;

	@instance TimerHandle	VBI_antTimer;
/*	noreloc VBI_antTimer */
	@instance word		VBI_antMaskOffset;
	@instance word		VBI_bitmapToVisHOffset;
	@instance word		VBI_bitmapToVisVOffset;
	@instance BMFormat	VBI_bmFormat;
	@instance word		VBI_xResolution;
	@instance word		VBI_yResolution;
	@instance optr		VBI_finishEditingOD;
	@instance word		VBI_finishEditingMsg;

	@instance dword		VBI_fatbits; /* actually an optr */
/*	noreloc VBI_fatbits */
	@instance dword		VBI_fatbitsWindow;  /* actually an optr */
/*	noreloc VBI_fatbitsWindow */

/*****************************************************************
	 The number of unended start undo chains this bitmap has
	 registered so far

*****************************************************************/
	@instance word		VBI_undoDepth;

/*****************************************************************
	 The number of undo actions registed in the current chain
*****************************************************************/
	@instance word		VBI_nUndoActions;


typedef struct {
	word	VBDK_bitmap;	/* offset within vm file */
	word	VBDK_gstate;
} VisBitmapDisplayKit;


@vardata VisBitmapDisplayKit	ATTR_BITMAP_INTERACTIVE_DISPLAY_KIT;


@endc /* VisBitmapClass */


/*
 * ------------------------------------------------------------------------------
 * 	BitmapBackupProcess Class
 * ------------------------------------------------------------------------------
 */

@class  BitmapBackupProcessClass, ProcessClass;

/* XXX
 * 	Writes the last user edit from the temporary store space
 * 	out into the main bitmap.
 * 
 * PASS:		bp = gstate of bitmap to draw to
 * 		cx = gstate of gstring to draw
 * 		dx = memory handle of gstring *if* you want it freed,
 * 		     0 otherwise
 * 
 * RETURN:	nothing
 */
@message void MSG_BACKUP_GSTRING_TO_BITMAP(	GStateHandle dest = bp,
						GStateHandle source = cx,
						MemHandle    mem = dx); 


@endc	/* BitmapBackupProcessClass */


/*
 * ------------------------------------------------------------------------------
 * 	Tool Class
 * ------------------------------------------------------------------------------
 */

@class  ToolClass, MetaClass;
/*
 * 
 * 				METHODS
 * 
 */

@message void MSG_TOOL_DRAW(); /* XXX */
@message void MSG_TOOL_ENABLE_CONSTRAIN(); /* XXX */
@message void MSG_TOOL_DISABLE_CONSTRAIN(); /* XXX */

@message void MSG_TOOL_AFTER_CREATE(); /* XXX */
@message void MSG_TOOL_TEST_POINT_IN_BOUNDS(); /* XXX */
@message void MSG_TOOL_REQUEST_EDITING_KIT(); /* XXX */
@message void MSG_TOOL_FINISH_EDITING(); /* XXX */

/*XXX
 * 	Returns the PointerDef representing the tool
 * 
 * 	PASS:		nothing
 * 
 * 	RETURN:		if tool has a pointer image:
 * 
 * 			ax = mask MRF_SET_POINTER_IMAGE
 * 			^lcx:dx = PointerDef
 * 
 * 			else:
 * 
 * 			ax = 0
 */
typedef struct {
	word	PI_setPointerImage;
	word	PI_unused;
	optr	PI_PointerDef;
} ToolPointerImage;

@message void MSG_TOOL_GET_POINTER_IMAGE(ToolPointerImage *retVal = axbpcxdx);


/*XXX
 *   Notifies the tool to turn on or turn off fatbits mode
 * 
 * 	PASS:		cx - nonzero for fatbits mode
 * 
 * 	RETURN:		nothing
 */
@message void MSG_TOOL_SET_FATBITS_MODE(Boolean fatbits = cx);


/*XXX
 *   Lets the tool have a go at constraining the mouse
 * 
 * 	PASS:		cx,dx - initial mouse location
 * 
 * 	RETURN:		cx,dx - constrained
 */
typedef struct {
	word	CC_y;
	word	CC_x;
} ConstrainedCoords;

@message void MSG_TOOL_CONSTRAIN_MOUSE(ConstrainedCoords *retVal = dxcx,
					word xpos = cx,
					word ypos = dx);



/*
 * 
 * 			STRUCTURES/RECORDS/ENUMS
 * 
 */



typedef struct {
    GStateHandle	TEK_screenGState;
    GStateHandle	TEK_gstate1;
    GStateHandle	TEK_gstate2;
} ToolEditingKit;



/*
 * 	ConstrainStrategy contains the information needed to implement
 * 	the constrain feature for various tools. There is a table of these
 * 	records (one for each tool) in the file 'ptrTool.asm'
 */

typedef WordFlags ConstrainStrategy;
/* 10 bits unused */

/*
 * 	The following 4 flags are set if the corresponding axis
 * 	is OK to constrain to; i.e., constrain will map the
 * 	coordinates to the closest OK axis.
 * 
 * 	CS_X_AXIS:			The horizontal axis
 * 
 * 	CS_Y_AXIS:			The vertical axis
 * 
 * 	CS_X_EQUALS_Y_AXIS:		The diagonal axis with
 * 					slope = 1 (Runs from top left
 * 					to bottom right of screen)
 * 
 * 	CS_X_EQUALS_MINUS_Y_AXIS:	The diagonal axis with
 * 					slop = -1 (Runs from bottom
 * 					left to top right of screen)
 * 
 * 
 * 	For those graphically minded readers, here's a little picture.
 * 
 * 
 * 	     x ->
 * 
 *       A     Y     B
 * 	\    |    /
 * 	 \   |   /
 * 	  \  |  /
 * 	   \ | /
 * 	    \|/
 *   y	-----+-----X
 *   	    /|\
 *   |	   / | \
 *   v	  /  |  \
 * 	 /   |   \
 * 	/    |    \
 * 
 * 
 * 
 * 	The axis labeled X corresponds to CS_X_AXIS
 * 	The axis labeled Y corresponds to CS_Y_AXIS
 * 	The axis labeled A corresponds to CS_X_EQUALS_Y_AXIS
 * 	The axis labeled B corresponds to CS_X_EQUALS_MINUS_Y_AXIS
 * 
 * 	Notice that the CS_X_EQUALS_MINUS_Y_AXIS actually runs from
 * 	top left to lower right, contrary to the way it always was
 * 	in your geometry class, due to the fact that y increases as
 * 	you go down.
 */

#define CS_X_AXIS 	0x0020
#define CS_Y_AXIS 	0x0010
#define CS_X_EQUALS_Y_AXIS 	0x0008
#define CS_X_EQUALS_MINUS_Y_AXIS 	0x0004

/*
 * 	CS_INITIAL_DIRECTION should be set if the first axis
 * 	constrained to should be the only axis to be constrained
 * 	to on future calls.
 */

#define CS_INITIAL_DIRECTION 	0x0002

/* 	CS_NEVER_CONSTRAIN set if the tool should never be constrained */

#define CS_NEVER_CONSTRAIN 	0x0001

/*
 * 	CS_DIAGONAL_CONSTRAINT = axes sith slopes 1, -1
 * 
 * 	CS_HV_CONSTRAINT = horizontal and vertical axes
 * 
 * 	CS_ALL_CONSTRAINT = both of the above
 * 
 * 	p.s.	I don't know whether or not you have an opinion on the
 * 		terminology I've used here, but I personally think that
 * 		it STINKS. The reason is that this constaint is masquerading
 * 		as a ConstrainStrategy flag (the leading CS_), but unlike
 * 		true flags is used WITHOUT the 'mask' operator. This pisses
 * 		me off, but seems to be an accepted tradition. Watch this
 * 		space for further updates.
 */

#define CS_DIAGONAL_CONSTRAINT (CS_X_EQUALS_Y_AXIS | CS_X_EQUALS_MINUS_Y_AXIS)

#define CS_HV_CONSTRAINT (CS_X_AXIS | CS_Y_AXIS)

#define CS_ALL_CONSTRAINT (CS_DIAGONAL_CONSTRAINT | CS_HV_CONSTRAINT)

/*
 * 
 * 				INSTANCE DATA
 * 
 */

	@instance optr	TI_bitmap;
	@instance word	TI_editToken;
	@instance word	TI_initialX;
	@instance word	TI_initialY;
	@instance word 	TI_previousX;
	@instance word	TI_previousY;

/*
 * 
 * 				FATAL ERRORS
 * 
 */


@endc	/* ToolClass */

/*
 * ------------------------------------------------------------------------------
 * 	DragTool Class
 * ------------------------------------------------------------------------------
 */

@class  DragToolClass, ToolClass;
/*
 * 
 * 				METHODS
 * 
 */


@message void MSG_DRAG_TOOL_DRAW_OUTLINE();

/*
 * 
 * 			STRUCTURES/RECORDS/ENUMS
 * 
 */


/*
 * 
 * 				INSTANCE DATA
 * 
 */


/*
 * 
 * 				FATAL ERRORS
 * 
 */


@endc	/* DragToolClass */

/*
 * ------------------------------------------------------------------------------
 * 	LineTool Class
 * ------------------------------------------------------------------------------
 */

@class  LineToolClass, DragToolClass;
@endc	/* LineToolClass */

/*
 * ------------------------------------------------------------------------------
 * 	RectTool Class
 * ------------------------------------------------------------------------------
 */

@class  RectToolClass, DragToolClass;
@endc	/* RectToolClass */

/*
 * ------------------------------------------------------------------------------
 * 	DrawRectTool Class
 * ------------------------------------------------------------------------------
 */

@class  DrawRectToolClass, RectToolClass;
@endc	/* DrawRectToolClass */

/*
 * ------------------------------------------------------------------------------
 * 	EllipseTool Class
 * ------------------------------------------------------------------------------
 */

@class  EllipseToolClass, DragToolClass;
@endc	/* EllipseToolClass */

/*
 * ------------------------------------------------------------------------------
 * 	DrawEllipseTool Class
 * ------------------------------------------------------------------------------
 */

@class  DrawEllipseToolClass, EllipseToolClass;
@endc	/* DrawEllipseToolClass */

/*
 * ------------------------------------------------------------------------------
 * 	PencilTool Class
 * ------------------------------------------------------------------------------
 */

@class  PencilToolClass, ToolClass;
@endc	/* PencilToolClass */

/*
 * ------------------------------------------------------------------------------
 * 	EraserTool Class
 * ------------------------------------------------------------------------------
 */

@class  EraserToolClass, ToolClass;

	@instance word	ETI_radius;

@endc	/* EraserToolClass */

/*
 * ------------------------------------------------------------------------------
 * 	EraserTool Class
 * ------------------------------------------------------------------------------
 */

@class  FatbitsToolClass, ToolClass;
@endc	/* FatbitsToolClass */

/*
 * ------------------------------------------------------------------------------
 * 	FloodFillTool Class
 * ------------------------------------------------------------------------------
 */


@class  FloodFillToolClass, ToolClass;
/*
 * 
 * 				METHODS
 * 
 */

@message void MSG_FLOOD_FILL_TOOL_FILL_SCAN_LINE();
@message void MSG_FILL();

/*
 * 
 * 			STRUCTURES/RECORDS/ENUMS
 * 
 */


/*
 * 
 * 				INSTANCE DATA
 * 
 */



/*
 * 
 * 				FATAL ERRORS
 * 
 */


@endc	/* FloodFillToolClass */

#if BITMAP_TEXT

/*
 * ------------------------------------------------------------------------------
 * 	TextTool Class
 * ------------------------------------------------------------------------------
 */


@class  TextToolClass, DragToolClass;
/*
 * 
 * 				METHODS
 * 
 */


/*
 * 
 * 			STRUCTURES/RECORDS/ENUMS
 * 
 */


/*
 * 
 * 				INSTANCE DATA
 * 
 */


	TTI_visText	optr

/*
 * 
 * 				FATAL ERRORS
 * 
 */


@endc	/* TextToolClass */

#endif

/*
 * ------------------------------------------------------------------------------
 * 	SelectionTool Class
 * ------------------------------------------------------------------------------
 */


@class  SelectionToolClass, DragToolClass;
/*
 * 
 * 				METHODS
 * 
 */


/*
 * 
 * 			STRUCTURES/RECORDS/ENUMS
 * 
 */

#define ANT_TIMER_PERIOD (7)
#define ANT_TIMER_DELAY (0)

/*
 * 	The following constants are used to determine the "mode" that the
 * 	user is in. The three possible modes are:
 * 
 * 	1 - User clicked, then let up, so that no MSG_META_DRAG_SELECT came in.
 * 	2 - User is dragging open a new selected area
 * 	3 - User is moving around the current selected area
 * 
 * 	Modes 1 and 2 are represented by the negative constants below.
 * 	Mode 3 is represented by a 
 */

typedef ByteEnum SelectionMode;
#define SM_START_WITHOUT_DRAG	0x0
#define SM_DEFINING_NEW_SELECTION	0x1
#define SM_MOVING_CURRENT_SELECTION	0x2

/*
 * 
 * 				INSTANCE DATA
 * 
 */


	@instance word 		STI_selectedInitialX;
	@instance word 		STI_selectedInitialY;
	@instance word		STI_selectedPreviousX;
	@instance word		STI_selectedPreviousY;

	@instance Handle	STI_selectedGString;
			/* handle to selected gstring */
	@instance word		STI_dragX;
	@instance word		STI_dragY;

	@instance SelectionMode	STI_selectionMode;

@endc	/* SelectionToolClass */

@class  VisFatbitsClass, VisClass;

@message void MSG_VIS_FATBITS_INVALIDATE_RECTANGLE(); /* FIXME */
@message void MSG_VIS_FATBITS_SET_VIS_BITMAP(); /* FIXME */
@message void MSG_VIS_FATBITS_SET_IMPORTANT_LOCATION_AND_IMAGE_BIT_SIZE(); /* FIXME */

	@instance optr		VFI_visBitmap;
	@instance Point		VFI_lastMouse;
	@instance Point		VFI_importantLocation;
	@instance Point		VFI_upperLeft;
	@instance ImageBitSize	VFI_imageBitSize;
	

@endc	/* VisFatbitsClass */

/*
 * 
 * 				Utility routines
 * 
 */




@endlib


