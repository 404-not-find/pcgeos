/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) Geoworks 1994 -- All Rights Reserved

PROJECT:	PC GEOS
MODULE:		table class
FILE:		table.goh

AUTHOR:		Patrick Buck, Jun 24, 1994

EXPORTED METHODS:

   MSG_TABLE_SET_ROW_COUNT
   MSG_TABLE_GET_ROW_COUNT
   MSG_TABLE_SET_VISIBLE_ROW_COUNT
   MSG_TABLE_GET_VISIBLE_ROW_COUNT
   MSG_TABLE_GET_COLUMN_COUNT
   MSG_TABLE_SET_ROW_FLAGS
   MSG_TABLE_GET_ROW_FLAGS
   MSG_TABLE_SET_ALL_COLUMN_DEFINITIONS	
   MSG_TABLE_GET_ALL_COLUMN_DEFINITIONS	
   MSG_TABLE_SET_COLUMN_DEFINITION		
   MSG_TABLE_GET_COLUMN_DEFINITION		
   MSG_TABLE_SET_ROW_HEIGHT		
   MSG_TABLE_GET_ROW_HEIGHT		
   MSG_TABLE_SET_CURRENT_SELECTION		
   MSG_TABLE_GET_CURRENT_SELECTION		
   MSG_TABLE_INSERT_ROWS				
   MSG_TABLE_REMOVE_ROWS				
   MSG_TABLE_GROW_COLUMN_RIGHT			
   MSG_TABLE_GROW_COLUMN_LEFT			
   MSG_TABLE_SHRINK_COLUMN_RIGHT			
   MSG_TABLE_SHRINK_COLUMN_LEFT			
   MSG_TABLE_REDRAW_TABLE			
   MSG_TABLE_REDRAW_ROW				
   MSG_TABLE_REDRAW_COLUMN			
   MSG_TABLE_REDRAW_CELL
   MSG_TABLE_REDRAW_RANGE				
   MSG_TABLE_SCROLL
   MSG_TABLE_SCROLL_TO_ROW
   MSG_TABLE_CHANGE_ROW_RANGE_SELECTION
   MSG_TABLE_GET_CELL_GSTATE
   MSG_TABLE_QUERY_DRAW
   MSG_TABLE_SELECT
   MSG_TABLE_GET_BOUNDS
   MSG_TABLE_SET_BORDER_FLAGS
   MSG_TABLE_GET_BORDER_FLAGS
   MSG_TABLE_SET_FLAGS
   MSG_TABLE_GET_FLAGS		
   MSG_TABLE_REDRAW_CURRENT_SELECTION
   MSG_TABLE_DRAG_DROP_SELECT
   MSG_TABLE_DRAG_DROP_COMPLETE
   MSG_TABLE_SET_SELECTION_DRAW_STYLE
   MSG_TABLE_GET_SELECTION_DRAW_STYLE
   MSG_TABLE_SCROLL_SINGLE_DOWN
   MSG_TABLE_SCROLL_SINGLE_UP
   MSG_TABLE_START_EDIT_CELL_TEXT
   MSG_TABLE_STOP_EDIT_CELL_TEXT
   MSG_TABLE_DONE_EDIT_CELL_TEXT
   MSG_TABLE_STRING_LOCATE
   MSG_TABLE_HOLD_DETECTED
   MSG_TABLE_GET_VISIBLE_ROW_RANGE
   MSG_TABLE_SELECTION_CHANGED

EXPORTED ROUTINES:

   TableDrawText

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	PB	6/24/94   	Initial revision

DESCRIPTION:

	This file contains definitions for TableClass.

	This class implements a simple dynamic scrolling table.  An object
	of this class displays a group of rectangular "cells" organized into 
	rows and columns.  All cells have the same height but their width can
	vary depending on which column they reside in.  The width and number
	of columns is arbitrary but all columns must fit within the horizontal
	boundaries of the table.  The table can scroll in the vertical direction
	which means that it can have a large number of rows.

	The following is a list of important features that this class provides:
	
	    * Large number of equally sized rows
	    * Small number of variable sized columns
	    * Ability to scroll through the rows
	    * Ability to dynamically add and remove rows
	    * Ability to dynamically resize the width of the columns
	    * Rows can be separated by lines (affects all rows or none)
	    * Columns can be separated by lines (affects specified columns only)
	    * The contents of a cell are drawn by a table's subclass
	    * A variety of selection styles are supported (single cell,
	      row, column etc).  The subclass can be notified when the 
	      selection changes.
	    * Cells in different columns can respond or ignore a variety
	      of mouse/pen related events (start select, end select, hold
	      select etc.)
	    * Supports visual feedback for dragging and dropping
	      from cell to cell and from outside the table to a cell.

	$Id: table.goh,v 1.1 97/04/04 15:51:33 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@deflib	table

@include <Objects/vCntC.goh>
@include <graphics.h>

/* ######################################################################## 			
			TableClass
   ######################################################################## */ 			

@class	TableClass, VisCompClass;

#define	T_NONE_SELECTED				-1  /* No cells selected */

/* ----------------------------------------------------
 Table Flags

 TF_INTERNAL_DRAG_DROP
  	start-select and hold-select specify a cell to
  	be dragged drag-select performs the dragging
  	end-select performs the drop.  If this flag is
  	set, TF_EXTERNAL_DRAG_DROP is ignored.

 TF_EXTERNAL_DRAG_DROP
  	we are dragging something into the table from
  	an external source, drag-select performs the
  	dragging end-select performs the drop.

 TF_ENABLE_AUTO_SCROLLING
  	Enables scrolling whenever the mouse is dragged
  	above or below the boundaries of the table.

 TF_SELECTION_ALWAYS_VISIBLE
  	Selection stays within visible table when
  	scrolling.  If this flag is set,
  	TF_FIXED_SELECTION is ignored.

 TF_FIXED_SELECTION - !*NOT IMPLEMENTED YET*
  	Selection remains visually fixed as cells
  	scroll by.

 TF_EXIT_DRAG_DROP_ON_COMPLETION
  	Exit drag-and-drop mode automatically upon completion of
  	every drag-and-drop operation.

 TF_TARGETABLE
	Indicates that the table object will grab the target
	whenever it gets MSG_META_START_SELECT.

 TF_NOTIFY_SELECTION_CHANGED
  	Set this if you want the table object to send itself
  	MSG_TABLE_NOTIFY_SELECTION_CHANGED whenever the
  	stored selection value changes.

 TF_MAIN_TABLE
  	Indicates that this is the main table in a content/view
  	containing more than one table object.  A main table
  	is the one that is considered to be active among a group
  	and it will take care of things like enabling/disabling
  	the scroll buttons for the view its in.

 TF_CONFIRM_NEW_SELECTION
  	Set this if you want the table to send itself
  	MSG_TABLE_CONFIRM_NEW_SELECTION before updating
  	the selection range to a new set of values.

 NOTE: *Never* set TF_EXTERNAL_DRAG_DROP or TF_INTERNAL_DRAG_DROP
       manually.  The rest of the flags may be set statically.
       Use MSG_TABLE_SET_FLAGS to set the flags dynamically.                 
---------------------------------------------------- */
typedef	WordFlags	TableFlags;
#define TF_INTERNAL_DRAG_DROP			0x8000
#define TF_EXTERNAL_DRAG_DROP			0x4000
#define TF_ENABLE_AUTO_SCROLLING		0x2000
#define TF_SELECTION_ALWAYS_VISIBLE		0x1000
#define TF_FIXED_SELECTION			0x0800
#define TF_EXIT_DRAG_DROP_UPON_COMPLETION	0x0400
#define TF_TARGETABLE				0x0200
#define TF_NOTIFY_SELECTION_CHANGED		0x0100
#define TF_MAIN_TABLE                           0x0080
#define TF_CONFIRM_NEW_SELECTION                0x0040

/* -------------------------------------------------------- 
   TableBorder Flags 

   These flags indicate what type of borders and/or margins
   to place around the table.
----------------------------------------------------------- */
typedef	WordFlags	TableBorderFlags;
#define TBF_BOX_BORDERS				0x8000
#define	TBF_BOX_MARGINS				0x4000
#define TBF_TOP_BORDER				0x2000
#define TBF_BOTTOM_BORDER			0x1000
#define TBF_LEFT_BORDER				0x0800
#define TBF_RIGHT_BORDER			0x0400
#define TBF_TOP_MARGIN				0x0200
#define TBF_BOTTOM_MARGIN			0x0100
#define TBF_LEFT_MARGIN				0x0080
#define TBF_RIGHT_MARGIN			0x0040

/* -------------------------------------------------------------- 
   Column flags

   TCF_DRAW_RIGHT_SEPARATOR
	Draw a line between the current column and the next one.

   TCF_ALLOW_AUTO_RESIZE - !*NOT IMPLEMENTED YET*
	Resize this column when table object gets resized.

   TCF_START_SELECT
	Send MSG_TABLE_SELECT on a start-select.

   TCF_END_SELECT
	Send MSG_TABLE_SELECT on an end-select.

   TCF_DRAG_SELECT
	Send MSG_TABLE_SELECT when the mouse pointer crosses
	cell boundaries between a start-select and an end-select.

   TCF_DOUBLE_SELECT
	Send MSG_TABLE_SELECT on a double-press.

   TCF_RESELECT
	Send MSG_TABLE_SELECT on a start-select if the cell
	under the mouse pointer is already within a range
	of selected cells.

   TCF_HOLD_SELECT
	Send MSG_TABLE_SELECT after clicking on a cell and 
	holding for a period of time.

   TCF_TRIT
	These specify the TableRangeInversionType to be used
	when selecting a cell in this column.  This value should
	be set using the type mentioned above (see below for
	an explanation of each type).

---------------------------------------------------------------- */
typedef	WordFlags	TableColumnFlags;
#define	TCF_DRAW_RIGHT_SEPARATOR		0x8000
#define	TCF_ALLOW_AUTO_RESIZE			0x4000
#define	TCF_START_SELECT			0x2000
#define	TCF_END_SELECT				0x1000
#define	TCF_DRAG_SELECT				0x0800
#define	TCF_DOUBLE_SELECT			0x0400
#define TCF_RESELECT				0x0200
#define TCF_HOLD_SELECT				0x0100
#define TCF_TRIT				0x000f

/* Shift constant for TableRangeInversionType in TableColumnFlags
   -------------------------------------------------------------- */
#define TCF_TRIT_OFFSET	0

/* -------------------------------------------
  Row flags

   TRF_DRAW_ROW_SEPARATOR
	Draws a line between all of the rows.

   TRF_CELL_CONTENTS_IN_ROW_SEPARATOR
        This flag indicates that part of a cell's
	contents will be drawn into the row separator
	area.  The row separator area is the top
	pixel of each table cell.  The row separator
	line will be drawn in there (border separator
	line for the first visible row).

	Pixels in this area are not included during
	bit blitting for single line scrolling.  
	This is so top and bottom borders won't
	get copied into the table for tables
	without row separators.  

	If you plan to draw into this area, then
	you probably won't be using row separators.
	In this case you will want pixels in this
	area to get bit blitted.

	IMPORTANT:
	If you set this flag to include row
	separator pixels in scrolling, you must
	also clear TRF_DRAW_ROW_SEPARATOR and
	set TBF_TOP_MARGIN and TBF_BOTTOM_MARGIN
	border flags.

--------------------------------------------- */
typedef	WordFlags	TableRowFlags;
#define	TRF_DRAW_ROW_SEPARATOR			0x8000
#define TRF_CELL_CONTENTS_IN_ROW_SEPARATOR      0x4000

/* --------------------
   Private flags

   <Internal use only>
----------------------- */
typedef WordFlags TablePrivateFlags;
#define	TPF_HAVE_MOUSE_GRAB			0x8000
#define TPF_AUTO_SCROLL_ON			0x4000
#define TPF_EDIT_CELL_TEXT			0x2000
#define TPF_WAITING_FOR_HOLD_EVENT		0x1000
#define TPF_HAVE_TARGET				0x0800
#define TPF_POSSIBLE_RESELECTION                0x0400

/* ------------------------------------------------------------------
 Drag drop flags

 TDDF_DONT_RESCAN_CELLS
  	Used by subclasses that intercept MSG_TABLE_DRAG_DROP... type
  	messages to tell the superclass not to redraw the visible
  	cells.
 -------------------------------------------------------------------- */
typedef WordFlags TableDragDropFlags;
#define TDDF_DONT_RESCAN_CELLS			0x8000

/* -----------------  */
/* Location of a cell */
/* -----------------  */
typedef	struct {
	word	TCL_row;		/* row number */
	word	TCL_column;		/* column number */
} TableCellLocation;

/* ----------------- */
/* Column definition */
/* ----------------- */
typedef	struct {
	TableColumnFlags	TCD_flags;
	word			TCD_width;	/* column width in points */
} TableColumnDefinition;

/* ---------- */
/* Cell range */
/* ---------- */
typedef	struct {
   	TableCellLocation	TCR_start;	/* start of a range */
   	TableCellLocation	TCR_end;	/* end of a range   */
} TableCellRange;

/* ------------------------------------------ */
/* Drag-and-drop source and destination cells */
/* ------------------------------------------ */
typedef struct {
   	TableCellRange		TDDC_from;	/* source cell */
   	TableCellRange		TDDC_to;	/* destination cell */
} TableDragDropCell;

/* --------------------------------------------------------------- */
/* This structure is used to pass parameters on the stack for	   */
/* MSG_TABLE_DRAG_DROP_COMPLETE.				   */
/* --------------------------------------------------------------- */
typedef struct {
   	TableDragDropCell	TDDCP_dragDrop;	/* from-to */
   	TableDragDropFlags	TDDCP_flags;	/* flags */
} TableDragDropCompleteParams;

/* ----------------------------------------------------------------- */
/* This structure is used to pass parameters on the stack for	     */
/* MSG_TABLE_START_EDIT_CELL_TEXT.  We need this for the C interface */
/* ----------------------------------------------------------------- */
typedef struct { 
   	TableCellRange		TECT_cells;	/* cell range to edit */
   	MemHandle		TECT_text;	/* ptr to initial text */
   	word			TECT_length;	/* string length (0 if null terminated) */
} TableEditCellTextParams;

/* -------------------------------------- */
/* Predetermined scrolling behavior types */
/* -------------------------------------- */
typedef	word TableScrollType;
#define	TST_SCROLL_PAGE_UP      0x0	/*  up by a page   */
#define TST_SCROLL_PAGE_DOWN	0x2	/*  down by a page */
#define TST_SCROLL_UP		0x4	/*  up by a row    */
#define TST_SCROLL_DOWN		0x6 	/*  down by a row  */
#define TST_SCROLL_TOP		0x8	/*  first row      */
#define TST_SCROLL_BOTTOM	0xa	/*  last row       */

/* ---------------------------------------- */
/* Type used to indicate a particular kind  */
/* of justification to be used when drawing */
/* text or graphics into a table cell       */
/* ---------------------------------------- */
typedef byte TableDrawJustificationType;
#define TDJT_TOP_LEFT			0x0
#define TDJT_TOP_CENTER 		0x2
#define TDJT_TOP_RIGHT			0x4
#define TDJT_CENTER_LEFT		0x6
#define TDJT_CENTER_CENTER		0x8
#define TDJT_CENTER_RIGHT		0xa
#define TDJT_BOTTOM_LEFT		0xc
#define TDJT_BOTTOM_CENTER		0xe
#define TDJT_BOTTOM_RIGHT		0x10
#define TDJT_CENTER_LEFT_ELLIPSIS	0x12
#define TDJT_CENTER_CENTER_OR_LEFT_ELLISPSIS 0x14

/* ---------------------------------------------------------------
   This is used to set the three low order TableColumnFlags values
   indicating how the default selections will look.

   TRIT_CELL
	Select only the cell that the mouse pointer is over.
	Takes effect on start-select.

   TRIT_ROW
	Select an entire row.  Takes effect on start-select.

   TRIT_CUSTOM_ROW
  	Select an arbitrary range of cells along a row.
  	The range is specified by setting TI_currentSelectionStart/End
  	TCL_column values.  Whenever the user makes a selection or
  	scrolls, the selection will be bounded by the current selection
  	column values.

   TRIT_COLUMN
	Select the visible portion of a column (top to bottom of
	visible table).  Takes effect on start-select.

   TRIT_MULTI_ROW - !*NOT IMPLEMENTED YET*
	Select all cells from left to right within a range.
	Start-select sets first cell and drag-select sets last
	cell.

   TRIT_RECTANGLE
	Select all cells within a rectangular region bounded by
	two corner cells.  Start-select sets one corner cell and
	drag-select sets the other corner.

   TRIT_MULTI_ROW_FULL
	Select a range of rows.  Start-select sets the starting
	row and drag-select sets the ending row.

   TRIT_MULTI_COL_FULL
	Select a range of columns.  Start-select sets the starting
	column and drag-select sets the ending column.

   TRIT_SELECTION
  	Set the specified selection as is.

   TRIT_NONE
	This indicates that you don't want to draw any selections.
	Pass this up to the superclass when intercepting 
	MSG_TABLE_SELECT or MSG_TABLE_DRAG_DROP_SELECT if you want
	the current selection to be stored without drawing anything.
	 
------------------------------------------------------------------ */
typedef	word	TableRangeInversionType;
#define TRIT_CELL			0x0000
#define TRIT_ROW			0x0001
#define TRIT_CUSTOM_ROW                 0x0002
#define TRIT_COLUMN			0x0003
#define TRIT_MULTI_ROW			0x0004
#define TRIT_RECTANGLE			0x0005
#define TRIT_MULTI_ROW_FULL		0x0006
#define TRIT_MULTI_COL_FULL		0x0007
#define TRIT_SELECTION                  0x0008
#define TRIT_NONE                       0x0009			

/* --------------------------------
 Indicates how selections are drawn
----------------------------------- */
typedef	word	TableSelectionDrawStyleType;
#define TSDST_FILLED_RECT		0x0000
#define TSDST_SOLID_RECT		0x0002
#define TSDST_OUTLINE_RECT		0x0004
#define TSDST_DOTTED_RECT		0x0006
#define TSDST_UNDERLINE			0x0008

/* -------------------------------------------------------------
   This is used by some messages to indicate the default drawing
   related action.
---------------------------------------------------------------- */
typedef word	TableDrawCommandType;
#define TDCT_DRAW			0x0000
#define TDCT_ERASE			0x0002
#define TDCT_TOGGLE			0x0004

/* ------------------------------------------------------------
  This is used to by some methods to identify which internally
  stored range of cells to act upon.
--------------------------------------------------------------- */
typedef word	TableCellRangeType;
#define	TCRT_CURRENT			0x0000
#define	TCRT_LAST			0x0002

/*-----------------------------------------------------------------------------
			Methods
-----------------------------------------------------------------------------*/

@message void MSG_TABLE_SET_ROW_COUNT(word rowCount = cx);
/*
 *	Sets the total number of rows in a table object.
 *	Selections will be erased if they fall outside of
 *      the new row count.
 *
 * 	PASS:		cx = row count
 * 	RETURN:		nothing
 * 	DESTROYED:	nothing
 *
 */

@message word MSG_TABLE_GET_ROW_COUNT() = cx;
/*
 *
 *	Gets the total number of rows in a table object.
 *
 *	PASS:		nothing
 *	RETURN:		cx = row count
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_SET_VISIBLE_ROW_COUNT(word rowCount = cx);
/*
 *
 *	Sets the number of rows that are visible.
 *	This forces the entire visible table to be redrawn. 
 *
 *	PASS:		cx = visible row count
 *	RETURN:		nothing
 *	DESTROYED:	nothing
 *
 */

@message word MSG_TABLE_GET_VISIBLE_ROW_COUNT() = cx;
/*
 *
 *	Gets the number of rows that are visible.
 *
 *	PASS:		nothing
 *	RETURN:		cx = visible row count
 *	DESTROYED:	nothing
 *
 */

@message word MSG_TABLE_GET_COLUMN_COUNT() = cx;
/*
 *
 *	Gets the total number of columns in a table object.
 *
 *	PASS:		nothing
 *	RETURN:		cx = visible column count
 *	DESTROYED:	nothing
 *
 */
 
@message void MSG_TABLE_SET_ROW_FLAGS(TableRowFlags flags = cx);
/*
 *
 *	Sets the row flags. 
 *
 *	PASS:		cx = TableRowFlags value
 *	RETURN:		nothing
 *	DESTROYED:	nothing
 *
 */

@message TableRowFlags MSG_TABLE_GET_ROW_FLAGS () = cx;
/*
 *
 *	Gets the row flags.
 *
 *	PASS:		nothing
 *	RETURN:		cx = TableRowFlags value
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_SET_ALL_COLUMN_DEFINITIONS
		(MemHandle allColumnDefs = bp,
		 word numColumns    = cx);
/*
 * !*NOT IMPLEMENTED YET* 
 *	Sets definitions for all of the columns.  The definitions are 
 *	passed as an array of TableColumnDefinition's stored in a global 
 *	memory block. The elements in this array should be ordered 
 *	starting with the definition for column zero.
 *
 *	The visible table will be redrawn if any of the columns gets 
 *	a new width.
 *
 *	PASS:		 cx = total number of columns
 *			^hbp = global memory handle to an array of 
 *				TableColumnDefinition entries 
 *	RETURN:		nothing	
 *	DESTROYED:	nothing
 *
 */


typedef struct {
	word	TGCDP_pad1;
	word	TGCDP_allColumnDefs;
	word	TGCDP_numColumns;
	word	TGCDP_pad2;
} TableGetColumnDefinitionParams;

@message void MSG_TABLE_GET_ALL_COLUMN_DEFINITIONS
		(TableGetColumnDefinitionParams *retVal = axbpcxdx);
/*
 * !*NOT IMPLEMENTED YET* 
 *	Gets definitions for all of the columns.  The definitions are 
 *	returned as an array of TableColumnDefinition's stored in a 
 *	global memory block. The elements in this array should be ordered 
 *	starting with the definition for column zero.
 *
 *	PASS:		nothing
 *	RETURN:	  	cx = total number of columns
 *	  		^hbp = global memory handle to an array of 
 *				TableColumnDefinition entries 
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_SET_COLUMN_DEFINITION
		(MemHandle columnDef = bp,
		 word column    = cx);
/*
 *
 *	Sets the definition structure for a column.  
 *	The visible table will be redrawn.
 *
 *	PASS:		^hbp = global memory handle to a block with
 *				the TableColumnDefinition value
 *
 *			cx   = column number
 *	
 *	RETURN:		nothing	
 *	DESTROYED:	nothing
 *
 */

@message MemHandle MSG_TABLE_GET_COLUMN_DEFINITION
		 (word column = cx) = bp;
/*
 *
 *	Gets the definition structure for a column.  
 *
 *	PASS:		cx   = column number
 *	
 *	RETURN:		^hbp = global memory handle to a block with
 *				the TableColumnDefinition value
 *
 *	DESTROYED:	nothing
 *
 */


@message void MSG_TABLE_SET_ROW_HEIGHT(word rowHeight = cx);
/*
 *
 *	Sets the height for all rows.  This forces the visible 
 *	table to be redrawn. 
 *
 *	PASS:		cx   = new row height
 *	RETURN:		nothing
 *	DESTROYED:	nothing
 *
 */

@message word MSG_TABLE_GET_ROW_HEIGHT() = cx;
/*
 *
 *	Gets the height for all rows.
 *
 *	PASS:		nothing
 *	RETURN:		cx   = row height
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_SET_CURRENT_SELECTION
	(@stack TableCellRange cellRange);
/*
 *
 *	
 *
 *	Sets the cell to be used as the current selection.
 *
 *	PASS:		ss:bp = TableCellRange
 *
 *	RETURN:		nothing
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_GET_CURRENT_SELECTION
	(TableCellRange *cellRange = axbpcxdx);
/*
 *
 *	Gets the cell to be used as the current selection.
 *
 *	PASS:		nothing
 *	RETURN:		ax   = current selection start row
 *  			bp   = current selection start column
 *  			cx   = current selection end row
 *  			dx   = current selection end column
 *			
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_INSERT_ROWS
		(word  row     = cx,
		 word  numRows = dx);
/*
 *
 *	Insert rows starting *after* the specified row.
 *	This may force the visible table to redraw.
 *	The number of visible rows is not affected.
 *
 *	PASS:		cx   = row number (-1 to prepend)
 *			dx   = number of rows to insert 
 *
 *	RETURN:		nothing
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_REMOVE_ROWS
		(word  row     = cx,
		 word  numRows = dx);
/*
 *
 *	Remove rows starting *at* the specified row.
 *	This may force the visible table to redraw.
 *	The number of visible rows is not affected.
 *
 *	PASS:		cx   = row number 
 *			dx   = number of rows to remove 
 *
 *	RETURN:		nothing
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_GROW_COLUMN_RIGHT
		(word  column = cx,
		 word  points = dx);
/*
 *
 *	Increase the width of a column toward the right.
 *	A column will refuse to grow if it will cause a neighboring 
 *	column to shrink to zero points.  This will force the visible table 
 *	to redraw.
 *
 *	PASS:		cx   = column number
 *			dx   = amount of space to add in points
 *
 *	RETURN:		carry set if unable to grow the column
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_GROW_COLUMN_LEFT
		(word  column = cx,
		 word  points = dx);
/*
 *
 *	Increase the width of a column toward the left.
 *	A column will refuse to grow if it will cause a 
 *	neighboring column to shrink to zero points.  This will 
 *	force the visible table to redraw.
 *
 *	PASS:		cx   = column number
 *			dx   = amount of space to add in points
 *
 *	RETURN:		carry set if unable to grow the column
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_SHRINK_COLUMN_RIGHT
		(word  column = cx,
		 word  points = dx);
/*
 *
 *	Decrease the width of a column from the right.
 *	A column cannot shrink to zero points.
 *	This will force the visible table to redraw.
 *	
 *	PASS:		cx   = column number
 *			dx   = amount of space to remove in points
 *
 *	RETURN:		carry set if unable to shrink the column
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_SHRINK_COLUMN_LEFT
		(word  column = cx,
		 word  points = dx);
/*
 *
 *	Decrease the width of a column from the left.
 *	A column cannot shrink to zero points.
 *	This will force the visible table to redraw.
 *
 *	PASS:		cx   = column number
 *			dx   = amount of space to remove in points
 *
 *	RETURN:		carry set if unable to shrink the column
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_REDRAW_TABLE();
/*
 *
 *	Forces the entire visible table to redraw itself.
 *
 *	PASS:		nothing
 *	RETURN:		nothing
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_REDRAW_ROW(word row = cx);
/*
 *
 *	Forces a row to redraw itself.
 *
 *	PASS:		cx   = row number
 *	RETURN:		nothing
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_REDRAW_COLUMN(word column = cx);
/*
 *	
 *
 *	Forces a column to redraw itself.
 *
 *	PASS:		cx   = column number
 *	RETURN:		nothing
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_REDRAW_CELL(TableCellLocation location = dx:cx);
/*
 *
 *	
 *
 *	Forces a cell to redraw itself.
 *
 *	PASS:		cx   = row number
 *			dx   = column number
 *
 *	RETURN:		nothing
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_REDRAW_RANGE
	(@stack TableCellRange cellRange);
/*
 *
 *	Forces a range of cells to redraw themselves.
 *
 *	PASS:		ss:bp = TableCellRange
 *
 *	RETURN:		nothing
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_SCROLL(TableScrollType scrollType = cx);
/*
 *	This message tells the table to scroll to a predetermined location.
 *
 *	PASS:		cx   = TableScrollType
 *	RETURN:		nothing
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_SCROLL_TO_ROW(word row = cx);
/*
 *
 *	This message tells the table to scroll to the indicated
 *	row (this row will become the first visible row if possible)
 *
 *	PASS:		cx   = destination row number
 *	RETURN:		nothing
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_CHANGE_ROW_RANGE_SELECTION
		( TableCellLocation startLocation = dx:cx,
		  word		    endColumn     = bp);
/*
 *	This message changes the current selection to the
 *	specified range of cells along a row.  	
 *
 *	PASS:		cx   = row number (or T_NONE_SELECTED for no selection)
 *			dx   = starting column number
 *			bp   = ending column number
 *
 *	RETURN:		nothing
 *	DESTROYED:	nothing
 *
 */

@message GStateHandle MSG_TABLE_GET_CELL_GSTATE
		(TableCellLocation location = dx:cx,
		 GStateHandle gstate = bp) = ax;
/*
 *	This message gets a gstate for the specified cell.
 *	The gstate comes with a clipping region describing
 *	the cell's boundaries.  The current position (CP)
 *	is set to the upper left corner of this clipping region.
 *
 *	The caller should destroy the supplied gstate after
 *	using it ( call GrDestroyState() ).   
 *
 *	PASS:		cx   = row number
 *			dx   = column number
 *			^hbp = gstate to use (0 to create one)
 *
 *	RETURN:		^hax	= gstate to draw into (zero if cell is not
 *				  visible or does not exist) 
 *	DESTROYED:	nothing
 *
 */

@message void MSG_TABLE_QUERY_DRAW
		(TableCellLocation location = dx:cx,
		 GStateHandle	   gstate   = bp);
/*
 *	
 *
 *	The TableClass object sends itself this message every time
 *	it needs to draw the contents of a cell.  The default
 *	handler does not draw anything.  This message is meant
 *	to be subclassed.
 *
 * 	Source:		TableClass object
 * 	Destination:	TableClass object
 * 	Interception:	A subclass of TableClass should intercept
 * 	                this message to draw the contents of a
 * 	 		cell.  There is no need to pass this
 * 	 		message to the superclass since it does
 *  			not do anything.
 *
 * 	PASS:		cx   = row number
 *			dx   = column number
 *			^hbp = handle of gstate to draw into
 *		
 * 	RETURN:		nothing
 * 	DESTROYED:	nothing
 */

@message void MSG_TABLE_SELECT
		(TableCellLocation location = dx:cx,
		 TableColumnFlags  tableColumnFlags = bp);
/*
 *	
 *
 * 	The TableClass object sends this message to itself whenever
 * 	a cell is selected.  Selection happens when a cell
 * 	receives one of the following messages:
 *
 *    	MSG_META_START_SELECT (single and double selection)  
 *    	MSG_META_END_SELECT
 *    	MSG_META_DRAG_SELECT
 *	MSG_META_PTR
 *
 * 	The selected cell will become the current selection.
 * 
 * 	The column flags for this cell also indicate whether this action
 * 	gets sent at all.  The value of bp shows which column flag
 * 	was responsible for causing this action to be sent.
 *
 * 	The default behavior for this message is to cause a range
 *   	of cells to become inverted depending on what type of
 *   	TableRangeInversionType value is stored in the
 *   	TableColumnFlags.  You can change this value to
 *   	TRIT_NONE if you don't want the inversion to be drawn.
 *
 *	If this message is sent as a result of a drag-and-drop,
 *	TableColumnFlags will be clear and the default handler will
 *	draw graphics appropriate to drag-and-drop.
 *
 * 	Source:		TableClass object
 * 	Destination:	TableClass object
 * 	Interception:	A subclass should intercept this to perform
 *  			different or additional actions upon selection. 
 * 
 * 	Pass:		cx   = row number
 *			dx   = column number
 *			bp   = TableColumnFlags
 *		
 * 	Return:		nothing
 */

@message void MSG_TABLE_GET_BOUNDS
		(Rectangle *retValue = axbpcxdx);
/*
 * 	Get the bounds of the table within the vis bounds
 *
 *	Pass:		nothing
 *
 *	Return:		ax   = left
 *  			bp   = top
 *  			cx   = right
 *  			dx   = bottom
 */

@message void MSG_TABLE_SET_BORDER_FLAGS
		(TableBorderFlags borderFlags = cx);
/* !*NOT IMPLEMENTED YET*  
 * Set the border flags.
 *
 * Pass:	cx   = TableBorderFlags
 * Return:	nothing
 */

@message TableBorderFlags MSG_TABLE_GET_BORDER_FLAGS() = cx;
/* !*NOT IMPLEMENTED YET* 
 * Get the border flags.
 *
 * Pass:	nothing
 * Return:	cx   = TableBorderFlags
 */

@message void  MSG_TABLE_SET_FLAGS
		(TableFlags setTableFlags = cx,
		 TableFlags unsetTableFlags = dx);
/*
 *
 *	
 *
 * 	Set the table flags.
 *
 * 	Pass:		cx   = TableFlags
 * 	Return:		nothing
 */

@message TableFlags MSG_TABLE_GET_FLAGS() = cx;
/*
 *
 * 	Get the table flags.
 *
 * 	Pass:		nothing
 * 	Return:		cx   = TableFlags
 */

@message void MSG_TABLE_REDRAW_CURRENT_SELECTION
		(TableDrawCommandType drawCommand = cx,
		 GStateHandle	gstate = bp);
/*
 * 	The TableClass object sends this message to itself
 * 	whenever it needs to redraw the currently selected
 * 	range of cells.  This happens when the table needs
 * 	to redraw some part of itself due to being moved,
 * 	resized, scrolled etc.
 *
 * 	The default behavior of this message is to redraw
 *	the selected cells in inverted mode.
 *
 * 	Source:	 	TableClass object
 * 	Destination:	TableClass object
 * 	Interception: 	Subclasses that intercept MSG_TABLE_SELECT
 *  		 	to provide a custom look for their
 *  		 	selection bars.  		
 * 
 * 	Pass:	 	cx    = TableDrawCommandType
 *			^hbp  = gstate to draw through (0 to create one)
 * 	Return:	 	gstate unchanged (if subclassing)
 */  

@message void  MSG_TABLE_DRAG_DROP_SELECT
		(TableCellLocation location = dx:cx,
		 TableColumnFlags  tableColumnFlags = bp);
/*
 *
 * 	The TableClass object sends this message to itself
 * 	instead of MSG_TABLE_SELECT when its operating in
 * 	drag-and-drop mode.
 *
 * 	The TableColumnFlags value has these meanings:
 *
 *  		TCF_START_SELECT - A source has been chosen
 *  		TCF_DRAG_SELECT  - We are dragging
 *
 * 	The default handler for this message just draws the
 * 	appropriate drag-and-drop selection bars.  You can
 * 	intercept this message but you should let the
 *	the superclass draw the drag-and-drop selection
 *	bars.
 *
 * 	Pass:		cx   = row number
 *			dx   = column number
 *			bp   = TableColumnFlags
 *		
 * 	Return:		nothing
 */
 
@message void MSG_TABLE_DRAG_DROP_COMPLETE
		(@stack TableDragDropCompleteParams cellFromTo);
/*
 *	
 *
 * 	The TableClass object sends this message to itself at
 * 	the end of a drag-and-drop operation.  The table is
 * 	set to drag-and-drop mode by setting one of these
 * 	TableFlags:
 *
 *  		TF_INTERNAL_DRAG_DROP
 *  		TF_EXTERNAL_DRAG_DROP
 *
 * 	In 'internal' mode, the source and destination of
 * 	the drag-and-drop are cells within the table.
 * 	In 'external' mode, the destination is a table cell
 * 	but the source is external to the table.
 * 	If both drag-and-drop flags are set, the mode will
 * 	default to 'internal'.
 *
 *	The default handler for MSG_TABLE_DRAG_AND_DROP_COMPLETE
 *	sends MSG_TABLE_QUERY_DRAW messages for all of the visible
 *	cells in the table.  You should call the superclass *after* 
 *	updating the database of table entries.
 *	
 *	If you want a different range of cells to be redrawn,
 *	intercept this message and use MSG_TABLE_REDRAW_xxx
 *	messages to redraw the affected cells.  If you do this,
 * 	you must pass the TDDF_DONT_RESCAN_CELLS flag to the
 *	superclass. 
 *
 * 	Source:	 	TableClassObject
 * 	Destination:	TableClassObject
 * 	Interception: 	A subclass intercepts this to update
 *  		 	its database of table entries.
 *
 * 	Pass:		ss:bp = TableDragDropCompleteParams
 *
 *   	TDDCP_dragDrop.TDDC_from = source cell range (TableCellRange type)
 *  				   where values in TableCellRange are
 *  				   T_NONE_SELECTED if external drag-and-drop
 *
 *  	TDDCP_dragDrop.TDDC_to   = destination cell range (TableCellRange type)
 *
 *  	TDDCP_flags		 = TableDragDropFlags
 *
 * 	Return:	 	nothing
 */


@message void  MSG_TABLE_SET_SELECTION_DRAW_STYLE
		(TableSelectionDrawStyleType drawStyle = cx);
/*
 *
 *	Sets the TableSelectionDrawStyleType for the table.
 *	It also changes the currently drawn selection bar if
 *	its visible.
 *	
 *	Pass:		cx   = TableSelectionDrawStyleType
 *	Return:		nothing
 */


@message TableSelectionDrawStyleType MSG_TABLE_GET_SELECTION_DRAW_STYLE() = cx;
/*
 *
 *	Gets the TableSelectionDrawStyleType for the table.
 *	
 *	Pass:		nothing
 *	Return:		cx   = TableSelectionDrawStyleType
 */

@message void MSG_TABLE_SCROLL_SINGLE_DOWN();
@message void MSG_TABLE_SCROLL_SINGLE_UP();
/*
 *	These messages can be used instead of MSG_TABLE_SCROLL
 * 	to make the table scroll up or down by a single row.
 *
 * 	PASS:		nothing
 * 	RETURN:		nothing
 * 	DESTROYED:	nothing
 */

@message void MSG_TABLE_START_EDIT_CELL_TEXT
	(@stack TableEditCellTextParams params);
/*
 *	This message creates a VisText object that can be used to
 *	edit the textual contents of a cell.  It creates a text object 
 *	and places it over the cell to be edited.  The text object will
 *	be empty unless some initial text is passed in TECT_text.
 *
 *	Pass:		ss:bp = TableEditCellTextParams
 *
 *  			TECT_cells	cell range to edit
 *  			TECT_text	memory handle to initial text
 * 			TECT_length	string length (0 if null terminated)
 *
 *	Return:		nothing
 */

@message void MSG_TABLE_STOP_EDIT_CELL_TEXT();
/*
 * This message removes the VisText cell editor.
 *
 * Pass:		nothing
 * Return:		nothing
 */ 

@message void MSG_TABLE_DONE_EDIT_CELL_TEXT
	(@stack TableEditCellTextParams params);
/*
 *	The TableClass object receives this message from the
 *	VisText cell editor at the end of the editing operation.
 *
 *	Pass:		ss:bp = TableEditCellTextParams
 *
 *  			TECT_cells	cell range being edited
 *  			TECT_text	memory handle to final text
 * 			TECT_length	string length (0 if null terminated)
 *
 *	Return:		nothing
 *	Note:		Call superclass so text block can be freed. 
 */

@message ClassStruct *MSG_TABLE_GET_TEXT_CLASS() = cx:dx;
/*  
 *  	The table will send this to itself to query for the class
 *  	to use for an item.  Applications needing subclass
 *  	TableTextClaas to provide some special behavior can get
 *  	their TableText subclass used for the table by
 *  	subclassing this message
 *  
 *  	Pass:	nothing
 *  	Return:	cx:dx	= class to use for item
 *  	Destoryed:	ax, bp
 */

@message Boolean MSG_TABLE_STRING_LOCATE(char *text = cx:dx) = carry;
/*
 *  This method is meant to be implemented by a subclass.
 *  Its functionality will be to act on some information
 *  about the data in the table based on the supplied string.
 *  Default handler returns carry.
 * 
 *  Pass:		cx:dx	= text string
 *  Return:	carry set if unable to find string
 *  Destroy:	Specified by subclass
 */

@message void MSG_TABLE_HOLD_DETECTED();
/*
 * 	The table will receive this message when a hold event
 * 	is detected after having received a start-select.
 * 	This will only be recived once until the the next
 * 	start-select.
 *
 * 	Pass:	nothing
 * 	Return:	nothing
 */

typedef struct {
	word	TRR_start;
	word	TRR_end;
} TableRowRange;

@message TableRowRange MSG_TABLE_GET_VISIBLE_ROW_RANGE() = dx:cx;
/*
 *	Gets the row numbers of the top and bottom visible
 * 	rows.  If there are less rows than the height of the
 * 	table, the last row number is returned as the
 * 	bottom row.
 *
 *	 Pass:		nothing
 *	 Return:	cx = top row number
 *	  		dx = bottom row number
 */

@message void MSG_TABLE_NOTIFY_SELECTION_CHANGED();
/* 
 *	Notification sent by the table object to itself to indicate
 *	that the table selection value has changed. You must set 
 *	TF_NOTIFY_SELECTION_CHANGED (TableFlags) in order for this 
 *	message to be sent.
 *
 *	 Pass:		nothing
 *	 Return:	nothing
 */

/*  ----------------------------------------------------- */
@message Boolean MSG_TABLE_CHAR_LOCATE(char searchChar = cl) = carry; 
/*  -----------------------------------------------------
 *  This method is meant to be implemented by a subclass.
 *  Its functionality will be to act on some information
 *  about the data in the table based on the supplied char.
 *  Default handler returns carry.
 * 
 *  Pass:	cx	= char to search for
 *  Return:	carry set if unable to find string
 *  Destroy:	Specified by subclass
 */


/* -------------------------------------------------------------------------
				Routines
   ------------------------------------------------------------------------*/


extern void 
    _pascal TableDrawText (GStateHandle gstate, sword xoffset, sword yoffset,
		word justificationType, word numChars, const char *str);
/* -------------
 * TableDrawText
 * -------------
 *
 *	
 * 
 * Attempts to draw justified text inside a table cell.
 * The supplied gstate should contain font and point size
 * information so that the size of the text can be determined.
 *
 * Justification is calculated relative to the rectangular
 * clipping region within the gstring.  The text can be justified
 * to nine different positions.  Once the position has been
 * chosen, offsets can be added to fine tune the position of
 * the text.
 *
 * 	Justification Positions
 *
 * 	TDJT_TOP_LEFT
 * 	TDJT_TOP_CENTER
 * 	TDJT_TOP_RIGHT
 * 	TDJT_CENTER_LEFT
 * 	TDJT_CENTER_CENTER
 * 	TDJT_CENTER_RIGHT
 * 	TDJT_BOTTOM_LEFT
 * 	TDJT_BOTTOM_CENTER
 * 	TDJT_BOTTOM_RIGHT
 *	TDJT_CENTER_LEFT_ELLIPSIS
 *
 *  Pass:	ds:si	= text string
 *   		cx	= number of chars in string (zero if null terminated)
 *   		bx	= TableDrawJustificationType
 *   		dl	= x signed offset in points (pos right, neg left)
 *   		dh	= y signed offset in points (pos down, neg up)
 *   		^hdi	= gstate to draw in (with rectangular clip region)
 *
 * Return:	nothing
 */

#if __HIGHC__ 
pragma	Alias(TableDrawText, "TABLEDRAWTEXT");
#endif 

@message void MSG_TABLE_CONFIRM_NEW_SELECTION
              (TableCellRange *cellRange = ss:bp);
/* 
 * Confirmation msg sent by the table object to itself to indicate
 * that the table selection value is about to be changed.
 * This allows the subclass to set a different selection range before
 * returning.
 *
 * This is useful during situations such as auto scrolling where
 * the subclass may want to expand or contract a selection
 * to include or exclude some columns after some particular
 * row scrolls out of or into the visible table.
 *
 * You must set TF_CONFIRM_NEW_SELECTION (TableFlags) in order for this 
 * message to be sent.
 * 
 */

/*==========================================================================
 			     Instance data
==========================================================================*/

@instance	word	TI_rows = 0;
	/* Total number of rows in the table */

@instance	word	TI_columns = 0;
	/* Total number of columns in the table (all columns are visible) */

@instance	word	TI_visibleRows = 0;
	/* Number of rows currently displayed */

@instance	word	TI_topRow = 0;
	/* Row number of the first visible row */

@instance	TableFlags	TI_tableFlags = 0;
	/* Info about the table */
 
@instance	TableRowFlags	TI_rowFlags = 0;
	/* Attributes common to all rows. */

@instance	ChunkHandle	TI_columnDefinitions = NullHandle;
	/* Chunk handle to a list of column definitions.  Each definition 
	 * consists of the following:
	 *   
	 *    TableColumnFlags record 
	 *    column width in points
	 */

@instance	word	TI_rowHeight = 0;
	/* Row height in points (row can be taller). */

@instance	TableCellLocation	TI_currentSelectionStart = {T_NONE_SELECTED, T_NONE_SELECTED};
	/* Stores the upper-left cell of in the current range 
	   of selected cells. */

@instance	TableCellLocation	TI_currentSelectionEnd = {T_NONE_SELECTED, T_NONE_SELECTED};
	/* Stores the lower-right cell in the current range
	   of selected cells. */

@instance	TableCellLocation	TI_lastSelectionStart = {T_NONE_SELECTED, T_NONE_SELECTED};
	/* Stores the upper-left cell in the last 
	   range of selected cells. */

@instance	TableCellLocation	TI_lastSelectionEnd = {T_NONE_SELECTED, T_NONE_SELECTED};
	/* Stores the lower-right cell in the last range
	   of selected cells if. */

@instance	Rectangle		TI_bounds = {0, 0, 0, 0};
	/* <Internal Use Only>
	   These are the bounds of the table itself.  If
	   the table has margins and/or borders, these
	   values will be different than VI_bounds. */

@instance	TableBorderFlags	TI_borderFlags = 0;
	/* These flags are used to control the presence and type of 
	   borders and margins to be used when drawing the table. */

@instance	TableRangeInversionType	TI_tableRangeInversion = 0;
   	/* <Internal Use Only>
   	   Stores the type of range inversion that was used
   	   for the last cell range selection. */

@instance	TableCellLocation	TI_lastCell = {T_NONE_SELECTED, T_NONE_SELECTED};			
   	/* <Internal Use Only>
   	   Need to keep track of last cell visited which
   	   is not necessarily the last cell selected. */

@instance	TableSelectionDrawStyleType	TI_selectionDrawStyle = 0;
   	/* Indicates how selections should be drawn.
   	   Always use MSG_TABLE_SET_SELECTION_DRAW_STYLE to set
   	   this because it will take care of redrawing the
   	   current selection bar if its visible.  Your UI will
   	   not look right otherwise. */

@instance	TablePrivateFlags		TI_privateFlags = 0;
	/* <Internal Use Only>
	   These flags store state information that is used internally */

@instance	ChunkHandle			TI_textObj = 0;
	/* Chunk handle to a VisText object used to accept user input */

@endc

/* ######################################################################## 			
			TableTextClass
   ######################################################################## */ 			

@class	TableTextClass, VisTextClass;

@message void MSG_TABLE_TEXT_INITIALIZE();
/* <Internal use only> */

@instance	TableCellLocation		TTI_startCell;
@instance	TableCellLocation		TTI_endCell;
	/* Stores the range of cells over which the text object appears */
@endc


/* ######################################################################## 			
			TableContentClass
   ######################################################################## */ 			

@class  TableContentClass, VisContentClass;
/*  ==========================================================================
 *  			     Exported Methods
 *  ==========================================================================*/

/*  ----------------------------------------------------- */
@message Boolean MSG_TABLE_CONTENT_KBD_SEND_TO_CHILDREN_ON() = carry;
/*  -----------------------------------------------------
 *  This tells the TableContent to send the keyboard
 *  messages to the children.  This behavior is the
 *  default behavior for the TableContent.
 *  It will not be able to send to the children if
 *  someone already has exclusive access to it.
 * 
 *  PASS:	nothing
 *  RETURN:	carry set if it could not send to all.
 *  DESTROYED:	nothing
 */

/*  ----------------------------------------------------- */
@message Boolean MSG_TABLE_CONTENT_KBD_SEND_TO_CHILDREN_OFF() = carry; 
/*  -----------------------------------------------------
 *  This tells the TableContent not to send the keyboard
 *  messages to the children.  It will not be able to
 *  turn off this feature if someone already has
 *  exclusive access to it.
 * 
 *  PASS:	nothing
 *  RETURN:	carry set if it could not send to all.
 *  DESTROYED:	nothing
 */

/*  ----------------------------------------------------- */
@message Boolean MSG_TABLE_CONTENT_GRAB_KBD_EXCLUSIVE(optr obj = cx:dx) = carry;
/*  -----------------------------------------------------
 *  Sent by one of the content's children so that
 *  it can be the only one to receive KBD messages.
 * 
 *  PASS:	^lcx:dx	= optr to where to send keyboard
 *  RETURN:	carry set if it could not grab it.
 *  DESTROYED:	nothing
 */

/*  ----------------------------------------------------- */
@message Boolean MSG_TABLE_CONTENT_RELEASE_KBD_EXCLUSIVE(optr obj = cx:dx) = carry;
/*  -----------------------------------------------------
 *  Sent by one of the content's children so that
 *  it can release the exclusive hold it has on KBD messages.
 *  Only the object who had exclusive can release it.
 * 
 *  PASS:	^lcx:dx	= optr who is releasing it.
 *  RETURN:	carry set if could not release
 *  DESTROYED:	nothing
 */

@alias (MSG_META_KBD_CHAR) Boolean MSG_META_KBD_CHAR_WITH_RETURN(
                                        word character = cx,
                                        word flags = dx,
                                        word state = bp) = carry;
/*
 * 	This is the normal keyboard message, except that we want a 
 *	return value specified so that the table content can know
 *	if the keyboard event was wanted.  
 *
 * PASS:	cx = 	character
 * 		dx =	flags
 *		bp =	state
 * RETURN:	carry (TRUE) if keyboard event not used.
 *		clear carry (FALSE) if event used.
 *
 */


/*  ==========================================================================
 *  			     Instance data
 *  ==========================================================================*/

    @default VCI_geoAttrs = (@default | VCGA_ORIENT_CHILDREN_VERTICALLY);

    @instance byte	TCI_kbdSend = 255;
	/*  <Internal use only>				 */
	/*  Flag to tell us to send messages to children */

    @instance optr	TCI_exclDestination = NullOptr;
	/*  <Internal use only>				 */
	/*  who is going to get sole use of kbd messages */

    @instance word	TCI_childSpacing = 0;

    @instance word	TCI_childWrapSpacing = 0;
	/*  Default spacing for children of this content. */

@endc	/* TableContentClass */


/* ######################################################################## 			
			LocatorClass
   ######################################################################## */ 			
@class  LocatorClass, TableClass;

#define LOCATOR_NUM_OF_ACTION_BUTTONS	(13)

typedef byte LocatorSelections[LOCATOR_NUM_OF_ACTION_BUTTONS];

/*
 *  These are private flags and should not be used by otheres.
 *  LSF_INITIALIZED	= tells if the Locator has already been initialized
 *  LSF_ACTION_BAR	= tells if current appearance of locator is
 * 			  an action bar
 *  LSF_CELL_LEAVE_AND_HOLDING
 * 			= tells if user has pressed action bar and moving
 *  			  around the pen/mouse outside the cell
 */

typedef ByteFlags LocatorStateFlags;
#define LSF_INITIALIZED	(0x80)
#define LSF_ACTION_BAR	(0x40)
#define LSF_CELL_LEAVE_AND_HOLDING	(0x20)
/* 5 bits unused */

/*  ==========================================================================
 *  			     Exported Methods
 *  ==========================================================================*/

/*  ----------------------------------------------------- */
@message void MSG_LOCATOR_CHANGE_TO_ACTION_BAR();
/*  -----------------------------------------------------
 *  Tells the locator that it should apear as the "ABC"
 *  buttons on the top as opposed to the text search
 *  field.
 * 
 *  PASS:	nothing
 *  RETURN:	nothing
 *  DESTROYED:	nothing
 */

/*  ----------------------------------------------------- */
@message void MSG_LOCATOR_CHANGE_TO_TEXT_SEARCH();
/*  -----------------------------------------------------
 *  Tells the locator that is should appear as the
 *  test search field as opposed to the action bar.
 * 
 * 
 *  PASS:	nothing
 *  RETURN:	nothing
 *  DESTROYED:	nothing
 */

/*  ----------------------------------------------------- */
@message Boolean MSG_LOCATOR_DO_STRING_LOCATE(char *locateString = cx:dx)=carry;
/*  -----------------------------------------------------
 *  Tells the locator to call the table object that
 *  is associated with the locator, to locate the
 *  string that is passed
 * 
 *  PASS:	cx:dx	= string to pass
 *  RETURN:	carry returned if search failed
 *  DESTROYED:	nothing
 */

/*  ----------------------------------------------------- */
@message Boolean MSG_LOCATOR_DO_CHAR_LOCATE(char searchChar = cl) = carry;
/*  -----------------------------------------------------
 *  Tells the locator to call the table object that
 *  is associated with the locator, to locate the
 *  char that is passed
 * 
 *  PASS:	cl	= Char to search for
 *  RETURN:	carry returned if search failed
 *  DESTROYED:	nothing
 */

/*  ==========================================================================
 *  			     Instance data
 *  ==========================================================================*/

    @instance LocatorStateFlags		LI_state = 0;
	/*  <Internal use only>		*/
	/*  Tells state of the locator. */

    @instance ChunkHandle		LI_actionBarColDefsHandle = 0;
	/*  <Internal use only>		*/


    @instance ChunkHandle		LI_textSearchColDefsHandle = 0;
	/*  <Internal use only>		*/

    @instance TableCellLocation	LI_selectionStart = {T_NONE_SELECTED, T_NONE_SELECTED};
	/*  <Internal use only>		*/

    @instance LocatorSelections LI_selections = {0,0,0,0,0,0,0,0,0,0,0,0,0};
	/*  <Internal use only>		*/
	/*  Data to keep track of what position each button is on */

    @instance optr		LI_destination = NULL;
	/*  Where this locator will send it's apply message */

@endc	/* LocatorClass */


/* ######################################################################## 			
		LocatorTextClass
   ######################################################################## */ 			
/*
 * For internal use only.  May be subclassed to change text behavior in
 * locator.
 */ 
@class  LocatorTextClass, TableTextClass;
@endc	/* LocatorTextClass */

/* ######################################################################## 			
			TableViewClass
   ######################################################################## */ 			
@class	TableViewClass, GenViewClass;

@protominor	TableNewForDove

@instance	optr				TVI_mainTable;
@instance	word				TVI_scrollerPos;

@protoreset

@endc

@endlib
