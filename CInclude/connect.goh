/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) Geoworks 1995 -- All Rights Reserved

PROJECT:	PC GEOS
MODULE:		Connect Library
FILE:		connect.goh

AUTHOR:		Thomas Lester, Mar 31, 1995

ROUTINES:
	Name			Description
	----			-----------

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	lester	3/31/95   	Initial version.

DESCRIPTION:
        Definitions for the Connect Library.
	** Don't forget to update connect.def correspondingly.
	
	$Id: connect.goh,v 1.1 97/04/04 15:59:37 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@ifndef __CONNECT_GOH
@define __CONNECT_GOH

@deflib connect

#include <geos.h>
@include <pccom.goh>
@include <foam.goh>
#include <Internal/ctXlatDr.h>		/* Connect Translate Driver */
@include <Internal/ctXferDr.goh>	/* Connect Transfer Driver */
@include <Objects/gCtrlC.goh>		/* include GenControlClass */
#include <file.h>			/* string size constants */
#include <initfile.h>



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  		Constants and Structures
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*
 * Desktop Connectivity Library Token Chars
 * These token chars are used in inter-application communication.
 */
#define	CONNECT_LIB_TOKEN	"DTCL"

/* 
 * Size of the Drive, Directory Path, and File Path setting strings 
 * with null termination.
 * These are defined here so applications know how big to make their
 * buffers.
 */
#define	CONNECT_SETTINGS_DRIVE_LENGTH_ZT	3
           /* 1 char for drive + 1 char for colon + 1 for the NULL */

#define	CONNECT_SETTINGS_PATH_LENGTH_ZT		(3 + DOS_STD_PATH_LENGTH + 1)
           /* 1 char for drive + 1 for colon + 1 for backslash
	      + path length + 1 for NULL */

/* 
 * Maximum length of a format name string, including null.
 * The format name string is always SBCS so its length = its size.
 */
#define FILE_FORMAT_NAME_SIZE		CTLD_FORMAT_NAME_SIZE

#define CONNECT_OPEN_CONNECTION_TIME_OUT	600 /* 10 seconds */


/*
 * The MultiFileArrayHeader and MultiFileArrayEntry structures are used by
 * the messages of ConnectMultiFileClass to form a chunk array of source and
 * destination paths for files to be uploaded or downloaded in a batch.
 */
typedef struct {
    ChunkArrayHeader    MFAH_CAH;
    char		MFAH_synopsis[81];
    dword		MFAH_size;
} MultiFileArrayHeader;

typedef struct {
    DiskHandle   MFAE_localDisk;
    byte         MFAE_remotePathOffset;
    char    	 MFAE_localFormat[FILE_FORMAT_NAME_SIZE];
    char    	 MFAE_remoteFormat[FILE_FORMAT_NAME_SIZE];
    char         MFAE_paths[1];
} MultiFileArrayEntry;

#define MAX_PRODUCT_ARRAY_ELEMENT_SIZE ((sizeof(MultiFileArrayEntry)) + \
					(2 * PATH_BUFFER_SIZE))
					

/* The PackageDescriptorArrayEntry structure is used by
 * ConnectMultiFileActionClass to form a chunk array of descriptive
 * information for different packages.
 *
 * Likely maximum sizes for package information.
 */
#define MAX_PACKAGE_NAME_LENGTH	        80
#define MAX_PACKAGE_SYNOPSIS_LENGTH	80
#define MAX_PACKAGE_SIZE_LENGTH	        14

#define MAX_PACKAGE_NAME_LENGTH_ZT	(MAX_PACKAGE_NAME_LENGTH + 1)
#define MAX_PACKAGE_SYNOPSIS_LENGTH_ZT	(MAX_PACKAGE_SYNOPSIS_LENGTH + 1)
#define MAX_PACKAGE_SIZE_LENGTH_ZT      (MAX_PACKAGE_SIZE_LENGTH + 1)
#define MAX_PACKAGE_INFO_LENGTH	        (MAX_PACKAGE_NAME_LENGTH_ZT + \
					 MAX_PACKAGE_SYNOPSIS_LENGTH_ZT + \
					 MAX_PACKAGE_SIZE_LENGTH_ZT)

typedef struct {
    byte    PDAE_synopsisOffset;
    byte    PDAE_sizeOffset;
    byte    PDAE_packageFilePathOffset;
    char    PDAE_data[1];  /* for: package name '/0'
			    *	   package synopsis '/0'
			    *	   package size '/0'
			    *	   server absolute path to package file '/0'
			    */
} PackageDescriptorArrayEntry;

/*
 * Passed to ConnectGetPackageDescriptorData routine to indicate what information
 * to return.
 */
typedef enum {
    PDDT_NAME,               /* package name */
    PDDT_SYNOPSIS,           /* package synopsis */
    PDDT_SIZE,               /* package size */
    PDDT_PATH                /* path to package's package file */
} PackageDescriptorDataType;

typedef struct {
    dword		PPAE_unused;
    StandardPath	PPAE_standardPath;
    char		PPAE_filePath[1]; /* for: local path to file '/0' */
} PackageProgressArrayEntry;


/*
 * State variables for the process of forcing a geode to quit.
 */
typedef struct {
    Boolean     CQGS_isApp;
      /* TRUE - if CONNECT_FORCE_GEODE is quitting an application geode. */

    optr        CQGS_geodesArray;
      /* The chunk array of app-geode handles to force to quit. */

    word        CQGS_arrayIndex;
      /* Current app (index into the gAppGeodesArray) to quit. */

    word        CQGS_numApps;
      /* The number of running applications. */

    TCHAR       CQGS_geodeName[GEODE_NAME_SIZE+GEODE_NAME_EXT_SIZE+1];
      /* Permanent name of the geode and ext and null-terminator */

    GeodeHandle CQGS_geode;
      /* Geode to quit. */

    word        CQGS_appCompletionMsg;
      /* Message to send when the geode finally quits. */

    optr        CQGS_appCompletionOptr;
      /* Object to receive the completion message. */

    word        CQGS_libCompletionMsg;
      /* Message to send when the library geode finally quits. */

    optr        CQGS_libCompletionOptr;
      /* Object to receive the library completion message. */

    GeodeHandle CQGS_excluded;
      /* Don't remove this app, when removing the library. */
} ConnectQuitGeodeState;

/*
 * Magic structure whose address you must pass to
 * ConnectDisableAppLaunchKeys().  Must agree with structure
 * definition in connect.def.  
 */
typedef struct {
    byte	CDALKM_monitor[18];
      /* You don't want to know what's in here (it's only defined in
	 assembly.)  18 is the size of struct Monitor in im.def. */

    optr	CDALKM_notifyOptr;
      /* Object to notify when if user hits a launch key while it's
	 prohibited to do so (i.e. this should probably bring up a
	 dialog telling them what's up). */

    Message	CDALKM_notifyMsg;
      /* Message to send to above object.  MUST NOT EXPECT ANY
	 ARGUMENTS. */
	 
} ConnectDisableAppLaunchKeysMonitor;

/*
 * These strings are passed to MSG_CONNECT_GET/SEND_FILE to 
 * specify source and destination file formats.  
 */
#define FAX_FORMAT              "fax"
#define TIFF_FORMAT             "tiff"
#define NOTES_FORMAT            "notes"
#define ASCII_FORMAT            "ascii"



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		.INI File Categories and Keys			 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

#define	CONNECT_INI_MAIN_CATEGORY	"connect"

#define	CONNECT_INI_SERIAL_PORT_KEY	"serialPort"
#define	CONNECT_INI_SERIAL_BAUD_KEY	"serialBaud"
#define	CONNECT_INI_INFRARED_PORT_KEY	"infraredPort"
#define	CONNECT_INI_INFRARED_BAUD_KEY	"infraredBaud"

/*
 * The ConnectSettingsControl object sends itself a 
 * MSG_META_GET_INI_CATEGORY to get the ini category to use when 
 * saving and reading the settings from the init file.
 * 
 * So, each app using a ConnectSettingsControlClass object should 
 * have a 
 *     ATTR_GEN_INIT_FILE_CATEGORY = "someCategoryNameString";
 * in its application object to specify the category string
 * to use when saving and reading the settings.
 */
#define	CONNECT_INI_CONNECTION_TYPE_KEY "connectionTypeSetting"
#define	CONNECT_INI_DATA_GROUP_KEY	"dataGroupSetting"
#define	CONNECT_INI_DRIVE_KEY		"driveSetting"
#define	CONNECT_INI_DIRECTORY_PATH_KEY	"directoryPathSetting"
#define	CONNECT_INI_FILE_PATH_KEY	"filePathSetting"


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  		Type defs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

#ifdef DO_DBCS
typedef TCHAR PathAndFileName[(PATH_BUFFER_SIZE+FILE_LONGNAME_BUFFER_SIZE)/2];
#else
typedef char PathAndFileName[PATH_BUFFER_SIZE+FILE_LONGNAME_BUFFER_SIZE];
#endif



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  		Enumerated types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
/*
 * Connection Types
 */
typedef enum {
    CT_SERIAL,
    CT_INFRARED
} ConnectionType;

/*
 * Data Groups
 */
typedef enum {
    DG_CONTACTS,
    DG_DOCUMENTS,
    DG_ALL_DATA,
    DG_CALENDAR,
} DataGroup;



/*
 * Connect Errors
 * 
 * NOTE: If you add/remove/change any of the ConnectError enums, be sure 
 *	 to make the same change to connect.def.
 */
#define	CE_DIALOG_DISPLAYED	0x8000
/* 
 * If this bit is set in a ConnectError and the ConnectError has been 
 * returned by the completion message for one of the messages listed 
 * below, it means that the connect library has already displayed an 
 * error dialog for the error. This is useful when the caller wants to 
 * know if it should display an error dialog itself.
 *
 * The following messages display error dialogs for ConnectErrors with 
 * the CE_DIALOG_DISPLAYED bit set:
 *	MSG_CONNECT_GET_FILE, MSG_CONNECT_SEND_FILE
 *	MSG_CMF_GET_FILE_ARRAY, MSG_CMF_SEND_FILE_ARRAY
 *	MSG_CMFA_LIST_PACKAGES
 *	MSG_CMFA_GET_PACKAGE
 *	MSG_CMFA_GET_PACKAGE_GIVEN_PACKAGE_FILE
 */
typedef enum {
    CE_SUCCESS = 0x0,
    CE_NOT_ENOUGH_MEMORY,
    /* There was not enough memory to perform the operation. */

    CE_MISC_FILE_ERROR,
    /* Some file error occurred. */

    CE_NOT_ENOUGH_DISK_SPACE_TO_START,
    /* There was not enough disk space to start the operation. */

    CE_NOT_ENOUGH_DISK_SPACE_TO_COMPLETE,
    /* There was not enough disk space to complete the operation, 
       which may have started. */

    CE_OPERATION_FAILED,
    /* The operation failed for some reason.
       The library does NOT put up a dialog for this error. */

    CE_USER_CANCELED,
    /* The user canceled the operation. */

    CE_FILE_TRANSFER_OPERATION_ALREADY_IN_PROGRESS,

    CE_DEST_DIRECTORY_DOES_NOT_EXIST,
    /* Tried to put file in directory but the directory did not exist. */


    /*
     * errors for ConnectSetServerPath
     */
    CE_CANNOT_SET_SERVER_PATH,
    /* Returned by ConnectSetServerPath if it was unable to set the path 
       on the server. 
       The library does NOT put up a dialog for this error. */

    /*
     * errors for ConnectGetServerPath
     */
    CE_CANNOT_GET_SERVER_PATH,
    /* Returned by ConnectGetServerPath if it was unable to get the path 
       from the server. 
       The library does NOT put up a dialog for this error. */

    /* 
     * errors for MSG_CONNECT_OPEN_CONNECTION
     */
    CE_CONNECTION_MEDIUM_IN_USE,
    /* There is some other app using the connection medium. 
       The user should have the other app quit using the connection 
       medium and try opening the connection again. */

    CE_CANNOT_START_CLIENT_SIDE_CONNECTION,
    /* Unable to start the client side part of the connection. */

    CE_CANNOT_CONTACT_SERVER,
    /* Unable to contact the server part of the connection.
       The user should check that the server software is running. */

    /* 
     * errors for MSG_CONNECT_CLOSE_CONNECTION
     */
    CE_CANNOT_CLOSE_CONNECTION,
    /* The connection was opened by a different application than the one
       trying to close the connection. 
       This would only happen if ConnectCloseConnection is called after
       ConnectOpenConnection has failed, which would be undesirable. */


    CE_NO_PACKAGES_FOUND,
    /* No packages could be found and listed. */

    CE_PACKAGE_FILE_INVALID,
    /* Returned by MSG_CMFA_GET_PACKAGE or 
       MSG_CMFA_GET_PACKAGE_GIVEN_PACKAGE_FILE.
       The library does NOT put up a dialog for this error.
       The package file for the chosen package is invalid. */

    CE_PACKAGE_INSTALLED_BUT_MUST_REBOOT_TO_USE,
    /* The package has been installed, almost.  The user must reboot the
       device to finish installation.  (Rebooting will overwrite some
       geodes that were in use at install time with newer versions. */

    CE_FILE_PROTOCOL_TOO_LOW,
    /* Internal ConnectError used by the get-package mechanism.
       The new file has a lower protocol than the preexisting file
       it would replace. */

    CE_UNABLE_TO_LOAD_TRANSFER_DRIVER,
    /* Returned if unable to load the transfer driver set via
       MSG_CONNECT_SET_TRANSFER_DRIVER. */

    CE_FILE_OPEN_BY_ANOTHER_APP,
    /* Another application has this local file opened. */

    /******************************************************************* 
     * The following connect errors are mapped from the PCCom library.
     *******************************************************************/
    CE_FILE_NOT_FOUND,
    /* PCCom cannot locate specified file.  Check filename spelling? */

    CE_PATH_NAME_INVALID,
    /* PCCom doesn't like the pathname.  Check for invalid characters
       and formatting. */

    CE_ACCESS_DENIED,
    /* PCCom couldn't modify the file and no details are given. */

    CE_FILE_NAME_INVALID,
    /* PCCom doesn't like the filename.  Check for invalid characters
       and formatting. */

    CE_VOLUME_UNAVAILABLE,
    /* PCCom can't access the volume medium; eg. disk drive doesn't
       have a disk in it. */

    CE_FILE_READ_ONLY,
    /* Target file has read-only status so we can't write to it. */

    CE_SHORT_READ_WRITE,
    /* While reading/writing a file, PCCom ran across this problem and
       has no explanation for it. */

    CE_VOLUME_WRITE_PROTECTED,
    /* PCCom was unable to modify the medium on the volume so assumes
       that it's write-protected. */
    /*
     * The following reported errors occurred on the REMOTE end.
     * These errors are analogous to the local errors as listed above.
     */
    CE_REMOTE_FILE_NOT_FOUND,
    /* PCCom cannot locate specified file.  Check filename spelling? */

    CE_REMOTE_PATH_NAME_INVALID,
    /* PCCom doesn't like the pathname.  Check for invalid characters
       and formatting. */

    CE_REMOTE_ACCESS_DENIED,
    /* PCCom couldn't modify the file and no details are given. */

    CE_REMOTE_FILE_NAME_INVALID,
    /* PCCom doesn't like the filename.  Check for invalid characters
       and formatting. */

    CE_REMOTE_FILE_OPEN_BY_ANOTHER_APP,
    /* A remote application has this remote file opened. */

    CE_REMOTE_FILE_READ_ONLY,
    /* Target file has read-only status so we can't write to it. */

    CE_REMOTE_SHORT_READ_WRITE,
    /* While reading/writing a file, PCCom ran across this problem and
       has no explanation for it. */

    CE_REMOTE_VOLUME_WRITE_PROTECTED,
    /* PCCom was unable to modify the medium on the volume so assumes
       that it's write-protected. */

    CE_REMOTE_USER_CANCELED,
    /* PCCom received an abort directive that did not originated from
       within the PCCom library. */

/*
 * The following errors are available on Communicator products shipped
 * after April 1997.  (Does not include those errors starting from 
 * CE_DIALOG_DISPLAYED.)
 */
    CE_OVERWRITE_CANCELLED,
    /* Used to distinguish between user cancelling a single overwrite
     * and a transfer operation which may consist of many files 
     * being transferred at once.
     */

/*
 * Start of ConnectErrors for which the main connect library messages
 * display error dialogs. See the CE_DIALOG_DISPLAYED documentation
 * for more details.
 */
    CE_OPERATION_ABORTED = CE_DIALOG_DISPLAYED,
    /* The operation was aborted for some reason.
       This error is returned when an operation has been started but aborts
       before it's done. The user should check the connection, etc. */

    CE_CANNOT_TRANSLATE_FILE,
    /* Some error occured when trying translate the file from one format to 
       another. This could be an error trying to load the translation driver
       or an error during the translation. */

    CE_CANNOT_CREATE_DIRECTORY,
    /* Tried to create directory but failed.   (Remote or local drive.) */

    CE_CONNECTION_LOST,
    /* PCCom has lost connection after retrying many times. Please check 
       the physical connection then try again. */

    CE_PATH_NOT_FOUND,
    /* PCCom cannot locate the specified path.  Check pathname spelling? */

    CE_DRIVE_INVALID,
    /* Target drive doesn't exist. */

    CE_SOURCE_FILE_OPEN_BY_ANOTHER_APP,
    /* Returned if the local source file is in use by another app
       and the CTF_NO_TRANSFER_IF_FILE_OPEN ConnectTransferFlags 
       was passed. */  

    CE_DEST_FILE_OPEN_BY_ANOTHER_APP,
    /* Returned if the local destination file is in use by another app
       and the CTF_NO_TRANSFER_IF_FILE_OPEN ConnectTransferFlags 
       was passed. */  

    CE_REMOTE_OPERATION_ABORTED,
    /* PCCom doesn't have a a reason for the abortion on the remote. */

    CE_REMOTE_PATH_NOT_FOUND,
    /* PCCom cannot locate the specified path.  Check pathname spelling? */

    CE_REMOTE_DRIVE_INVALID,
    /* Target drive doesn't exist. */

    CE_REMOTE_NOT_ENOUGH_DISK_SPACE_TO_COMPLETE,
    /* PC disk is out of space. */

    CE_REMOTE_VOLUME_UNAVAILABLE,
    /* PCCom can't access the volume medium; eg. disk drive doesn't
       have a disk in it. */

    CE_PACKAGE_OLD_SO_NOT_INSTALLED,
    /* Returned by MSG_CMFA_GET_PACKAGE or 
       MSG_CMFA_GET_PACKAGE_GIVEN_PACKAGE_FILE.
       No files in the package were installed because they had lower 
       protocols than versions already existing on the device. */

    CE_PACKAGE_NOT_COMPATIBLE,
    /* Returned by MSG_CMFA_GET_PACKAGE or 
       MSG_CMFA_GET_PACKAGE_GIVEN_PACKAGE_FILE.
       The package was not installed because it contains files that are not
       compatible with the software existing on the device. */

    CE_CANNOT_USE_INSTALL_BATCH_FILE_FOR_MORE_THAN_ONE_INSTALL,
    /* Returned by SetupNewFileToBeMovedOnReboot if the last installation
       changed the install batch file (install.bat), and the current
       installation will do so as well.  We can't allow this because if
       the current installation fails, the batch file is deleted which 
       would wipe out the previous, successful install. */

    CE_COULD_NOT_PREPARE_FOR_TRANSFER,
    /* Returned by MSG_CONNECT_PREPARE_FOR_TRANSFER if virtual serial
       port could not be reserved or another error is encountered.  
       Error dialog will have been displayed by the connect library. 
       MSG_CONNECT_RESET_AFTER_TRANSFER must NOT be called if this
       error has been returned because none of the set up actions were 
       effected.*/

} ConnectError;
/*
 * NOTE: If you add/remove/change any of the ConnectError enums, be sure 
 *	 to a make the same change to connect.def.
 */

/*
 * If you change ConnectSoundType, update connect.def too.
 */
typedef enum {
    CST_SUCCESS = 0x0,
    /*
     * Sound to play when operation is successful
     */
} ConnectSoundType;


/*
 * ConnectStandardDialogBoxType
 *
 * NOTES:
 *
 * The dialog can be of any CustomDialogType: CDT_QUESTION, CDT_WARNING, 
 *				              CDT_NOTIFICATION, CDT_ERROR
 *
 * Possible GenInteractionType's are: GIT_PROPERTIES, GIT_PROGRESS, 
 *				      GIT_COMMAND, GIT_NOTIFICATION,
 *				      GIT_AFFIRMATION
 *
 * Only GIT_NOTIFICATION and GIT_PROPERTIES interactions can have a custom
 * reply trigger.
 * 
 * The GIT_PROPERTIES dialogs return either IC_APPLY or IC_DISMISS.
 * The GIT_NOTIFICATION dialogs return IC_OK.
 *
 * To add a new type:
 *	1) Add an enumerated constant here.
 * 	2) Add a string for the body text (CSDS_???) in UI\uiStrings.goc.
 *	3) Add a string for title text, and/or trigger text if appropriate.
 *	4) Add a bitmap for the title icon if appropriate.
 *	5) Add extern's for the string and bitmap chunks to UI\uiDialogs.goc.
 *	5) Add an entry to the ConnectStdDialogEntryTable table in 
 *	   UI\uiDialogs.goc.
 */
typedef enum {
    /*
     * Common dialogs.
     */
    CSDBT_FILE_OVERWRITE_WARNING = 0x0,
    /* Trying to create file but file already exists. 
       Ask user if we should overwrite it. 
       CDT_QUESTION, GIT_PROPERTIES, arg1 = file name */

    CSDBT_CANNOT_COPY_TO_FILE,
    /* Trying to copy(transfer) a file but can't for some reason. 
       Display the reason if it's known. 
       CDT_NOTIFICATION, GIT_NOTIFICATION, arg1 = file name, arg2 = reason */

    CSDBT_CANNOT_COPY_FROM_FILE,
    /* Trying to copy(transfer) a file but can't for some reason. 
       Display the reason if it's known. 
       CDT_NOTIFICATION, GIT_NOTIFICATION, arg1 = file name, arg2 = reason */

    CSDBT_DEST_FILE_OPEN_BY_ANOTHER_APP,
    /* Destination file can not be overwriten because it's 
       open by another application. 
       CDT_NOTIFICATION, GIT_NOTIFICATION, arg1 = file name */

    CSDBT_CANNOT_FIND_DRIVE,
    /* Trying to change to drive but can't. 
       CDT_NOTIFICATION, GIT_NOTIFICATION, arg1 = drive */
    
    CSDBT_CANNOT_FIND_DIRECTORY,
    /* Trying to change to directory but can't. 
       CDT_NOTIFICATION, GIT_NOTIFICATION, arg1 = directory path */
    
    CSDBT_CANNOT_FIND_DISK_IN_REMOTE_DRIVE,
    /* Tried accessing the remote drive, but there wasn't a disk.
       CDT_NOTIFICATION, GIT_NOTIFICATION, arg1 = drive */

    CSDBT_DIRECTORY_DOES_NOT_EXIST_CREATE_IT,
    /* Trying to do something with directory but directory does not
       exits. Ask user if we should create the directory.
       CDT_QUESTION, GIT_PROPERTIES, arg1 = directory path */

    CSDBT_DIRECTORY_CREATE_ERROR,
    /* Trying to create directory but can't. 
       CDT_NOTIFICATION, GIT_NOTIFICATION, arg1 = directory path */

    CSDBT_CANNOT_ESTABLISH_CONNECTION,
    /* Trying to establish connection to PC but can't.
       CDT_NOTIFICATION, GIT_NOTIFICATION */

    CSDBT_CONNECTION_MEDIUM_ALREADY_IN_USE,
    /* Trying to switch to connection medium but it's already in use. 
       CDT_NOTIFICATION, GIT_NOTIFICATION */
    
    CSDBT_OPERATION_ABORTED,
    /* An operation was aborted.
       CDT_NOTIFICATION, GIT_NOTIFICATION */

    CSDBT_TRANSLATION_ERROR,
    /* Error during file translation.
       CDT_NOTIFICATION, GIT_NOTIFICATION, arg1 = reason for error */

    CSDBT_ILLEGAL_SETTING,
    /* The user gave an illegal setting to the settings controller.
       CDT_NOTIFICATION, GIT_NOTIFICATION, arg1 = setting name,
       arg2 = illegal setting text */

    CSDBT_CONNECTION_LOST,
    /* The connection was dropped after a number of failed attempts to
       re-connect.
       CDT_NOTIFICATION, GIT_NOTIFICATION */

    /*
     * Dialogs used by Get Package code.
     */
    CSDBT_REPLACE_EXISTING_SOFTWARE,
    /* A new package will replace some existing file with a 
       newer version.
       Ask user if we should replace it. 
       CDT_QUESTION, GIT_PROPERTIES, arg1 = package name */

    CSDBT_REPLACE_UNRELATED_SOFTWARE,
    /* A new package will replace some unrelated existing file.
       Ask user if we should replace it.
       CDT_QUESTION, GIT_PROPERTIES, arg1 = package name */

    CSDBT_REPLACE_EXISTING_DOCUMENT,
    /* A new package will replace an existing document.
       Ask user if we should replace it.
       CDT_QUESTION, GIT_PROPERTIES, arg1 = package name,
				     arg2 = existing document name */

    CSDBT_WILL_NEED_TO_REBOOT,
    /* After the package is installed, the device will need to 
       be rebooted for it to be usable.
       Tell the user what's going on and ask if we should continue.
       CDT_QUESTION, GIT_PROPERTIES, arg1 = package name */

    CSDBT_PACKAGE_OLD_SO_NOT_INSTALLED,
    /* No files in the package were installed because they had lower 
       protocols than versions already existing on the device.
       CDT_NOTIFICATION, GIT_NOTIFICATION, arg1 = package name */

    CSDBT_PACKAGE_NOT_COMPATIBLE,
    /* The package is not compatible with software existing on the 
       device. For example, the package contains a library with a major
       protocol different than the existing version on the device.
       CDT_NOTIFICATION, GIT_NOTIFICATION, arg1 = package name */

    CSDBT_CANNOT_USE_INSTALL_BATCH_FILE_FOR_MORE_THAN_ONE_INSTALL,
    /* The install batch file, used at reboot to copy files that were
       part of an installation, can only be used for one installation
       at a time.  This is because a *failed* installation that modified
       the batch file causes the batch file to be deleted.  But deletion
       would wipe out the work of any previous, successful installation.
       CDT_NOTIFICATION, GIT_NOTIFICATION */

    CSDBT_SOURCE_FILE_OPEN_BY_ANOTHER_APP,
    /* Source file can not be sent because it's open by another
       application.  
       CDT_NOTIFICATION, GIT_NOTIFICATION, arg1 = file name */
    
    CSDBT_NULL_SETTING,
    /* The user gave a blank setting to the settings controller.
       CDT_NOTIFICATION, GIT_NOTIFICATION, arg1 = setting name */

    CSDBT_REMOTE_NOT_ENOUGH_DISK_SPACE_TO_COMPLETE,
    /* PC disk is out of space.
       CDT_NOTIFICATION, GIT_NOTIFICATION */

    CSDBT_OUT_OF_MEMORY,
    /* Insufficient memory (heap space memory, that is) to perform operation. 
       CDT_NOTIFICATION, GIT_NOTIFICATION. */

    CSDBT_DATA_CALL_IN_PROGRESS,
    /* Connectivity operations are not allowed when a data call is in progress.
       CDT_NOTIFICATION, GIT_NOTIFICATION */

    CSDBT_THIS_IS_THE_LAST_ONE,
    /* This is just a dummy entry used for error checking.
       It must remain at the end of the list. */

} ConnectStandardDialogBoxType;


/*
 * Force geode to quit return value for completion message.
 */
typedef enum {
    CQGS_BUSY,
    /* 
     * The geode will not quit because it has one or more 
     * APP_MODE_CONNECTIONS.
     */

    CQGS_FAILED_IACP_CONNECTION,
    /*
     * Couldn't establish an IACP_CONNECTION with the geode; the geode may
     * not be running.
     */

    CQGS_FAILED,
    /*
     * Failed due to memory allocation error or other misc errors.
     */

    CQGS_SUCCESS,
    /* The geode has quit. */

} ConnectQuitGeodeStatus;


/*
 * Return values for the ConnectCheckLegalDos* routines.
 */
typedef enum {
    CCLE_LEGAL,
    CCLE_STRING_NULL,
    CCLE_STRING_TOO_LONG,
    CCLE_DOS_DEVICE_NAME_CONFLICT,
    CCLE_ONE_LETTER_DRIVE_NAME,
    CCLE_ILLEGAL_DOS_DRIVE_NAME,
    CCLE_ILLEGAL_DOS_DIR_PATH,
    CCLE_ILLEGAL_DOS_FILE_PATH,
    CCLE_ILLEGAL_DOS_FILE_NAME,

} ConnectCheckLegalError;





/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Connect Class


Notes on the ConnectClass
 
An application that wishes to use the Connect library to transfer 
files needs to include a connect object and send messages telling
it to transfer files.


Detaching, Quitting, and Lazarus:

The connect object prevents the application from being transparently
detached while an operation is in progress by setting and 
clearing the application's AS_AVOID_TRANSPARENT_DETACH flag.

If an application using a connect object is forced to detach while
a connect operation is in progress (someone calls SysShutdown or something
similar), the application should cancel the operation and delay passing the
MSG_META_DETACH to the application object's superclass until the operation
completion message has been received and handled. 
Applications should use the ConnectSubApplicationClass, which provides a
mechanism for doing this. Please refer to the ConnectSubApplicationClass
for more information.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@class  ConnectClass, MetaClass ;

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Messages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@message void MSG_CONNECT_OPEN_CONNECTION(ConnectionType cType,
					  sword timeOut,
					  optr completionOptr,
					  Message completionMsg);
/*
 * Desc:	Establish a connection to the server.
 *
 *		The connect library will display error dialogs for
 *		all errors that can occur while trying to establish 
 *		a connection.
 *
 * Context:	connect connection management
 * Source:	any object 
 * Destination:	any ConnectClass object
 * Interception:unlikely
 *
 * Pass:
 *	cType
 *		The type of connection to open.
 *	
 *	timeOut
 *		Number of clock tics to keep trying to open a connection.
 *		A value of -1 will cause the connect object to continue 
 *		trying to open the connection until it succeeds or the user
 *		presses the CANCEL button.
 *	
 *	completionOptr
 *	completionMsg
 *		Message to send upon completion of the operation or on an
 *		error and the optr to which it will be sent. The message 
 *		should be defined using the 
 *		CONNECT_OPEN_CONNECTION_COMPLETION_MSG prototype. The optr
 *		may be NULL if no completion message is desired.
 *
 * Return:
 *	void
 */

/* 
 * Message prototype for return message sent back from
 * MSG_CONNECT_OPEN_CONNECTION with the result of the attempt to 
 * open a connection.
 */
@prototype void CONNECT_OPEN_CONNECTION_COMPLETION_MSG(ConnectError error);


@message ConnectError MSG_CONNECT_CLOSE_CONNECTION();
/*
 * Desc:	Close the connection to the server.
 *
 * Context:	connect connection management
 * Source:	any object 
 * Destination:	any ConnectClass object
 * Interception:unlikely
 *
 * Pass:
 *	nothing
 *
 * Return:
 * 	ConnectError -	CE_SUCCESS
 *			CE_CANNOT_CLOSE_CONNECTION
 */



/*
 * Message prototype to be used by applications when defining a 
 * completion message to pass to the send and get messages.
 */
@prototype void CONNECT_COMPLETION_MSG(ConnectError error);

typedef ByteFlags ConnectTransferFlags ;
#define	   CTF_MULTIPLE_TRANSFER		0x10
/* If set, connect library will return different errors when
 * user cancels file specific queries.   Useful when doing a
 * multiple file transfer.
 * (e.g. cancelling overwrite does not mean user cancelled 
 * file transfer).
 * Available in Communicator products shipped after April 1997.
 */
#define	   CTF_DONT_RESERVE_VIRTUAL_SERIAL_PORT	0x08
/* If set, the connect object will NOT reserve the virtual
   serial port during connectivity operations. */
#define	   CTF_NO_TRANSFER_IF_FILE_OPEN		0x04
/* If set, the connect object will NOT try to get/send a file 
   if it is open locally by another app. */
#define    CTF_CREATE_DEST_PATH_DIRECTORY 	0x02
/* If set, an attempt will be made to create the destination path 
   if it does not exist. */
#define    CTF_QUERY_ON_OVERWRITE 		0x01
/* If set, check for overwriting an existing file and put up dialog 
   asking the user if we should overwrite. */




/*
 * MSG_CONNECT_SEND_FILE
 *
 * Desc:	Send a file to the server. 
 *
 *		Will translate the file format if localFormat and 
 *		remoteFormat are non null. After the file is translated
 *		the connect object will send the progress dialog, if any,
 *		a MSG_CONNECT_PROGRESS_DIALOG_SET_TRANSFER_SIZE with the 
 *		size of the translated file so the progress dialog will 
 *		display the correct total transfer size.
 *
 *		Note: This message does not support the use of transfer 
 *		      drivers.
 *
 * Context:	connect file transfer
 * Source:	any object 
 * Destination:	any ConnectClass object
 * Interception:unlikely
 *
 * Pass:
 *	localDiskHandle
 *	localFilePath	
 *		Source disk handle and source path and file name.
 *		The file name may be a GEOS FileLongName only if format
 *		translation is requested and the translation driver 
 *		takes a GEOS file.
 *		The file path specifies a path relative to the location
 *		specified by the corresponding disk handle. If the handle is
 *		a disk handle, the path is relative to that disk's root. If
 *		the handle is a standard path constant, the path is relative
 *		to that standard path. If the handle is null, the path is
 *		relative to the current working directory.
 *		Examples: 	SP_DOCUMENT, "foo\source.txt"
 *			  	SP_APPLICATION, "tetris.geo"
 *
 *	remoteFilePath	
 *		Destination path and DOS file name. 
 * 		The file path specifies either an absolute path with drive
 *		specifier or a path relative to the current
 *		directory on the server which can be changed with the
 *		ConnectSetServerPath routine. The file path can not start
 *		with a backslash.
 *		Examples: 	"temp\backup\file.txt"
 *				"file.txt"
 *				"c:\temp\file.txt"
 *				"..\backup\file.txt"
 *
 *	localFormat	      
 *	remoteFormat
 *		Strings indicating the format of the source file and
 *		destination file, used for format translation. May be
 *		NULL if no format translation is required.
 *
 *	progressDialog
 *		Optr of the ConnectProgressDialogClass object to recieve 
 *		the transfer status updates. May be NULL for no status 
 *		updates.
 *
 *	flags
 *		ConnectTransferFlags for this operation.
 *	
 *	completionOptr
 *	completionMsg
 *		Message to send upon completion of the operation or on an
 *		error and the optr to which it will be sent. The message 
 *		should be defined using the CONNECT_COMPLETION_MSG
 *		prototype. The optr may be NULL if no completion message is 
 *		desired.
 *		Error dialogs are displayed for	ConnectErrors with the
 *		CE_DIALOG_DISPLAYED bit set.
 *	
 * Return:
 *	void
 */
@message void
MSG_CONNECT_SEND_FILE(DiskHandle localDiskHandle,
		      TCHAR *localFilePath,
		      TCHAR *remoteFilePath,
		      char *localFormat,
		      char *remoteFormat,
		      optr progressDialog,
		      ConnectTransferFlags flags,		      
		      optr completionOptr,
		      Message completionMsg);


/*
 * MSG_CONNECT_GET_FILE
 *
 * Desc:	Get a file from the server.
 *
 *		Will translate the file format if localFormat and 
 *		remoteFormat are non null. 
 *
 *		Note: This message supports the use of a ConnectTransferDrivers
 *		      which may be set with the
 *		      MSG_CONNECT_SET_TRANSFER_DRIVER message.
 *	
 * Context:	connect file transfer
 * Source:	any object 
 * Destination:	any ConnectClass object
 * Interception:unlikely
 *
 * Pass:
 *	localDiskHandle
 *	localFilePath	
 *		Destination disk handle and desination path and file name.
 *		The file name may be a GEOS FileLongName only if format
 *		translation is requested and the translation driver 
 *		creates a GEOS file.
 *		The file path specifies a path relative to the location
 *		specified by the corresponding disk handle. If the handle is
 *		a disk handle, the path is relative to that disk's root. If
 *		the handle is a standard path constant, the path is relative
 *		to that standard path. If the handle is null, the path is
 *		relative to the current working directory.
 *		Examples: 	SP_DOCUMENT, "foo\dest.txt"
 *			  	SP_APPLICATION, "tetris.geo"
 *
 *	remoteFilePath	
 *		Source path and DOS file name. 
 * 		The file path specifies either an absolute path with drive
 *		specifier or a path relative to the current
 *		directory on the server which can be changed with the
 *		ConnectSetServerPath routine. The file path can not start
 *		with a backslash.
 *		If a ConnectTransferDriver is being used, the remoteFilePath 
 *		must be an absolute path.
 *		Examples: 	"temp\backup\file.txt"
 *				"file.txt"
 *				"c:\temp\file.txt"
 *				"..\backup\file.txt"
 *
 *	localFormat
 *	remoteFormat	      
 *		Strings indicating the format of the destination file and
 *		source file, used for format translation. May be
 *		NULL if no format translation is required.
 *
 *	progressDialog
 *		Optr of the ConnectProgressDialogClass object to recieve 
 *		the transfer status updates. May be NULL for no status 
 *		updates.
 *
 *	flags
 *		ConnectTransferFlags for this operation.
 *	
 *	completionOptr
 *	completionMsg
 *		Message to send upon completion of the operation or on an
 *		error and the optr to which it will be sent. The message 
 *		should be defined using the CONNECT_COMPLETION_MSG
 *		prototype. The optr may be NULL if no completion message is 
 *		desired.
 *		Error dialogs are displayed for	ConnectErrors with the
 *		CE_DIALOG_DISPLAYED bit set.
 *
 * Return:
 *	void
 */
@message void
MSG_CONNECT_GET_FILE(DiskHandle localDiskHandle,
		      TCHAR *localFilePath,
		      TCHAR *remoteFilePath,
		      char *localFormat,
		      char *remoteFormat,
		      optr progressDialog,
		      ConnectTransferFlags flags,		      
		      optr completionOptr,
		      Message completionMsg);
/*
 * Possible ConnectError's returned with completion message.
 *	XXX: NOT ACCURATE!!!!!!!!!!!
 *
 *		CE_SUCCESS
 *		CE_FILE_TRANSFER_OPERATION_ALREADY_IN_PROGRESS
 *		CE_USER_CANCELED
 *		CE_OPERATION_FAILED
 *		CE_CANNOT_CREATE_DIRECTORY
 *		CE_DEST_DIRECTORY_DOES_NOT_EXIST
 *		CE_CONNECTION_FAILED
 *		CE_NOT_ENOUGH_DISK_SPACE
 *		CE_NOT_ENOUGH_MEMORY
 *	   XXX: add any errors from DoFileFormatTranslation 
 *	   XXX: file open by other app error
 *	
 */


/*
 * Desc:	Cancel the current GET or SEND operation.
 *
 * Context:	connect file transfer
 * Source:	any object 
 * Destination:	any ConnectClass object
 * Interception:unlikely
 *
 * Pass:
 *	void
 * Return:
 *	void
 */
@message void MSG_CONNECT_CANCEL_TRANSFER();

/*
 * Desc:	Set a ConnectTransferDriver to use instead of the PCCom library.
 *		Currently only MSG_CONNECT_GET_FILE supports the use of
 *		a ConnectTransferDriver; MSG_CONNECT_SEND_FILE does not.
 *		You can switch back to using the PCCom library by calling
 *		MSG_CONNECT_SET_TRANSFER_DRIVER passing NULL.
 *
 * Context:	connect file transfer
 * Source:	any object 
 * Destination:	any ConnectClass object
 * Interception:unlikely
 *
 * Pass:
 *	driver
 *		The long name of the ConnectTransferDriver to use.
 *
 * Return:
 *	void
 */
@message void MSG_CONNECT_SET_TRANSFER_DRIVER(char *driver);

/*
 * Forces the given geode (library or app) to quit.  This is necessary
 * in certain cases like deinstallation.  This message does not guarantee
 * that the app/library will quit -- the completionOptr should check the 
 * error value of the completion message to be sure.  The completion message 
 * should be defined  using the CONNECT_QUIT_GEODE_COMPLETION_MSG prototype.
 *
 * Context:	deinstallation process or similar situations
 * Source:	any object
 * Destination:	any ConnectClass object
 * Interception:unlikely
 * Pass:        GeodeHandle geode - target geode
 *              word completionMsg - CONNECT_QUIT_GEODE_COMPLETION_MSG prototype
 *              optr completionOptr - object to receive completion message.
 *              optr exceptThisApp - usually the message caller or sender
 *                                   
 */
@message void MSG_CONNECT_FORCE_GEODE_TO_QUIT(GeodeHandle geode, 
					      word completionMsg, 
					      optr completionOptr, 
					      GeodeHandle exceptThisApp);



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Internal Messages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/* 
 * Internal message used by MSG_CONNECT_OPEN_CONNECTION to repeatedly 
 * try to contact the server in a cancellable fashion. 
 */
@message void MSG_CONNECT_CONTACT_SERVER();

/*
 * Internal messages used during file get and send operations.
 */
@message void MSG_CONNECT_CONTINUE_SEND_AFTER_TRANSLATION();
@message void MSG_CONNECT_FINISH_SEND_AFTER_TRANSFER();

@message void MSG_CONNECT_CONTINUE_GET_AFTER_TRANSFER();
@message void MSG_CONNECT_FINISH_GET_AFTER_TRANSLATION();

@message ConnectError MSG_CONNECT_HANDLE_ERROR(ConnectError error,
					       TCHAR *arg1,
					       TCHAR *arg2);

@message ConnectError MSG_CONNECT_START_TRANSLATION(DiskHandle sourceDiskHandle,
						    TCHAR *sourceFilePath,
						    char *sourceFormat,
						    DiskHandle destDiskHandle,
						    TCHAR *destFilePath,
						    char *destFormat);

@message void MSG_CONNECT_TRANSLATION_DONE(ConnectTranslateDriverError xlatError,
					   MemHandle driverArgs);

/*
 * Internal transfer status message sent from the PCCom library to the 
 * Connect object during PCComGet's and PCComSend's.
 */
@message (PCCOM_STATUS_MSG) MSG_CONNECT_PCCOM_TRANSFER_STATUS;

/*
 * Internal transfer status message sent from the Connect Transfer Driver
 * to the Connect object during DR_CTFD_GET_FILE and DR_CTFD_SEND_FILE's.
 */
@message (CONNECT_TRANSFER_DRIVER_STATUS_MSG) MSG_CONNECT_TRANSFER_DRIVER_TRANSFER_STATUS;

/*
 * Desc:	Internal messages.
 *		Allocate the vardata path buffers.
 *		Delete the vardata path buffers.
 *
 * Context:	connect file transfer
 * Source:	Connect object itself. 
 * Destination:	Connect object itself. 
 *
 * Interception:If someone is going to do multiple GET/SEND operations,
 *		they may want to subclass this message and
 *		MSG_CONNECT_DELETE_VARDATA_PATH_BUFFERS and set things
 *		up so the path buffers are only allocated once before 
 *		the multiple GET/SEND operations and delete once afterwards.
 *		That is, keep the Connect object from allocating and
 *		deleting the vardata path buffers during each single file 
 *		transfer operation.
 *
 * Pass:	void
 * Return:	void
 */
@message void MSG_CONNECT_ALLOCATE_VARDATA_PATH_BUFFERS();
@message void MSG_CONNECT_DELETE_VARDATA_PATH_BUFFERS();

@prototype void CONNECT_QUIT_GEODE_COMPLETION_MSG(GeodeHandle geode, 
					       ConnectQuitGeodeStatus status);

/*
 * When a library is asked to quit, via MSG_CONNECT_FORCE_GEODE_TO_QUIT, it
 * tells all running apps to shutdown, and this is the completion message for
 * each app that quits.
 *
 * Context:	shutting down of a library geode
 * Source:	ConnectClass object
 * Destination:	Connect
 * Interception:not likely
 *
 */
@message (CONNECT_QUIT_GEODE_COMPLETION_MSG) 
    MSG_CONNECT_CONTINUE_FORCE_LIBRARY_TO_QUIT;

/*
 * During a transfer, we don't want the application to transparently 
 * detach. These messages are used to prevent/allow transparent detaching.
 *
 * Also, the virtual serial port will be reserved during a transfer to
 * disable data calls unless the CTF_DONT_RESERVE_VIRTUAL_SERIAL_PORT
 * flag is set. If the port cannot be reserved, an error will
 * be returned and transparent detaching will not be prevented.  
 * MSG_CONNECT_RESET_AFTER_TRANSFER should NOT be called 
 * in this case.
 *
 * MSG_CONNECT_RESET_AFTER_TRANSFER will release the virtual
 * serial port if it was reserved, and will allow the app to be 
 * transparently attached. 
 *
 * Note:
 *	The MSG_CONNECT_{PREPARE_FOR/RESET_AFTER}_TRANSFER
 *	messages may be nested and we will not tell the application
 *	it can transparently detach nor release the virtual serial
 *	port until we've received a matching number of PREPARE/RESET
 *	messages.
 *
 *	This is useful when a subclass of the Connect object wants 
 *	to prevent the app from detaching around an operation that 
 *	uses MSG_CONNECT_(GET|SEND)_FILE.
 *
 * Context:      file transfer
 * Source:       ConnectClass (or subclass) object itself
 * Destination:  the object itself
 * Interception: not likely
 */
@message ConnectError 
    MSG_CONNECT_PREPARE_FOR_TRANSFER(ConnectTransferFlags flags);
@message void MSG_CONNECT_RESET_AFTER_TRANSFER();



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Instance data and defaults
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*
 * Status of the current GET or SEND operation.
 */
typedef WordFlags ConnectGetSendStatus ;

#define CGSS_USING_TRANSFER_DRIVER		0x0100
/* Set when a ConnectTransferDriver is being used instead of
   the PCCom library. */

#define CGSS_USER_CANCELED			0x0080
/* Set when the user has canceled the operation. */

#define CGSS_SEND_REMOVE_TEMP_FILE		0x0040
/* Set when doing a file SEND and translation was done.
   The source file was translated into a temporary file
   and the temporary file is being transferred to the PC. 
   The Connect object will remove the temporary file when 
   the transfer has completed. */

#define	CGSS_SEND_IN_PROGRESS			0x0020
/* Set when the connect object is in the process of SEND'ing a file. */

#define	CGSS_GET_DEST_FILE_EXISTS		0x0010
/* Set when there is an existing destination file
   during a GET operation. */

#define CGSS_GET_MOVE_TEMP_TO_DEST		0x0008
/* Set when doing a file GET and an existing destination file 
   will be overwritten and there is room for a temp file.
   The source file is being transferred into a temporary file
   and the Connect object will move the temporary file to
   the dest file when the transfer has completed. */

#define	CGSS_GET_TRANSFER_INTO_TEMP		0x0004
/* Set when doing a file GET and the source file is 
   being transfered into a temp file. */

#define	CGSS_GET_NEED_TRANSLATION		0x0002
/* Set when doing a file GET and a translation is needed.
   The source file is being transferred into a temporary file
   and the Connect object will translate the temporary file 
   into the dest file when the transfer has completed. */

#define	CGSS_GET_IN_PROGRESS			0x0001
/* Set when the connect object is in the process of GET'ing a file. */


/*
 * Context:	Status of the current transfer.
 * Usage:	Used by the connect object to check if an operation is 
 *		currently in progress before starting a new one.
 *		Also used by the connect object to remember what it
 *		needs to do when a GET or SEND transfer is completed 
 *		(ie, move the temp file to the destination or translate 
 *		the temp file to the destination or remove the temp file.)
 *		Also used by the connect object to figure out what needs
 *		to be cleaned up when a GET or SEND operation is canceled.
 */
@instance	ConnectGetSendStatus CI_connectGetSendStatus = 0x0000;

/*
 * Context:	Optr and message to send upon transfer completion.
 * Usage:	Used by the Connect object to remember where and what
 *		message to send when the GET/SEND operation completes 
 *		or is canceled.
 */
@instance	optr	CI_notifyOnCompletionOptr = NullOptr ;
@instance	Message	CI_notifyOnCompletionMsg = NULL ;

/*
 * Context:	Optr of progress dialog for transfer progress updates.
 * Usage:	Used by the Connect object to send progress updates 
 *		during file transfers.
 */
@instance	optr	CI_progressDialogOptr = NullOptr ;

/*
 * Context:	Path and filename of temp file.
 * Usage:	Used when translating a file or GET'ing a file to 
 *		to a temporary file before overwriting the destination.
 *		Also used by the send operation to save the source file
 *		path between stage 1 and 2 when there is no translation.
 */
@instance	DiskHandle	CI_tempDiskHandle = NULL;
@vardata	PathAndFileName TEMP_CONNECT_TEMP_FILE_PATH;

/*
 * Context:	Path and filename of transfer destination, and
 *              file handle of already existing destination.
 * Usage:	This data is used by the connect object when the 
 *		GET transfer completes to move the temp file to the 
 *		destination.
 *		The CI_destFilePath is also used by the SEND operation
 *		to save the destination file path between stage 1 and 2
 *		of the send operation.
 *		
 *		If the GET operation is overwriting an existing destination 
 *		file, we try to open the existing file for exclusive access
 *		to prevent another app from opening it while the GET is in
 *		progress. If the open is successful, the file handle is
 *		stored in the CI_originalDestFile instance data.
 */
@instance	DiskHandle	CI_destDiskHandle ;
@vardata	PathAndFileName TEMP_CONNECT_DEST_FILE_PATH;
@instance       FileHandle      CI_originalDestFile = NullHandle;

/*
 * Context:	Source and destination file formats.
 *		Only for a GET operation.
 * Usage:	This data is used by the connect object when the 
 *		GET transfer completes to translate the temp file 
 *		to the destination. 
 */
@instance	char	CI_sourceFormat[FILE_FORMAT_NAME_SIZE] ;
@instance	char	CI_destFormat[FILE_FORMAT_NAME_SIZE] ;

/*
 * Context:	Handle of data block used for the get operation.
 *		Only for a GET operation.
 * Usage:	
 *		
 */
@instance	MemHandle	CI_getSourceDataBlock = NullHandle ;

/*
 * Instance data for file format translation.
 */
/* Context:	Handle of translation thread. */
@instance	ThreadHandle	CI_xlateThread = NullHandle;

/* Context:	Handle of translation driver geode. */
@instance	GeodeHandle	CI_xlateDrvHandle = NullHandle;

/* Context:	fptr to translation driver strategy routine. */
@instance	void (*CI_xlateDrvStratRoutine)() = NULL;

/*
 * Instance data for open connection operation.
 */

@instance	optr		CI_openConnectionDialog = NullOptr;
@instance	optr		CI_openConnectionReturnObj = NullOptr;
@instance	Message		CI_openConnectionReturnMsg = NULL;
@instance	dword		CI_openConnectionTimeOutTime;

typedef ByteFlags ConnectOpenConnectionTimeOutFlags;
#define	COCTOF_INFINITE			0x02
/* Set if the user wants an infinite time out. */
#define	COCTOF_OVERFLOW			0x01
/* Internally used to indicate that the system tic counter will overflow. */
@instance	ConnectOpenConnectionTimeOutFlags CI_openConnectionTimeOutFlags;

/*
 * Instance data for using a ConnectTransferDriver.
 *
 * Context:	Name of ConnectTransferDriver to use.
 *		If NULL, PCCom is used.
 */
@instance	FileLongName	CI_xferDriverName = NULL;

/* Context:	Handle of ConnectTransferDriver geode. */
@instance	GeodeHandle	CI_xferDrvHandle = NullHandle;

/* Context:	fptr to ConnectTransferDriver strategy routine. */
@instance	void (*CI_xferDrvStratRoutine)() = NULL;

@vardata	ConnectQuitGeodeState TEMP_CONNECT_QUIT_VARS;

/*
 * Context:	Counter for ALLOW/PREVENT transparent detach mechanism
 * Usage:	Used by MSG_CONNECT_(ALLOW|PREVENT)_APP_TRANSPARENT_DETACH
 */
@instance	word		CI_avoidDetachCount = 0;

/*
 * Status of the connection to the server.
 */
typedef ByteFlags ConnectConnectionStatus;
#define CCS_VIRTUAL_SERIAL_PORT_RESERVED	0x02
/* Set when the connect object has the virtual serial 
   port reserved. */
#define CCS_CONNECTION_OPEN			0x01
/* Set when the connect object has an open connection
   to the server. */

/*
 * Context:	INTERNAL: Status of the connection to the server.
 * Usage:	Used by the connect object to store the 
 *		connection status.
 */
@instance	ConnectConnectionStatus	CI_connectionStatus = 0x00;

/*
 * Context:	INTERNAL: IACP Connection token of the connection to 
 *			  a document server.
 * Usage:	This vardata is used by the get file code to store 
 *		the token for the connection to the document server when 
 *		it tries to gain access to an existing file. The file
 *		access is released when MSG_CONNECT_HANDLE_ERROR calls
 *		UtilReleaseFileAccess.
 */
@vardata	IACPConnection	TEMP_CONNECT_IACP_CONNECTION_TOKEN;


@endc	/* ConnectClass */


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		ConnectMultiFileClass

ConnectMultiFileClass is subclassed from ConnectClass to provide
synchronization for cases where files are batch transferred.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
@class ConnectMultiFileClass, ConnectClass;

/*
 * MSG_CMF_GET_FILE_ARRAY, MSG_CMF_SEND_FILE_ARRAY
 *
 * Desc:	Gets (sends) a bunch of file from (to) the server.
 *		May also translate the file format.
 *
 * Context:	connect file transfer
 * Source:	any object 
 * Destination:	any ConnectMultiFileClass object
 * Interception:unlikely
 *
 * Pass:
 *  	array
 *  	    Optr to a chunk array of MultiFileArrayEntry structures.  
 *          The chunk array should reside in its own block and will be 
 *          freed in MSG_CMF_FINISH_FILE_ARRAY.  
 *
 *	flags		= ConnectTransferFlags
 *
 *      progressDialog	= optr of associated ConnectProgressDialog.
 *			  May be NullOptr.
 *
 *	completionOptr
 *	completionMsg
 *		Message to send upon completion of the operation or on an
 *		error and the optr to which it will be sent. The message 
 *		should be defined using the CONNECT_COMPLETION_MSG
 *		prototype. The optr may be NULL if no completion message is 
 *		desired.
 *		Error dialogs are displayed for	ConnectErrors with the
 *		CE_DIALOG_DISPLAYED bit set.
 *  	    
 * NOTE for MSG_CMF_SEND_FILE_ARRAY:
 *	If any of the MultiFileArrayEntry's request that a file be
 *	translated, do NOT use a progress dialog that displays the
 *	the total transfer size. Translation changes the file size 
 *	causing the total transfer size to not match the cumulative 
 *	byte tally. This does not apply to MSG_CMF_GET_FILE_ARRAY 
 *	because during a get operation, the files are transfered 
 *	before being translated.
 */
@message void MSG_CMF_GET_FILE_ARRAY(
	optr array,
	ConnectTransferFlags flags,
	optr progressDialog,
	optr completionOptr,
	Message completionMsg);
@message void MSG_CMF_SEND_FILE_ARRAY(
	optr array,
	ConnectTransferFlags flags,
	optr progressDialog,
	optr completionOptr,
	Message completionMsg);

/*
 * MSG_CMF_GET_NEXT_FILE, MSG_CMF_SEND_NEXT_FILE
 *
 * Desc:	Gets (sends) a file from (to) the server, as specified
 *  	    	by the MultiFileArray in the object's instance data.
 *
 * Context:	connect file transfer
 * Source:  	any object 
 * Destination:	any ConnectClass object
 * Interception: Subclass this message to perform any file-by-file functions
 *  	    	 during a batch transfer.
 *
 * Pass:
 *  	see CONNECT_COMPLETION_MSG prototype
 *  	    
 */
@message (CONNECT_COMPLETION_MSG) MSG_CMF_SEND_NEXT_FILE;
@message (CONNECT_COMPLETION_MSG) MSG_CMF_GET_NEXT_FILE;

/*
 * MSG_CMF_FINISH_FILE_ARRAY
 *
 * Desc:	Deals with various clean-up issues once the file array has
 *  	    	been transferred. Frees the chunk array and the block it
 *		resides in and then sends the completion AD, etc.
 *
 * Pass:
 *  	    error
 *  	    	ConnectError to pass on to the completion message.
 *
 */
@message void MSG_CMF_FINISH_FILE_ARRAY(ConnectError error);



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Instance data and defaults
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*
 * Status of the current GET or SEND operation.
 */
typedef WordFlags ConnectMFGetSendStatus ;

#define CMFGSS_DO_NOT_ALLOCATE_OR_DELETE_PATH_BUFFERS	0x0002
/* Set when the subclassed messages 
   MSG_CONNECT_(ALLOCATE|DELETE)_VARDATA_PATH_BUFFERS 
   should not allocate/delete the vardata path buffers. */

#define CMFGSS_TRANSFER_CANCELED			0x0001
/* Set when the multi-file transfer in progress has been 
   cancelled by the user. */



/*
 * CMFI_fileArray keeps track of the MultiFileArray during successive calls
 * to MSG_CMF_GET(SEND)_NEXT_FILE. This field is set by
 * MSG_CMF_GET(SEND)_FILE_ARRAY.
 */
@instance	optr		CMFI_fileArray = NullOptr;

/*
 * CMFI_nextFile is an index into CMFI_fileArray, specifying which file
 * should be sent or retrieved next.
 */
@instance	word		CMFI_nextFile = 0;

@instance	optr		CMFI_progressDialog = NullOptr;

/*
 * CMFI_completionOptr and CMFI_completionMsg store the AD to send
 * once the entire array has been transferred.
 */
@instance	optr		CMFI_completionOptr = NullOptr;
@instance	Message		CMFI_completionMsg = 0;

/*
 * Status of the multi-file transfer in progress is kept in this
 * field.
 */
@instance       ConnectMFGetSendStatus CMFI_connectmfGetSendStatus = 0;

/*
 * Context:	INTERNAL: Temporary vardata storage used to pass the
 *			  ConnectTransferFlags from
 *			  MSG_CMF_(GET|SEND)_FILE_ARRAY to 
 *			  MSG_CMF_(GET|SEND)_NEXT_FILE.
 *
 * Usage:	This vardata is allocated and set by the 
 *		MSG_CMF_(GET|SEND)_FILE_ARRAY, used by
 *		MSG_CMF_(GET|SEND)_NEXT_FILE, and deleted by
 *		MSG_CMF_FINISH_FILE_ARRAY.
 */
@vardata	ConnectTransferFlags	TEMP_CMF_CONNECT_TRANSFER_FLAGS;

@endc	/* ConnectMultiFileClass */



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		ConnectMultiFileActionClass

ConnectMultiFileActionClass is subclassed from ConnectMultiFileClass
to allow the sending of a message to deal with each file in a batch
file transfer upon its receipt.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
@class ConnectMultiFileActionClass, ConnectMultiFileClass;

/*
 * MSG_CMFA_SET_FILE_ACTION
 *
 * Desc:	Sets the action to take upon receipt of a file
 *
 * Context:	Caller wants to do something with each file in the
 *		course of a multi-file get.
 * Source:	any object
 * Destination:	any ConnectMultiFileActionClass object
 * Interception:unlikely
 *
 * Pass:
 *  	fileActionOptr
 *  	fileActionMsg
 *		Message to send upon receipt of a file and the optr to
 *		which it will be sent. The message should be defined
 *		using the CMFA_FILE_ACTION_MSG prototype. The optr may 
 *		be NULL if no file action message is desired. 
 */
@message void MSG_CMFA_SET_FILE_ACTION(optr fileActionOptr, 
				       Message fileActionMsg);

/*
 * Message prototype to be used when defining a file action 
 * message to pass to MSG_CMFA_SET_FILE_ACTION.
 * The completionOptr and completionMsg will be filled in by 
 * the ConnectMultiFileActionClass when it sends off the file
 * action message. 
 */
@prototype void CMFA_FILE_ACTION_MSG(optr completionOptr, 
				     Message completionMsg);

/*
 * MSG_CMFA_GET_FILE_DETAILS_BLOCK
 *
 * Desc:	Gets the block detailing the file transfer just completed
 *
 * Context:	Caller has received the CMFAI_fileActionMsg in the course of
 *		a multi-file get, and needs to find out what file to handle.
 * Source:	any object
 * Destination:	any ConnectMultiFileActionClass object
 * Interception:unlikely
 *
 * Pass:
 *	nothing
 *		
 * Return:
 *	handle of the CMFAI_fileDetailsBlock
 *  	    
 */
@message MemHandle MSG_CMFA_GET_FILE_DETAILS_BLOCK();

/*
 * MSG_CMFA_ALLOCATE_PACKAGE_ARRAY
 *
 * Desc:	Allocates CMFAI_packageArray.
 *
 * Context:	Caller wants to start using the array
 * Source:	any object
 * Destination:	any ConnectMultiFileActionClass object
 * Interception:unlikely
 *
 * Pass:
 *	headerSize	= size to allocate
 *		
 * Return:
 *  	nothing    
 */
@message void MSG_CMFA_ALLOCATE_PACKAGE_ARRAY(
	word headerSize);

/*
 * Message prototype to be used by applications when defining a 
 * completion message to pass to MSG_CMFA_LIST_PACKAGES.
 */
@prototype void CMFA_LIST_PACKAGES_COMPLETION_MSG(ConnectError error,
						  optr packageArray);

/*
 * MSG_CMFA_LIST_PACKAGES
 *
 * Desc:	Initiates the process of getting a list of the software
 *              packages available on the specified drive of the server.
 *
 * Context:	Caller needs to display a list of downloadable packages
 * Source:	any object
 * Destination:	any ConnectMultiFileActionClass object
 * Interception:unlikely
 *
 * Pass:
 *  	remotePath
 *  	    string indicating absolute remote path from which to list packages
 *	flags		= ConnectTransferFlags
 *	progressDialog	= optr of associated ConnectProgressDialog.
 *			  May be NullOptr.
 *	completionOptr
 *	completionMsg
 *		Message to send upon completion of the operation or on an
 *		error and the optr to which it will be sent. The message 
 *		should be defined using the CMFA_LIST_PACKAGES_COMPLETION_MSG
 *		prototype. The optr may be NULL if no completion message is 
 *		desired.
 *		Error dialogs are displayed for	ConnectErrors with the
 *		CE_DIALOG_DISPLAYED bit set.
 */
@message void MSG_CMFA_LIST_PACKAGES(
	TCHAR *remotePath,
	ConnectTransferFlags flags,
	optr progressDialog,
	optr completionOptr,
	Message completionMsg);

/*
 * Message prototype to be used by applications when defining a 
 * completion message to pass to MSG_CMFA_GET_PACKAGE or 
 * MSG_CMFA_GET_PACKAGE_GIVEN_PACKAGE_FILE.
 */
@prototype void CMFA_GET_PACKAGE_COMPLETION_MSG(ConnectError error);

/*
 * MSG_CMFA_GET_PACKAGE
 *
 * Desc:	Downloads the package specified by the passed index
 *		into the passed PackageDescriptorArray.
 * Context:	Caller wants to download selected package
 * Source:	anyone
 * Destination:	any ConnectMultiFileActionClass object
 * Interception:unlikely
 *
 * Pass:
 *	packageArray	= optr to chunk array of PackageDescriptorArrayEntries
 *	n		= index of package to get
 *	flags		= ConnectTransferFlags
 *	progressDialog	= optr of associated ConnectProgressDialog
 *			  May be NullOptr.
 *	completionOptr
 *	completionMsg
 *		Message to send upon completion of the operation or on an
 *		error and the optr to which it will be sent. The message 
 *		should be defined using the CMFA_GET_PACKAGE_COMPLETION_MSG
 *		prototype. The optr should be NullOptr if no completion 
 *		message is desired.
 *		Error dialogs are displayed for	ConnectErrors with the
 *		CE_DIALOG_DISPLAYED bit set.
 */
@message void MSG_CMFA_GET_PACKAGE(
	optr packageArray,
	word n,
 	ConnectTransferFlags flags,
	optr progressDialog,
	optr completionOptr,
	Message completionMsg);

/*
 * MSG_CMFA_GET_PACKAGE_GIVEN_PACKAGE_FILE
 *
 * Desc:	Downloads the package specified by the passed
 *              local package file path and remote package path
 * Context:	Caller already has the package file locally, knows where
 *              the package is, and wants to download it
 * Source:	anyone
 * Destination:	any ConnectMultiFileActionClass object
 * Interception:unlikely
 *
 * Pass:
 *	Gets the package specified in the passed package file.
 *	
 *	localDiskHandle
 *	localPackageFilePath	
 *		Disk handle and local path and file name of package file.
 *		The file path specifies a path relative to the location
 *		specified by the corresponding disk handle. If the handle is
 *		an actual disk handle, the path is relative to that disk's 
 *		root. If the handle is a standard path constant, the path is
 *		relative to that standard path. If the handle is null, the
 *		path is relative to the current working directory.
 *		Examples: 	SP_DOCUMENT, "foo\package.ins"
 *			  	SP_TEMP_FILES, "package.ins"
 *	remotePackagePath
 *		Absolute remote directory path with drive specifier to 
 *		package, not including any file name. The source paths of
 *		the files listed in the package file are relative to this 
 *		remotePackagePath. The directory path cannot end with 
 *		a backslash.
 *		Examples: 	"c:\install"
 *			  	"f:"
 *
 *	flags		= ConnectTransferFlags
 *	progressDialog	= optr of progress dialog to which progress
 *			  updates should be sent.
 *			  Pass NullOptr if no progress reports are desired.
 *	completionOptr
 *	completionMsg
 *		Message to send upon completion of the operation or on an
 *		error and the optr to which it will be sent. The message 
 *		should be defined using the CMFA_GET_PACKAGE_COMPLETION_MSG
 *		prototype. The optr should be NullOptr if no completion
 *		message is desired. 
 *		Error dialogs are displayed for	ConnectErrors with the
 *		CE_DIALOG_DISPLAYED bit set.
 */
@message void MSG_CMFA_GET_PACKAGE_GIVEN_PACKAGE_FILE(
	DiskHandle localDiskHandle,
	TCHAR *localPackageFilePath,
	TCHAR *remotePackagePath,
	ConnectTransferFlags flags,
	optr progressDialog,
	optr completionOptr,
	Message completionMsg);

/*
 * MSG_CMFA_CANCEL_GET_PACKAGE
 *
 * Desc:	Cancels current transfer and deletes all files so far
 *		downloaded. 
 *
 * Context:	Caller wants to cancel and clean up.
 * Source:	anyone
 * Destination:	any ConnectMultiFileActionClass object
 * Interception:unlikely
 *
 * Pass:
 *  	    nothing
 */
@message void MSG_CMFA_CANCEL_GET_PACKAGE();


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Internal Messages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*
 * MSG_CMFA_FINISH_LIST_PACKAGES
 *
 * Desc:	Cleans up after a package listing and sends CMFAI_completionMsg
 *              (with a ConnectError and PackageDescriptorArray optr) to
 *		CMFAI_completionOptr.
 *
 * Context:	INTERNAL. Call specified within MSG_CMFA_LIST_PACKAGES.
 * Source:	any ConnectMultiFileActionClass object
 * Destination:	any ConnectMultiFileActionClass object
 * Interception:unlikely
 *
 * Pass:
 *  	see CONNECT_COMPLETION_MSG prototype
 *  	    
 */
@message (CONNECT_COMPLETION_MSG) MSG_CMFA_FINISH_LIST_PACKAGES;

/*
 * MSG_CMFA_CONTINUE_GET_PACKAGE
 *
 * Desc:	Parses the retrieved package file and downloads the
 *		specified files.
 *
 * Context:	INTERNAL. Call specified within MSG_CONNECT_GET_PACKAGE.
 * Source:	any ConnectMultiFileActionClass object
 * Destination:	any ConnectMultiFileActionClass object
 * Interception:unlikely
 *
 * Pass:
 *  	see CONNECT_COMPLETION_MSG prototype
 *  	    
 */
@message (CONNECT_COMPLETION_MSG) MSG_CMFA_CONTINUE_GET_PACKAGE;

/*
 * MSG_CMFA_FINISH_GET_PACKAGE
 *
 * Desc:	Cleans up after a package download and sends 
 *		CMFAI_completionMsg (with a ConnectError) to
 *		CMFAI_completionOptr. 
 *
 * Context:	INTERNAL. Call specified within MSG_CMFA_GET_PACKAGE.
 * Source:	any ConnectMultiFileActionClass object
 * Destination:	any ConnectMultiFileActionClass object
 * Interception:unlikely
 *
 * Pass:
 *  	see CONNECT_COMPLETION_MSG prototype
 *  	    
 */
@message (CONNECT_COMPLETION_MSG) MSG_CMFA_FINISH_GET_PACKAGE;

/*
 * MSG_CMFA_UPDATE_PACKAGE_DESCRIPTOR_ARRAY
 *
 * Desc:	Reads the package name, description, and size out of a package
 *              file and stores them in a PackageDescriptorArrayEntry
 *		chunk in CMFAI_packageArray.
 *
 * Context:	INTERNAL. Call specified within MSG_CMFA_LIST_PACKAGES.
 * Source:	any ConnectMultiFileActionClass object
 * Destination:	any ConnectMultiFileActionClass object
 * Interception:unlikely
 *
 * Pass:
 *  	see CMFA_FILE_ACTION_MSG prototype
 *  	    
 */
@message (CMFA_FILE_ACTION_MSG) MSG_CMFA_UPDATE_PACKAGE_DESCRIPTOR_ARRAY;

/*
 * MSG_CMFA_FILE_ACTION_FOR_GET_PACKAGE
 *
 * Desc:	This is the file action message that gets sent out to 
 *		deal with each file downloaded durring a get package 
 *		operation.
 *
 * Context:	INTERNAL. Call specified within MSG_CONNECT_GET_PACKAGE.
 * Source:	any ConnectMultiFileActionClass object
 * Destination:	any ConnectMultiFileActionClass object
 * Interception:unlikely
 *
 * Pass:
 *  	see CMFA_FILE_ACTION_MSG prototype
 */
@message (CMFA_FILE_ACTION_MSG)	MSG_CMFA_FILE_ACTION_FOR_GET_PACKAGE;
@message (CONNECT_QUIT_GEODE_COMPLETION_MSG)
    MSG_CMFA_FILE_ACTION_FOR_GET_PACKAGE_STAGE_2;

/*
 * MSG_CMFA_CONTINUE_GET_NEXT_FILE
 *
 * Desc:	INTERNAL: Second part of the ConnectMultiFileActionClass
 *		MSG_CMF_GET_NEXT_FILE handler. 
 *
 *		Note that this message must be defined to take the same 
 *		parameters as MSG_CMF_GET_NEXT_FILE. See the 
 *		MSG_CMFA_CONTINUE_GET_NEXT_FILE code for more details.
 *
 * Context:	INTERNAL. ConnectMultiFileActionClass multi-file get.
 * Source:	ConnectMultiFileActionClass object
 * Destination:	ConnectMultiFileActionClass object
 * Interception:unlikely
 *
 * Pass:
 *  	see CONNECT_COMPLETION_MSG prototype
 */
@message (CONNECT_COMPLETION_MSG) MSG_CMFA_CONTINUE_GET_NEXT_FILE;


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Instance data and defaults
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*
 * CMFAI_packageArray stores the OD for the chunk array of
 * PackageDescriptorArrayEntries created when listing packages,
 * or for the array of PackageProgressArrayEntries created when
 * getting a package.
 */
@instance	optr		CMFAI_packageArray = NullOptr;
/*
 * CMFAI_fileDetailsBlock stores the MultiFileArrayEntry for the file just 
 * received.
 */
@instance	MemHandle	CMFAI_fileDetailsBlock = NullHandle;
/*
 * CMFAI_fileActionOptr and CMFAI_fileActionMsg store the AD to call
 * upon receipt of each file.
 */
@instance	optr		CMFAI_fileActionOptr = NullOptr;
@instance	Message		CMFAI_fileActionMsg = 0;
/*
 * CMFAI_completionOptr and CMFAI_completionMsg store the AD to send
 * once the whole transfer operation has completed.
 */
@instance	optr		CMFAI_completionOptr = NullOptr;
@instance	Message		CMFAI_completionMsg = 0;

/*
 * Status of the current get package operation if any.
 */
typedef WordFlags ConnectMFAGetPackageStatus;


#define CMFAGPS_REPLACE_DOCUMENT_DIALOG_DISPLAYED	0x0200
/*
 * Set if the "replacing existing document" dialog 
 * has been displayed for this particular file being
 * downloaded from a package.
 *
 * This flag is cleared by MSG_CMFA_FILE_ACTION_FOR_GET_PACKAGE
 * and checked/set by DisplayReplaceExistingDocumentDialog.
 */

#define CMFAGPS_REBOOT_DIALOG_DISPLAYED			0x0100
#define CMFAGPS_EXISTING_DIALOG_DISPLAYED		0x0080
#define CMFAGPS_UNRELATED_DIALOG_DISPLAYED		0x0040
/*	
 * These flags are set if the corresponding dialog 
 * has already been displayed during the current 
 * package install. 
 */


#define CMFAGPS_FILE_INSTALLED_FROM_PACKAGE		0x0010
/*
 * Set if at least one file from the current 
 * package has been installed. This flag is
 * used to determine if the "package not installed"
 * dialog should be displayed.
 */

#define CMFAGPS_NEED_TO_REBOOT				0x0008
/*
 * Set if the device needs to be re-booted in order 
 * for the package just install to be usable.
 */

#define CMFAGPS_NEW_FILE_IS_GEOS_FILE			0x0004
/*
 * Set if the file being downloaded from the package
 * is a GEOS file.
 */
#define CMFAGPS_EXISTING_LOCAL_DEST_FILE		0x0002
/* 
 * Set when the file being downloaded from a package
 * will overwrite an existing local destination file.
 * By local is meant that the file exists in directory 
 * under the primary tree.
 */
#define CMFAGPS_DOWNLOADING_FILES_IN_PACKAGE		0x0001
/* 
 * Set when downloading the files in a package.
 * This flag is set by MSG_CMFA_CONTINUE_GET_PACKAGE 
 * and cleared by MSG_CMFA_FINISH_GET_PACKAGE.
 */


/*
 * INTERNAL: Status of the get-package operation in progress is kept 
 *           in this field.
 */
@instance	ConnectMFAGetPackageStatus  CMFAI_getPackageStatus = 0x0000;

/*
 * Context:	INTERNAL: Completion optr and message for the get 
 *			  package file action message.
 * Usage:	Used by MSG_CMFA_FILE_ACTION_FOR_GET_PACKAGE and siblings 
 *		to store the completion optr and message.
 */
@instance	optr	MFAI_getPackageFileActionCompletionOptr = NullOptr;
@instance	Message	MFAI_getPackageFileActionCompletionMsg = 0;

/*
 * Context:	INTERNAL: File path of destination file during package get.
 * Usage:	This vardata is used by the get package code to store 
 *		the destination file path since it modifies the 
 *		MultiFileArrayEntry to download the new file into a 
 *		a temporary place so we can do protocol and file name 
 *		checks before moving it to its final destination.
 *		The vardata is allocated by MSG_CMFA_CONTINUE_GET_PACKAGE 
 *		and deleted by MSG_CMFA_FINISH_GET_PACKAGE.
 */
@vardata	PathAndFileName TEMP_CMFA_DEST_FILE_PATH;

/*
 * Context:	INTERNAL: GEOS file name of new file if it's a GEOS file.
 * Usage:	This vardata is used by the get package code to store 
 *		the GEOS file name of the new file if it's a GEOS file.
 *		The vardata is allocated and set by
 *		CheckForAndDealWithOverwriteConflicts and deleted
 *		by MSG_CMFA_FILE_ACTION_FOR_GET_PACKAGE_STAGE_3.
 */
@vardata	FileLongName	TEMP_CMFA_NEW_FILE_GEOS_FILE_NAME;

/*
 * Context:	INTERNAL: Package name of the package being gotten.
 * Usage:	This vardata is used by the get package code to store 
 *		the package name. The vardata is allocated and set by 
 *		MSG_CMFA_GET_PACKAGE or
 *		MSG_CMFA_GET_PACKAGE_GIVEN_PACKAGE_FILE. The vardata 
 *		is deleted by MSG_CMFA_FINISH_GET_PACKAGE.
 *		The get package file action message uses the vardata	
 *		when it puts up dialogs.
 */
@vardata	char[]	TEMP_CMFA_PACKAGE_NAME;

/*
 * Context:	INTERNAL: Package filename of the package being gotten.
 * Usage:	This vardata is used by the get package code to store 
 *		the DOS package file name. The vardata is allocated and 
 *		set by MSG_CMFA_GET_PACKAGE or
 *		MSG_CMFA_GET_PACKAGE_GIVEN_PACKAGE_FILE. The vardata 
 *		used and deleted by MSG_CMFA_CONTINUE_GET_PACKAGE.
 */
@vardata	TCHAR[]	TEMP_CMFA_PACKAGE_FILENAME;

/*
 * Context:	INTERNAL: Absolute remote directory path with drive
 *			  specifier to package.
 * Usage:	This vardata is used by the get package code to store 
 *		the remote package directory path. The vardata is 
 *		allocated and set by MSG_CMFA_GET_PACKAGE or
 *		MSG_CMFA_GET_PACKAGE_GIVEN_PACKAGE_FILE. The vardata 
 *		used and deleted by MSG_CMFA_CONTINUE_GET_PACKAGE.
 */
@vardata	TCHAR[]	TEMP_CMFA_REMOTE_PACKAGE_PATH;

/*
 * Context:	INTERNAL: IACP Connection token of the connection to 
 *			  a document server.
 * Usage:	This vardata is used by the get package code to store 
 *		the token for the connection to the document sever when 
 *		it tries to gain access to a document.
 *		The vardata is allocated and set by FreeUpDestFile.
 *		The vardata used and deleted by
 *		MSG_CMFA_FILE_ACTION_FOR_GET_PACKAGE_STAGE_3.
 */
@vardata	IACPConnection	TEMP_CMFA_IACP_CONNECTION_TOKEN;

/*
 * Context:	INTERNAL: Temporary vardata storage used to pass the
 *			  ConnectTransferFlags from MSG_CMFA_GET_PACKAGE
 *			  and MSG_CMFA_GET_PACKAGE_GIVEN_PACKAGE_FILE
 *			  to MSG_CMFA_CONTINUE_GET_PACKAGE.
 *			  
 * Usage:	This vardata is allocated and set by the 
 *		CommonGetPackageCode() routine which is called by
 *		MSG_CMFA_GET_PACKAGE and
 *		MSG_CMFA_GET_PACKAGE_GIVEN_PACKAGE_FILE.  
 *		It's used and deleted by MSG_CMFA_CONTINUE_GET_PACKAGE.
 */
@vardata	ConnectTransferFlags	TEMP_CMFA_CONNECT_TRANSFER_FLAGS;

@endc	/* ConnectMultiFileActionClass */


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Connect Settings Controller
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*
 * Notes on the ConnectSettingsControlClass:
 *
 * The ConnectSettingsControlClass stores the current connect settings 
 * in the inti file. It sends itself a MSG_META_GET_INI_CATEGORY to 
 * get the ini category to use when saving and reading the settings.
 * Applications will generally have ATTR_GEN_INIT_FILE_CATEGORY attr 
 * in their application object specifying the category string.
 *
 * The ConnectSettingsControlClass also provides messages that the
 * application can use to get the current settings.
 */	
@class  ConnectSettingsControlClass, GenControlClass ;

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Messages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
/*
 * Bring the settings dialog on screen.
 *
 * Context:	settings dialog opening
 * Source:	any object (most likely a trigger in the application)
 * Destination:	any ConnectSettingsControl object
 * Interception:unlikely
 */
@message void MSG_CONNECT_SETTINGS_CONTROL_INITIATE_DIALOG();

/*
 * Get the current value for a particular setting.
 *
 * These messages are used by the application to get the current settings.
 *
 * Context:	ConnectSettingsControl setting fetching
 * Source:	any object
 * Destination:	any ConnectSettingsControl object
 * Interception:unlikely
 */
@message ConnectionType 
    MSG_CONNECT_SETTINGS_CONTROL_GET_CONNECTION_TYPE_SETTING();
@message DataGroup 
    MSG_CONNECT_SETTINGS_CONTROL_GET_DATA_GROUP_SETTING();

#define CONNECTION_TYPE_TEXT_BUFFER_LENGTH 80

@message void
    MSG_CONNECT_SETTINGS_CONTROL_GET_CONNECTION_TYPE_TEXT(TCHAR *buffer,
							  word bufferLength);

#define DATA_GROUP_TEXT_BUFFER_LENGTH 80

@message void
    MSG_CONNECT_SETTINGS_CONTROL_GET_DATA_GROUP_TEXT(TCHAR *buffer,
						     word bufferLength);
/*
 * Get the entire text of the setting into a buffer referenced by a pointer.
 *	PASS:	buffer		= Pointer to the text buffer
 *		bufferLength	= length of buffer
 *
 *	Note: Use CONNECT_SETTINGS_DRIVE_LENGTH_ZT and
 *	      and CONNECT_SETTINGS_PATH_LENGTH_ZT for buffer lengths.
 */
@message void 
    MSG_CONNECT_SETTINGS_CONTROL_GET_DRIVE_TEXT(TCHAR *buffer,
						word bufferLength);
@message void 
    MSG_CONNECT_SETTINGS_CONTROL_GET_DIRECTORY_PATH_TEXT(TCHAR *buffer,
						word bufferLength);
@message void 
    MSG_CONNECT_SETTINGS_CONTROL_GET_FILE_PATH_TEXT(TCHAR *buffer,
						word bufferLength);


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Internal Messages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*
 * Close the settings dialog.
 *
 * Context:	settings dialog closing
 * Source:	any object (most likely the dialog's custom close trigger)
 * Destination:	any ConnectSettingsControl object
 * Interception:unlikely
 */
@message void MSG_CONNECT_SETTINGS_CONTROL_CLOSE_DIALOG();

/*
 * Writes the current text settings to the init file.
 *
 * This message is sent by the controller to itself when the user 
 * closes the controller interaction.
 *
 * Context:	ConnectSettingsControl init file setting management
 * Source:	ourself
 * Destination:	any ConnectSettingsControl object
 * Interception:unlikely
 */
@message void MSG_CONNECT_SETTINGS_CONTROL_WRITE_SETTINGS();

/*
 * Reads the current settings from the init file and updates the 
 * controller UI to display the current settings.
 * 
 * If the init file does not contain an entry for the feature, 
 * we check for vardata holding an app specific default value.
 *
 * This message is sent by the controller to itself when it first 
 * comes up on screen.
 *
 * Context:	ConnectSettingsControl init file setting management
 * Source:	ourself
 * Destination:	any ConnectSettingsControl object
 * Interception:unlikely
 */
@message void MSG_CONNECT_SETTINGS_CONTROL_READ_SETTINGS();

/*
 * Checks if the drive name, directory path and/or file
 * path settings are legal.  
 *
 * If the CLSF_WARN flag is set, puts up an error dialog 
 * for the first illegal setting it finds.
 *
 * Returns the ConnectSettingsControlFeatures flag of the 
 * first illegal setting it finds or NULL if no settings 
 * are illegal.
 *
 * Context:	ConnectSettingsControl legal settings checking
 * Source:	ourself
 * Destination:	any ConnectSettingsControl object
 * Interception:unlikely
 */
typedef ByteFlags CheckLegalSettingsFlags;
#define    CLSF_WARN 		0x01
/* If set, display a dialog for illegal settings. */

@message ConnectSettingsControlFeatures 
    MSG_CONNECT_SETTINGS_CONTROL_CHECK_LEGAL_SETTINGS
    (CheckLegalSettingsFlags flags);

/*
 * Save the current settings of the connectiion type and 
 * data group GenItemGroups to the init file.
 *
 * Context:	ConnectSettingsControl init file setting management
 * Source:	ourself
 * Destination:	any ConnectSettingsControl object
 * Interception:unlikely
 */
@message void MSG_CONNECT_SETTINGS_CONTROL_SAVE_GIG_SETTINGS();


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Vardata
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
/*
 * Help file for this controller object.  If this is not present then GenClass
 * queries up the tree.
 * eg:
 * ATTR_CONNECT_SETTINGS_CONTROL_HELP_FILE {
 *      char "contax  ", 0
 * }
 */
@vardata char[] ATTR_CONNECT_SETTINGS_CONTROL_HELP_FILE;

/*
 * Specifies the help context for this controller object.
 * eg:
 * ATTR_CONNECT_SETTINGS_CONTROL_HELP_CONTEXT {
 *      char "Settings", 0
 * }
 * Placed on an object of GenControlClass windowed GenInteraction, 
 * although it doesn't have to be. 
 */
@vardata char[] ATTR_CONNECT_SETTINGS_CONTROL_HELP_CONTEXT;

/*
 * VArdata to hold default settings.
 * 
 * If the app wants to provide a default setting, it should add the
 * appropriate ATTR to it's ConnectSettingsControl object.
 */
@vardata ConnectionType	ATTR_CONNECT_SETTINGS_CONTROL_DEFAULT_CONNECTION_TYPE;
@vardata DataGroup ATTR_CONNECT_SETTINGS_CONTROL_DEFAULT_DATA_GROUP;
/* FIXME: These should be using TCHAR[] but GOC produces invalid objects if 
   TCHAR[] is used and a statically defined object contains the vardata. 
   See goc bug #48345 */
@vardata char[] ATTR_CONNECT_SETTINGS_CONTROL_DEFAULT_DRIVE;
@vardata char[] ATTR_CONNECT_SETTINGS_CONTROL_DEFAULT_DIRECTORY_PATH;
@vardata char[] ATTR_CONNECT_SETTINGS_CONTROL_DEFAULT_FILE_PATH;


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Instance data and defaults
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

typedef ByteFlags ConnectSettingsControllerMiscFlags;

#define	CSCMF_GENERATING_UI		0x01
/* Set when the settings controller is generating its UI.
   Set and cleared by our subclass of MSG_GEN_CONTROL_GENERATE_UI.
   If this flag is set, we can ignore the apply messages sent by the 
   GenItemGroups and not save thier settings to the init file. */

/*
 * Context:	Miscellaneous flags.
 * Usage:	INTERNAL
 */
@instance	ConnectSettingsControllerMiscFlags  CSCI_miscFlags = 0x00;

/*
 * Context:	Title of the settings dialog.
 * Usage:	When the settings dialog is built, this text chunk is
 *		used to set its complex moniker.
 */
@instance	ChunkHandle	CSCI_dialogTitle = NullChunk;

/*
 * Context:	Settings changed notification mechanism.
 * Usage:	If the app has a ConnectSettingsDisplay controller that is 
 *		displaying the settings set by this controller, this 
 *		optr shouild be set to that ConnectSettingsDisplay 
 *		controller so it gets send a 
 *		MSG_CONNECT_SETTINGS_DISPLAY_CONTROL_UPDATE_UI when 
 *		our setting dialog closes.
 */
@instance	optr	CSCI_settingsDisplayController = NullOptr;

/***********************************************************************
 *              Feature Sets
 ***********************************************************************/
typedef WordFlags ConnectSettingsControlFeatures;
#define CSCF_CONNECTION_TYPE	0x0010
#define CSCF_DATA_GROUP		0x0008
#define CSCF_DRIVE		0x0004
#define CSCF_DIRECTORY_PATH	0x0002
#define CSCF_FILE_PATH		0x0001


#define CSC_DEFAULT_FEATURES (CSCF_CONNECTION_TYPE | CSCF_DATA_GROUP | \
			      CSCF_DRIVE | CSCF_DIRECTORY_PATH | \
			      CSCF_FILE_PATH)

/* NOTE: This controller has no toolbox features. */

@endc	/* ConnectSettingsControlClass */



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Connect Settings Display Controller
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*
 * Notes on the ConnectSettingsDisplayControlClass:
 *
 * The ConnectSettingsDisplayControlClass is used to display the current 
 * connect settings. It will be used in the main screens of the Responder
 * Connectivity Applications.
 */	
@class  ConnectSettingsDisplayControlClass, GenControlClass ;

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Messages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*
 * Fetch the current connect settings from the ConnectSettings controller
 * and update our UI to display them.
 *
 * Context:	settings update
 * Source:	any object (probably either ourself or a ConnectSettings
 *		controller)
 * Destination:	any ConnectSettingsDisplayControl object
 * Interception:unlikely
 */
@message void MSG_CONNECT_SETTINGS_DISPLAY_CONTROL_UPDATE_UI();


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Instance data and defaults
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@default	GI_states = (@default) | GS_ENABLED;

/*
 * Context:	settings update mechanism
 * Usage:	This is the optr of the ConnectSettings controller which 
 *		sets the settings that we are displaying. The default
 *		MSG_CONNECT_SETTINGS_DISPLAY_CONTROL_UPDATE_UI handler
 *		uses this optr to fetch the current connect settings.
 */
@instance	optr	CSDCI_settingsController = NullOptr;

/***********************************************************************
 *              Feature Sets
 ***********************************************************************/
typedef WordFlags ConnectSettingsDisplayControlFeatures;
#define CSDCF_CONNECTION_TYPE	0x0010
#define CSDCF_DATA_GROUP	0x0008
#define CSDCF_DRIVE		0x0004
#define CSDCF_DIRECTORY_PATH	0x0002
#define CSDCF_FILE_PATH		0x0001


#define CSDC_DEFAULT_FEATURES (CSDCF_CONNECTION_TYPE | CSDCF_DATA_GROUP | \
			      CSDCF_DRIVE | CSDCF_DIRECTORY_PATH | \
			      CSDCF_FILE_PATH)

/* NOTE: This controller has no toolbox features. */

@endc	/* ConnectSettingsDisplayControlClass */



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Connect Progress Dialog
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
/*
 * Notes on the ConnectProgressDialogClass
 * 
 * This is what a progress dialog looks like. 
 *
 *	 --------------------------------------------------------
 *	 |<text describing what is happening>            	|
 *	 |                                               	|
 *	 |             <xxx bytes transfered.>			|
 *	 |                     or                          	|
 *	 |          <xxx bytes of yyy transfered.>		|
 *	 |                                               	|
 *	 |                   <bitmap>                    	|
 *	 |                                               Cancel	|
 *	 --------------------------------------------------------
 *
 * Here is a sample usage of a progress dialog:
 *
 * dialog = ConnectCreateProgressDialog(cancellationOptr, cancellationMsg);
 *
 * Use MSG_FOAM_PROGRESS_DIALOG_*_DESCRIPTION_TEXT* messages to set 
 * the description text.
 *
 * @call dialog::
 *   MSG_CONNECT_PROGRESS_DIALOG_INITIATE_DIALOG(ConnectProgressDialogFlags);
 *
 * Use the connect object to do some file transfer operations, and the 
 * connect object will automatically update the progress dialog with 
 * the current byte count.
 *
 * @call connectObject::MSG_CONNECT_GET_FILE(..., dialog, ...);
 * [...]
 * @call connectObject::MSG_CONNECT_GET_FILE(..., dialog, ...);
 *
 * @call dialog::MSG_CONNECT_PROGRESS_DIALOG_DISMISS_DIALOG();
 * @call dialog::MSG_CONNECT_PROGRESS_DIALOG_DESTROY_DIALOG();
 * 
 */	
@class  ConnectProgressDialogClass, FoamProgressDialogClass ;


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Messages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

typedef ByteFlags ConnectProgressDialogFlags ;

#define CPDF_INHIBIT_CANCELLATION		0x10
/* Internal only: Set if pressing the cancel trigger should not result in
   cancellation immediately, but when MSG_CONNECT_PROGRESS_DIALOG_RESUME_
   CANCEL is sent. */

#define	CPDF_IGNORE_STATUS_UPDATES		0x08
/* Set to leave the status text the same, regardless of updates from
   MSG_CONNECT_PROGRESS_DIALOG_REPORT_PROGRESS. 
   This flag does not prevent the status text from being reset with
   MSG_FOAM_PROGRESS_DIALOG_SET_STATUS_TEXT. */

#define	CPDF_CANCELLING				0x04
/* Set if the operation is being cancelled. */

#define	CPDF_DISPLAY_TOTAL_TRANSFER_SIZE	0x02
/* Set if the total transfer size should be displayed 
   in the status string. */

#define	CPDF_DISPLAY_CUMULATIVE_BYTE_TALLY	0x01
/* Set if the progress dialog should display the cumulative 
   tally of bytes for all files transfered since the progress 
   dialog was initiated. */

/*
 * Initiate the progress dialog.
 *
 * Context:	progress dialog initiation
 * Source:	any object
 * Destination:	any ConnectProgressDialog object
 * Interception:unlikely
 */
@message void 
MSG_CONNECT_PROGRESS_DIALOG_INITIATE_DIALOG(ConnectProgressDialogFlags flags);

/*
 * Dismiss the progress dialog.  Has no effect if dialog has already
 * been dismissed, i.e., the user cancelled the operation.
 *
 * Context:	progress dialog dismissal
 * Source:	any object
 * Destination:	any ConnectProgressDialog object
 * Interception:unlikely
 */
@message void MSG_CONNECT_PROGRESS_DIALOG_DISMISS_DIALOG();

/*
 * Destroy the progress dialog.
 *
 * Context:	progress dialog management
 * Source:	any object
 * Destination:	any ConnectProgressDialog object
 * Interception:unlikely
 */
@message void MSG_CONNECT_PROGRESS_DIALOG_DESTROY_DIALOG();

/*
 * Set the total transfer size.
 *
 * If the CPDF_DISPLAY_TOTAL_TRANSFER_SIZE flag is set, the
 * status string will be displayed as 
 * "xxx bytes of <total transfer size>".
 *
 * Context:     progress dialog management
 * Source:      any object
 * Destination:	any ConnectProgressDialog object
 * Interception:unlikely
 */
@message void MSG_CONNECT_PROGRESS_DIALOG_SET_TRANSFER_SIZE(dword size);

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Internal Messages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*
 * Connect Progress Types
 */
typedef enum {
    CPT_BYTE_COUNT,
} ConnectProgressType;

/*
 * Update the progress status, unless CPDF_IGNORE_STATUS_UPDATES is
 * set in CPDI_flags.
 *
 * If CPDF_DISPLAY_CUMULATIVE_BYTE_TALLY is set and the ConnectProgressType 
 * is CPT_BYTE_COUNT, the displayed byte count is the cumulative tally 
 * of bytes for all files transfered since the progress dialog was initiated.
 *
 *
 * Context:	progress dialog status update
 * Source:	any object (usually the Connect object doing the file transfer)
 * Destination:	any ConnectProgressDialogClass object
 * Interception:unlikely
 */
@message void 
MSG_CONNECT_PROGRESS_DIALOG_REPORT_PROGRESS(ConnectProgressType type,
                                            dword data);		  

/* 
 * Tell the progress dialog that a new file is being sent.
 * Used to keep the cumulative byte tally.
 * Sent by the connect object. 
 *
 * Right now the dataBlock handle is always null but in the future it might
 * hold the handle of a block containing the name of the new file being
 * transfered.
 */
@message void 
MSG_CONNECT_PROGRESS_DIALOG_STARTING_NEW_FILE(MemHandle dataBlock);

/* 
 * Tell the progress dialog to cancel the operation.
 * Sent by the progress dialog itself when its cancel trigger is hit.
 */
@message void 
MSG_CONNECT_PROGRESS_DIALOG_CANCEL();		  

/* 
 * Message prototype for cancellation message sent from
 * MSG_CONNECT_PROGRESS_DIALOG_CANCEL after internal cancellation
 * matters have been handled.
 */
@prototype void CONNECT_PROGRESS_DIALOG_CANCELLATION_MSG();

/* 
 * Set the cancellation action, if any, to take in the course of
 * handling MSG_CONNECT_PROGRESS_DIALOG_CANCEL.
 */
@message void 
MSG_CONNECT_PROGRESS_DIALOG_SET_CANCEL_ACTION(optr cancellationOptr,
					      Message cancellationMsg);

/*
 * Get the ConnectProgressDialogFlags stored in CPDI_flags.
 */
@message ConnectProgressDialogFlags
MSG_CONNECT_PROGRESS_DIALOG_GET_FLAGS();

/*
 *  Allow the app to guarantee that the user cannot cancel during some
 *  section of code, returning the current flags, so that the cancel
 *  status can be tested.
 */
@message ConnectProgressDialogFlags
MSG_CONNECT_PROGRESS_DIALOG_SUSPEND_CANCEL();

/*
 * Allow cancels to be sent from the progress dialog again.  If
 * Cancel was pressed since the call to SUSPEND_CANCEL, it will occurr
 * at this time.
 */
@message void
MSG_CONNECT_PROGRESS_DIALOG_RESUME_CANCEL();



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Instance data and defaults
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*
 * Context:	flag storage
 * Usage:	
 */
@instance	ConnectProgressDialogFlags	CPDI_flags;

/*
 * Context:	Cumulative tally of bytes for all files transfered 
 *		since the progress dialog was initiated, not including 
 *		the current file.
 * Usage:	
 */
@instance	dword	CPDI_cumulativeTally;

/*
 * Context:	bytes transferred so far for the current file
 * Usage:	
 */
@instance	dword	CPDI_bytesCurrentFile;

/*
 * Context:	Total transfer size used in the status string 
 *		if the CPDF_DISPLAY_TOTAL_TRANSFER_SIZE flag 
 *		is set.
 * Usage:	Set by MSG_CONNECT_PROGRESS_DIALOG_SET_TRANSFER_SIZE.
 *              
 */
@instance       dword   CPDI_transferSize = 0;

/*
 * Context:	CPDI_cancellationOptr and CPDI_cancellationMsg store the AD
 * 		specified by the creator of the progress dialog to send on
 *		cancellation.
 * Usage:	Sent by handler for MSG_CONNECT_PROGRESS_DIALOG_CANCEL
 *		after CPDF_CANCELLING has first been set in CPDI_flags.
 */
@instance	optr		CPDI_cancellationOptr = NullOptr;
@instance	Message		CPDI_cancellationMsg = 0;

/*
 * Context:     CPDI_cancelDialog stores a dialog which notifies
 *              that operation is being cancelled.  When the user
 *              presses cancel, this dialog comes up.
 * Usage:       In MSG_CONNECT_PROGRESS_CANCEL, this dialog is created
 *              and displayed.  In MSG_CONNECT_PROGRESS_DIALOG_DESTROY_DIALOG,
 *              this dialog is nuked.
 */
@instance       optr            CPDI_cancelDialog = 0;

@endc	/* ConnectProgressDialogClass */



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		ConnectSubApplicationClass

This class should be used for applications that are using a 
Connect object. It provides a mechanism for delaying the 
application from detaching if there is a connect operation in 
progress when the application is asked to detach.

Note that ConnectSubApplicationClass is a subclass of the
FoamSubApplicationClass so it is not appropriate for applications 
that should not use the FoamSubApplicationClass.


The application needs to follow these steps:
 
1) Use the ConnectSubApplicationClass.

2) Set the CSAI_connectObj instance data to the optr of the 
application's connect object.

3) Call the application with
MSG_CSA_SET_FLAGS(CSAF_WAITING_FOR_COMPLETION_MSG, NULL) right before 
sending the connect object a message starting a connect operation.

Have the completion message do the following:
4) Call the application with MSG_CSA_SET_FLAGS(NULL, 
CSAF_WAITING_FOR_COMPLETION_MSG) at the start of the
completion message handler.

7) Check the ConnectSubApplicationFlags returned by MSG_CSA_SET_FLAGS 
and if the application is waiting to continue a detach, don't put up 
any dialogs.

8) If the application is waiting to continue a detach, send the application
a MSG_CSA_CONTINUE_DETACH at the end of the completion message handler.


Example completion message handler:
{
    ConnectSubApplicationFlags csaFlags;

    * The completion message is being handled, so clear the 
    * CSAF_WAITING_FOR_COMPLETION_MSG flag. This needs to be done 
    * at the start of the completion message handler.
    *
    * At the same time, get the current ConnectSubApplicationFlags 
    * so we can check if the application object is waiting to continue
    * an application detach when we're done handling the completion
    * message.
    csaFlags = @call app::
	MSG_CSA_SET_FLAGS(NULL, CSAF_WAITING_FOR_COMPLETION_MSG);

    if (!(csaFlags & CSAF_WAITING_TO_DETACH)) {
	 * Code that should only be executed if we're not about to 
	 * detach. For example: putting up error dialogs.
	[insert code here]
    }

     * Code that should be executed even if we're about to detach.
     * For example: Freeing memory, deleting temp files, etc.
    [insert code here]

     * If the app is waiting to detach, tell it to continue the detach.
     * This needs to be at the end of the completion message handler.
    if (csaFlags & CSAF_WAITING_TO_DETACH) {
	@send app::MSG_CSA_CONTINUE_DETACH();
    }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
@class  ConnectSubApplicationClass, FoamSubApplicationClass;

typedef ByteFlags	ConnectSubApplicationFlags;
#define	CSAF_WAITING_TO_DETACH			0x02
/* This flag is set if the application has received a MSG_META_DETACH
 * and is waiting for the completion message to send it a
 * MSG_CSA_CONTINUE_DETACH before continuing the application detach.
 */

#define	CSAF_WAITING_FOR_COMPLETION_MSG		0x01
/* This flag is set if the application has started a connect operation
 * but has not yet received and handled the completion message for the
 * operation. 
 */


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Messages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*
 * MSG_CSA_GET_FLAGS
 *
 * Desc:	Get the current ConnectSubApplicationFlags.
 *
 * Context:	ConnectSubApplicationClass flags
 * Source:	any object 
 * Destination:	any ConnectSubApplicationClass object
 * Interception:unlikely
 *
 * Pass:	nothing
 * Return:	ConnectSubApplicationFlags - current flags
 */
@message ConnectSubApplicationFlags MSG_CSA_GET_FLAGS();

/*
 * MSG_CSA_SET_FLAGS
 *
 * Desc:	Set and clear some ConnectSubApplicationFlags.
 *
 * Context:	ConnectSubApplicationClass flags
 * Source:	any object 
 * Destination:	any ConnectSubApplicationClass object
 * Interception:unlikely
 *
 * Pass:	flagsToSet	- ConnectMultiFileActionClass flags to set
 *		flagsToClear	- ConnectMultiFileActionClass flags to clear
 * Return:	ConnectSubApplicationFlags - current flags after the
 *					     requested flags have been 
 *					     set and cleared.
 */
@message ConnectSubApplicationFlags \
    MSG_CSA_SET_FLAGS(ConnectSubApplicationFlags flagsToSet,
		      ConnectSubApplicationFlags flagsToClear);

/*
 * MSG_CSA_CONTINUE_DETACH
 *
 * Desc:	Continues the application detach by sending the superclass
 *		a MSG_META_DETACH.
 *
 * Context:	mechanism to delay application detach
 * Source:	the ConnectSubApplicationClass MSG_META_DETACH handler or
 *		one of the application's connect completion message handlers
 * Destination:	any ConnectMultiFileActionClass object
 * Interception:This message should be intercepted if the application needs
 *		to do anything before the application really detaches.
 *		Here is a good place to prepare for the lazarus case.
 */
@message void	MSG_CSA_CONTINUE_DETACH();


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Instance data and defaults
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*
 * Context:	ConnectSubApplicationClass flags
 * Usage:	The flags can be set with MSG_CSA_SET_FLAGS and 
 *		retrieved with MSG_CSA_GET_FLAGS.
 */
@instance	ConnectSubApplicationFlags	CSAI_flags = 0x00;

/*
 * Context:	mechanism to delay application detach
 * Usage:	Contains the optr of the connect object to which to send a 
 *		MSG_CONNECT_CANCEL_TRANSFER if there is an operation in
 *		progress when the ConnectSubApplicationClass receives 
 *		a MSG_META_DETACH. 
 *	
 *		Assuming the application has one static connect object, 
 *		this instance data should be set in the application 
 *		object declaration.
 */
@instance	optr		CSAI_connectObj = NullOptr;

/*
 * Context:	mechanism to delay application detach
 * Usage:	This vardata is used to store the callerID and ackOD 
 *		passed with MSG_META_DETACH to ConnectSubApplicationClass. 
 *		The vardata is later used and deleted by the 
 *		ConnectSubApplicationClass MSG_CSA_CONTINUE_DETACH handler 
 *		when it sends a MSG_META_DETACH to our superclass to
 *		continue the detach.
 */
typedef	struct {
    word	CSADD_callerID;
    optr	CSADD_ackOD;
} ConnectSubAppDetachData;
@vardata	ConnectSubAppDetachData	TEMP_CONNECT_SUB_APP_DETACH_DATA;

@endc	/* ConnectSubApplicationClass */



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  		Exported functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/


/*
 * Desc:	Create a basic progress dialog using UserCreateDialog, 
 *		and set the cancellation action to be taken by
 *		MSG_CONNECT_PROGRESS_DIALOG_CANCEL.
 *
 *		Generally, set the cancellationOptr to the Connect
 *              object and the cancellationMsg to
 *		MSG_CONNECT_CANCEL_TRANSFER.
 *
 * Return: 	optr of created dialog or NULL if couldn't create dialog.
 */
extern optr _cdecl 
ConnectCreateProgressDialog(optr cancellationOptr, Message cancellationMsg);

/*
 * Desc:	Create a subclassed progress dialog using UserCreateDialog, 
 *		and set the cancellation action to be taken by
 *		MSG_CONNECT_PROGRESS_DIALOG_CANCEL.
 *
 *		Generally, set the cancellationOptr to the Connect
 *              object and the cancellationMsg to
 *		MSG_CONNECT_CANCEL_TRANSFER.
 *
 * Return: 	optr of created dialog or NULL if couldn't create dialog.
 */
extern optr _cdecl 
ConnectCreateProgressDialogFromTemplate(optr progressDialogTemplate,
					optr cancellationOptr,
					Message cancellationMsg);


/*
 * SYNOPSIS:	Put up a standard Connect dialog box.
 */
extern InteractionCommand _cdecl ConnectDoStandardDialog(
				   ConnectStandardDialogBoxType dialogType,
				   TCHAR *arg1,
				   TCHAR *arg2);

/*
 * Desc:	Set the server's current directory.
 *
 *		The path may be relative to the server's current 
 *		directory or absolute with a drive specification.
 *
 *		For example: a relative path would be "temp\dir1"
 *			     an absolute path would be "c:\foo\temp\dir1"
 *			     "a:" goes to the root dir of the A drive
 */
extern ConnectError _cdecl ConnectSetServerPath(TCHAR *path);

/*
 * Desc:	Get the server's current path.
 *
 *		The server's absolute path with drive specifier is
 *		copied into the buffer.	
 *
 *		The buffer must be PATH_BUFFER_SIZE.
 */
extern ConnectError _cdecl ConnectGetServerPath(TCHAR *buffer);

/*
 * Desc:	Tell the server to display its current absolute 
 *		directory path.
 *
 * Return: 	ConnectError 
 */
extern ConnectError _cdecl ConnectDisplayServerPath(void);

/*
 * Desc:	Fill the passed buffer with the requested information.
 *
 *		pkgArray = optr of locked chunk array. Each entry is a
 *                         PackageDescriptorArrayEntry.
 *              n        = index of element about which to get info
 *              pddt     = PackageDescriptorDataType: kind of info desired
 *              retBuf   = buffer in which to return requested info
 *              bufLength   = number of chars (not bytes) to read into retBuf,
 *                            BUT the last position is nulled.  (If data is
 *                            less than bufLength chars, then the extra space
 *                            is null padded.)
 *
 * 
 */
extern ConnectError _cdecl
ConnectGetPackageDescriptorData(optr pkgDescArray, word n,
				PackageDescriptorDataType pddt,
				TCHAR *retBuf, word bufLength );


/*
 * Desc:	Abridge the path so it fits in the passed number of
 *		points minus the width of the includedInWidth string, if any.
 *
 *		includedInWidth is a pointer to a string whose width
 *		will be subtracted from the maxWidth before the path
 *		is abridged. includedInWidth may be NULL.
 *
 *		The includedInWidth argument is useful for cases where you
 *		know the total width available for a string like 
 *		"to <file path>" and want to abridge the file path to fit 
 *		in the total width minus the width of the "to " sub-string.
 *
 *		Pass 0 for the fontID and/or pointSize to use the
 *		default (whatever that is).
 */
extern void _cdecl
ConnectAbridgePath(char *thePath, word maxWidth, 
		   char *includedInWidth,
		   FontID fontID, WWFixedAsDWord pointSize);

/*
 * Desc:	Check if the passed string is a legal DOS drive name.
 *
 *		Legal drive names look like "X:" or "X:\", where X is 
 *		an upper or lower case letter between A and Z.
 *
 * Return: 	ConnectCheckLegalError -
 *			CCLE_LEGAL
 *			CCLE_STRING_NULL
 *			CCLE_STRING_TOO_LONG
 *			CCLE_ONE_LETTER_DRIVE_NAME
 *			CCLE_ILLEGAL_DOS_DRIVE_NAME
 */
extern ConnectCheckLegalError _cdecl
ConnectCheckLegalDosDriveName (const TCHAR *driveName);

/*
 * Desc:	Check if the passed string is a legal absolute DOS 
 *		directory path.
 *
 *              "." and ".." may appear in the directory path.
 *
 *		Note: This routine does not check if the characters
 *		      are legal DOS path characters.
 *
 * Return: 	ConnectCheckLegalError -
 *			CCLE_LEGAL
 *			CCLE_STRING_NULL
 *			CCLE_STRING_TOO_LONG
 *			CCLE_ONE_LETTER_DRIVE_NAME
 *			CCLE_ILLEGAL_DOS_DRIVE_NAME
 *			CCLE_DOS_DEVICE_NAME_CONFLICT
 *			CCLE_ILLEGAL_DOS_DIR_PATH
 */
extern ConnectCheckLegalError _cdecl
ConnectCheckLegalDosDirPath (const TCHAR *dirPath);

/*
 * Desc:	Check if the passed string is a legal absolute DOS 
 *		file path.
 *
 *              "." and ".." may appear in the file path.
 *		Note: This routine does not check if the characters
 *		      are legal DOS path characters.
 *
 * Return: 	ConnectCheckLegalError -
 *			CCLE_LEGAL
 *			CCLE_STRING_NULL
 *			CCLE_STRING_TOO_LONG
 *			CCLE_ILLEGAL_DOS_DRIVE_NAME
 *			CCLE_DOS_DEVICE_NAME_CONFLICT
 *			CCLE_ILLEGAL_DOS_FILE_NAME
 *			CCLE_ILLEGAL_DOS_FILE_PATH
 */
extern ConnectCheckLegalError _cdecl
ConnectCheckLegalDosFilePath (TCHAR *filePath);

/*
 * Desc:	Check if the passed string is a legal DOS file name.
 *
 *		Note: This routine does not check if the characters
 *		      are legal DOS file name characters.
 *
 * Return: 	ConnectCheckLegalError -
 *			CCLE_LEGAL
 *			CCLE_STRING_NULL
 *			CCLE_STRING_TOO_LONG
 *			CCLE_DOS_DEVICE_NAME_CONFLICT
 *			CCLE_ILLEGAL_DOS_FILE_NAME
 */
extern ConnectCheckLegalError _cdecl
ConnectCheckLegalDosFileName (const TCHAR *fileName);

/*
 * Desc:        Creates the passed path on the server, if the path
 *              does not exist.
 */
ConnectError _cdecl
ConnectCreatePathOnServer (TCHAR *serverPath);

/*
 * Desc:        Routine called in completion messages.  Puts up a warning 
 *              or error dialog if:
 *               - the passed error message is CE_NOT_ENOUGH_DISK_SPACE
 *                 _TO_{START,COMPLETE}, as returned by 
 *		   MSG_CONNECT_(GET|SEND)_FILE or MSG_CMFA_GET_PACKAGE.
 *               - the amount of space left (after a successful transfer)
 *                 is below the warning or critical level.
 *              Returns TRUE if warning/error dialog was displayed.
 */
Boolean _cdecl
ConnectWarnIfOutOfSpace ( ConnectError error );

/*
 * Desc:        The following routines will retrieve the geode handle
 *              given the long name.
 *              If CE_SUCCESS is returned, then geodeHan is the GeodeHandle of 
 *              the first-found running geode of specified name, or NullHandle 
 *              if geode not found running.
 *              CE_MISC_FILE_ERROR returned if some error occurred while trying
 *              to find the geode.
 */
extern ConnectError _far _pascal
ConnectGeodeFindFromLongName( const char _far *name,
			      GeodeAttrs attrMatch,
			      GeodeAttrs attrNoMatch,
			      GeodeHandle _far *geodeHan);

/*
 * Desc:        Play custom sound with UserStandardSound
 */
extern void
_far _pascal ConnectPlaySound( ConnectSoundType soundToPlay );

/*
 * Desc: 	Maps PCComFullReturnType to ConnectError.  The
 * 		default error code is used when the mapping fails.
 *	    	Okay to pass PCCRT_NO_ERROR.
 *       
 */
extern ConnectError _cdecl
ConnectMapPCCFRTToConnectError( ConnectError defaultErr, 
			        PCComFullReturnType pccomErr );

/*
 * Desc:        Displays an abort error message in the following format:
 *			"[Error msg body] [arg][ - reason str]!"
 *			eg. "Cannot copy to file foo.txt - file is read-only!"
 *              The error message body is determined by dbType.
 *		The reason string is determined by error.
 */
extern InteractionCommand _cdecl
ConnectDoStandardDialogWithReason( ConnectError error,
				   ConnectStandardDialogBoxType dbType,
				   TCHAR *arg );

/*
 * Desc:	Displays error dialogs for common case ConnectErrors,
 *		that is, ConnectErrors with the CE_DIALOG_DISPLAYED
 *		bit set.
 *
 *	These are the cases that the dialog will be displayed. "*" means
 *	the argument passed in isn't important.
 *
 *	ConnectError			arg1			arg2
 *	-----------			----			----
 *	CE_CANNOT_TRANSLATE_FILE	*			*
 *	CE_OPERATION_ABORTED		*			*
 *	CE_REMOTE_OPERATION_ABORTED	*			*
 *	CE_CONNECTION_LOST		*			*
 *	CE_PATH_NOT_FOUND		dir path w/o filename	*
 *	CE_REMOTE_PATH_NOT_FOUND	dir path w/o filename	*
 *	CE_DRIVE_INVALID		arg1[0] = drive letter	*
 *	CE_REMOTE_DRIVE_INVALID		arg1[0] = drive letter	*
 *	CE_REMOTE_VOLUME_UNAVAILABLE	arg1[0] = drive letter	*
 *	CE_CANNOT_CREATE_DIRECTORY	dir path w/o filename	*
 *	CE_REMOTE_NOT_ENOUGH...COMPLETE	   *			*
 *	CE_SOURCE_FILE_OPEN_BY_ANOTHER_APP file name or file path *
 *	CE_DEST_FILE_OPEN_BY_ANOTHER_APP   file name or file path *
 *	CE_PACKAGE_OLD_SO_NOT_INSTALLED package name		*
 *	CE_PACKAGE_NOT_COMPATIBLE	package name		*
 *	CE_CANNOT_USE_INSTALL_BATCH_
 *	 FILE_FOR_MORE_THAN_ONE_INSTALL	*			*
 *	
 * Return: 	TRUE - if a dialog was displayed.
 */
extern Boolean _cdecl
ConnectDoStandardErrorDialog( ConnectError error, TCHAR *arg1, TCHAR *arg2 );

/*
 * Desc:	Prevents the keys F5-F12 from launching an app.
 */
extern void _far _pascal
ConnectDisableAppLaunchKeys(ConnectDisableAppLaunchKeysMonitor *monitor);

/*
 * Desc:	Allows the keys F5-F12 to launch apps again, after
 *		having called ConnectDisableAppLaunchKeys().
 * Pass:	Pointer to same monitor you passed to 
 *		ConnectDisableAppLaunchKeys().
 */
extern void _far _pascal
ConnectEnableAppLaunchKeys(ConnectDisableAppLaunchKeysMonitor *monitor);

/*-------------------------------------------------------------------------
 *   Any API below this line is not available for Communicator devices
 *   shipped before January 1997.  (pragmas excluded)
 *-----------------------------------------------------------------------*/

/*
 * Desc:        Compress/Decompress the source file into the 
 *              destination file.
 * 
 * Pass:        source & destination file handles
 *
 * Return:      number of bytes written out (0 if error)
 */

extern word _far _pascal
ConnectCompressFile (FileHandle srcFileHan, FileHandle destFileHan);

extern word _far _pascal
ConnectDecompressFile (FileHandle srcFileHan, FileHandle destFileHan);

#ifdef __HIGHC__
pragma Alias(ConnectGeodeFindFromLongName, "CONNECTGEODEFINDFROMLONGNAME");
pragma Alias(ConnectPlaySound, "CONNECTPLAYSOUND");
pragma Alias(ConnectDisableAppLaunchKeys, "CONNECTDISABLEAPPLAUNCHKEYS");
pragma Alias(ConnectEnableAppLaunchKeys, "CONNECTENABLEAPPLAUNCHKEYS");
pragma Alias(ConnectCompressFile, "CONNECTCOMPRESSFILE");
pragma Alias(ConnectDecompressFile, "CONNECTDECOMPRESSFILE");
#endif /* __HIGHC__ */


@endlib /* connect */

@endif /* __CONNECT_GOH */
