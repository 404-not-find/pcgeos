/*----------------------------------------------------------------------------

	Copyright (c) GeoWorks 1989-1992 -- All Rights Reserved

PROJECT:	PC GEOS
MODULE:		CInclude - Spool Library Definitions
FILE:		spool.goh

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Schoon  4/30/92		Initial Version
	jenny	8/31/93		Completed

DESCRIPTION:
	Definitions for users of the spool library, and the various object
	exported by the library (PrintControl and  PageSizeControl).

	$Id: spool.goh,v 1.1 97/04/04 15:57:56 newdeal Exp $

----------------------------------------------------------------------------*/
@optimize
@deflib spool

@include <Objects/gProcC.goh>
@include <object.goh>
#include <driver.h>
#include <thread.h>
#include <print.h>

/* To remove warning on PC SDK using BCC4.5.
 * 7/17/96 - ptrinh
 */
#include <Internal/spoolInt.h>

/*
 * GenApplication GCN lists to be placed on:
 *	GAGCNLT_SELF_LOAD_OPTIONS
 */

/*--------------------------------------------------------------------------*
 *			PrintControlClass  
 *--------------------------------------------------------------------------*/

@class PrintControlClass, GenControlClass;

/*--------------------------------------------------------------------------*
 *			How printing works  
 *--------------------------------------------------------------------------*/

/* MSG_PRINT_CONTROL_INITIATE_PRINT initiates the user interface to 
 * printing. This is normally sent from the "Print" trigger in the file menu
 * The user interface normally consists of a dialog box containing printing 
 * options.  Some of these options can be specified by the attributes 
 * PrintControlAttrs.  The application can also add its own UI components 
 * to the print dialog box. 
 * 
 * When the user interface for printing finishes successfully (usually  
 * pressing a "Print" button), MSG_PRINT_CONTROL_PRINT is invoked.  This  
 * method creates a graphics string (stored in a VM file) and then sends the
 * following messages: 
 *
 *	MSG_PRINT_VERIFY_PRINT_REQUEST	to PCI_output 
 *	MSG_PRINT_GET_DOC_NAME 		to PCI_docNameOutput 
 *	MSG_PRINT_START_PRINTING	to PCI_output 
 * 
 * While the application is printing, it might want to send back to the PC 
 * an indication of progress (MSG_PRINT_CONTROL_REPORT_PROGRESS). 
 * This is done to notify the user of what is occurring, and to allow the 
 * user to interrupt a print request before the spooler take control  
 * of the print job. See the method description below, and the  
 * PrintControlFlags documentation. 
 * 
 * After all these methods have been responded to (as appropriate), the 
 * PrintControl object will clean up some details, and pass the print 
 * job request onto the spool library.
 */

/*--------------------------------------------------------------------------
		What every application writer should know... 
----------------------------------------------------------------------------*/

/* Using the PrintControl is a relatively easy thing to do, provided some
 * simple rules are followed.  First, some terms:
 * 
 *	Printing:	The creation of a GString by an application, which
 *			is stored in a file in the SYSTEM\SPOOL directory.
 *	Spooling:	This file is the spooled, by being queued (if
 *			necessary) on a print queue; and then has several
 *			page width x certain height swath bitmaps generated
 *			and printed.
 *	PrintControl:	The UI object that controls all the UI
 *				aspects of the problem
 *	The Spool Process:	The thread that controls all of the spooling
 *				aspects of the problem.
 *	Spool Threads:		Individual print queues for every printer
 *				active (with jobs) on a system
 *	Print Dialog Box:	The pretty dialog box that appears (usaually)
 *				when you press the "Print..." trigger.
 *	User Print Group:	The application-defined group of UI objects
 *				that can be incorporated into the Print Dialog
 *				Box. NOTE: The root of this UI-tree must be
 *				be set NOT_USABLE!!!!
 *	User Print Trigger:	The application-defined trigger or other UI
 *				objects that can be used in place of the
 *				usual "Print..." trigger. Again, these must
 *				set NOT_USABLE in the .UI file.
 */ 
/* How to set up your PrintControl object:
 *	* Determine if you want a dialog box. Default:YES
 *	* Determine if you want page controls. Default:YES
 *	* Determine if the application can output text or graphics or both,
 *	  and possibly, what level of detail. Default:ALL outputs possible
 *	* Determine if you want a special print trigger. If so, create the
 *	  object(s), and set the correct instance data. Default:NONE
 *	  Note: The AD of the application-defined trigger should be:
 *		action = MSG_PRINT_CONTROL_INITIATE_PRINT, FooObj;
 *	  where FooObj is of type PrintControl.
 *	* Determine if you want special UI object in the Print Dialog Box.
 *	  If so, create the object, and set the instance data. Default:NONE
 *	* Make the PrintControl a generic child of something (probably
 *		the GenPrimary).
 *	* Add the PrintControl to your Active List!
 * 
 *	*  How to use your PrintControl object:
 *	* If working with a multiple page document, use the provided methods
 *	  to allow the PC to display the full range of pages available. Use
 *	  the USER page range to select intelligent default page ranges.
 *	* The document size must be set prior to the time the document is
 *	  spooled. Do this by either setting the document size in the
 *	  .UI file, or sending the approriate method BEFORE send a
 *	  MSG_PRINT_CONTROL_PRINTING_COMPLETED back to the PC.
 *	* MSG_PRINT_START_PRINTING will be send to PCI_output as
 *	  notification for the application to start printing.
 *	* MSG_PRINT_NOTIFY_PRINT_DB is sent to PCI_output evertime the print
 *	  dialog box comes on/off screen.
 *	* MSG_PRINT_VERIFY_PRINT_REQUEST is sent to PCI_output if the
 *	  attribute is
 *	  is set in PCI_attrs. See the method declaration for more
 *	  information.
 *
 * When printing:
 *	* The printMethod (MSG_PRINT_START_PRINTING) is received by
 *	  PCI_output
 *	* Send MSG_PRINT_CONTROL_REPORT_PROGRESS to allow visual
 *	  feedback to the user
 *	* Send MSG_PRINT_CONTROL_PRINTING_COMPLETED back to the PC's
 *	  OD when you have completed printing. MAKE SURE THE DOCUMENT SIZE
 *	  HAS BEEN SET CORRECTLY.
 */
/* Check the individual method declarations for additional information... */


/*--------------------------------------------------------------------------*
 *		Constants & Structures
 *--------------------------------------------------------------------------*/

typedef ByteFlags PrintControlFeatures;
#define PRINTCF_PRINT_TRIGGER	0x02 	 /* wants a print trigger */
#define PRINTCF_FAX_TRIGGER	0x01	 /* wants a fax trigger */

typedef ByteFlags PrintControlToolboxFeatures;
#define PRINTCTF_PRINT_TRIGGER	0x02	/* wants a print tool trigger */
#define PRINTCTF_FAX_TRIGGER	0x01	/* wants a fax tool trigger */

#define PRINTC_DEFAULT_FEATURES (PRINTCF_PRINT_TRIGGER | \
				 PRINTCF_FAX_TRIGGER)

#define PRINTC_DEFAULT_TOOLBOX_FEATURES	(PRINTCTF_PRINT_TRIGGER | \
					 PRINTCTF_FAX_TRIGGER)


#define MAXIMUM_NUMBER_OF_PRINTERS	255
#define MAXIMUM_PRINTER_NAME_LENGTH	64	; includes NULL terminator


typedef ByteFlags PrinterOutputModes;
#define POM_unused  	    	0xe0 /* leave these bits alone!!! */
#define POM_GRAPHICS_LOW	0x10 /* Graphics mode low quality available */
#define POM_GRAPHICS_MEDIUM	0x08 /* Graphics mode medium quality available*/
#define POM_GRAPHICS_HIGH	0x04 /* Graphics mode high quality available */
#define POM_TEXT_DRAFT		0x02 /* Character mode draft quality available */
#define POM_TEXT_NLQ		0x01 /* Character mode NLQ quality available  */

#define PRINT_GRAPHICS	(POM_GRAPHICS_LOW | \
			 POM_GRAPHICS_MEDIUM |  POM_GRAPHICS_HIGH )

#define PRINT_TEXT	(POM_TEXT_DRAFT | POM_TEXT_NLQ)

/* 
 * The default quality chosen by an application
 */
typedef ByteEnum PrintQualityEnum;
#define	PQT_HIGH	0	/* default to high */
#define	PQT_MEDIUM	1	/* default to medium */
#define	PQT_LOW		2	/* default to low */
/* More mnemonically named equivalents for the PrintQualityEnum values. */
#define PQE_HIGH    PQT_HIGH	/* default to high */
#define PQE_MEDIUM  PQT_MEDIUM	/* default to medium */
#define PQE_LOW	    PQT_LOW	/* default to low */

typedef WordFlags PrintControlAttrs;
#define PCA_NO_PRINTER_CONTROLS	0x8000	/* No printer controls are available */
#define PCA_SEE_IF_DOC_WILL_FIT	0x4000	/* check, before printing, if the
					   document will fit on the paper */
#define PCA_MARK_APP_BUSY	0x2000	/* mark busy while application is 
					   printing */
#define PCA_VERIFY_PRINT	0x1000	/* indicate we want to verify before 
					   printing */
#define PCA_SHOW_PROGRESS	0x0800	/* show the print progress dialog box */
#define PCA_PROGRESS_PERCENT	0x0400	/* show progress by percentage 
					   completed */
#define PCA_PROGRESS_PAGE	0x0200	/* show progress by page completed */
#define PCA_FORCE_ROTATION	0x0100	/* Force rotation of output */
#define PCA_COPY_CONTROLS	0x0080	/* Copy controls are available */
#define PCA_PAGE_CONTROLS	0x0040	/* Page range controls are available */
#define PCA_QUALITY_CONTROLS	0x0020	/* Print quality controls are 
					   available */
#define PCA_USES_DIALOG_BOX	0x0010	/* A print dialog box should appear */
#define PCA_GRAPHICS_MODE	0x0008	/* Supports graphics mode output */
#define PCA_TEXT_MODE		0x0004	/* Supports text mode output */
#define PCA_DEFAULT_QUALITY	0x0003	/* default print quality */

typedef enum /* word */ {
    PCS_PRINT_BOX_VISIBLE,  	    /* Print DB is onscreen */
    PCS_PRINT_BOX_NOT_VISIBLE       /* Print DB not onscreen */
} PrintControlStatus;

typedef enum /* word */ {
    PCPT_PAGE	    = 0,	/* change page number */
    PCPT_PERCENT    = 2,	/* change percent done */
    PCPT_TEXT	    = 4		/* change text message */
} PCProgressType;

/*--------------------------------------------------------------------------*
		Messages
 *--------------------------------------------------------------------------*/

/***************************************************************************/
@message void MSG_PRINT_CONTROL_INITIATE_PRINT();
/*
 * Initiate printing. This will normally cause the print dialog box to 
 * come up on screen. 
 *  
 * Context:	Invoked by the user wanting to print a document, by  
 *		(usually) clicking on the print trigger in the file menu. 
 * Source:	Anyone 
 * Destination:	PrintControlClass object 
 * Interception: Generally should not be intercepted. 
 *
 * Pass:	Nothing
 * Return:	Nothing
 */

/***************************************************************************/
@message void MSG_PRINT_CONTROL_PRINT();

/* Requests the printing process to actually begin. 
 *  
 * Context:	Invoked by the user clicking on the "Print" trigger in the 
 *		print dialog box. 
 * Source:	Anyone 
 * Destination:	PrintControlClass object 
 * Interception: Generally should not be intercepted. 
 *
 * Pass:	Nothing
 * Return:	Nothing
 */

/***************************************************************************/
@message void MSG_PRINT_CONTROL_VERIFY_COMPLETED( Boolean continue = cx);

/* Tells the PrintControl that the print verify has been completed,
 * and either printing will ensure, or it will be cancelled.
 * 
 * Context:	Sent in response to MSG_PRINT_VERFIY_PRINTING
 * Source:	Anyone, but most likely the PCI_output object
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	continue = TRUE to continue print job
 *			 = FALSE to cancel printing
 *
 * Return:	Nothing
 */

/***************************************************************************/
@message void MSG_PRINT_CONTROL_SET_DOC_NAME( char *string = cx:dx );

/* Sets the document name, which is displayed in the Printer Control Panel
 * If this message in not received by the PrintControl object, the print
 * job will never be released to the spooler.
 *
 * Context:	Sent in response to MSG_PRINT_GET_DOC_NAME
 * Source:	Anyone, but most likely the GenAppDocumentControl object
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	string	= Null-terminated string of length no greater
 *			  than FILE_LONGNAME_LENGTH + 1.
 * Return:	Nothing
 */

/***************************************************************************/
@message Boolean MSG_PRINT_CONTROL_REPORT_PROGRESS(
					PCProgressType progress = cx,
					word pageOrPercent = dx );

/* Sent to display the progress of the application spooling a (generally)
 * large or complex image as an integer value.
 * 
 * Context:	Sent by application while printing.
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 * 
 * Pass:	 Progress 	 	PageOrPercent
 *		 --------		-------------
 *		 PCPT_PAGE 		Page number  
 *		 PCPT_PERCENT 	 	Percentage completed
 *
 *			  NOTE: You must have the PCI_attrs field set
 *			  properly for any progress dialog box to appear!
 *
 * Return:	 TRUE (to continue printing)
 *		 FALSE (to abort printing)
 *		  	An application should stop drawing to the
 *			provided GState immediately, and send a
 *			MSG_PRINT_CONTROL_PRINTING_CANCELLED
 *			to the PrintControl object.
 */

/***************************************************************************/
@alias(MSG_PRINT_CONTROL_REPORT_PROGRESS) \
Boolean MSG_PRINT_CONTROL_REPORT_STRING( PCProgressType progress = cx, \
					 char *progressString = dx:bp );

/* Sent to display the progress of the application spooling a (generally)
 * large or complex image as a string.
 *
 * Context:	Sent by application while printing.
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	progress = PCPT_TEXT
 *		progressString = Text message to display 
 *
 * Return:	 TRUE (to continue printing)
 *		 FALSE (to abort printing)
 *		  	An application should stop drawing to the
 *			provided GState immediately, and send a
 *			MSG_PRINT_CONTROL_PRINTING_CANCELLED
 *			to the PrintControl object.
 */
	
/***************************************************************************/
@message void MSG_PRINT_CONTROL_PRINTING_CANCELLED();

/* Cancel the print job currently being spooled by the application. Do *not*
 * send both this method and a MSG_PRINT_CONTROL_PRINTING_COMPLETED for
 * a single print job.
 *
 * Context:	Sent by an application to stop spooling a document once
 *		spooling has begun, possibly due to an error. The application
 *		may not use the GState handle it was drawing to once this
 *		message has been sent.
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	Nothing
 * Return:	Nothing
 */

/***************************************************************************/
@message void MSG_PRINT_CONTROL_PRINTING_COMPLETED();

/* Indicate that the application has finished spooling the document
 *
 * Context:	Sent by the application once it is done "drawing" the
 *		document.
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	Nothing
 * Return:	Nothing
 */

/***************************************************************************/
@message void MSG_PRINT_CONTROL_SET_ATTRS( PrintControlAttrs attributes = cx );

/* Set the attributes for a PrintControl object.
 *
 * Context:	Utility message sent to set the PrintControlAttrs
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	attributes	= PrintControlAttrs	
 *
 * Return:	Nothing
 */

/***************************************************************************/
@message PrintControlAttrs MSG_PRINT_CONTROL_GET_ATTRS() = cx;

/* Get the attributes for a PrintControl object
 *
 * Context:	Utility message sent to get PrintControlAttrs
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Return:	PrintControlAttrs 
 */

/***************************************************************************/
@message void MSG_PRINT_CONTROL_SET_TOTAL_PAGE_RANGE( word firstPage = cx, \
						      word lastPage = dx );

/* Sets the first & last page numbers that are in the document
 *
 * Context:	Sent whenever the number of pages in a document changes, or
 *		a new document is opened. Must be correct prior to sending
 *		MSG_PRINT_CONTROL_PRINTING_COMPLETED
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	firstPage = First page (usually 0 or 1)
 *		lastPage = Last page
 *
 * Return:	Nothing
 */

/***************************************************************************/
typedef struct {
	word	PCPR_lastPage;
	word	PCPR_firstPage;
} PCPageRange;

@message PCPageRange MSG_PRINT_CONTROL_GET_TOTAL_PAGE_RANGE() = cx.dx;
/*
 * Gets the first & last page numbers in a document
 *
 * Context:	Utility message sent to get the number of pages
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	Nothing
 *
 * Return:	PCPageRange structure containing first and last
 *		page numbers
 *
 * Note: This is not the range of pages the user has selected to be
 *       printed. That is the SELECTED page range.
 */


/***************************************************************************/
@message void MSG_PRINT_CONTROL_SET_SELECTED_PAGE_RANGE(word firstPage = cx, \
							word lastPage = dx );

/* Sets the (initial) first & last pages to be printed in a document
 *
 * Context:	Utility message sent to set a common default page range
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	firstPage = First page (usually 0 or 1)
 *		lastPage = Last page
 *
 * Return:	Nothing
 */


/***************************************************************************/
@message PCPageRange MSG_PRINT_CONTROL_GET_SELECTED_PAGE_RANGE() = cx.dx;
/* 
 * Returns the user-selected range of pages to be printed
 *
 * Context:	Sent to obtain the range of pages to be printed, usually
 *		right after the application received MSG_PRINTING_PRINT.
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	Nothing
 *
 * Return:	PCPageRange structure containing first and last
 *		page numbers
 */


/***************************************************************************/
@message void MSG_PRINT_CONTROL_SET_DOC_SIZE(word width = cx,
    	    	    	    	    	     word height = dx);

/* Sets the dimensions of the document to be printed.
 *
 * Context:	Sent (generally) whenever a new document is opened, or when
 *		the existing document changes size. The size must be accurate
 *		prior to MSG_SPOOL_PRINT_COONTROL_PRINTING_COMPLETED is sent.
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	width 	= Width (in points)
 *		height 	= Height (in points)
 *
 * Return:	Nothing
 *
 * Note: For 32-bit document sizes, use MSG_SPOOL_PRINT_CONTROL_SET_
 *	 EXTENDED_DOC_SIZE 
 */


/***************************************************************************/

/*
 * Use the DWORD_WIDTH and DWORD_HEIGHT macros to get the width and
 * height from the returned value.
 */
@message SizeAsDWord MSG_PRINT_CONTROL_GET_DOC_SIZE() = dx.cx;

/* Returns the dimensions of the document to be printed.
 *
 * Context:	Utility message sent to get the size of a document
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	Nothing
 *
 * Return:	DocSize structure: DS_width = Width (in points)
 *		    	    	   DS_height = Height (in points)
 *
 * Note: For 32-bit document sizes, use MSG_SPOOL_
 *	 PRINT_CONTROL_GET_EXTENDED_DOC_SIZE
 */

/***************************************************************************/
@message void MSG_PRINT_CONTROL_SET_EXTENDED_DOC_SIZE( \
					PCDocSizeParams *ptr = dx:bp );

/* Sets the dimensions of the document to be printed.
 *
 * Context:	Sent (generally) whenever a new document is opened, or when
 *		the existing document changes size. The size must be accurate
 *		prior to MSG_SPOOL_PRINT_COONTROL_PRINTING_COMPLETED is sent.
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	*ptr	= PCDocSizeParams structure.
 *
 * Return:	Nothing
 */


/***************************************************************************/
@message void MSG_PRINT_CONTROL_GET_EXTENDED_DOC_SIZE( \
					PCDocSizeParams *ptr = dx:bp );

/* Returns the dimensions of the document to be printed.
 *
 * Context:	Utility message sent to get the size of a document
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	ptr = pointer to PCDocSizeParams (empty)
 *
 * Return:	ptr = pointer to PCDocSizeParams (filled)
 *
 * Note: This will return the correct result, regardless
 *       of whether 16-bit or 32-bit size were set.
 */


/***************************************************************************/
@message void MSG_PRINT_CONTROL_SET_DOC_MARGINS( PCMarginParams *ptr = dx:bp );

/* Sets the margins the user has selected for the current document.
 *
 * Context:	Sent when a new document is opened, or when the margins for 
 *		the current document are changed. The margins *must* be set 
 *		prior to MSG_PRINT_CONTROL_PRINTING_COMPLETED is sent.
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 * 
 * Pass:	ptr = pointer to PCMarginParams structure 
 *
 * Return:	Nothing
 */


/***************************************************************************/
@message void MSG_PRINT_CONTROL_GET_DOC_MARGINS( PCMarginParams *ptr = dx:bp );

/* Gets the margins the user has selected for the current document.
 *
 * Context:	Utility message sent to the PrintControl object
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	ptr = pointer to PCMarginParams structure (empty)
 *
 * Return:	ptr = pointer to PCMarginsParams structure (filled)
 */


/***************************************************************************/
@message void MSG_PRINT_CONTROL_SET_DOC_SIZE_INFO(PageSizeReport *ptr = dx:bp);

/* Set all of the information about the document size & orientation
 *
 * Context:	Sent (generally) whenever a new document is opened, or when
 *		the existing document changes size. The size must be accurate
 *		prior to MSG_SPOOL_PRINT_CONTROL_PRINTING_COMPLETED is sent.
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	ptr = pointer to PageSizeReport structure
 *
 * Return:	Nothing
 */

/***************************************************************************/
@message void MSG_PRINT_CONTROL_GET_DOC_SIZE_INFO(PageSizeReport *ptr = dx:bp);

/* Gets the data about the size & orientation of the document to be printed.
 *
 * Context:	Utility message sent to get the size of a document
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	ptr = pointer to PageSizeReport structure (empty)
 *
 * Return:	ptr = pointer to PageSizeReport structure (filled)
 */

/***************************************************************************/
@message void MSG_PRINT_CONTROL_SET_OUTPUT( optr objectPtr = cx:dx );

/* Sets the output of the PrintControl object, the object which receives
 * all the printing-related messages.
 *
 * Context:	Sent whenever a different object in an application needs to
 *		communicate with the PrintControl object. Rarely used.
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	objectPtr = OD of object
 * 
 * Return:	Nothing
 */

/***************************************************************************/
@message optr MSG_PRINT_CONTROL_GET_OUTPUT() = cx:dx;

/* Get the output object's OD of the PrintControl object
 *
 * Context:	Utility message sent to get the output of the PrintControl
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 * 
 * Pass:	Nothing
 *
 * Return:	OD of the output object
 */
 

/***************************************************************************/
@message void MSG_PRINT_CONTROL_SET_DOC_NAME_OUTPUT( optr document = cx:dx );

/* Sets the document name output of the PrintControl object, the object
 * which receives MSG_PRINT_GET_DOC_NAME.
 *
 * Context:	Sent whenever a different object in an application needs to
 *		communicate with the PrintControl object. Rarely used.
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	document = OD of document name object
 *
 * Return:	Nothing
 */


/***************************************************************************/
@message optr MSG_PRINT_CONTROL_GET_DOC_NAME_OUTPUT() = cx:dx;

/* Get the document name output OD of the PrintControl object
 *
 * Context:	Utility message sent to get the output of the PrintControl
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 * 
 * Pass:	Nothing
 *
 * Return:	OD of the document name object
 */


/***************************************************************************/
@message void MSG_PRINT_CONTROL_SET_DEFAULT_PRINTER( word printerNum = cx );

/* Sets the application-default printer, to be used the next time the
 * print dialog box appears.
 *
 * Context:	Used by system utilities or other applications that want
 *		override the user-set default printer.
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	printerNum	= Printer number (zero-based)
 *				= -1 indicates we should use the system's
 *				  default
 *
 * Return:	Nothing
 */


/***************************************************************************/
@message word MSG_PRINT_CONTROL_GET_DEFAULT_PRINTER() = cx;

/* Returns the application-default printer. Donot* expect that this indeed
 * is the printer that the user in printing to, as he/she may have been able
 * to change to a new printer. This method is included for orthogonality.
 *
 * Context:	Utility message to get the application-default printer.
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	Nothing
 *
 * Return:	Printer number (zero-based)  OR
 *		-1 indicates we should use the system's default
 */


/***************************************************************************/
@message PrinterMode MSG_PRINT_CONTROL_GET_PRINT_MODE() = cl;

/* Returns the print-mode selected by the user for printing.
 *
 * Context:	This may be used by applications to adjust their output
 *		depending what type of output has been selected by the user.
 *		It is only useful between the time MSG_PRINTING_PRINT is
 *		received & MSG_PRINT_CONTROL_PRINTING_COMPLETED is sent.
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	Nothing
 *
 * Return:	PrinterMode (0 if no mode is yet selected)
 */


/***************************************************************************/
@message void MSG_PRINT_CONTROL_GET_PAPER_SIZE_INFO(
				PageSizeReport *ptr = dx:bp);

/* Get the current paper size & orientation selected by the user
 *
 * Context:	Utility message sent to the PrintControl object
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass: 	ptr = pointer to PageSizeReport structure (empty)
 *
 * Return:	ptr = pointer to PageSizeReport structure (filled)
 */


/***************************************************************************/
typedef struct {
    	word	PD_widthHigh;	/* paper width, in points - high word */
	word	PD_widthLow;	/* paper width, in points - low word */
	dword	PD_height;  	/* paper height, in points */
} PaperDimensions;

/* 
 * To make a dword from the values returned in PD_widthHigh and PD_widthLow,
 * use the PAPER_WIDTH macro.
 */
#define PAPER_WIDTH(pd) (((pd).PD_widthHigh << 16) | (pd).PD_widthLow)
#define PAPER_HEIGHT(pd) ((pd).PD_height)

@message void MSG_PRINT_CONTROL_GET_PAPER_SIZE(
				PaperDimensions *retValue = axcxdxbp);

/* Return the dimensions of the paper selected for the current printer.
 *
 * Context:	Utility message sent to the PrintControl object
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:     	Nothing
 *
 * Return:	*retValue->PD_height= Paper height (in points)
 *		*retValue->PD_widthLow	= low word of paper width (in points)
 *		*retValue->PD_widthHigh	= high word of paper height (in points)
 */

/***************************************************************************/
@message void MSG_PRINT_CONTROL_GET_PRINTER_MARGINS(
				PCMarginParams *retValue = axcxdxbp,
				Boolean setMargins = dx);

/* Returns the margins enforced by the current printer.
 *
 * Context:	Utility message sent when setting default margins for a
 *		document, or possibly when printing for a non-WYSIWYG app.
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:    	*retValue	= empty PCMarginParams structure
 *
 *	    	setMargins	= TRUE  - to set the document margins to be 
 *		    	          the same as the printer's margins
 *  			    	= FALSE - to leave the document margins the same
 *
 * Return: 	*retValue	= filled PCMarginParams structure
 */

/***************************************************************************/

@message void MSG_PRINT_CONTROL_CALC_DOC_DIMENSIONS(
				PageSizeReport *ptr = dx:bp); 

/* Calculates and returns the dimensions of the document, based on the
 * currently selected paper size, the printer's margins, and the
 * PCA_FORCE_ROTATION bit. The document size & margins will also be set by
 * this message.
 *
 * Context:	Used by non-WYSIWYG applications who want to ensure that
 *		the document created will exactly fit on the paper the user
 *		has selected for the printer, called after MSG_PRINTING_
 *		PRINT has been received.
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass: 	*ptr	= empty PageSizeReport structure
 *
 * Return:	*ptr	= filled PageSizeReport structure with the
 *			  margins already subtracted from the
 *			  dimensions of the page and the orientation
 *			  taken into account.
 */


/***************************************************************************/
@message Boolean MSG_PRINT_CONTROL_CHECK_IF_DOC_WILL_FIT(Boolean warning = cx);

/* Test to see if the document will fit with the currently selected paper
 *
 * Context:	Possibly sent when a user selects new margins or document size
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted
 *
 * Pass: 	warning	= Boolean (display a warning to the user)
 *
 * Return:	TRUE  - if the document will fit
 *				OR 
 *		FALSE - if the document will not fit
 */


/*--------------------------------------------------------------------------*
		Internal Messages
--------------------------------------------------------------------------*/

/* Do *NOT* send any of the following three methods to the PrintControl.
 * They are for internal use only, but must be declared here so that this
 * class  may use them
 */


/***************************************************************************/
@message void MSG_PRINT_CONTROL_VERIFY_PRINT();

/* Sent to allow printing "anyway" after the verification dialog box has
 * appeared.
 *
 * Context:	The user has selected to ignore the warning about the
 *		margins or the document size, and wants to print anyway.
 * Source:	GenTrigger in verify dialog box
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	Nothing
 *
 * Return:	Nothing
 */


/***************************************************************************/
@message void MSG_PRINT_CONTROL_VERIFY_SCALE();

/* Sent to allow printing by scaling the document to ensure it fits on the
 * paper selected by the user.
 *
 * Context:	The user has selected to have the document automatically
 *		scaled to fit, after a warning appeared.
 * Source:	GenTrigger in verify dialog box
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	Nothing
 *
 * Return:	Nothing
 */


/***************************************************************************/
@message void MSG_PRINT_CONTROL_VERIFY_CANCEL();

/* Sent to stop printing, because of a document/paper margin size conflict
 *
 * Context:	The user selected to Cancel printing after the warning
 *		from the PrintControl appeared.
 * Source:	GenTrigger in verify dialog box
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	Nothing
 *
 * Return:	Nothing
 */


/***************************************************************************/
@message void MSG_PRINT_CONTROL_ABORT_PRINT_JOB();

/* Sent to eventually stop printing.
 *
 * Context:	The user selected to Cancel printing while the print
 *		progress dialog box was onscreen.
 * Source:	GenTrigger in progress dialog box
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	Nothing
 *
 * Return:	Nothing
 */


/*-----------------------------------------------------------------------------
		Post-2.0 Messages
  ---------------------------------------------------------------------------*/

@protominor	PostZoomerMessages

@message void MSG_PRINT_CONTROL_INITIATE_OUTPUT_UI(PrinterDriverType type = cl);

/* Display the output (print or fax, currently) dialog box.
 *
 * Context:	Invoked by the user wanting to print a document, by 
 *		(usually) clicking on the print trigger in the file menu.
 *		Generally used just internally, as the PrintControl provides
 *		all the UI one should need for printing.
 * Source:	Anyone
 * Destination:	PrintControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	CL	= PrinterDriverType
 *
 * Return:	Nothing
 *		AX, CX, DX, BP - destroyed
 */

@message void MSG_PRINT_SET_PRINT_CONTROL_PAGE_SIZE(PageSizeReport *psr = dx:bp);

/*
 * Sets the page size to be displayed by the print control.  Internal only,
 * and currently Redwood-only.
 *
 * Context:	Utility message sent to set the page dimensions
 * Source:	Anyone
 * Destination:	PageSizeControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	DX:BP	= PageSizeReport structure
 *
 * Return:	Nothing
 */

@protominor	SpoolMailboxSupport;

@message Boolean MSG_PRINT_GET_MAILBOX_OBJECT_TYPE(word *dataType = multipleax) = carry;
/* Fetch the MailboxObjectType the caller should render, if the print request
 * came via a MailboxSendControl
 *
 * Context:	Called by the recipient of MSG_PRINT_START_PRINTING if the
 *		application supports the MailboxSendControl. It allows
 *		the caller to print things other than the current document.
 * Source:	Anyone
 * Destination:  PrintControlClass
 * Interception: not useful
 *
 * Pass:
 *		nothing
 * Return:
 *		1 if print request didn't come from the
 *		    MailboxSendControl, so there's no MailboxObjectType to
 *		    return
 *			*dataType = destroyed
 *		0 if MailboxObjectType returned:
 *			*dataType = MailboxObjectType to render
 */

@message void MSG_PRINT_CANNOT_PRINT(word error = cx);
/* Internal message sent by the print dialog box when it finds it cannot
 * fulfill its purpose.
 *
 * Context:	Called by the SpoolSummons object when it initializes and
 *		finds it is hosed.
 * Source:	SpoolSummonsClass
 * Destination:	PrintControlClass
 * Interception: probably not useful
 */

@message word MSG_PRINT_GET_FIRST_PAGE_OFFSET() = dx;
/* Return the height of the last page of the  currently selected cover page.  
 * Returns zero if no cover page is being used.
 *
 * Context:     Called by an application after receiving a 
 *              MSG_PRINT_START_PRINING and before drawing to the print
 *              gstate.
 * Source:      Any application that has a PrintControl
 * Destination: PrintConrtolClass 
 * Interception: probably not useful
 */



@protoreset


/*--------------------------------------------------------------------------*
		Methods imported from MetaClass
--------------------------------------------------------------------------*/

/***************************************************************************/
@importMessage MetaPrintMessages, void MSG_PRINT_VERIFY_PRINT_REQUEST(   \
					optr printCtrlOD = cx:dx );

/* Sent to request the application to verfiy that state of the 
 * application-supplied UI is indeed valid for printing to ensue.
 *
 * Context:	Once printing is requested by the user, this message is 
 *		sent
 *		out, giving the application a chance to cancel the print job.
 * Source:	PrintControl object
 * Destination:	PCI_output
 * Interception: May be intercepted by any object. To obtain the root of the
 *		generic tree to analyze, an application may want to use
 *		MSG_PRINT_CONTROL_GET_APP_PRINT_UI
 *
 * 		The interceptor must send back to the passed OD a
 *		MSG_PRINT_CONTROL_VERIFY_COMPLETED with the
 *		applicable arguments. Failure to do so will cause the
 *		print job to never be completed.
 *
 * Pass:	printCtrlOD = OD of the PrintControlClass object
 *
 * Return:	Nothing
 */



/***************************************************************************/
@importMessage MetaPrintMessages, void MSG_PRINT_START_PRINTING(           \
					optr printCtrlOD = cx:dx,  \
					GStateHandle gstate = bp );

/* Sent to tell the application to begin printing
 *
 * Context:	Once the user has clicked on the Print trigger in the
 *		Print dialog box, a spool file will be created, and this
 *		message will be sent.
 * Source:	PrintControl object
 * Destination:	PCI_output
 * Interception: May be intercepted by any object
 *
 * Pass: 	printCtrlOD = OD of the PrintControlClass object
 *	 	gstate      = GState handle to print (draw) to
 *
 * Return:	Nothing
 */

/***************************************************************************/
@importMessage MetaPrintMessages, void MSG_PRINT_GET_DOC_NAME(
					optr printCtrlOD = cx:dx);

/* Sent to request the name of the document being printed.
 *
 * Context:	Once printing is requested by the user, this message
 * 		is sent
 *		out, and the document will not be handed off to the spooler
 *		until it is returned.
 * Source:	PrintControl object
 * Destination:	PCI_docNameOutput
 * Interception: Intercepted by the AppDocumentControlClass, which will then
 *    	    	return the name of the current document. The recipient of
 *		this messagemust* respond with MSG_PRINT_CONTROL_SET
 *		DOC_NAME.
 *
 * Pass:	printCtrlOD = OD of the PrintControlClass object
 *
 * Return:	Nothing
 */
 

/***************************************************************************/
@importMessage MetaPrintMessages, void MSG_PRINT_NOTIFY_PRINT_DB( \
					 optr printCtrlOD = cx:dx, \
					 PrintControlStatus pcs = bp );

/* Sent to indicate that the print dialog box will either soon be coming
 * onto the screen, or has left the screen.
 *
 * Context:	Used so application may keep UI gadgetry up-to-date only
 *		when necessary.
 * Source:	PrintControl object
 * Destination:	PCI_output
 * Interception: May be intercepted by any object.
 *
 * Pass:	printCtrlOD = OD of the PrintControlClass object
 *		pcs         = PrintControlStatus
 *
 * Return:	Nothing
 */

 
/***************************************************************************/
@importMessage MetaPrintMessages, void MSG_PRINT_NOTIFY_PRINT_JOB_CREATED( \
					optr printCtrlOD = cx:dx, \
					word jobID = bp);

/* Sent to indicate that a print job has been created by the spooler in
 * response to an application's request.
 *
 * Context:	Send out by the PrintControl after a successful call to
 *		SpoolAddJob
 * Source:	PrintControl object
 * Destination:	PCI_output
 * Interception: May be intercepted by any object. Applications will need
 *		the passed ID if they want to modify any part of the job's
 *		status, though this behavior is not encouraged. Rather,
 *		let the user manipulate the print jobs by using the
 *		Printer Control Panel.
 *
 * Pass:	printCtrlOD = OD of PrintControl object originating job
 *		jobID	= Print job ID
 * 
 * Return:	Nothing
 */

/*--------------------------------------------------------------------------*
		Instance Data

 Note: Please refer to the documentation under PrintControlClass
       for more information on all of the following instance data
--------------------------------------------------------------------------*/

@instance PrintControlAttrs   	PCI_attrs =  \
	(PCA_COPY_CONTROLS | PCA_PAGE_CONTROLS | PCA_QUALITY_CONTROLS |
	 PCA_USES_DIALOG_BOX | PCA_GRAPHICS_MODE | PCA_TEXT_MODE );

@instance word	PCI_startPage = 1;	  /* first possible page to print */
@instance word  PCI_endPage = 1;	  /* last possible page to print */
@instance word  PCI_startUserPage = 0;	  /* start of page range to print */
@instance word  PCI_endUserPage = 0x7fff; /* end of page range to print */
@instance word  PCI_defPrinter = -1;	  /* the default printer to use */
 	    	    	    	    	  /* the document size data: */
@instance PageSizeReport PCI_docSizeInfo = {0, 0, 0, {0, 0, 0, 0}};
@instance optr  PCI_output;		  /* destination for methods sent out */
@instance optr  PCI_docNameOutput;	  /* OD for MSG_PRINT_GET_DOC_NAME */

@default GII_visibility = GIV_SUB_GROUP;
@default GII_type = GIT_ORGANIZATIONAL;
@default GI_attrs = @default | GA_KBD_SEARCH_PATH;

#define	PRINT_TRIGGER_VALUES  		'GI_visMoniker = "Print";'
#define	FAX_TRIGGER_VALUES 		'GI_visMoniker = "Fax";'

/*--------------------------------------------------------------------------*
		Variable instance data
--------------------------------------------------------------------------*/

typedef ByteFlags PrintStatusFlags;
#define PSF_FAX_AVAILABLE	0x80	/* set if a fax driver is available */
#define PSF_ABORT		0x08	/* user wants to abort printing */
#define PSF_RECEIVED_COMPLETED	0x04	/* MSG_PC_PRINTING_COMPLETED received */
#define PSF_RECEIVED_NAME	0x02	/* MSG_PC_SET_DOC_NAME received */
#define PSF_VERIFIED		0x01	/* PSG_PC_VERIFY_? received */

typedef struct {
    optr	TPCI_currentSummons;	/* currently active summons */
    optr	TPCI_progressBox;	/* OD of progress dialog box */
    ChunkHandle	TPCI_jobParHandle;	/* memory handle to JobParamters */
    word	TPCI_fileHandle;	/* file handle (if printing) */
    word	TPCI_gstringHandle;	/* gstring handle (if printing) */
    word	TPCI_printBlockHan;	/* the printer block handle */
    PrintControlAttrs	TPCI_attrs;
    PrintStatusFlags	TPCI_status;
    byte	TPCI_holdUpCompletionCount; /* # of things not wanting the
					     * message stored in 
					     * TEMP_PRINT_COMPLETION_EVENT to
					     * be sent out just yet. */
} TempPrintCtrlInstance;

@vardata TempPrintCtrlInstance TEMP_PRINT_CONTROL_INSTANCE;

/*---------------------------------------------------------------------------
		Attrs
---------------------------------------------------------------------------*/

/*
 * Attribute to allow applications to add their own UI to the Print DB.
 * The generic tree whose optr is stored here must *not* be set USABLE.
 * This is different from ATTR_GEN_CONTROL_APP_UI, which would add
 * triggers into the menu where your PrintControl object is a child.
 */
@vardata optr ATTR_PRINT_CONTROL_APP_UI;
@reloc ATTR_PRINT_CONTROL_APP_UI, 0, optr;

typedef struct {
	MemHandle	TPCED_event;
	MessageFlags	TPCED_messageFlags;
} TempPrintCompletionEventData;
@vardata TempPrintCompletionEventData TEMP_PRINT_COMPLETION_EVENT;

typedef struct {
	optr			TPACD_addrControl;
	PrinterDriverType	TPACD_driverType;
} TempPrintAddressControlData;

@vardata TempPrintAddressControlData TEMP_PRINT_CONTROL_ADDRESS_CONTROL;
/* Attribute set when the print control is used by the MailboxSendControl
 * DO NOT SET IT YOURSELF */

@endc 	/* end PrintControlClass */

/*--------------------------------------------------------------------------*
		PageSizeControlClass definition
--------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------
 	If your application maintains the document size information, then
 you want your PageSizeControl object to act like any other controller.
 This is the default behavior.

	If, instead, you have a simpler application, you will want to use
 your PageSizeControl object as you would any other generic object. To do
 this, set the PZCA_ACT_LIKE_GADGET flag. To have the object initialize
 itself to the default system values, all you must do is set the 
 PZCA_INITIALIZE flag. Use this instead of stuffing the instance data
 of the object with pre-defined paper size values, as these values are
 probably not appropriate for foreign users.
-------------------------------------------------------------------------*/

/*
 * GenApplication GCN lists to be placed on:
 *	GAGCNLT_SELF_LOAD_OPTIONS
 */

@class PageSizeControlClass, GenControlClass;

/*--------------------------------------------------------------------------*
    		Constants
--------------------------------------------------------------------------*/

#define MINIMUM_PAGE_WIDTH_VALUE	36		 /* 1/2 inch */
#define MINIMUM_PAGE_HEIGHT_VALUE	36		 /* 1/2 inch */

#ifdef DO_PIZZA
#define MAXIMUM_PAGE_WIDTH_VALUE	3189	 /* 112.5 cm */
#define MAXIMUM_PAGE_HEIGHT_VALUE	3189	 /* 112.5 cm */
#else
#define MAXIMUM_PAGE_WIDTH_VALUE	(72*45)	 /* 45 inches */
#define MAXIMUM_PAGE_HEIGHT_VALUE	(72*45)	 /* 45 inches */
#endif

#define MAXIMUM_LABELS_ACROSS		63
#define MAXIMUM_LABELS_DOWN		63

/* PageSize attributes */

typedef WordFlags PageSizeCtrlAttrs;
/* External */
#define PZCA_ACT_LIKE_GADGET	0x8000	/* Use like gadget, not controller */
#define PZCA_PAPER_SIZE 	0x4000	/* Show paper size, not document size */
#define PZCA_INITIALIZE		0x2000	/* Initialize to default value - can
					 only be passed if a gadget */
#define PZCA_LOAD_SAVE_OPTIONS	0x1000	/* Load/Save options to/from INI file */

/* Internal */
#define PZCA_NEW_PAGE_TYPE	0x0080
#define PZCA_SWAP_WIDTH_HEIGHT  0x0040
#define PZCA_INITIALIZED	0x0020
#define PZCA_IGNORE_UPDATE	0x0010
#define PZCA_PORTRAIT_VALID	0x0008
#define PZCA_LANDSCAPE_VALID	0x0004

/* Features flags (used with ATTR_GEN_CONTROL_REQUIRE_UI &
 *                           ATTR_GEN_CONTROL_PROHIBIT_UI)
 */
typedef WordFlags PageSizeControlFeatures;
#define PSIZECF_MARGINS		0x0010	/* not part of default features! */
#define PSIZECF_CUSTOM_SIZE	0x0008
#define PSIZECF_LAYOUT		0x0004
#define PSIZECF_SIZE_LIST	0x0002
#define PSIZECF_PAGE_TYPE	0x0001

#define PSIZEC_DEFAULT_FEATURES (PSIZECF_PAGE_TYPE | \
				 PSIZECF_SIZE_LIST | \
				 PSIZECF_LAYOUT | \
				 PSIZECF_CUSTOM_SIZE)

/* Toolbox features flags (used with ATTR_GEN_CONTROL_REQUIRE_TOOLBOX_UI &
 *                                   ATTR_GEN_CONTROL_PROHIBIT_TOOLBOX_UI)
 */
typedef WordFlags PageSizeControlToolboxFeatures;
#define PSIZECTF_DIALOG_BOX 	0x0001

#define PSIZECT_DEFAULT_TOOLBOX_FEATURES	PSIZECTF_DIALOG_BOX


/*--------------------------------------------------------------------------*
		Messages
--------------------------------------------------------------------------*/

/***************************************************************************/
@message void MSG_PZC_SET_PAGE_SIZE( PageSizeReport *psr = dx:bp );


/* Sets the page size to be displayed by the list
 *
 * Context:	Utility message sent to set the page dimensions
 * Source:	Anyone
 * Destination:	PageSizeControlClass object
 * Interception: Generally should not be intercepted.
 *
 * 	If your application maintains the document size information, then
 * you want your PageSizeControl object to act like any other controller.
 * This is the default behaviour.
 *
 * 	If, instead you have a simplier application, you will want to use
 * your PageSixeControl object as you would any other generic object.  To do
 * this, set the PZCA_ACT_LIKE_GADGET flag.  To have the object initialize
 * itself to the default system values, all you must do is set the 
 * PZCA_INITIALIZE flag.  Use this instead of stuffing the instance data 
 * of the object with pre-defined paper size values, as these values are 
 * probably not appropriate for foreign users.
 *
 * Pass:	psr 	= pointer to PageSizeReport	
 *
 * Return:	Nothing
 */

/***************************************************************************/
@message void MSG_PZC_GET_PAGE_SIZE( PageSizeReport *psr = dx:bp );

/* Returns the page size that the user has selected.
 *
 * Context:	Utility message sent to get the page dimensions
 * Source:	Anyone
 * Destination:	PageSizeControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	psr = pointer to PageSizeReport structure (empty)
 *
 * Return: 	psr = pointer to PageSizeReport structure (filled);
 */

/*---------------------------------------------------------------------------*
		Internal messages
---------------------------------------------------------------------------*/

/***************************************************************************/
@message void MSG_PZC_REQUEST_PAGE_SIZE_MONIKER();
@message void MSG_PZC_SET_PAGE_TYPE();
@message void MSG_PZC_SET_PAGE_SIZE_ENTRY();
@message void MSG_PZC_SET_PAGE_WIDTH();
@message void MSG_PZC_SET_PAGE_HEIGHT();
@message void MSG_PZC_SET_PAPER_ORIENTATION();
@message void MSG_PZC_SET_ENVELOPE_ORIENTATION();
@message void MSG_PZC_SET_LABEL_COLUMNS();
@message void MSG_PZC_SET_LABEL_ROWS();
@message void MSG_PZC_SET_MARGIN_LEFT();
@message void MSG_PZC_SET_MARGIN_TOP();
@message void MSG_PZC_SET_MARGIN_RIGHT();
@message void MSG_PZC_SET_MARGIN_BOTTOM();

/*---------------------------------------------------------------------------*
		More external messages
---------------------------------------------------------------------------*/

/***************************************************************************/
@message void MSG_PZC_SET_MAXIMUM_WIDTH(dword width = dx.cx);
/*
 * Sets the maximum width for a page
 *
 * Context:	Utility message sent to set the maximum width
 * Source:	Anyone
 * Destination:	PageSizeControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	width	= Width (in points)
 *
 * Return: 	Nothing
 */

/***************************************************************************/
@message void MSG_PZC_SET_MAXIMUM_HEIGHT(dword height = dx.cx);
/*
 * Sets the maximum height for a page
 *
 * Context:	Utility message sent to set the maximum width
 * Source:	Anyone
 * Destination:	PageSizeControlClass object
 * Interception: Generally should not be intercepted.
 *
 * Pass:	height	= Height (in points)
 *
 * Return: 	Nothing
 */

/*---------------------------------------------------------------------------*
		MetaMessages
---------------------------------------------------------------------------*/

/***************************************************************************/
@importMessage MetaPrintMessages, void MSG_PRINT_REPORT_PAGE_SIZE(
			    		PageSizeReport *psr = ss:bp);

/* Sent to report the page size & layout options the user has selected.
 *
 * Context:	Sent out after a user has clicked on the apply trigger
 *		in the Page Setup DB.
 * Source:	PageSizeControl object
 * Destination:	GCI_output (of GenControlClass)
 * Interception: May be intercepted by any object.
 *
 * Pass:	psr =	Pointer to PageSizeReport structure
 *
 * Return:	Nothing
 */


/*--------------------------------------------------------------------------*
		Instance Data
--------------------------------------------------------------------------*/

@instance PageSizeCtrlAttrs PZCI_attrs;

@instance dword PZCI_width;		/* current width */
@instance dword PZCI_height;		/* current height */
@instance PageLayout PZCI_layout;	/* current page layout information*/
@instance PCMarginParams PZCI_margins;	/* current document margins */

@default GII_type = GIT_PROPERTIES;
@default GII_visibility = GIV_DIALOG;

#define	PAGE_SETUP_CONTROL_VALUES 	'GI_visMoniker = "Page Setup";'

/*--------------------------------------------------------------------------*
		Variable instance data
--------------------------------------------------------------------------*/

typedef struct {
    dword	PZCMD_width;		/* maximum width */
    dword	PZCMD_height;		/* maximum height */
} PageSizeControlMaxDimensions;

@vardata PageSizeControlMaxDimensions TEMP_PAGE_SIZE_CONTROL_MAX_DIMENSIONS;

/*--------------------------------------------------------------------------*
		Attrs
--------------------------------------------------------------------------*/

@prototype void PAGE_SIZE_UI_CHANGES_MSG(PageSizeReport *psr = ss:bp);

typedef struct {
    optr	PSCC_destination;	/* destination for message */
    Message	PSCC_message;		/* message to be sent */
} PageSizeControlChanges;

@vardata PageSizeControlChanges ATTR_PAGE_SIZE_CONTROL_UI_CHANGES;

/* Attribute to allow applications to be made aware of every change made
 to gadgetry in the PageSizeControl. This is especially useful for apps
 that want to add UI that will be dependent upon the state of this
 controller. No effort is made to eliminate the redundant output of data. */

/*--------------------------------------------------------------------------*
		Hints
--------------------------------------------------------------------------*/

@endc	/* end PageSizeControlClass */

/*------------------------------------------------------------------------------
		Process class
---------------------------------------------------------------------------*/

@class	SpoolProcClass,	GenProcessClass;

/*-----------------------------------------------------------------------------
	MESSAGES		
-----------------------------------------------------------------------------*/


@message void MSG_SPOOL_SHOW_PRINTER_CONTROL_PANEL();
/*
 * Brings up the Printer Control Panel.  This message is defined here
 * so that other apps can initiate the control panel.  NO OTHER
 * messages should be sent to the spool's process from outside the
 * spool library.
 *
 * Context:	Sent to the SpoolApplicationClass from the UI
 * Source:	UI (Express Menu)
 * Destination:	SpoolerClass (process) object
 * Interception: Should not be intercepted.
 *
 * Pass:	Nothing
 *
 * Return:	Nothing
 */


@exportMessages SpoolProcInternalMessages, @DEFAULT_EXPORTED_MESSAGES;

@endc	/* end SpoolProcClass */ 

/*--------------------------------------------------------------------------*
		Constants and Structure Definitions
--------------------------------------------------------------------------*/

#define DWhigh(x) ((word) ((x) >> 16))
#define DWlow(x) ((word) (x))

/*
 * For dealing with paper sizes, use a buffer this big
 */
#define MAX_PAPER_STRING_LENGTH 	48	/* includes NULL-terminator */

/*
 * Total number of paper sizes for each PageType
 */
#define MAX_PRE_DEFINED_PAPER_SIZES	128
#define MAX_USER_DEFINED_PAPER_SIZES	128
#define MAX_PAPER_SIZES			(MAX_PRE_DEFINED_PAPER_SIZES + \
					 MAX_USER_DEFINED_PAPER_SIZES)

/* 
 * Operation status codes returned by some spool library routines
 */
typedef enum /* word */ {
    SPOOL_OPERATION_SUCCESSFUL,
    SPOOL_JOB_NOT_FOUND,
    SPOOL_QUEUE_EMPTY,
    SPOOL_QUEUE_NOT_EMPTY,
    SPOOL_QUEUE_NOT_FOUND,
    SPOOL_CANT_VERIFY_PORT,
    SPOOL_OPERATION_FAILED,
} SpoolOpStatus;

/*
 * Structure for the time stamp of a print job spool
 */
typedef struct {
    byte	STS_second;		/* second of the minute (0-59) */
    byte	STS_minute;		/* minute of the hour (0-59) */
    byte	STS_hour;		/* hour of the day (0-23) */
} SpoolTimeStruct;

/* 
 * Structure for names of spool files.
 */
typedef struct {			
    char SFN_base[5];
    char SFN_num[3]; 
    char SFN_ext[5]; 
} SpoolFileName;

/*
 * Passed to SpoolInfo.
 */
typedef enum /* word */ {
    SIT_JOB_INFO    	= 0,
    SIT_QUEUE_INFO  	= 2,
    SIT_JOB_PARAMETERS	= 4
} SpoolInfoType;

/*
 * When SpoolInfo is passed SIT_JOB_INFO, it returns a JobStatus structure.
 */
typedef struct {
    char JS_fname[13]; 			/* std DOS (8.3) spool filename */	
    char JS_parent[FILE_LONGNAME_LENGTH+1];	    /* parent app's name */
    char JS_documentName[FILE_LONGNAME_LENGTH+1];   /* document name */
    word JS_numPages;			/* # pages in document */
    SpoolTimeStruct JS_time; 	 	/* time spooled */
    byte JS_printing;			/* TRUE/FALSE if we are printing */
} JobStatus;

/*--------------------------------------------------------------------------*
		Library routines
--------------------------------------------------------------------------*/

extern void
    _pascal SpoolGetDefaultPageSizeInfo(PageSizeReport *psr);
/*
 *  Pass:	*psr	= empty PageSizeReport structure
 *
 *  Return:	*psr filled with the default page size info
 *
 * 	Gets the system default PageSizeReport structure.
 */

extern void
    _pascal SpoolSetDefaultPageSizeInfo(PageSizeReport *psr);
/*
 *  Pass:   	*psr	= PageSizeReport structure specifying
 *    	    	    	  document width, height, layout, and margins
 *
 *  Return:	nothing
 *
 * 	Set the system default PageSizeReport structure.
 */

typedef struct {
	word	NPSI_numSizes;
	word	NPSI_defaultSize;
} NumPaperSizesInfo;

extern void
    _pascal SpoolGetNumPaperSizes(NumPaperSizesInfo *sizesInfo,
				  PageType pageType);
/*
 *  Pass:   	*sizesInfo  = empty NumPaperSizesInfo structure
 *  	    	pageType    = page type (paper, envelope, label...)
 *
 *  Return: 	*sizesInfo filled with the number of paper sizes
 *		and the default size. Currently, the default size
 *		returned is always 0.
 *
 *    	Use this routine to find the number of paper sizes, both
 *    	pre-defined & user-defined, that should appear in a paper size list
 */

extern word 
    _pascal SpoolGetPaperString(char *stringBuf,
				word paperSizeNum,
				PageType pageType);
/*
 *  Pass:   	*stringBuf  = empty char buffer of size MAX_PAPER_STRING_LENGTH
 *    	    	paperSizeNum = a paper size number between 0 and the
 *   	    	    	       value returned by SpoolGetNumPaperSizes()
 *   	    	    	       (paperSizeNum is not a PaperSizes enum)
 *   	    	pageType    = page type (paper, envelope, label...)
 *
 *  Return:	length (not counting final null) of null-terminated
 *		string now stored in *stringBuf
 *
 *    	Use this routine to determine the strings to be displayed for
 *	a specific paper size.
 */

typedef struct {
    word    	PSI_width;  	    /* width, in points */
    word    	PSI_height; 	    /* height, in points */
    PageLayout	PSI_defaultLayout;
} PaperSizeInfo;

extern void
     _pascal SpoolGetPaperSize(PaperSizeInfo *sizeInfo,
			       word paperSizeNum,
	 		       PageType pageType);
/*
 *  Pass:   	*sizeInfo   = empty PaperSizeInfo structure
 *    	    	paperSizeNum = a paper size number between 0 and the
 *   	    	    	       value returned by SpoolGetNumPaperSizes()
 *   	    	    	       (paperSizeNum is not a PaperSizes enum)
 *   	    	pageType    = page type (paper, envelope, label...)
 *
 *  Return:	*sizeInfo filled with the width and height (in points)
 *		of the paper size, plus the default page layout
 *
 *	Use this routine for determining the dimensions of a paper
 *	size.
 */

extern word 
    _pascal SpoolConvertPaperSize(word width,
				  word height,
				  PageType pageType);
/*
 *  Pass:   	width	    = paper width, in points
 *  	    	height	    = paper height, in points
 *   	    	pageType    = page type (paper, envelope, label...)
 *
 *  Return:	on success returns paper size number
 *		on failure returns -1
 *
 *	Converts a width and height to a paper size number according to the
 *	type of paper.
 */


typedef struct {
    word    PSOI_numOrdered;	/* number of ordered sizes */
    word    PSOI_numUnused; 	/* number of unused sizes */
} PaperSizeOrderInfo;

extern void
    _pascal SpoolGetPaperSizeOrder(byte *orderBuf,
				   byte *userDefBuf,
			           PaperSizeOrderInfo *numBuf);
/*
 *  Pass:   	*orderBuf   = empty buffer of size MAX_PAPER_SIZES
 *  	    	*userDefBuf = empty buffer of size MAX_PAPER_SIZES
 *  	    	*numBuf	    = empty PaperSizeOrderInfo structure
 *
 *  Return:	*orderBuf filled with the current paper size order array,
 *		*userDefBuf filled with the user-defined paper size array,
 *	    	*numBuf holding the number of ordered sizes and the
 *  	    	    number of unused sizes
 *
 *	Gets the current paper size order array.
 */

extern void 
    _pascal SpoolSetPaperSizeOrder(byte *orderArray,
				   word numEntries,
				   PageType pageType);
/*
 *  Pass:   	*orderArray = array of paper sizes. Each element is a
 *  	    	    	      byte signifying:
 *    	    	    	      	0-127: a predefined paper size
 *  	    	    	      	128-255: a user-defined paper size
 *  	    	numEntries  = number of entries in *orderArray
 *   	    	pageType    = page type (paper, envelope, label...)
 *  	    	   	
 *  Return:	nothing
 *
 *	Resets the order in which paper sizes are displayed to the user.
 */

extern word
    _pascal SpoolCreatePaperSize(char *paperSizeString,
    	    	    	    	 word width,
    	    	    	    	 word height,
    	    	    	    	 PageLayout layout,
    	    	    	    	 PageType pageType);
/*
 *  Pass:   	*paperSizeString    =
 *  	    	width	    = paper width, in points
 *  	    	height	    = paper height, in points
 *  	    	layout      = layout (orientation, rows, columns...)
 *   	    	pageType    = page type (paper, envelope, label...)
 *
 *  Return:    	on success, returns the new paper size (between 128 and 255)
 *		on failure, returns 0	
 *
 *	Create a new paper size and store it in the .INI file.
 */

extern Boolean
    _pascal SpoolDeletePaperSize(word paperSizeNum,
    	    	    	    	 PageType pageType);
/*
 *  Pass:   	paperSizeNum = a paper size number between 0 and the
 *   	    	    	       value returned by SpoolGetNumPaperSizes()
 *   	    	    	       (paperSizeNum is not a PaperSizes enum)
 *   	    	pageType    = page type (paper, envelope, label...)
 *
 *  Return:	on success returns 0
 *		on failure returns non-zero
 *
 *	This routine deletes a user-defined paper size
 */

extern word
    _pascal SpoolGetNumPrinters(PrinterDriverType driverType,
				byte localOnlyFlag);
/*
 *  Pass:   	driverType  	= a PrinterDriverType or PDT_ALL
 *   	    	localOnlyFlag	= non-zero if only locally-defined
 *  	    	    	    	  printers should be counted
 *
 *  Return:	number of printers
 *
 *	Return the number of printers of the passed type currently installed
 *	in the system.
 */

typedef struct {
    char     	    	PSI_stringBuf[GEODE_MAX_DEVICE_NAME_SIZE];
    word    	    	PSI_stringLength;
    PrinterDriverType	PSI_driverType;
} PrinterStringInfo;

extern Boolean
    _pascal SpoolGetPrinterString(PrinterStringInfo *retInfo,
    	    	    	    	  word printerNum);
/*
 *  Pass:   	*retInfo    =	empty PrinterStringInfo structure
 *  	    	printerNum  =	number of printer to get the string for
 *
 *  Return:	on success, returns 0 plus *retInfo filled with
 *    	    	  the desired name, the length of the name 
 *    	    	  (excluding final null), and the driver type.
 *		on failure, returns non-zero
 *
 *	Fills a buffer with the requested null-terminated printer name string.
 */

extern word
    _pascal SpoolCreatePrinter(char *printerName,
    	    	    	       PrinterDriverType driverType);
/*
 *  Pass:   	*printerName    = null-terminated printer name
 *  	    	driverType      = a PrinterDriverType or PDT_ALL
 *
 *  Return: 	number of new printer
 *		or -1 if printer already exists
 *
 *	Add a new printer to the end of the current printer list.
 *
 *	This routine is normally called from within the PrefMgr.
 */

extern void
    _pascal SpoolDeletePrinter(word printerNum);
/*
 *  Pass:   	printerNum  = number of printer to delete
 *
 *  Return:	nothing
 *
 *	Delete a printer from the current printer list.
 *
 *	This routine is normally called from within the PrefMgr.
 */

extern int
    _pascal SpoolGetDefaultPrinter(void);
/*
 *  Pass:   	nothing
 *
 *  Return: 	number of default printer
 *
 *	Return the system-default printer, which is used (for example)
 *	by the PrintControlClass as the default printer to print to.
 *
 *	This routine is normally called from within the PrefMgr.
 */

extern void
    _pascal SpoolSetDefaultPrinter(word printerNum);
/*
 *  Pass:   	printerNum	= number of printer to use as default
 *
 *  Return: 	nothing
 *
 *	Sets the system-default printer, used (for example) by the
 *	PrintControlClass as the default printer to print to.
 *
 *	This routine is normally called from within the PrefMgr.
 */

extern FileHandle
    _pascal SpoolCreateSpoolFile(char *fileNameBuf);
/*
 *  Pass:   	*fileNameBuf	= an empty buffer of size
 *  	    	    	    	  DOS_DOT_FILE_NAME_LENGTH_ZT
 *
 *  Return:	on success, returns handle of new file plus new
 *		  null-terminated file name stored in *fileNameBuf
 *    	    	on failure, returns 0    	  
 *
 *	Creates a uniquely-named empty spool file in the SP_SPOOL
 *  	standard directory. The file name is of the form SPOOLXXX.DAT.
 */

extern SpoolOpStatus
    _pascal SpoolDelJob(word jobID);
/*
 *  Pass:   	jobID	= ID number of job to delete
 *
 *  Return: 	status of operation, one of:
 *		    SPOOL_OPERATION_SUCCESSFUL
 *		    SPOOL_JOB_NOT_FOUND
 *		    SPOOL_QUEUE_EMPTY
 *
 *  	Use this routine to delete a job from a queue.
 */

/*
 * Parameters for SpoolInfoQueue (called by SpoolInfo).
 */
typedef struct {
    Boolean	    	SIQP_activityQuery;
    struct _PrintPortInfo  *SIQP_portInfo;
    MemHandle	    	SIQP_retBlock;
    word	    	SIQP_retNumJobs;
} SpoolInfoQueueParams;

/*
 * Parameters for SpoolInfoJob (called by SpoolInfo).
 */
typedef struct {
    word	SIJP_jobID;
    MemHandle	SIJP_retBlock;
} SpoolInfoJobParams;

/*
 * Parameters to pass to SpoolInfo.
 */
typedef union {
    SpoolInfoQueueParams    SIP_queueParams;
    SpoolInfoJobParams	    SIP_jobParams;
} SpoolInfoParams;

extern SpoolOpStatus
    _pascal SpoolInfo(SpoolInfoType infoType,
		      SpoolInfoParams *params);
/*
 *  Pass:   	infoType    = SIT_QUEUE_INFO to check for active queues or
 *   	    	    	      get a list of all job ID's in a queue.
 *   	    	    	    = SIT_JOB_INFO to get the JobStatus structure
 *  	    	    	      for a job.
 *  	    	
 *  	    	*************************************************************
 *
 *  	    	If infoType is SIT_QUEUE_INFO,
 *   	    	    (params->SIP_queueParams).SIQP_activityQuery
 *  	            	    	    		= non-zero to check whether
 *    	    	    	    	       	    	  any print queues are active
 *  	    	    	    	    	    	= 0 to get list of all
 *   	    	    	    	    	    	  job ID's in a queue
 *
 *   	    	    (params->SIP_queueParams).SIQP_portInfo
 *  	    	    	    	        	= pointer to port info of a
 *   	    	    	    	      	    	  queue if activityQuery = 0
 *  	    	    	    	    	    	= NULL if activityQuery != 0
 *
 *  	    	*************************************************************
 *
 *  	    	If infoType is SIT_JOB_INFO,
 *   	    	    (params->SIP_jobParams).SIJP_jobID
 *  	    	    	    	          	= ID of relevant job
 *
 *  	    	*************************************************************
 *
 *  Return:	If infoType is SIT_QUEUE_INFO
 *      	    if SIQP_activityQuery != 0, returns
 *		    	SPOOL_QUEUE_NOT_EMPTY if at least one queue is active
 *		    	SPOOL_QUEUE_EMPTY if no queues are active
 *
 *  	    	    if SIQP_activityQuery = 0, then on success returns
 *		    	SPOOL_OPERATION_SUCCESSFUL and
 *   	    	    	(params->SIP_queueParams).SIQP_retBlock
 *		    	    	    	 	= handle of block holding
 *			    	    	      	  ID's of all jobs in queue,
 *  	    	    	    	    	    	  listed in the order they
 *  	    	    	    	    	    	  sit in the queue, currently
 *  	    	    	    	    	    	  active job first.
 *  	    	    	    	    	    	    
 *   	    	    	(params->SIP_queueParams).SIQP_retNumJobs
 *		    	    	    		= # ID's in block
 *
 *		    if SIQP_activityQuery = 0, then on failure returns one of
 *			SPOOL_QUEUE_NOT_FOUND
 *			SPOOL_QUEUE_EMPTY
 *
 *  	    	*************************************************************
 *
 *	    	If infoType is SIT_JOB_INFO,
 *	    	    on success returns
 *   	    	    	SPOOL_OPERATION_SUCCESSFUL and
 *   	    	    	(params->SIP_jobParams).SIJP_retBlock
 *    	    	    	    	    	    	 = handle of block holding
 *				    	    	   JobStatus structure
 *		    on failure, returns one of
 *			SPOOL_JOB_NOT_FOUND
 *			SPOOL_QUEUE_EMPTY
 *
 *	Check for active queues or get a list of all job ID's in a queue
 *	*OR* get the JobStatus structure for a job.
 */

extern SpoolOpStatus
    _pascal SpoolHurryJob(word jobID);
/*
 *  Pass:   	jobID	=   ID number of job to hurry
 *
 *  Return:	status of operation 
 *
 *	Use this routine to push a job to the front of its print queue.  It
 *	will not replace the currently active job, but be placed as the next 
 * 	job in line.
 */

extern SpoolOpStatus
    _pascal SpoolDelayJob(word jobID);
/*
 *  Pass:   	jobID	=   ID number of job to delay
 *
 *  Return:	status of operation
 *
 *	Use this routine to push a job to the end of its print queue.
 */

extern SpoolOpStatus
	_pascal SpoolModifyPriority(word jobID,
    	    	    	    	    ThreadPriority priority);
/*
 *  Pass:   	jobID	    =   ID number of job whose thread's priority
 *  	    	    	    	should be modified
 *    	    	priority    =	new ThreadPriority to set
 *  	    	    	    	(PRIORITY_STANDARD or lower priority)
 *
 *  Return:	status of operation
 *
 *	Use this routine to modify the priority of the thread that is
 *	processing a queue.  All print queue threads start out with
 *	PRIORITY_LOW.  The highest priority you can set is 
 *	PRIORITY_STANDARD.
 */

extern SpoolOpStatus
	_pascal SpoolVerifyPrinterPort(struct _PrintPortInfo *portInfo);
/*
 *  Pass:	*portInfo    = port info for queue 
 *	
 *  Return:	status of operation, one of:
 *		    SPOOL_OPERATION_SUCCESSFUL
 *		    SPOOL_CANT_VERIFY_PORT
 *  	    	For custom ports, this routine currently always returns success.
 *
 *   Use this routine to check for the existence of a printer port.
 *   This function will also change the port to be thread driven instead
 *   of interrupt driven (and change the .ini file) if it finds that
 *   interrupt operation is not possible with the port (because of a faulty
 *   port or a damaged printer, for example).  Currently, this only affects
 *   parallel ports.  Serial ports are not tested in this way.
 */

extern void
    _pascal SpoolSetDocSize(Boolean openFlag,
    	    	    	    PageSizeReport *psr);
/*
 *  Pass:	openFlag    = TRUE if document is open
 *  	    	    	      FALSE if document is closed
 *		*psr 	    = if document is open, PageSizeReport structure
 *			      else null
 *
 *  Return:	nothing
 *
 *  	Performs the work of telling the PageSizeControl object in the
 *  	application the document size. 
 */

#ifdef __HIGHC__

pragma Alias(SpoolGetNumPaperSizes, "SPOOLGETNUMPAPERSIZES");
pragma Alias(SpoolGetPaperString, "SPOOLGETPAPERSTRING");
pragma Alias(SpoolGetPaperSize, "SPOOLGETPAPERSIZE");
pragma Alias(SpoolConvertPaperSize, "SPOOLCONVERTPAPERSIZE");
pragma Alias(SpoolGetPaperSizeOrder, "SPOOLGETPAPERSIZEORDER");
pragma Alias(SpoolSetPaperSizeOrder, "SPOOLSETPAPERSIZEORDER");
pragma Alias(SpoolCreatePaperSize, "SPOOLCREATEPAPERSIZE");
pragma Alias(SpoolDeletePaperSize, "SPOOLDELETEPAPERSIZE");

pragma Alias(SpoolGetNumPrinters, "SPOOLGETNUMPRINTERS");
pragma Alias(SpoolGetPrinterString, "SPOOLGETPRINTERSTRING");
pragma Alias(SpoolCreatePrinter, "SPOOLCREATEPRINTER");
pragma Alias(SpoolDeletePrinter, "SPOOLDELETEPRINTER");
pragma Alias(SpoolGetDefaultPrinter, "SPOOLGETDEFAULTPRINTER");
pragma Alias(SpoolSetDefaultPrinter, "SPOOLSETDEFAULTPRINTER");

pragma Alias(SpoolCreateSpoolFile, "SPOOLCREATESPOOLFILE");
pragma Alias(SpoolSetDocSize, "SPOOLSETDOCSIZE");

pragma Alias(SpoolDelJob, "SPOOLDELJOB");
pragma Alias(SpoolInfo, "SPOOLINFO");
pragma Alias(SpoolHurryJob, "SPOOLHURRYJOB");
pragma Alias(SpoolDelayJob, "SPOOLDELAYJOB");
pragma Alias(SpoolModifyPriority, "SPOOLMODIFYPRIORITY");
pragma Alias(SpoolVerifyPrinterPort, "SPOOLVERIFYPRINTERPORT");

pragma Alias(SpoolGetDefaultPageSizeInfo, "SPOOLGETDEFAULTPAGESIZEINFO");
pragma Alias(SpoolSetDefaultPageSizeInfo, "SPOOLSETDEFAULTPAGESIZEINFO");

#endif

@endlib
