COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) GeoWorks 1992 -- All Rights Reserved

PROJECT:	PC/GEOS Sound System	
MODULE:		Sound Blaster Driver
FILE:		soundblasterInt.asm

AUTHOR:		Todd Stumpf, Oct 26, 1992
	
REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	TS	10/26/92		Initial revision

DESCRIPTION:
	This file contains the interrupt routine required by the SoundBlaster
	to indicate the end of a DMA transfer.  Supporting routines are
	also included
		
	$Id: soundblasterInt.asm,v 1.1 97/04/18 11:57:41 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
idata	segment
	;
	;  We never want to program an illegal register
	;	value, and we don't want to spend the
	;	~30 usec programming a register if
	;	don't have to.  So, we keep two maps
	;	of the register set, one containing
	;	the last know value, and the other
	;	containing a mask of which are legal
	;	to change, and which are not....
	ourFMRegisterMap	FMRegisterMap
	ourValidFMRegisterMap	FMRegisterMap
	;
	;  All SoundBlasters have the same factory-settings.
	;	These are:
	;	    base IO port address: 220h
	;	    interrupt level	:  07h
	;	    DMA channel		:  01h
	;  However, the boards can be configured by the user
	;	for other settings.
	basePortAddress		word	DEFAULT_BASE_ADDRESS
	baseInterruptLevel	word	DEFAULT_IRQ_LEVEL
	baseDMAChannel		word	DEFAULT_DMA_CHANNEL


	readStatusPort		word	dspReadStatus	; + basePortAddress
	lastInterruptTransferLength	word	; # of bytes to transfered


	readDataPort		word	dspDataRead	; + basePortAddress
	writeStatusPort		word	dspDataWrite	; + basePortAddress
	writeDataPort		word	dspDataWrite	; + basePortAddress

	interruptTransferMode		byte	; command for dsp
	interruptTransferLength		word	; # of bytes to transfer next

idata	ends

ResidentCode		segment	resource

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		SBDDACEndOfDMATransfer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Handle EOD (End Of DMA) interrupt

CALLED BY:	INTERRUPT
PASS:		nothing
RETURN:		nothing
DESTROYED:	nothing at all!
SIDE EFFECTS:	
		Sets up remainder of DMA transfer if pending.

		
PSEUDO CODE/STRATEGY:
		Remember, this gets called at the end of the
		DMA transfer.  Most likely, we do nothing, but
		if the transfer fell across a page boundry, or
		it was from a stream, there will very likely
		be another transfer waiting.  Thus, we must
		re-program everything in under a sample.

		For 4kHz, we have 250 usec.
		For 22kHz, we have under 50usec.
		For 44kHz, we have only 25usec.

		On an IBM PC, that means we have 100-200 cycles
		before we get a pop.  Blech.
		
		On a base 8Mhz AT, we get, 200-400 cycles.  Blech.

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	TS	10/26/92    	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
bumInterrupt		label near
	;
	;  We recieved a fake int 7.  pop ax and return from the interrupt.
	pop	ax
	iret

emptyStream 		label near
	;
	;  We have emptied the stream.  Set the transfer sizes
	;	to zero, and alter the stream pointers.
EC<	mov	cx, ds				; cx <- "dgroup"	>
EC<	cmp	cx, segment dgroup		; is it really dgroup?	>
EC<	ERROR_NE -1							>

	mov_tr	cx, ax				; cx <- transfer amount
	clr	ds:[interruptTransferLength]
	clr	ds:[lastInterruptTransferLength]
	jmp	short	updateStream

trimTransferAmount	label near
EC<	mov	ax, ds					>
EC<	cmp	ax, segment dgroup			>
EC<	ERROR_NE -1					>
	;
	;  We don't have enough data available to do a full transfer.
	;
	mov	ax, ds:[dataOnStream]		; ax <- max available
	jmp	short programDSP


SBDDACEndOfDMATransferInt7	proc	far
	;
	;  The SoundBlaster cards can be programmed to interrupt at
	;  level 7 at the end of a DMA transfer.  As interrupt 7 is
	;  also the default interrupt, we might need to check that the
	;  interrupt we recieve is really the interrupt generated by
	;  the board, and not just a "fake" interrupt.
	push	ax	; save trashed register

	mov	al, IC_READ_ISR			; read interrupt status reg.
	out	IC1_CMDPORT, al			; instruct chip
	jmp	$+2

	in	al, IC1_CMDPORT			; read status register

	test	al, (1 shl 7)			; is bit 7 set?
	jz	bumInterrupt			; if not, we're done

	pop	ax	; restore trashed register
	.fall_thru
SBDDACEndOfDMATransferInt7	endp


SBDDACEndOfDMATransfer		proc	far
	uses	ax, cx, dx, ds, si
	.enter
	cld

	mov	ax, segment dgroup		; ax <- dgroup of driver
	mov	ds, ax				; es <- dgroup of driver

EC<	push	cx, ds, es					>
EC<	mov	es, ds:[streamSegment]				>
EC<	mov	ds, es:[SD_writer.SSD_data.SN_data]		>
EC<	mov	cx, es						>
EC<	cmp	cx, ds:[SC_position.SSS_stream].SSS_streamSegment>
EC<	ERROR_NE -1						>
EC<	pop	cx, ds, es					>

EC<	tst	ds:[streamSegment]				>
EC<	ERROR_Z	-1						>

ackInterrupt::
	;
	;  Not only must the interrupt controller be told
	;	of the completion of the interrupt, but so
	;	must the DSP itself.  This is done
	;       By reading from the data available port once.
	mov	dx, ds:[readStatusPort]		; dx <- base address for board

	in	al, dx				; read from port.  ONCE.

	mov	ax, ds:[lastInterruptTransferLength]

	sub	ds:[dataOnStream], ax			; remove bytes
EC<	ERROR_L	-1	; dataOnStream went negative		>
	jle	emptyStream

	mov	ax, ds:[interruptTransferLength]; ax <- # of bytes to transfer

	;
	;  To start the next transfer we just need to re-program the mode
	;  and length.

	cmp	ax, ds:[dataOnStream]
	ja	trimTransferAmount

programDSP label near
EC<	mov	cx, ds					>
EC<	cmp	cx, segment dgroup			>
EC<	ERROR_NE -1					>

	mov_tr	cx, ax				; cx <- length
	mov	ah, ds:[interruptTransferMode]	; ah <- DSP command for format
	call	SBDDACDMANextBlock

	;
	;  Whew.  We can breath now.  The transfer has begun,
	;	so we have "spare" time.  First, set up things for
	;	the next transfer.  As soon as this is done,
	;	we can enable interrupts.
EC<	cmp	cx, ds:[maxTransferSize]		>
EC<	ERROR_A	-1					>

	xchg	cx, ds:[lastInterruptTransferLength]

updateStream label near
	push	es				; save trashed register

	mov	es, ds:[streamSegment]

EC<	push	cx, ds						>
EC<	mov	ds, es:[SD_writer.SSD_data].SN_data		>
EC<	mov	cx, es						>
EC<	cmp	cx, ds:[SC_position.SSS_stream].SSS_streamSegment>
EC<	ERROR_NE -1						>
EC<	pop	cx, ds						>

	;
	;  Update semaphores for reader and writer
	sub	es:[SD_reader.SSD_sem].Sem_value, cx
	add	es:[SD_writer.SSD_sem].Sem_value, cx
	
	;
	;  Update ptr for reader
	add	cx, es:[SD_reader].SSD_ptr

	cmp	cx, es:[SD_max]
	LONG	ja	modulosPointer

writeReaderPtr:
	mov	es:[SD_reader].SSD_ptr, cx

EC<	call	SBDDACVerifyLegalStream				>

	mov	cx, di					; save trashed reg.

	;
	;  We are now going to call the stream driver to
	;	handle updating the stream.  This can
	;	and does enable interrupts, so we need to
	;	make sure we don't context switch.
	;  Call SysEnterInterrupt to deal with this.
	call	SysEnterInterrupt

	call	StreamWriteDataNotify	; destroys ax, di

	INT_OFF

	mov	di, cx					; restore trashed reg.

	tst	es:[SD_reader.SSD_sem].Sem_queue
	jz	sendACK

	;
	;  Since there is a writer blocked on writing,
	;	we need to free it up so it can write.
	mov	cx, bx					; save trashed reg.

	mov	ax, es					; ax:bx <- queue
	mov	bx, offset SD_reader.SSD_sem.Sem_queue
	call	ThreadWakeUpQueue	

	INT_OFF

	mov	bx, cx					; restore trashed reg.

EC<	mov	cx, es						>
EC<	mov	es, es:[SD_writer.SSD_data].SN_data		>
EC<	cmp	cx, es:[SC_position.SSS_stream].SSS_streamSegment>
EC<	ERROR_NE -1						>

sendACK:
	pop	es				; restore trashed register

	;
	;  Now, there is nothing that is keeping us from
	;	sending an EOI right now.  But before we
	;	do, we want to "exit" this interrupt

	;  On any computer, with any setting, anywhere,
	;	we send an EOI to the interrupt chip
	;	on the PC.  So, why not do it now.
	mov	al, IC_GENEOI
	out	IC1_CMDPORT, al			; acknowledge PC chip

done:
	call	SysExitInterrupt

	.leave
SafePopf	label	far
	iret

modulosPointer:
	;
	;  We wrapped the pointer.  Subtract the max value
	;	and add to starting value.
	;
	sub	cx, es:[SD_max]			; cx <- # past end
	add	cx, offset SD_data-1		; cx <- # past beginning
	LONG	jmp	writeReaderPtr

SBDDACEndOfDMATransfer	endp

if ERROR_CHECK
COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		SBDDACVerifyLegalStream
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Error checking conditions for stream

CALLED BY:	SBDDACEndOfDMATransfer
PASS:		
RETURN:		
DESTROYED:	nothing
SIDE EFFECTS:	

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	TS	2/22/93    	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
SBDDACVerifyLegalStream	proc	near
	.enter

	mov	cx, ds
	cmp	cx, segment dgroup
	ERROR_NE -1

	mov	cx, es
	cmp	cx, ds:[streamSegment]
	ERROR_NE -1

	mov	cx, es:[SD_reader].SSD_ptr
	cmp	cx, offset SD_data
	ERROR_B	-1
	cmp	cx, es:[SD_max]
	ERROR_A	-1
	mov	cx, es:[SD_writer].SSD_ptr
 	cmp	cx, offset SD_data
 	ERROR_B	-1
 	cmp	cx, es:[SD_max]
 	ERROR_A	-1

 	push	ds

 	mov	ds, es:[SD_writer.SSD_data].SN_data
 	mov	cx, es
 	cmp	cx, ds:[SC_position.SSS_stream].SSS_streamSegment
 	ERROR_NE -1

 	pop	ds

 	mov	cx, ds
 	cmp	cx, segment dgroup
 	ERROR_NE -1

 	mov	cx, es
 	cmp	cx, ds:[streamSegment]
      	ERROR_NE -1

	.leave
	ret
SBDDACVerifyLegalStream	endp

endif
ResidentCode	ends
