COMMENT @----------------------------------------------------------------------

	Copyright (c) GeoWorks 1988 -- All Rights Reserved

PROJECT:	PC GEOS
FILE:		cards.temp

AUTHOR:		Jon Witort

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Jon	9/90		Initial version

DESCRIPTION:
	This file contains the definitions for the library.  It is included
both by the library and by users of the library.  When included by the library,
the symbol "_DECLARER_" must be true.

	$Id: cards.def,v 1.1 97/04/04 14:23:52 newdeal Exp $

------------------------------------------------------------------------------@

StartLibrary	cards

NotifyCardBackChange	struct

	NCBC_vmFile		hptr
	NCBC_mapBlock		word
	NCBC_cardWidth		word
	NCBC_cardHeight		word

NotifyCardBackChange	ends


;
;	CardBackSelectorClass
;
CardBackSelectorClass	class	GenControlClass

MSG_CBS_QUERY_CARD_BACK				message
MSG_CBS_SET_CARD_BACK				message

TempCBSCardInfo	struct
	TCBSCI_cardWidth	word
	TCBSCI_cardHeight	word
TempCBSCardInfo	ends

TEMP_CBS_CARD_INFO			vardata TempCBSCardInfo

CardBackSelectorFeatures	record
	CBSF_CARD_BACK_LIST : 1
CardBackSelectorFeatures	end

CARD_BACK_SELECTOR_DEFAULT_FEATURES	equ	mask CardBackSelectorFeatures

	CBSI_vmFile		hptr
		noreloc	CBSI_vmFile
	CBSI_mapBlock		word
	CBSI_cardWidth		word
	CBSI_cardHeight		word

CardBackSelectorClass	endc


;------------------------------------------------------------------------------
;	Game Class
;------------------------------------------------------------------------------

;### GameClass -- Defs inserted below by "pmake def"
; Extracted from game.asm:


GameClass	class	VisContentClass, master
MSG_GAME_GET_VM_FILE			message
;
;	Returns the vm file containing the card bitmaps
;
;	PASS:		nothing
;
;	RETURN:		^hax - vm file
;

MSG_GAME_NOTIFY_CARD_FLIPPED	message
;
;	This method is passed to the game object whenever a deck flips a
;	card.
;

MSG_GAME_SET_WHICH_BACK		message
MSG_GAME_GET_WHICH_BACK		message
MSG_GAME_BROADCAST_DOUBLE_CLICK	message
;
;	This method is called by a deck when the user double clicks
;	one of its cards. Game calls children asking
;	for a deck to accept the double-clicked card.
;
;	PASS:		^lcx:dx = double clicked deck
;			bp = attributes of the specific card that was
;				double clicked
;
;	RETURN:		carry set if card was taken, clear else	

MSG_GAME_CHANGE_BACK		message
;
;	Provides the user with a summons in order to change the card
;	back design. This method is usually sent by a trigger in a
;	summons in the applications UI.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_GAME_CHOOSE_BACK		message
;
;	Changes the backs of all the cards to match the one that the user
;	has chosen through the summons. This method is usually sent by a
;	list entry in the back selection summons.
;
;	PASS:		^lcx:dx = optr to selected list entry representing
;				  a card back
;
;	RETURN:		nothing

MSG_GAME_CREATE_BACK_SUMMONS	message
;
;	Creates the summons through which the user can select between
;	various card backs.
;
;	PASS:		nothing
;
;	RETURN:		^lcx:dx = the summons

MSG_GAME_CHECK_HILITES		message
;
;	Broadcasts to children to hilite themselves if they would
;	be the destination if cards were dropped right now. This differs
;	from MSG_GAME_INVERT_ACCEPTORS in that the position of the drag is a 
;	factor for this method (i.e., the cards must match AND the positions
;	must match).
;
;	PASS:		^lcx:dx = dragging deck
;			bp = attributes of the drop card
;
;	RETURN:		nothing

MSG_GAME_CHECK_MINIMUM_SCORE	message
;
;	Returns the larger of the passed value and the minimum allowed
;	score for the game. The default handler does nothing, so this
;	message should be subclassed if it is to be used.
;
;	PASS:		cx = score to check
;
;	RETURN:		if cx is not below minimum score, then cx = score
;			if cx IS below minimum score, then cx = minimum score

MSG_GAME_COLLECT_ALL_CARDS	message
;
;	Collects all the game's cards and gives them to the game's hand object
;
;	PASS:		nothing
;
;	NOTHING:	nothing

MSG_GAME_DECK_SELECTED		message
;
;	This is the method sent to the game object when a card is selected;
;	The card tells the deck that it's been selected, and the deck asks
;	the game object for advice on what to do.
;
;	PASS:		^lcx:dx = deck that was selected
;			bp = # of card in composite that was selected
;
;	RETURN:		nothing

MSG_GAME_DISABLE_UNDO		message
;
;	Informs the game that the Undo operation is no longer valid, and
;	the user should be prohibited from doing it.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_GAME_ENABLE_UNDO		message
;
;	Informs the game that the Undo operation is now valid, and that it
;	may enable the user to select this option.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_GAME_DISTRIBUTE_FADE		message
;
;	Sends a MSG_CARD_FADE_DRAW to every card in the fade array
;
;	PASS:		nothing
;
;	RETURN:		nothing


MSG_GAME_DRAW_BLANK_CARD		message
;
;	Draws a generic blank card at the specified location. Uses both
;	GI_frameReg and GI_interiorReg to construct the blank card
;
;	PASS:		cx,dx = left,top of blank card
;			bp = gstate
;
;	RETURN:		nothing

MSG_GAME_FAKE_BLANK_CARD		message
;
;	Draws a black-bordered white rectangle the size of a card at the
;	specified location.
;
;	PASS:		cx,dx = left,top of fake blank card
;			bp = gstate

MSG_GAME_DRAW_FRAME		message
;
;	Draws a card frame at the specified location. Uses
;	GI_frameReg to construct the frame.
;
;	PASS:		cx,dx = left,top of frame
;			bp = gstate
;
;	RETURN:		nothing

MSG_GAME_DROPPING_DRAG_CARDS	message
;
;	This method is called by the dragging deck when the user
;	has released the cards. Game calls children asking
;	for a deck to accept the dropped cards.
;
;	PASS:		^lcx:dx = dragging (and dropping) deck
;			bp = drop card attributes
;
;	RETURN:		Carry set if dropped cards were taken by another deck.

MSG_GAME_GET_BACK_BITMAP		message
;
;	Returns the information necessary to get at the bitmap currently
;	in use as the card back design.
;
;	PASS:		nothing
;
;	RETURN:		cx = vm block handle containing bitmap
;			dx = offset within block of bitmap
;
;	Accessing the bitmap from cx,dx as returned goes something like:
;
;	mov	ax, cx			;ax <- block header
;	call	VMLock
;	mov	ds, ax
;
;	;Now ds:dx = bitmap color
;	;    ds:dx+2 = bitmap

MSG_GAME_GET_DRAG_TYPE		message
;
;	Returns the drag type (i.e., either DRAG_OUTLINE or DRAG_FULL)
;
;	PASS:		nothing
;
;	RETURN:		cl = DragType


MSG_GAME_GET_FACE_BITMAP		message
;
;	Returns the information necessary to get at the bitmap for the
;	passed card type
;
;	PASS:		bp = card attributes
;
;	RETURN:		cx = vm block handle containing bitmap
;			dx = offset within block of bitmap
;
;	Accessing the bitmap from cx,dx as returned goes something like:
;
;	mov	ax, cx			;ax <- block header
;	call	VMLock
;	mov	ds, ax
;
;	Now ds:dx = bitmap color
;	    ds:dx+2 = bitmap

MSG_GAME_GET_USER_MODE		message
;
;	Returns the UserMode that the game is currently under
;
;	PASS:		nothing
;
;	RETURN:		cl = UserMode

MSG_GAME_HAND_SELECTED		message
;
;	Game is sent this method when a (the) hand object is selected.
;	The default action is to treat the hand like any other deck,
;	which probably won't be terribly accurate in most cases. This
;	handler will likely be widely subclassed.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_GAME_INVERT_ACCEPTORS		message
;
;	Asks all decks to hilite themselves if they would accept
;	the current drag based on the drop card (NOT on the current
;	position of the drag).
;
;	PASS:		^lcx:dx = dragging deck
;			bp = card attributes of the drop card
;
;	RETURN:		nothing
	
MSG_GAME_MARK_ACCEPTORS		message
;
;	Asks all decks to set their DA_WANTS_DRAG bit if they
;	would accept the current drag based on the drop card
;	(not on the current position of the drag)
;
;	PASS:		^lcx:dx = dragging deck
;			bp = card attributes of the drop card
;
;	RETURN:		nothing
	
MSG_GAME_QUERY_DRAG_CARD		message
;
;	This is the method that a deck calls when one of
;	its cards is selected. This method determines whether
;	a given card should be included in the drag or not,
;	depending on the deck's attributes. For example, in the
;	following scenario:
;
;
;			+--------------------+
;			!                    !
;			! 6 Hearts           !
;			!                    !
;			+--------------------+
;			!                    !
;			! 5 Clubs            !
;			!                    !
;			+--------------------+
;			!                    !
;			! 4 Diamonds         !
;			!                    !
;			+--------------------+
;			!                    !
;			! 3 Clubs            !
;			!                    !
;			!                    !
;			!                    !
;			!                    !
;			!                    !
;			!                    !
;			!                    !
;			!                    !
;			!                    !
;			+--------------------+
;
;		if the 4 is selected, and we are playing klondike
;		under the easiest rules(BEGINNER_MODE), we want to drag
;		the 3 and the 4; we would make three calls to this method;
;		calls concering the 3 and 4 would indicate that the
;		cards should be dragged, whereas the 5 would be
;		rejected.
;
;PASS:		ch = # of selected card		;(the 4 in the above example)
;		cl = attrs of selected card	;(the 4 in the above example)
;
;		dh = # of query card
;		dl = attrs of query card
;
;		bp = deck attrs
;		
;RETURN:	carry set if accept
;		carry clear if no accept

MSG_GAME_RANDOM			message
;
;	Returns a random number between 0 and the passed value
;
;	PASS:		dl = maximum random number to return
;
;	RETURN:		dx = random number
;
;	This random number generator is not a very good one; it is sufficient
;	for a wide range of tasks requiring random numbers (it will work
;	fine for shuffling, etc.), but if either the "randomness" or the
;	distribution of the random numbers is crucial, you may want to look
;	elsewhere.

MSG_GAME_REGISTER_DRAG		message
;
;	This method stores the passed OD of a deck in case we need to
;	communicate with the dragging deck for any reason (one case in
;	particular is the need to forward any MSG_META_EXPOSED's to this deck)
;
;	PASS:		^lcx:dx = dragging deck
;
;	RETURN:		nothing

MSG_GAME_REGISTER_HILITED		message
;
;	Keeps track of the one (if any) deck that is currently
;	hilited.  Also issues a MSG_DECK_INVERT to this deck
;	if it is just now getting hilited (vs. having been hilited
;	for multiple calls already).  Also re-inverts the used-to-be
;	hlited deck (if any), to make it unhilited.
;
;	PASS:		^lcx:dx = hilited deck
;			or cx = dx = 0 for no hilited deck
;
;	RETURN:		nothing

MSG_GAME_SEED_RANDOM		message
;
;	Seeds the game's random number generator
;
;	PASS:		dx = seed
;
;	RETURN:		nothing

MSG_GAME_SET_DRAG_TYPE		message
;
;	Sets the DragType that the game should play under
;
;	PASS:		cl = DragType
;
;	RETURN:		nothing

MSG_GAME_SET_USER_MODE		message
;
;	Sets the UserMode that the game should play under
;
;	PASS:		cl = UserMode
;
;	RETURN:		nothing

MSG_GAME_SETUP_GEOMETRY		message
;
;	Gives the game object an opportunity to arrange its many objects
;	on the screen (usually at startup). This method is passed the width
;	and height of a card as rudimentary size units.
;
;	PASS:		cx,dx = x,y deck spacing
;
;	RETURN:		nothing

MSG_GAME_RESTORE_BITMAPS	message
;
;	Will read in the BitMap's of the cards
;
;	PASS:		*ds:si	= GameClass object
;
;	RETURN:		nothing


MSG_GAME_SETUP_STUFF		message
;
;	Sets up various defaults and does assorted dirty work associated
;	with starting up a game.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_GAME_SET_DONOR		message
;
;	Records the passed OD as the last deck to give cards to another
;	deck
;
;	PASS:		^lcx:dx = donor deck
;
;	RETURN:		nothing

MSG_GAME_SET_CARD_DIMENSIONS		message
;
;	Gives the game object an opportunity to arrange its many objects
;	on the screen (usually at startup). This method is passed the width
;	and height of a card as rudimentary size units.
;
;	PASS:		cx,dx = width,height of a card
;
;	RETURN:		nothing

MSG_GAME_SET_DOWN_SPREADS		message
;
;	Gives the game object an opportunity to set any spread info
;	concerning face down cards.
;
;	PASS:		cx,dx = x,y spreads for face down cards
;
;	RETURN:		nothing

MSG_GAME_SET_UP_SPREADS		message
;
;	Gives the game object an opportunity to set any spread info
;	concerning face up cards.
;
;	PASS:		cx,dx = x,y spreads for face up cards
;
;	RETURN:		nothing

MSG_GAME_SET_FONT_SIZE		message
;
;	Gives the game object an opportunity to set any text to the
;	passed size.
;
;	PASS:		cx = point size
;
;	RETURN;		nothing

MSG_GAME_SET_FADE_PARAMETERS	message
;
;	Sets the initial and incremental fade masks to use while fade
;	drawing. Note that the initial mask is *NOT* the first mask
;	used when drawing; the mask is incremented before the first
;	draw, i.e., the first draw during a fade will use the
;	mask (initial + inremental).
;
;	PASS:		cl = incremental mask
;			dl = initial mask
;
;	RETURN:		nothing

MSG_GAME_SHUTDOWN			message
;
;	Takes care of any business involved with closing the game application
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_GAME_UNMARK_ACCEPTORS			message
;
;	Gives the game a chance to unmark any decks that for some reason
;	were marked as acceptors of the current drag. Klondike uses this method
;	to unmark any two's that may be marked as willing to accept aces,
;	since aces onto twos are a special exception in klondike's rules.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_GAME_UPDATE_FADE_ARRAY	message
;
;	Does the grunt work maintaining the fade array. Cards make requests
;	to be added to or removed from the array, and this handler fulfills
;	those requests and manages the timer and gstate associated with
;	card fading.
;
;	PASS:		^lcx:dx = card making request
;			bp = PLEASE_ADD_ME_TO_THE_ARRAY if card wants its OD
;				included in the array,
;			     PLEASE_REMOVE_ME_FROM_THE_ARRAY if card wants
;				its OD out of the array
;
;	RETURN:		nothing

MSG_GAME_UPDATE_SCORE		message
;
;	Updates the game's score internally and on screen
;
;	PASS:		if score is to be zeroed:
;				cx = dx = 0
;			if score is to be set absolutely but not to 0:
;				cx = value to set score to
;			if score is to be incremented or decremented:
;				cx = 0, dx = amount to add to current score
;
;	RETURN:		nothing

MSG_GAME_ZERO_FADE_ARRAY		message
;
;	Clears out the game's fade array, sending MSG_CARD_CLEAR_FADING's
;	to each of the cards in the array before removing them.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_GAME_SEND_CARD_BACK_NOTIFICATION		message
;
;	Forces the Game object to send out a notification regarding
;	the bitmaps it's using as card designs
;
;	PASS:		nothing
;
;	RETURN:		nothing
;

MSG_GAME_SAVE_STATE		message
;
;	Creates a memory block sufficient to restore the current game
;	whenm passed to MSG_GAME_RESTORE_STATE
;
;	PASS:		nothing
;
;	RETURN:		^hcx - mem block
;			dx - bytes written so far (so subclassings know
;			     where to start writing)
;

MSG_GAME_RESTORE_STATE		message
;
;	Restores a game to its previous state when passed a block
;	that was returned from MSG_GAME_SAVE_STATE
;
;	PASS:		^hcx - mem block
;
;	RETURN:		dx - bytes read from block (so subclassings know
;			     where to start reading)
;

protominor UtilityMessages

MSG_GAME_TRANSFERRING_CARDS     message
;
;       This is called by the donor deck when cards are dropped and
;       transferred to another deck. Makes a good message to intercept for 
;       generating sound.
;
;       PASS:           ^lcx:dx = deck to which cards will be transferred
;
;       RETURN:         nothing
;

MSG_GAME_TRANSFER_FAILED        message
;
;       This is called by the source deck when cards are dropped and no
;       deck accepts them, just prior to animating the failed transfer.
;       Makes a good message to intercept for generating sound.
;
;       PASS:           ^lcx:dx = source deck
;
;       RETURN:         nothing
;

protoreset

;----------------------------------------------------------------------------
;				FATAL ERRORS
;----------------------------------------------------------------------------
;
CANT_STOP_TIMER_WITH_NULL_HANDLE	enum	FatalErrors
CANT_DESTROY_GSTATE_WITH_NULL_HANDLE	enum	FatalErrors

;----------------------------------------------------------------------------
;			VISUAL UPWARD QUERIES
;----------------------------------------------------------------------------
;

VUQ_CARD_DIMENSIONS 	enum VisUpwardQueryType, APP_VIS_QUERY_START
;
;	Returns the dimensions of a full-sized card
;
;	PASS:		nothing
;
;	RETURN:		cx = card width
;			dx = card height
;			carry set to indicate query handled

VUQ_CARD_BITMAP		enum VisUpwardQueryType
;
;	Returns the bitmap that should be used for a given set
;	of card attributes
;
;	PASS:		bp = CardAttrs
;
;	RETURN:		cx = block handle of bitmap
;			dx = offset of bitmap within block
;			carry set to indicate query handled

VUQ_INITIAL_FADE_MASK	enum VisUpwardQueryType
;
;	Returns the area mask that fading cards should store initially.
;
;	PASS:		nothing
;
;	RETURN:		cl = initial AreaMask
;			carry set to indicate query handled

VUQ_GAME_ATTRIBUTES	enum VisUpwardQueryType
;
;	Returns the game's attributes
;
;	PASS:		nothing
;
;	RETURN:		cl = GameAttrs
;			carry set to indicate query handled

VUQ_GAME_OD		enum VisUpwardQueryType
;
;	Returns the OD of the game object
;
;	PASS:		nothing
;
;	RETURN:		^lcx:dx = game object
;			carry set to indicate query handled

DragType	etype	byte
DRAG_OUTLINE	enum	DragType, 0		;outline dragging mode
DRAG_FULL	enum	DragType, 1		;full card dragging mode

UserMode	etype	byte
BEGINNER_MODE		enum UserMode,0
INTERMEDIATE_MODE	enum UserMode,1
ADVANCED_MODE		enum UserMode,2

EVEN_DATE_TIME_BUFFER_SIZE equ ((DATE_TIME_BUFFER_SIZE+1)/2)*2

GameAttrs	record
	:4

	GA_ICONIFIED : 1			;set if game is visually closed

	GA_REDEAL_REQUESTED : 1			;set if a redeal has been
						;requested but unprocessed

	GA_USE_WIN_BACK : 1			;set if the card back design
						;should be the one designated
						;as the winner's back design

	GA_JUST_WON_A_GAME : 1			;set if the user has won
						;since the last redeal
GameAttrs	end

GI_displayScheme	DisplayType

GI_gameAttrs		GameAttrs

GI_dragType		DragType

GI_userMode		UserMode

GI_hand			optr			;OD to the object
						;serving as the 'hand'

GI_scoreOutput		optr			;VisText object that
						;holds the score

GI_fadeArray		lptr.ChunkArrayHeader	;this array keeps the ODs
						;of any cards that should
						;receive messages to fade in
						;when the time comes

GI_lastDonor		optr			;OD of the deck that last
						;gave cards to another
						;(used for undo)

GI_hilited		optr			;OD of the one deck that is
						;currently hilited (more than
						;one may be hilited, but in
						;the case that we need to
						;remember one in particular,
						;the OD goes here.

GI_dragger		optr			;OD of the deck that
						;owns cards currently
						;being dragged (if any)

GI_score		word			;the game score

GI_lastScore		word			;the score before the last
						;score change

GI_faderHandle		hptr			;handle of the timer that
						;sends messages to fade
			noreloc GI_faderHandle

GI_gState		hptr.GState		;gstate to fade through

			noreloc GI_gState

;
;	The following two instance data slots control the visual effect of
;	fading. The first one, GI_initialFadeMask is the initial area mask
;	the card should store, adding to this the second value,
;	GI_incrementalFadeMask, each time it receives a method to update
;	the fade.
;
;	Example 1:	Cards should fade in 25%, 50%, 75%, then 100%
;
;	GI_initialFadeMask = SDM_0
;	GI_incrementalFadeMask = SDM_25 - SDM_0
;
;	Example 2:	Cards shouldn't fade (i.e., 100% only)
;
;	GI_initialFadeMask = SDM_100
;	GI_incrementalFadeMask = 0
;

GI_initialFadeMask	SystemDrawMask		;this is the area mask the
						;cards take when they initially
						;begin fading in

GI_incrementalFadeMask	byte			;this is the amount to add to
						;a card's fade mask to get
						;the new fade mask

GI_whichBack		word			;indicates which of the card
						;back designs in the array
						;should be used

GI_frameReg		lptr.Rectangle		;the region to be drawn as the
						;card border

GI_interiorReg		lptr.Rectangle		;the region to be drawn as the
						;card's interior background

GI_vmFile		hptr			;vm file containing the
						;card bitmaps
			noreloc GI_vmFile

GI_mapBlock		word			;stores the map block of the
						;card bitmaps

GI_cardWidth		word			;width of a full sized card

GI_cardHeight		word			;height of a full sized card

GI_upSpreadX		word
GI_upSpreadY		word
GI_downSpreadX		word
GI_downSpreadY		word

GI_undoTrigger		optr			;OD of any undo trigger

GI_randomSeed		word			;the seed to use when
						;generating random numbers
GameClass	endc



;------------------------------------------------------------------------------
;	Card Class (must come before DeckClass)
;------------------------------------------------------------------------------

;### CardClass -- Defs inserted below by "pmake def"
; Extracted from card.asm:


CardClass	class	VisClass, master
MSG_CARD_GET_VM_FILE			message
;
;	Returns the vm file containing the card bitmaps
;
;	PASS:		nothing
;
;	RETURN:		^hax - vm file
;

MSG_CARD_CLEAR_FADING			message
;
;	Clears the CA_FADING bit from the card's attributes. The card will
;	no longer think it is fading, and can go on with normal life. This
;	message will NOT automatically remove the card from the fade array.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_CARD_CLEAR_INVERTED			message
;
;	Clears the CA_INVERTED bit from the card's attributes. If the card was
;	inverted, sends itself a MSG_CARD_INVERT
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_CARD_CLIP_BOUNDS			message
;
;	Clips the Vis bounds of a card. The arguments are passed with
;	the assumption that the card will be obscured by another visual
;	object (most likely another card), and that the upper left of the
;	obscuring object will be offset by cx,dx from the upper left of the
;	called card.
;
;	PASS:		cx = relative x-displacement of obscuring object
;			     from the left of this card
;			dx = relative y-displacement of obscuring object
;			     from the top of this card
;
;	RETURN:		nothing
;
;	Note that if cx and dx are both non-zero, the bounds will not be
;	clipped, as the unobscured region of the card will still have
;	maximum width and height at some points.

MSG_CARD_FADE_DRAW			message
;
;	This method fades the card in one more step, and sends a method
;	to the visual parent if it is done fading (mask = 100%).
;
;	PASS:		bp = gstate to draw through
;			cl = adjustment to the card's current area mask
;
;	RETURN:		nothing

MSG_CARD_FADE_REDRAW			message
;
;	Instructs the card that it should begin to fade in.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_CARD_FLIP				message
;
;	Turns a card face up if it is face down, and vice-versa. Does
;	nothing visually.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_CARD_GET_ATTRIBUTES			message
;
;	Retrieves the card's CI_cardAttrs field in bp. See CardAttrs
;	below for the data structure.
;
;	PASS:		nothing
;
;	RETURN:		bp = CI_cardAttrs for the card
;			carry = clear if successful

MSG_CARD_INVERT				message
;
;	Graphically inverts the screen in the card's vis bounds. If
;	the card is fading, the method is queued until it's finished.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_CARD_MARK_DIRTY_IF_FACE_DOWN		message
;
;	Sets the CA_DIRTY bit in the card's CI_cardAttr field if
;	it is face down to indicate that its bitmap has changed.
;	This routine is used when the card back bitmap is changed,
;	and we want to redraw all the face down cards.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_CARD_MAXIMIZE				message
;
;	Sets the card's width and height to full card size (dimensions
;	are stored in the game object
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_CARD_MOVE_RELATIVE			message
;
;	Moves a card relative to its current position
;
;	PASS:		cx = horizontal displacement
;			dx = vertical displacement
;
;	RETURN:		nothing

MSG_CARD_NORMAL_REDRAW			message
;
;	Card creates a gstate and draws itself.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_CARD_QUERY_DRAWABLE			message
;
;	Signals whether the card is drawable (i.e., if VBA_DRAWABLE bit
;	is set.
;
;	PASS:		nothing
;
;	RETURN:		carry set if card is drawable
;			carry clear if card is not drawable

MSG_CARD_SET_ATTRIBUTES			message
;
;	Sets the card's attributes to the passed value, then
;	marks the card as dirty and sets its bitmap
;
;	PASS:		bp = CardAttrs
;
;	RETURN:		nothing

MSG_CARD_SET_BITMAP			message
;
;	Points CI_bitmap to the right bitmap to draw for this card. The
;	card must have its rank, suit, and face up/down attributes set
;	before calling this method.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_CARD_SET_DRAWABLE			message
;
;	Set the VA_DRAWABLE vis bit for this card
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_CARD_SET_NOT_DRAWABLE			message
;	Clear the VA_DRAWABLE vis bit for this card
;
;	PASS:		nothing
;
;	RETURN:		carry = the complement of the original VA_DRAWABLE
;			        so that the carry is set if nothing was done.

MSG_CARD_SPRAY_DRAW			message
;
;	This method takes in a gstate, rotates it, then draws the card
;	through the gstate somewhere along the y-axis.
;
;	PASS:		bp = gstate
;			cx = y coordinate to draw card at (x assumed to be 0)
;			dx = # of degrees to rotate gstate before drawing
;
;	RETURN:		bp = newly rotated gstate
;
;	Since regions cannot be rotated (at least for release 1), the
;	blank card background is actually a fake; it is just a card sized 
;	white rectangle with a black border.

MSG_CARD_TURN_FACE_DOWN			message
;
;	Turns the card face down (*NOT* visually). Clears the CA_FACE_UP
;	bit and sets the CA_DIRTY bit, then updates the card's bitmap.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_CARD_TURN_FACE_UP			message
;
;	Turns the card face up (*NOT* visually). Sets the CA_FACE_UP
;	bit and sets the CA_DIRTY bit, then updates the card's bitmap.
;
;	PASS:		nothing
;
;	RETURN:		nothing

CardRank	etype byte
CR_NONE		enum CardRank,0
CR_ACE		enum CardRank,1
CR_TWO		enum CardRank,2
CR_THREE	enum CardRank,3
CR_FOUR		enum CardRank,4
CR_FIVE		enum CardRank,5
CR_SIX		enum CardRank,6
CR_SEVEN	enum CardRank,7
CR_EIGHT	enum CardRank,8
CR_NINE		enum CardRank,9
CR_TEN		enum CardRank,10
CR_JACK		enum CardRank,11
CR_QUEEN	enum CardRank,12
CR_KING		enum CardRank,13

CR_WILD		enum CardRank,15

CardSuit	etype	byte
CS_DIAMONDS	enum CardSuit,0		; these forced assignments should
CS_HEARTS	enum CardSuit,1		; NOT be changed, as they allow for
CS_CLUBS	enum CardSuit,2		; optimizations in the code (in
CS_SPADES	enum CardSuit,3		; particular, the high bit indicates
					; blackness

CardAttrs	record
	: 5

	CA_INVERTED : 1			;set if the card should draw inverted

	CA_MONO_BITMAP : 1		;set if the card's current bitmap is
					;monochrome

	CA_DIRTY : 1			;indicates whether the card's bitmap
					;pointer should be updated before
					;drawing

	CA_FADING : 1			;indicates whether this card is
					;currently fading (i.e., is not fully
					;faded in yet).

	CA_RANK CardRank : 4		;the card's rank

	CA_SUIT CardSuit : 2		;the card's suit

	CA_FACE_UP : 1			;indicates whether the card is face up
CardAttrs	end

	CI_cardAttrs		CardAttrs	;The card's atrributes

	CI_bitmap		optr		;Identifies the bitmap to be
						;drawn for this card
	noreloc CI_bitmap
	CI_areaMask		SystemDrawMask	;last area mask used when
						;drawing this card (used
						;in fading)

CardClass	endc



;------------------------------------------------------------------------------
;	Deck Class
;------------------------------------------------------------------------------

;### DeckClass -- Defs inserted below by "pmake def"
; Extracted from deck.asm:


DeckClass	class	VisCompClass, master
MSG_DECK_GET_VM_FILE			message
;
;	Returns the vm file containing the card bitmaps
;
;	PASS:		nothing
;
;	RETURN:		^hax - vm file
;

MSG_DECK_GET_N_CARDS			message
;
;	Returns the number of cards in this deck's composite
;
;	PASS:		nothing
;
;	RETURN:		cx = # cards

MSG_DECK_ADD_CARD_FIRST			message
;
;	Adds a card into the deck's visual tree as the first child.
;	Also moves the card to DI_topCardLeft, DI_topCardTop
;
;	PASS:		^lcx:dx = card to add
;
;	RETURN:		nothing

MSG_DECK_CARD_DOUBLE_CLICKED		message
;
;	Called when one of the deck's cards receives a double click event.
;
;	PASS:		bp = # of child in composite that was double-clicked
;			(bp = 0 for first child)
;
;	RETURN:		nothing

MSG_DECK_CARD_SELECTED			message
;
;	Called when one of the decks cards is selected by the user. Deck
;	records the location of the mouse event and passes the event
;	up to the game object.
;
;	PASS:		cx,dx = x,y of mouse event
;			bp = # of child in composite that was selected
;			(bp = 0 for first child)
;
;	RETURN:		nothing

MSG_DECK_CHANGE_KIDS_BACKS		message
;
;	Marks any face down children as dirty, indicating that their
;	bitmap needs to be updated (in light of a back bitmap change
;	from the user).
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_DECK_CHECK_DRAG_CAUGHT		message
;
;	Checks to see whether this deck's "catch bounds" overlap with
;	the passed deck's "drag bounds".
;
;	PASS:		^lcx:dx = dragging deck
;
;	RETURN:		carry set if drag bounds of the passed deck
;			overlap with the catch bounds of this deck.

MSG_DECK_CHECK_POTENTIAL_DROP		message
;
;	Checks to see whether this deck would accept the drag if it
;	were to be dropped.
;
;	PASS:		^lcx:dx = dragging deck
;
;	RETURN:		carry set if deck would accept cards

MSG_DECK_CLEAN_AFTER_SHRINK		message
;
;	This method invalidates the portion of a deck's original
;	vis bounds that was clipped as a result of the deck
;	shinking.
;	(i.e., Let A = original deck bounds, B = new deck bounds:
;		this method invalidates A - B)
;
;
;	PASS:		bp = gstate to invalidate through
;
;		ALSO:
;			DI_initRight and DI_initBottom should contain the
;			right, bottom coordinates of the deck before
;			it shrunk.
;
;	RETURN:		nothing

MSG_DECK_CLIP_NTH_CARD			message
;
;	Clips the visible bounds of the deck's nth card in preparation
;	for another card to be played onto it.
;
;	PASS:		bp = # of child in composite to clip
;			(bp = 0 for first card)
;			cx = x displacement of oncoming card
;			dx = y displacement of oncoming card
;
;	RETURN:		nothing

MSG_DECK_SET_ATTRS			message
;
;	Sets deck's attribute instance data.
;
;	PASS:		cl = DeckAttrs
;
;	RETURN:		nothing

MSG_DECK_DOWN_CARD_SELECTED		message
;
;	Called by one of the deck's face down cards when it is selected.
;
;	PASS:		bp = # of child in composite that was selected
;
;	RETURN:		nothing

MSG_DECK_DRAGGABLE_CARD_SELECTED		message
;
;	Once the game object has determined that a selected card is one that
;	can be dragged,  it sends this method to the deck. This method
;	starts the dragging process (grabbing the mouse, setting the
;	initial instance data for dragging, etc.)
;
;	PASS:		bp = # of children to drag
;			cx,dx = current mouse position
;
;	RETURN:		nothing

MSG_DECK_DRAG_OR_FLIP			message
;
;	Instructs the deck to either start a drag (if the passed card
;	is face up) or flip a card (if the passed card is face down).
;
;	PASS:		bp = # of child in composite that was selected
;
;	RETURN:		nothing

MSG_DECK_DRAW_DRAGS			message
;
;	Deck sends MSG_VIS_DRAW's to each of its drag cards
;
;	PASS:		bp = gstate to draw through
;
;	RETURN:		nothing

MSG_DECK_DRAW_DRAG_OUTLINE		message
;
;	Draws an outline of the cards being dragged.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_DECK_DRAW_MARKER			message
;
;	Deck draws itself the way it should look when it has no cards.
;
;	PASS:		bp = gstate to draw thorugh
;
;	RETURN:		nothing

MSG_DECK_DRAW_REVERSE			message
;
;	Draws the deck's cards in reverse order (i.e., last card is
;	drawn first). Since it is in general the case that a deck's
;	last card is its bottom-most card, drawing the cards in reverse
;	is what the user would expect to see if the bounds of the
;	cards overlap.
;
;	PASS:		bp = gstate
;
;	RETURN:		nothing

MSG_DECK_DROP_DRAGS			message
;
;	Tells deck to end the current drag. Deck informs the
;	game object that it is dropping the cards; the game object
;	seeks out possible destinations, and tells the deck whether
;	or not the transfer was successful (i.e., whether the cards
;	were taken elsewhere). Deck then cleans up the mess left
;	by dragging (both visually and internally).
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_CARD_FLIP_CARD			message
;
;	Deck turns its top card over and sends it a MSG_CARD_FADE_REDRAW
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_DECK_FULL_PTR				message
;
;	Moves dragged cards in accordance with a new MSG_META_PTR under
;	full card dragging.
;
;	PASS:		cx,dx = new mouse coordinates
;
;	RETURN:		nothing

MSG_DECK_RETRIEVE_CARDS			message
;
;	Retrieves the last set of cards that were given to another deck.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_DECK_GET_CATCH_BOUNDS			message
;
;	Returns the bounds within which a drag is considered "fair game"
;	for this deck to take.
;
;	PASS:		nothing
;
;	RETURN:		ax = left of catch boundary
;			bp = top of catch boundary
;			cx = right of catch boundary
;			dx = bottom of catch boundary

MSG_DECK_GET_COMPARISON_KIT		message
;
;	A comparison kit contains the information needed to determine whether
;	a deck would accept a particular card during a drag. This method
;	returns this info.
;
;	PASS:		nothing
;
;	RETURN:		bp = ComparisonKit

MSG_DECK_GET_DEALT			message
;
;	Add the passed card into the composite, and fade it in if it's
;	face up.
;
;	PASS:		^lcx:dx = card to add
;
;	RETURN:		nothing

MSG_DECK_GET_DRAG_BOUNDS			message
;
;	Returns the bounds of the deck's current drag
;
;	PASS:		nothing
;
;	RETURN:		ax = left of drag boundary
;			bp = top of drag boundary
;			cx = right of drag boundary
;			dx = bottom of drag boundary

MSG_DECK_GET_DROP_CARD_ATTRIBUTES		message
;
;	Returns the attributes of the "drop card", the bottom card
;	of a drag set.
;
;	PASS:		nothing
;
;	RETURN:		bp = CardAttrs of the drop card

MSG_DECK_GET_NTH_CARD_ATTRIBUTES		message
;
;	Returns the CardAttrs of the deck's nth card
;
;	PASS:		bp = # of child in composite to get attributes of
;
;	RETURN:		bp = attributes of nth card
;			carry = clear if successful


MSG_DECK_GET_RID_OF_CARDS			message
;
;	Deck gives up all its cards to the passed deck. This is the same
;	as MSG_DECK_POP_ALL_CARDS, except that scoring is disabled throughout
;	the transfer.
;
;	PASS:		^lcx:dx = deck to give cards to
;
;	RETURN:		nothing

MSG_DECK_IMPLODE_EXPLODE			message
;
;	This is the effect of an illegal drop in outline dragging
;	mode.  the outline of the drag region shinks to nothing
;	(implodes), then an outline grows to the size of the drag,
;	only relocated to where the drag began.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_DECK_INVALIDATE_INIT			message
;
;	Issues a WinInvalRect in the region where the drag first began.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_DECK_INVERT_IF_ACCEPT			message
;
;	Deck visually inverts itself (or its top card, if any) if the
;	bit DA_WANTS_DRAG in DeckAttrs is set (i.e., it would accept
;	the drag if it were dropped upon).
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_DECK_INVERT			message
;
;	Deck will visually invert itself if it is marked as willing
;	to accept the current drag
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_DECK_CLEAR_INVERTED			message
;
;	Ensures that the deck is not inverted
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_DECK_MARK_IF_ACCEPT			message
;
;	This method sets the DA_WANTS_DRAG bit in the DeckAttrs
;	iff the deck would accept the drag set from the passed dragger.
;
;	PASS:		^lcx:dx = dragging deck
;
;	RETURN:		 nothing

MSG_DECK_MOVE_AND_CLIP			message
;
;	Prepares the deck to push a card into its composite.
;	The data in DI_topCardLeft and DI_topCardTop are changed
;	to reflect the new card coming, and the vis bounds of the
;	current	top card are clipped.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_DECK_OFFSET_TOP_LEFT			message
;
;	Adds offsets to the deck's information about the origin of
;	its top card (i.e., it is likely that another card is coming, and
;	it will be offset by some x,y offset).
;
;	PASS:		nothing
;
;	RETURN:		cx = offset added to DI_topCardLeft
;			dx = offset added to DI_topCardTop

MSG_DECK_OUTLINE_PTR			message
;
;	Moves dragged cards in accordance with a new MSG_META_PTR under
;	outline dragging.
;
;	PASS:		cx,dx = new mouse coordinates
;
;	RETURN:		nothing

MSG_DECK_POP_ALL_CARDS			message
;
;	Transfer all this deck's cards to another deck by popping them
;	off one by one and pushing them onto the other deck.
;
;	PASS:		^lcx:dx = deck to pop all cards to
;
;	RETURN:		nothing

MSG_DECK_POP_CARD				message
;
;	Removes the deck's top card from the deck's composite
;
;	PASS:		nothing
;
;	RETURN:		if deck has children:
;				carry clear
;				^lcx:dx = popped card
;			else:
;				carry set
			
MSG_DECK_POP_N_CARDS			message
;
;	Pop a certain number of cards and push them into another deck's
;	composite.
;
;	PASS:		^lcx:dx = deck to give cards to.
;			bp = number of cards to give.
;
;	RETURN:		nothing

MSG_DECK_PUSH_CARD			message
;
;	Pushes a card into the deck's composite, places it in the appropriate
;	spot on screen, and draws it in.
;
;	PASS:		^lcx:dx = card to push
;
;	RETURN:		nothing

MSG_DECK_PUSH_CARD_NO_EFFECTS		message
;
;	This method IS the same as MSG_DECK_PUSH_CARD_NO_EFFECTS; it is here
;	so that it can be subclassed (see klondike's talon for ex.)

MSG_DECK_REDRAW				message
;
;	Creates a gstate, then draws itself and its cards through it.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_DECK_REMOVE_NTH_CARD			message
;
;	Removes a card from the deck's composite
;
;	PASS:		if cx = 0, then dx = # of child to remove (0 for first)
;			else ^lcx:dx = card to remove
;
;	RETURN:		if a card was removed:
;				carry clear
;				^lcx:dx = removed card
;
;			if a card was not removed (couldn't be found):
;				carry set
			
MSG_DECK_REPAIR_FAILED_TRANSFER		message
;
;	Fixes up the state of affairs (both visual and internal)
;	after the deck drops cards and no deck accepts them.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_DECK_REPAIR_SUCCESSFUL_TRANSFER	message
;
;	Fixes up the state of affairs (both visual and internal)
;	after the deck drops cards and another deck accepts them.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_DECK_REQUEST_BLANK_CARD		message
;
;	Asks the game object to draw a blank card at a specified location
;
;	PASS:		cx,dx = x,y to draw blank card
;			bp = gstate
;
;	RETURN:		nothing

MSG_DECK_REQUEST_FAKE_BLANK_CARD		message
;
;	Asks the game object to draw a "fake" blank card at a specified
;	location. A fake blank card is just a black-bordered white rectangle
;	the size of a card.
;
;	PASS:		cx,dx = x,y to draw blank card
;			bp = gstate
;
;	RETURN:		nothing

MSG_DECK_REQUEST_FRAME			message
;
;	Asks the game object to draw a card frame at a specified location
;
;	PASS:		cx,dx = x,y to draw card frame
;			bp = gstate
;
;	RETURN:		nothing

MSG_DECK_RETURN_CARDS			message
;
;	Invalidates itself, transfers a specified number of cards to
;	a specified deck, and maximizes the top cards remaining after
;	the transfer.
;
;	PASS:		^lcx:dx = deck to give cards to.
;			bp = number of cards to give
;
;	RETURN:		nothing

MSG_DECK_SETUP_DRAG			message
;
;	Sets up the deck's instance data to drag a set of cards around.
;	Stores things like # of cards dragging, initial location of the drag
;	set, etc.
;
;	PASS:		bp = # of cards to drag
;			cx,dx = mouse location
;
;	RETURN:		nothing

MSG_DECK_SET_POINTS			message
;
;	Sets the # of points awarded/penalized for pushing,
;	popping, and turning cards in this deck
;
;	PASS:		cx = points awarded for pushing a card to this deck
;			dx = points awarded for popping a card from this deck
;			bp = points awarded for flipping a card over
;
;	RETURN:		nothing

MSG_DECK_SPRAY_CARDS			message
;
;	Creates a card fan with the deck's cards.
;
;	PASS:		bp = gstate to draw through
;			cx = radius of fan
;			dx = # degrees to rotate the gstate after each card
;
;	RETURN:		nothing

MSG_DECK_STRETCH_BOUNDS			message
;
;	Widens (or shrinks) a deck's vis bounds by a certain amount (usually
;	due to the pushing or popping of a new card).
;
;	PASS:		cx = incremental width
;			dx = incremental height
;
;	RETURN:		nothing

MSG_DECK_TAKE_CARDS_IF_OK			message
;
;	Deck is instructed to take the drag set if the drag set has the correct
;	drop card and overlaps with this deck's catch bounds.
;
;	PASS:		^lcx:dx = dragging deck
;			bp = CardAttrs of the drop card of the drag set
;
;	RETURN:		carry is set if the deck takes the drag set,
;			carry is clear otherwise

MSG_DECK_TAKE_DOUBLE_CLICK_IF_OK		message
;
;	Deck is instructed to take the drag set if the drag set has the correct
;	drop card. Whether or not the drag set is within range of the deck's
;	catch bounds is NOT an issue.
;
;	PASS:		^lcx:dx = dragging deck
;			bp = CardAttrs of the drop card of the drag set
;
;	RETURN:		carry is set if the deck takes the drag set,
;			carry is clear otherwise

MSG_DECK_TAKE_HIT_IF_OK			message
;
;	Deck pushes the passed card if its current top card
;	is face down.
;	This is pretty much a method used exclusively for poker,
;	but it may have some general application.
;
;	PASS:		^lcx:dx = card to be pushed
;
;	RETURN:		carry set if card was taken, clear otherwise

MSG_DECK_TEST_ACCEPT_CARDS		message
;
;	Tests deck to see whether a set of dragged cards
;	would be accepted to the drag if it were dropped right
;	now (i.e., rank&suit are ok, and position is ok).
;
;	PASS:		^lcx:dx = dragging deck
;
;	RETURN:		carry is set if the deck would accept the drag
;			set, clear otherwise
	
MSG_DECK_TEST_RIGHT_CARD			message
;
;	Checks to see if the deck would accept the drag set from
;	the passed deck if it were dropped upon (i.e., see if the catch
;	card of this deck would take the drop card fom the drag deck).
;
;	PASS:		^lcx:dx = dragging deck
;
;	RETURN:		nothing

MSG_DECK_TRANSFER_ALL_CARDS		message
;
;	Transfers all of a deck's cards to another deck. Relative
;	order of the cards is preserved.
;
;	PASS:		^lcx:dx = deck to give cards to.
;
;	RETURN:		nothing

MSG_DECK_TRANSFER_DRAGGED_CARDS		message
;
;	Transfers a deck's drag cards (if any) to another deck
;
;	PASS:		^lcx:dx = deck to give cards to.
;
;	RETURN:		nothing

MSG_DECK_TRANSFER_N_CARDS			message
;
;	Transfers a specified number of cards to another deck
;
;	PASS:		^lcx:dx = deck to give cards to
;			bp = # of cards to give
;
;	RETURN:		nothing

MSG_DECK_UPDATE_DRAG			message
;
;	Updates the deck's drag instance data to reflect a new mouse
;	position.
;
;	PASS:		cx,dx = new mouse position
;
;	RETURN:		cx,dx = left,top of drag set given new mouse position
;			ax,bp = left,top of drag set BEFORE new mouse position

MSG_DECK_UPDATE_TOPLEFT			message
;
;	Sets the instance data indicating the position of the deck's
;	top card, and also reesizes the deck to make a tight fit
;	around its cards.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_DECK_UP_CARD_SELECTED			message
;
;	Called when one of a deck's face up cards is selected.
;
;	PASS:		bp = # of child in composite that was selected
;
;	RETURN:		nothing

MSG_DECK_SET_DOWN_SPREADS		message
;
;	Sets the instance data in the deck that determines the visual
;	offset between face down cards in that deck.
;
;	PASS:		cx,dx = x,y spreads for face down cards
;
;	RETURN:		nothing

MSG_DECK_SET_UP_SPREADS		message
;
;	Sets the instance data in the deck that determines the visual
;	offset between face up cards in that deck.
;
;	PASS:		cx,dx = x,y spreads for face up cards
;
;	RETURN:		nothing

MSG_DECK_SAVE_STATE		message
;
;	Tacks any info necessary to recreate the decks state onto the
;	end of the passed mem block, to be used on a subsequent
;	MSG_DECK_RESTORE_STATE
;
;	PASS:		^hcx:dx - ptr to add data to (need to realloc space)
;
;	RETURN:		^hcx:dx - updated to point after data
;

MSG_DECK_RESTORE_STATE		message
;
;	Restores a deck to its previous state when passed a block
;	that was returned from MSG_GAME_SAVE_STATE
;
;	PASS:		^hcx:dx - place to read saved info from
;
;	RETURN:		^hcx:dx - updated to point past this decks
;				  info (in preparation for the next deck)
;

;------------------------------------------------------------------------------
;		Structure of whatever
;------------------------------------------------------------------------------

;
;	If the user drops a drag set that doesn't get caught and is less
;	than the distance specified by the following 2 constants, then it
;	is considered somewhat of a mistake, and no fixup visual effects
;	are generated.
;
MINIMUM_HORIZONTAL_DISPLACEMENT = 20
MINIMUM_VERTICAL_DISPLACEMENT = 20

;------------------------------------------------------------------------------
;			Definitions
;------------------------------------------------------------------------------

CONVERT_WHLT_TO_LTRB	macro

	xchg	ax,cx	; ax = left, cx = width
	xchg	bx,dx	; bx = top, dx = height
	add	cx,ax	; cx = left + width = right
	dec	cx
	add	dx,bx	; dx = top + height = bottom
	dec	dx

endm

;
;	SuitAcceptanceCondition specify suit restrictions when checking
;	whether one card may be played onto another. For example, if
;	SAC_SAME_COLOR is in effect, then red cards may only be played
;	onto other red cards, and black cards may only be played onto
;	other blacks.
;
SuitAcceptanceCondition	etype	byte
SAC_OPPOSITE_COLOR	enum	SuitAcceptanceCondition
SAC_SAME_COLOR		enum	SuitAcceptanceCondition
SAC_SAME_SUIT		enum	SuitAcceptanceCondition
SAC_ANY_SUIT		enum	SuitAcceptanceCondition

;
;	RankAcceptanceCondition specify rank restrictions when checking
;	whether one card may be played onto another. For example, if
;	RAC_ONE_GREATER_RANK is in effect, then sevens may only be played
;	onto sixes, etc. If RAC_ABSOLUTE_RANK is in effect, then the deck
;	will only accept cards of a particular rank (i.e., not relative
;	to the deck's catch card).  An example is the foundations in Klondike,
;	which take only aces to begin with. An additional field is included in
;	CardAcceptanceConditions to specify which absolute rank we're talking
;	about.
;
RankAcceptanceCondition	etype	byte
RAC_ONE_LESS_RANK	enum	RankAcceptanceCondition
RAC_ONE_GREATER_RANK	enum	RankAcceptanceCondition
RAC_EQUAL_RANK		enum	RankAcceptanceCondition
RAC_ABSOLUTE_RANK	enum	RankAcceptanceCondition

;
;	CardAcceptanceConditions give a complete specification of restrictions
;	in effect when checking whether one card may be played onto another.
;
CardAcceptanceConditions	record
	:7
	CAC_SINGLE_CARD_ONLY:1			;this bit should be set if the
						;deck will only accept drag
						;sets of one card only
						;(Klondike's foundations are
						;cases in point).

	CAC_SAC SuitAcceptanceCondition:2
	CAC_RAC RankAcceptanceCondition:2
	CAC_RANK CardRank:4			;rank for RAC_ABSOLUTE_RANK
CardAcceptanceConditions	end

;
;	A ComparisonKit is a structure passed around when a drag set is being
;	checked for acceptance into other decks; it contains both the
;	attributes of the deck's catch card (CK_TOP_CARD) and what kind of
;	restrictions this deck places on transfers (CK_CAC).
;
ComparisonKit	record
	CK_TOP_CARD CardAttrs : 7
	CK_CAC CardAcceptanceConditions : 9
ComparisonKit	end

;
;	DeckDragWhichCard gives information about which cards the deck should
;	drag when the user selects some card in its composite:
;
;	DDWC_NONE:		Never drag cards (example is Klondike's hand)
;
;	DDWC_TOP_ONLY:		If user selects top card, it is dragged; any
;				other card when selected will do nothing.
;
;	DDWC_UNTIL_SELECTED:	Deck will drag all cards up to and including
;				the selected card.
;
;	DDWC_TOP_OR_UPS:	If top card is selected, it is dragged; if
;				any other face up card is selected, all face
;				up cards are dragged (example is Klondike's
;				tableu elements in advanced mode).
;
DeckDragWhichCard	etype	byte
DDWC_NONE		enum	DeckDragWhichCard
DDWC_TOP_ONLY		enum	DeckDragWhichCard
DDWC_UNTIL_SELECTED	enum	DeckDragWhichCard
DDWC_TOP_OR_UPS		enum	DeckDragWhichCard

DeckAttrs	record
	:1,

	DA_INVERTED : 1,

	DA_DDWC DeckDragWhichCard : 2,

	DA_JUST_UNCOVERED : 1,		;Talon specific

	DA_IGNORE_DOUBLE_CLICKS : 1,	;Double clicking on a deck that
					;has this bit set will do nothing

	DA_IGNORE_EXPRESS_DRAG : 1,	;this bit, when set, instructs
					;the deck to not consider taking
					;a drag that has been double
					;clicked (as in klondike).

	DA_WANTS_DRAG : 1		;This bit indicates that the current
					;drag meets all the
					;CardAcceptanceConditions for this deck
DeckAttrs	end


;;instance data
	DI_deckAttrs	DeckAttrs

	DI_markerColor	Color		;color of deck's marker
	DI_markerMask	SystemDrawMask

	DI_pushPoints		word	;# of points to add to score if a card
					;is added to this deck

	DI_popPoints		word	;# of points to add to score if a card
					;is removed to this deck

	DI_flipPoints	word		;# of points to add to score if a card
					;is flipped over in this deck.

	;
	;	CardAcceptanceConditions that should be applied when the
	;	deck has no cards.
	;
	DI_noCardAC	CardAcceptanceConditions

	;
	;	CardAcceptanceConditions that should be applied when the
	;	deck's top card is face down.
	;
	DI_downCardAC	CardAcceptanceConditions

	;
	;	CardAcceptanceConditions that should be applied when the
	;	deck's top card is face up.
	;
	DI_upCardAC	CardAcceptanceConditions

	DI_offsetFromDownCardX	word	;horizontal offset when placing a card
					;onto a face down card

	DI_offsetFromDownCardY	word	;vertical offset when placing a card
					;onto a face down card
;
;	This card is face down
;	+------------------+
;	|          ^       |
;	|        Y |       |
;	|          v       |
;	|     +------------------+
;	|     |                  |
;	|     |                  |		
;	|<--->|                  |	
;	|  X  |                  |	
;	|     |                  |	
;	|     |                  |	
;	|     |                  |	
;	|     |                  |	


	DI_offsetFromUpCardX	word	;horizontal offset when placing a card
					;onto a face up card
	DI_offsetFromUpCardY	word	;vertical offset when placing a card
					;onto a face up card
;
;	This card is face up
;	+------------------+
;	|          ^       |
;	|        Y |       |
;	|          v       |
;	|     +------------------+
;	|     |                  |
;	|     |                  |	
;	|<--->|                  |	
;	|  X  |                  |	
;	|     |                  |	
;	|     |                  |	
;	|     |                  |	
;	|     |                  |	


	DI_topCardLeft	word	;left bound of deck's current top card

	DI_topCardTop	word	;top bound of deck's current top card

	DI_nCards	word	;# cards in the deck

	;
	;	the following two instance data slots are for UNDO:
	;
	;	DI_lastRecipient is the OD of the last deck that this deck
	;			 gave cards to.
	;
	;	DI_lastGift is the number of cards this deck gave last time.
	;

	DI_lastRecipient	optr	;OD of last deck that received cards
					;from this deck.

	DI_lastGift	word		;number of cards last given to deck
					;pointed at by DI_lastRecipient

	;
	;	The rest of the instance data is only used when the deck
	;	is dragging cards around
	;

	DI_nDragCards	word	;# of cards currently being dragged

	DI_dragOffsetX	word	;distance from mouse pointer to the left
				;bound of a drag area
	DI_dragOffsetY	word	;distance from mouse pointer to the top
				;bound of a drag area

	DI_prevLeft	word	;left coordinate used the last time the drag
				;was drawn
	DI_prevTop	word	;top coordinate used the last time the drag
				;was drawn

	DI_initLeft	word	;initial left coordinate of the drag
	DI_initTop	word	;initial top coordinate of the drag

	DI_initRight	word	;
	DI_initBottom	word	;
	
	DI_dragWidth	word	;width of the drag area
	DI_dragHeight	word	;height of the drag area

	DI_gState	hptr.GState	;graphics state for dragging
DeckClass	endc

;------------------------------------------------------------------------------
;	Hand Class
;------------------------------------------------------------------------------

;### HandClass -- Defs inserted below by "pmake def"
; Extracted from hand.asm:

HandClass	class	DeckClass
MSG_HAND_EXCHANGE_CHILDREN	message
;
;	Exchanges the attributes (which effectively switches the cards) of
;	the mth and nth cards in the deck's composite.
;
;	PASS:		cx,dx = #'s of cards in composite to switch attributes
;
;	RETURN:		nothing

MSG_HAND_MAKE_FULL_HAND		message
;
;	Creates a full set of 52 cards and adds them to tthe hand's composite.
;	This method can be sent multiple times if multiple decks are required.
;
;	PASS:		nothing
;
;	RETURN:		nothing

MSG_HAND_SHUFFLE			message	
;
;	Shuffles the order of the cards within the hand.
;
;	PASS:		nothing
;
;	RETURN:		nothing

HandClass	endc



;------------------------------------------------------------------------------
;	CardListEntry Class
;------------------------------------------------------------------------------

;### CardListEntryClass -- Defs inserted below by "pmake def"

global VisSendToChildrenWithTest:far

global WriteNum:far
global WriteTime:far
global ScoreToTextObject:far

EndLibrary	cards
