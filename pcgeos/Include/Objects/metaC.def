COMMENT @----------------------------------------------------------------------

	Copyright (c) GeoWorks 1989 -- All Rights Reserved

PROJECT:	PC GEOS
FILE:		Objects/metaC.def

DECLARER:	Kernel

DESCRIPTION:
	This file defines MetaClass

	$Id: metaC.def,v 1.1 97/04/04 14:17:59 newdeal Exp $

------------------------------------------------------------------------------@

SetDef	__METAC

StartKernel

include geode.def
include object.def
include chunkarr.def
include geoworks.def

;------------------------------------------
;		Structures
;------------------------------------------

;
; Base structure defined so Esp can build on it for all other classes. It
; *must* be defined before the class is declared.
; 
MetaBase	struct
    MB_class	fptr.ClassStruct	;Instance's class
MetaBase	ends

;
;			  Class Declaration
;
MetaClass	class	0

    MI_base	MetaBase	<>	; Public instance data

;------------------------------------------
;	Methods
;------------------------------------------

MSG_META_NULL		message	private
.assert (MSG_META_NULL eq FIRST_META_GCN_LIST_TYPE)
;
; Not really a method that is intended to be handled by anybody, but
; instead just a method stuff here to have the value "0" all to itself, so that
; MSG_META_EXPOSED, or whatever else comes next, DOESN'T.  Sometimes AD's, etc.
; are still clear when sent, as well as notification for gained & lost grabs.
; DO NOT EXPECT THIS METHOD TO BE EITHER DELIVERED OR NOT DELIVERED.
;
; Context:	Object system reserved message
; Source:	Unrestricted
; Destination:	Unrestricted
; Interception:	Don't (not actually possible, anyway)
; Pass:		N/A
; Return:	N/A

MSG_META_INITIALIZE	message
;
; MSG_META_INITIALIZE is called only when an object or a master class part
; of an object is created.  MSG_META_INITIALIZE sets the object to its default
; state.
;
; Context:	Core message of PC/GEOS Object System
; Source:	Object system itself, often smack in the middle of attempting
;		to deliver another message to an object that hasn't yet been
;		grown out, instance data-wise
; Destination:	Object not yet grown out
; Interception:	Any class wishing to have default instance data values other
;		that all zero's should intercept this message to fill in the
;		initial values for the instance data belonging to the class.
;		For classes other than master classes, standard procedure is
;		to first call the superclass, then perform any additional
;		instance data initialization necessary.  Master classes should
;		NOT call the superclass, as MSG_META_INITIALIZE is unique
;		among messages in that it is sent only to classes within the
;		particular master group that needs to be initialized.  Handlers
;		of MSG_META_INITIALIZE should limit their activities to
;		just stuffing instance data -- specifically, object messaging
;		is not allowed (though scanning vardata is OK).
; Pass: 	nothing
; Return:	nothing
;		ax, cx, dx, bp - destroyed
;
; More notes on writing a handler for MSG_META_INITIALIZE:
; 
; Object classes that inherit instance data (everyone but meta) should call
; MSG_META_INITIALIZE of their superclass (which is not necessarily
; the object's class...) to initialize that portion of their instance data.
; In addition, they must initialize their own portion of the instance data
; (Start by assuming it's all 0's).  The order won't matter, so long as you
; don't depend on the inherited instance data having any particular value
; while you initialize your data.  When in doubt, call superclass first.
;

MSG_META_RESERVED_1		message
;

MSG_META_DUMMY		message
;
; Does nothing.  However, it may be sent using a "call" to flush a
; queue, or simply to force variant classes to be grown out.
; DO NOT PROVIDE A HANDLER FOR THIS MESSAGE!
;
; Context:	Object system reserved message
; Interception:	DON'T
; Pass:		N/A
; Return:	N/A
;		ax, cx, dx bp - presume destroyed (though nothing should
;				really touch these)

;-------------------------------------------------
;		Standard methods
;-------------------------------------------------

MSG_META_APP_STARTUP	message	
;
; This is related to MSG_META_ATTACH and is sent by the generic UI to the
; GenApplication object *before* it sends MSG_META_ATTACH to it. The
; distinction between these two messages is MSG_META_ATTACH is sent only
; when the application is becoming available to the user; if an application
; is opened as a server, with no UI being presented to the user, then
; MSG_META_APP_STARTUP is the only message that will be sent to the
; application object.
;
; The default handler for this message will pass it on to all members
; of the MGCNLT_APP_STARTUP list.
;
; Context:	Sent on application startup before the UI for the application
;		has been attached.
; Source:	GenProcessClass; forwarded by GenApplicationClass and
;		others.
; Destination:  Any object that needs to be notified when the application
;		is launched, regardless of whether the user will be
;		interacting with the application, or if the launching was
;		driven by another application's need.
; Interception: Usually intercepted by any object on the MGCNLT_APP_STARTUP
;		list.
;
; Pass:
;		dx	- handle of AppLaunchBlock
;
; Return:
;		AppLaunchBlock preserved
;		ax, cx, bp - destroyed
;


MSG_META_ATTACH		message
;
; MSG_META_ATTACH is sent to any Geode which has a process, when it is
; first loaded.  It is also used in the object world to notify objects on
; an "active lists" that the application has been brought back up from a 
; state file.  As the method is used for different purposes, the data
; passed varies based on usage:
;
; Context:	Core message of the Geode Attach/Detach mechanism
;
; As sent in general by GeodeLoad, if the bit GA_PROCESS is set in the 
; Geode:
;
; Source:	Kernel routine GeodeLoad
; Destination:	Newly created process (other than GenProcessClass) object
; Interception:	No default handling provided, so you will likely want to
;		intercept this message to do any process initialization req'd.
; Pass:		cx - value passed to GeodeLoad in di
; 		dx - value passed to GeodeLoad in bp
; Return:	nothing
;		ax, cx, dx, bp - destroyed
;
; As required by the GenProcessClass, which all application using the UI library
; must have their processes subclassed off of:
;
; Source:	Kernel routine GeodeLoad
; Destination:	Newly created GenProcessClass (or subclass thereof) object
; Interception:	Often intercepted as a convenient place to perform general
;		application initialization that should occur whether just
;		being launched, coming back from state, or being launched in
;		engine mode.  Note that the interface of the
;		application will not be on screen (in fact, won't even be
;		linked into the system wide generic tree) until the superclass
;		is called.
; Pass: 	dx	- Block handle to block of structure AppLaunchBlock
; Return:	nothing
;		AppLaunchBlock - destroyed
;		ax, cx, dx, bp - destroyed
;
; As sent to the GenApplication object by GenProcessClass, upon an application
; starting up, either for the first time, or when being restored to the
; state it was in before being detached from a previous session:
;
; Source:	GenProcessClass object
; Destination:	GenApplicationClass object
; Interception:	Not generally req'd, as the default handler broadcasts the
;		message out to everything on the application's active list.
;		This act causes the interface for the application to come up
;		on screen.
; Pass:	 	dx 	- AppLaunchBlock
;		bp 	- Extra state block from state file, or 0 if none.
;		  	  This is the same block as returned from
;		  	  MSG_GEN_PROCESS_CLOSE_APPLICATION, in some previous
;			  detach
; Return:	nothing
;		AppLaunchBlock - preserved
;		extra state block - preserved
;		ax, cx, dx, bp - destroyed
;
; As sent to objects on the Application object's active list (Not done until
; GenApplication is set USABLE by GenProcessClass), or those object's active
; lists, & on down:
;
; Source:	GenApplicationClass object
; Destination:	Any object on the app's active list
; Interception:	Standard UI objects defined as needing to be placed on the
;		active list will intercept this message to do whatever it is
;		that they needed to do when the application is first loaded.
;		If you intercept this yourself, be sure to call the superclass,
;		in case it expects to receive this notification itself.
; Pass: 	cx	- AppAttachFlags
;		dx	- Handle of AppLaunchBlock, or 0 if none.
;			  IMPORTANT:  See "Note" below
;		bp	- Handle of extra state block, or 0 if none.
;		  	  This is the same block as returned from
;		  	  MSG_GEN_PROCESS_CLOSE_APPLICATION, in some previous
;			  detach IMPORTANT:  See "Note" below
; Return:	nothing
;		AppLaunchBlock - preserved
;		extra state block - preserved
;		ax, cx, dx, bp - destroyed
;
; Note:	If sent to an object with a MGCNLT_ACTIVE_LIST GCN list, a default
;	handler will normally pass the message on to all items on that object's
; 	active list. Before doing so, however, it passes the message on to its
;	superclass. if carry is returned set, it will NOT send the message on
;	to the object's active list.  This scheme has been devised to allow
;	Specific UI objects to handle MSG_META_ATTACH as they wish. (This added
;	so that OLDisplayControl can delay sending of MSG_META_ATTACH to
;	GenDisplays until GenDisplayControl gets MSG_VIS_OPEN.)
;
;	The upshot of this:  If the specific UI uses this mechansim, then
;	the GenProcessClass will have already destroyed the AppLaunchBlock &
;	extra state block by the time that MSG_META_ATTACH is sent on to the
;	objects on its ActiveList
;
;
; As sent to a thread spawned by MSG_PROCESS_CREATE_EVENT_THREAD:
;
; Source:	Kernel
; Destination:	Newly created thread (actually class designated to handle
;		thread's messages)
; Interception:	No default handling provided, so you will likely want to
;		intercept this message to do any thread initialization req'd.
; Pass: 	nothing
; Return: 	nothing
;		ax, cx, dx, bp - destroyed
;


MSG_META_DETACH		message
;
; MSG_META_DETACH is used to sever the links between an object and the
; run-time world that it has created.  The "state" of the object is left intact,
; in case an image of the object needs to be saved away in a state file for
; later recreation.  MSG_META_DETACH sent to an application's process will
; start the process by which it is detached from the system, & then exited.
; MSG_META_DETACH is asynchronous, in that it need not complete its job
; immediately upon being called.  Rather, it may take as much time & queue
; delays as it wants, invoking & waiting for the completion of subsidiary
; detaches (say of child objects needing to perform special actions to
; DETACH, or of threads created earlier), before it responds with 
; MSG_META_ACK to let its caller know that the DETACH has completed.
;
; Context:	Core message of the Geode Attach/Detach mechanism
; Source:	Kernel/GenProcess/GenApplication/other detach nodes
; Destination:	GenProcess/GenApplication/objects on application active list
; Interception:	Intercepted as a means of finding out that the application
;		is shutting down.  Be sure to call the superclass in case
;		it needs such notification.
; Pass: 	cx 	- caller's ID
;		dx:bp 	- callers' OD:  OD which will be sent a MSG_META_ACK
;				when the object has finished detaching.
; Return: 	nothing
;		ax, cx, dx, bp - destroyed
;
; If you create additional threads, or object classes which need to be 
; notified when the app is about to be exited, you may need to extend the
; DETACH mechanism by intercepting MSG_META_DETACH in a subclass of an
; object already receiving that message, such as GenApplication, GenControl,
; GenInteraction dialogs, etc.  If it weren't for the responsibility of
; objects receiving MSG_META_DETACH to respond w/MSG_META_ACK when they
; have completed detaching, you could just intercept the message, send it
; whereever the heck you wanted, & then call the superclass.  Because of the
; MSG_META_ACK requirement, though, it's not that easy.  You must make sure
; that all objects you've sent MSG_META_DETACH's to have responded with a
; MSG_META_ACK of their own before your object can reply w/MSG_META_ACK. It
; gets even more complicated when you consider that your superclass may be
; sending out MSG_META_DETACH's of its own.  The kernel provides some 
; default behavior in MetaClass, & some utility routines, to make this a
; simpler task.  The default handler for MSG_META_DETACH, for instance, at
; a leaf object (one which doesn't propogate the MSG_META_DETACH), performs
; the required ACK response.  Thus, leaf objects can just intercept 
; MSG_META_DETACH for notification purposes, then call the superclass, & worry
; no more.  The utility routines "ObjInitDetach" & "ObjEnableDetach" work
; in conjunction with a default MSG_META_ACK handler in MetaClass to keep 
; track of how many outstanding MSG_META_ACK's are being waited for, & call
; MSG_META_DETACH_COMPLETE on your object once all ACK's have returned (the
; count reaches 0).  The default handler for MSG_META_DETACH_COMPLETE then
; generates the ACK response required of your object to complete its DETACH.
; To use these utilities, your code should look like:
;
;	XXXDetach	proc	far
;		call	ObjInitDetach		; Allocate temp chunk, save vars
;						; ax = MSG_META_DETACH
;
;		For each child/dependent {
;			call	ObjIncDetach
;			< Send DETACH or equivalent here, to child/dependent
;				needing to get a MSG_META_DETACH >
;		}
;
; 		< Call superclass w/MSG_META_DETACH, passing same parameters as
;			received in this handler, here. >
;
;		call	ObjEnableDetach		; Allow ACK response once final
;						; ACK from child/dependents have
;						; been received.
;		ret
;
; You may optionally call the superclass before sending the DETACH to your
; child/dependents, depending on which order you want things to detach in.
; The call to the SuperClass *must* happen between the ObjInitDetach &
; ObjEnableDetach, however.
;
;					Doug 6/3/92
;

MSG_META_DETACH_COMPLETE		message
;
; MSG_META_DETACH_COMPLETE is sent to the object having called ObjInitDetach,
; when as many MSG_META_ACK's have been received as ObjIncDetaches
; were called, & ObjEnableDetach was called.  The MetaClass handler for this
; message sends MSG_META_ACK to the OD passed to the ObjInitDetach call.  This
; message is provided so that an object will know when all of its children
; have detached, so that it may, for instance in the case of a field object,
; set itself not usable & remove itself from the system object, BEFORE the
; MSG_META_ACK is sent on to the caller of the MSG_META_DETACH on the field.
;
; Note that this message is received only if ObjInitDetach has been called
; for this object. Note also that your superclass may call ObjInitDetach
; without your knowing.
;
; Context:	Core message of the Geode Attach/Detach mechanism
; Source:	MetaClass handler for MSG_META_ACK, if detach count has dropped
;		to zero (i.e. no outstanding requests), for objects that are
;		detach nodes only (make use of ObjInitDetach/ObjEnableDetach).
; Destination:	self
; Interception:	A handy message to intercept if you are using the ObjInitDetach
;		mechanism & need to know when all objects asked to detach
;		have responded.  Calling the superclass at this point in
;		time will cause an ACK to go back to whatever object sent
;		the MSG_META_DETACH to this object originally.  There is no
;		requirement to call the superclass at this time, & in fact
;		this is a way to prolong the detach cycle for this object --
;		by simply staring up another ObjInitDetach sequence, for
;		instance.
; Pass: 	nothing
; Return: 	nothing
;		ax, cx, dx, bp - destroyed

MSG_META_DETACH_ABORT		message
;
; MSG_META_DETACH_ABORT is sent to the object having called ObjInitDetach.
; It should only be sent to the GenSystem and GenField objects currently.
; It basically just clears the temp chunk (WARNING! Most objects can't
; handle having their detaches aborted -- don't use this method lightly).
;
; Context:	Core message of the Geode Attach/Detach mechanism
; Source:	Renigade object on active list, after having received
;		MSG_META_DETACH, as an alternative to replying w/
;		MSG_META_ACK.
; Destination:	optr passed in MSG_META_DETACH
; Interception:	Handled by GenField to deal w/apps that refuse to die, & 
;		GenSystem for Field that have problem apps.  Other than
;		that, any detach node wishing to provide this service will
;		have to figure out a way to do it itself.
; Pass:		nothing
; Return:	nothing
;		ax, cx, dx, bp - destroyed
;

MSG_META_ACK			message
;
; MSG_META_ACK is what an object gets back in response to a MSG_META_DETACH
; notifying it that the object has fulfilled the request.
;
; Context:	Core message of the Geode Attach/Detach mechanism
; Source:	Object having received MSG_META_DETACH (Default handler in
;		MetaClass will reflexively respond to any MSG_META_DETACH with a
;		MSG_META_ACK, though you can change this behavior either by
;		using ObjInitDetach et all, or by not letting the message get
;		to the MetaClass handler, & responding yourself w/MSG_META_ACK
;		sometime later)
; Destination:	optr passed in MSG_META_DETACH
; Interception:	MetaClass provides default handling of this message, for objects
;		using the ObjInitDetach mechanism.  Objects NOT using this
;		mechanism will want to intercept this if there is a need to
;		know when the object asked to detach earlier has completed its
;		detach.
; Pass: 	cx - data passed to MSG_META_ACK
;		dx:bp	- object which has completed detaching
; Return: 	nothing
;		ax, cx, dx, bp - destroyed
;
; Writing MSG_META_ACK:
;
; MSG_META_ACK can normally be inheritied from MetaClass which calls
; ObjAckDetach, which decrements the detach count, & when it reaches 0,
; sends a MSG_DETACH_COMPLETED to the object itself.
; (NOTE:   If you are expecting a MSG_META_ACK back from anything,
; make sure you are using the mechanism initiated with ObjInitDetach yourself,
; or you should handle MSG_META_ACK yourself to prevent MetaClass from assuming
; you ARE using such a mechanism.
;

MSG_META_APP_SHUTDOWN	message	
;
; This is the flip side of MSG_META_APP_STARTUP. It is sent before the
; application exits, regardless of the mode in which the application was
; operating. It arrives after the UI for the application is fully detached,
; though still in the Generic Tree. It operates in the same way as
; MSG_META_DETACH, except the receiving object sends MSG_META_SHUTDOWN_ACK
; when its shutdown is complete, and the object receives
; MSG_META_SHUTDOWN_COMPLETE when it receives the final MSG_META_SHUTDOWN_ACK
; it was expecting.
;
; Context:	Sent by GenProcessClass after detaching the UI before exiting
;		the app, regardless of the mode in which the application
;		was invoked (if the UI was never attached, it obviously doesn't
;		get detached either...).
; Source:	GenProcessClass; forwarded by GenApplicationClass and others
; Destination:  Any object that needs to be notified when the application
;		is about to exit.
; Interception: Usually intercepted by any object on the MGCNLT_APP_STARTUP
;		list.
;
; Pass:
;		cx - word of data for caller's use
;		dx:bp - optr to which MSG_META_SHUTDOWN_ACK should be sent
; Return:
;		nothing
;		ax, cx, dx, bp - destroyed
;

MSG_META_SHUTDOWN_COMPLETE		message
;
; MSG_META_SHUTDOWN_COMPLETE is sent to the object having called ObjInitDetach
; with ax = MSG_META_APP_SHUTDOWN, when as many MSG_META_SHUTDOWN_ACK's have
; been received as ObjIncDetaches were called, & ObjEnableDetach was called.
; The MetaClass handler for this message sends MSG_META_SHUTDOWN_ACK to the OD
; passed to the ObjInitDetach call.
;
; Note that this message is received only if ObjInitDetach has been called
; for this object. Note also that your superclass may call ObjInitDetach
; without your knowing.
;
; Context:	Core message of the Geode Startup/Shutdown mechanism
; Source:	MetaClass handler for MSG_META_SHUTDOWN_ACK, if detach count
;		has dropped to zero (i.e. no outstanding requests), for objects
;		that are shutdown nodes only (make use of ObjInitDetach/
;		ObjEnableDetach).
; Destination:	self
; Interception:	A handy message to intercept if you are using the ObjInitDetach
;		mechanism & need to know when all objects you notified
;		have responded.  Calling the superclass at this point in
;		time will cause a SHUTDOWN_ACK to go back to whatever object
;		sent the MSG_META_APP_SHUTDOWN to this object originally.
;		There is no requirement to call the superclass at this time, &
;		in fact this is a way to prolong the shutdown cycle for this
;		object -- by simply staring up another ObjInitDetach sequence,
;		for instance.
; Pass: 	nothing
; Return: 	nothing
;		ax, cx, dx, bp - destroyed

MSG_META_SHUTDOWN_ACK			message
;
; MSG_META_SHUTDOWN_ACK is what an object gets back in response to a
; MSG_META_APP_SHUTDOWN notifying it that the object has fulfilled the request.
;
; Context:	Core message of the Geode Startup/Shutdown mechanism
; Source:	Object having received MSG_META_APP_SHUTDOWN (Default handler in
;		MetaClass will reflexively respond to any MSG_META_APP_SHUTDOWN
;		with a MSG_META_SHUTDOWN_ACK, though you can change this
;		behavior either by using ObjInitDetach et all, or by not letting
;		the message get to the MetaClass handler, & responding yourself
;		w/MSG_META_SHUTDOWN_ACK sometime later)
; Destination:	optr passed in MSG_META_APP_SHUTDOWN
; Interception:	MetaClass provides default handling of this message, for objects
;		using the ObjInitDetach mechanism.  Objects NOT using this
;		mechanism will want to intercept this if there is a need to
;		know when the object asked to shutdown earlier has completed its
;		shutdown.
; Pass: 	cx - data passed with MSG_META_APP_SHUTDOWN
;		dx:bp	- object which has completed shutting down
; Return: 	nothing
;		ax, cx, dx, bp - destroyed
;
; Writing MSG_META_SHUTDOWN_ACK:
;
; MSG_META_SHUTDOWN_ACK can normally be inheritied from MetaClass which calls
; ObjAckDetach, which decrements the detach count, & when it reaches 0,
; sends a MSG_META_SHUTDOWN_COMPLETED to the object itself.
; (NOTE:   If you are expecting a MSG_META_SHUTDOWN_ACK back from anything,
; make sure you are using the mechanism initiated with ObjInitDetach yourself,
; or you should handle MSG_META_SHUTDOWN_ACK yourself to prevent MetaClass from
; assuming you ARE using such a mechanism.)
;

MSG_META_GET_CLASS		message
;
; Returns class of object
;
; Context:	Object system utility message
; Source:	Unrestricted
; Destination:	Any object
; Interception:	Unecessary, as MetaClass does the right thing.
; Pass:		nothing
; Return: 	cx:dx	- class of object
;		ax, bp 	- destroyed
;

MSG_META_IS_OBJECT_IN_CLASS	message
;
; Determines if object belongs to a certain class or not (either IS
; that class, or is a subclass of that class) If a variant class is
; encountered, the object will NOT be grown out past that class
; in the search (If you want to do a complete search past
; variant classes, send a MSG_META_DUMMY first.
;
; Context:	Object system utility message
; Source:	Unrestricted
; Destination:	Any object
; Interception:	Unecessary, as MetaClass does the right thing.
; Pass:		cx:dx	- class to see if object is member of
; Return: 	carry	- set if object is a member of the class
;		ax, cx, dx, bp - destroyed
;

;------------------------------------------
;		Utility methods
;-----------------------------------------

MSG_META_BLOCK_FREE		message
;
; This message causes the object block containing the obejct to be freed after
; the block's "in use" count reaches zero and after the appropriate queues are
; flushed.  This is a fairly low-level operation, and should be performed only
; after the objects in the block have been removed from any tree(s) they are
; attached to, & are otherwise "shut down".  For generic objects, this 
; generally means first calling MSG_GEN_SET_NOT_USABLE, then
; MSG_GEN_REMOVE_CHILD, before using this message.  For Visible objects,
; MSG_VIS_REMOVE will both visually shut down the visible tree, & then
; remove it from its parent.
;
; Context:	Object death mechanism
; Source:	Unrestricted
; Destination:	Any object within a block that is ready to have a low-level
;		nuke performed on it. (i.e. isn't on screen, isn't linked to
;		objects in other blocks, etc.)
; Interception:	Unecessary, as MetaClass does the right thing.
; Pass: 	nothing
; Return:	nothing
;		ax, cx, dx, bp - destroyed

MSG_META_OBJ_FREE			message
;
; MSG_META_OBJ_FREE causes an object to be freed (via LMemFree) after
; clearing out the queues of the process that owns the block and the thread
; the executes the block.  This is a fairly low-level operation, and should
; be performed only after the object has been removed from any trees it
; belongs to, & is otherwise "shut down".  Consider first MSG_GEN_DESTROY for
; generic objects/branches, MSG_VIS_DESTROY for visible ones.
;
; Context:	Object death mechanism
; Source:	Unrestricted
; Destination:	Any object that is ready to have a low-level
;		nuke performed on it. (i.e. isn't on screen, isn't linked to
;		other objects, etc.)
; Interception:	Unecessary, as MetaClass does the right thing.
; Pass: 	nothing
; Return:	nothing
;		ax, cx, dx, bp - destroyed


MSG_META_FINAL_OBJ_FREE		message
;
; Frees object chunk, or, if object is in a resource, marks it dirty & resizes
; to 0.  Last thing done by MSG_META_OBJ_FREE.
;
; Context:	Object death mechanism
; Source:	Kernel ONLY (If you want to kill an object, send it 
;		MSG_META_OBJ_FREE.  It will flush the input queues associated
;		with the object, & then deliver this message to it to do
;		the final freeing)
; Destination:	Any LMem-based object (i.e. anything but a Process).
; Interception:	May be intercepted by any object class that holds instance data
;		of associated chunks, blocks, etc. which should be freed up
;		along with the object being freed. This is the very, very last
;		message any object will receive in life, as the default handler
;		frees the chunk.  The intercepting message should free 
;		(using a low-level free operation) any associated data
;		structures not covered by the superclass handler.  (For example
;		GenClass frees the moniker stored in GI_visMoniker)
;		WARNING #1: Be careful to NOT actually free anything marked by
;		the LMem block as coming from a resource, as this will cause
;		death on re-attach.  The best you can do is to resize the
;		chunk to size zero.
;		WARNING #2: Intercepting methods are NOT allowed to perform
;		any operation that results in events destined for the object
;		to be placed on any queue -- death will result when the message
;		is unable to be delivered to the non-existent object at 
;		a later point (a bug that's very hard to track down).  Be
;		aware that high-level UI & system messages are allowed to
;		operate in this manner & so should not be used on this object.
;		Basically, messages nor routines should not be used on the
;		object itself, unless it can be determined that they do not,
;		and can not, exhibit this behavior.
; Pass:		nothing
; Return:	nothing
;		ax, cx, dx, bp - destroyed
;

MSG_META_DEC_BLOCK_REF_COUNT				message
;
; General-purpose message to call MemDecRefCount on one or two memory
; handles.
; 
; This is particularly useful for IACP, where one initializes the reference
; count of a block to the number of servers returned by IACPConnect, and records
; this as the completion message to be sent back to oneself. When all the
; servers have processed the message, the reference count on the handle(s)
; will go to zero and they will be freed.
;
; Context:	Utility message
; Source:	Anyone
; Destination:	Anything
; Interception:	Not much point, really.
; Pass:		cx	= first handle whose reference count should be
;			  decremented, or 0 if none
;		dx	= second handle whose reference count should be
;			  decremented, or 0 if none
; Return:	nothing
; 		ax, cx, dx, bp - destroyed
;


;------------------------------------------------------------------------------
;		Object management methods
;------------------------------------------------------------------------------

MSG_META_RESOLVE_VARIANT_SUPERCLASS			message
;
; Inform the system what class to use as the superclass for a variant
; class for a particular object.
;
; Context:	The system sends this message to the object when it first
;		attempts to deliver a message to the superclass of a variant
;		class. The object must examine itself and determine what
;		its superclass for that master level should be.
; Source:	object system
; Destination:	any object with a variant class in its class hierarchy
; Interception:	Because variant master classes tend to be strictly
;		administrative in nature, providing useful and very
;		generic functionality to their subclasses, all immediate
;		children of a variant master class will need to intercept
;		this message and return the appropriate class pointer.
; Pass:		cx - master offset of the level being resolved. If you
;		     know there's a variant class above your own, you will
;		     need to examine this to determine if it is your master
;		     level whose variant is being resolved, or the one
;		     above you.
; Return:	cx:dx - superclass to use.
;		ax, bp - destroyed
; 

MSG_META_RELOCATE			message
;
; *** THIS METHOD MAY NOT CALL LMemAlloc/LMemReAlloc/LMemFree
; Sent to relocate object if the class's HAS_RELOC flag is set.
;
; Source:	Kernel, when loading in object block, generally resources, or
;		object blocks stored in VM file format. This is called
;		before the class's relocation tables are processed (see
;		Interception, below).
; Destination:	Individual object needing control over how it gets relocated.
; Interception:	Intercepted by any class needing to perform special relocations
;		on its instance data or prevent its superclass's relocations
;		from being performed.   Interceptor must call
;		ObjRelocOrUnRelocSuper to have the relocations in its own
;		class table, along with those of the superclass, performed.
; Pass:		*ds:si - instance
;		dx - VMRelocType
;			VMRT_UNRELOCATE_BEFORE_WRITE
;			VMRT_RELOCATE_AFTER_READ
;			VMRT_RELOCATE_AFTER_WRITE
;			VMRT_RELOCATE_FROM_RESOURCE
;			VMRT_UNRELOCATE_FROM_RESOURCE
;		bp - frame to pass to ObjRelocOrUnRelocSuper
; Return:	carry - set if error
; 		bp - preserved
;		ax, cx, dx, - destroyed
;
; NOTE: The calling of this method is non-standard in that it does
; not pass through the class's method table. Rather, the handler address
; is placed after the method table and a direct call is issued. This
; means a relocation routine should not be bound to MSG_META_RELOCATE but
; should rather be bound to "reloc", which Esp understands to mean the
; handler is for both MSG_META_RELOCATE and MSG_META_UNRELOCATE.
;

MSG_META_UNRELOCATE		message
;
; *** THIS METHOD MAY NOT CALL LMemAlloc/LMemReAlloc/LMemFree
; Sent to unrelocate object if the class's HAS_RELOC flag is set.
;
; Source:	Kernel, when saving out object block, generally resources to
;		state file, or 	object blocks stored in VM file format.  This
;		is called before the class's relocation tables are processed
;		(see Interception, below).
; Destination:	Individual object needing control over how it gets unrelocated.
; Interception:	Intercepted by any class needing to perform special
;		unrelocations on its instance data or prevent its superclass's
;		unrelocations from being performed. Interceptor must call
;		ObjRelocOrUnRelocSuper to have the unrelocations in its own
;		class table, along with those of the superclass, performed.
; Pass:		*ds:si - instance
;		dx - VMRelocType
;		bp - frame to pass to ObjRelocOrUnRelocSuper
; Return:	carry - set if error
;		bp - preserved
;		ax, cx, dx - destroyed
;
; NOTE:	Refer to NOTE for MSG_META_RELOCATE -- all of that applies
; equally here.

;------------------------------------------
;		UI/IM Methods
;------------------------------------------

MSG_META_LEAVE_CONSTRAIN	message

PTR_LEAVE_LEFT		equ	00000001b
PTR_LEAVE_TOP		equ	00000010b
PTR_LEAVE_RIGHT		equ	00000100b
PTR_LEAVE_BOTTOM	equ	00001000b

;-----------------------------------------
;	Other utility methods
;-----------------------------------------

MSG_META_SET_FLAGS		message
;
; Set the object chunk flags for an object.  This works just
; like the ObjSetFlags routine, but can be used when the
; object being affected is being run by a different thread.
;
; Context:	Object system utility message
; Source:	Unrestricted
; Destination:	Any object
; Interception:	Unecessary, as MetaClass does the right thing.
; Pass:		cx - chunk to set flags for
;		dl - bits to SET
;		dh - bits to RESET
; Return:	nothing
; 		ax, cx, dx, bp - destroyed

MSG_META_GET_FLAGS		message
;
; Get the object chunk flags for an object.  This works just
; like the ObjGetFlags routine, but can be used when the
; object being queried is being run by a different thread.
;
; Context:	Object system utility message
; Source:	Unrestricted
; Destination:	Any object
; Interception:	Unecessary, as MetaClass does the right thing.
; Pass:		cx - chunk to get flags for
; Return:	al - flags
;		ah - 0
;		cx, dx, bp - destroyed

MSG_META_VM_FILE_DIRTY		message
;
; This method can be sent to all processes that have a VM file
; open the first time a block in the file is marked dirty after
; the file is opened or updated. For this method to be generated,
; the VM file must have the VMA_NOTIFY_DIRTY attribute bit set.
;
; Context:	VM / Object System liason mechanism
; Source:	Kernel VM code
; Destination:	ProcessClass
; Interception:	May be intercepted at process to do whatever is desired on
;		this occurrence of this event.  Default behavior in
;		GenProcessClass sends notification to the current model
;		GenDocumentGroupClass object.
; Pass:		cx - file handle open to the VM file, from the receiving
;		     process's perspective.
; Return:	nothing
;		ax, cx, dx, bp - destroyed
;

MSG_META_QUIT		message
;
; MSG_META_QUIT, sent to a GenApplication object, will initiate a shutdown 
; sequence for the application which the process & all objects on the UI's
; active lists are given a chance to put up dialogs, continue or terminate
; the quit.
;
; GenApplication does some error checking for multiple quit's or detach's,
; & then starts this sequence by passing MSG_META_QUIT(QL_BEFORE_UI) to the
; process.  The default process handler for MSG_META_QUIT varies depending
; on the QuitLevel, which is passed in dx, but only when sent to the process.
; The method handler for each level of quit should then send MSG_META_QUIT_ACK
; with the same QuitLevel when it is done.  The default behavior for a
; processes MSG_META_QUIT responses are:
;
;	QL_BEFORE_UI	-> Sends MSG_META_QUIT_ACK to self via queue
;	QL_UI		-> Sends MSG_GEN_APPLICATION_INITIATE_UI_QUIT(0) to the
;			   				GenApplication
;	QL_AFTER_UI	-> Sends MSG_META_QUIT_ACK to self via queue
;	QL_DETACH	-> Sends MSG_META_DETACH to self via queue
;	QL_AFTER_DETACH	-> Sends MSG_META_QUIT_ACK to self via queue
;
; The process's MSG_META_QUIT_ACK handler is what causes this walking down the
; QuitList;  It provides the following behavior for each QuitLevel:
;
;	QL_BEFORE_UI	-> Sends MSG_META_QUIT(QL_UI) to self
;	QL_UI		-> Sends MSG_META_QUIT(QL_AFTER_UI) to self
;	QL_AFTER_UI	-> Sends MSG_META_QUIT(QL_DETACH) to self
;	OL_DETACH	-> Sends MSG_META_QUIT(QL_AFTER_DETACH) to self
;	QL_AFTER_DETACH	-> Sends MSG_GEN_PROCESS_FINISH_DETACH to self.
;
;
; MSG_GEN_APPLICATION_INITIATE_UI_QUIT(0) send to the GenApplication, as listed above,
; is the point where the generic UI objects are asked to quit.
; When sent to a GenApplication (active list), it will cause MSG_QUITs
; to be sent to all objects on the active list that are marked as desiring 
; them. These objects on the active list can handle the MSG_META_QUIT any way
; they please, as long as they send a MSG_GEN_ACTIVE_LIST_QUIT to the first
; parental GenActiveList (MSG_GEN_GUP_CALL_OBJECT_OF_CLASS with a
; MSG_GEN_ACTIVE_LIST_QUIT classed event to their generic parent) with the
; abort flag set as detailed below in MSG_META_QUIT_ACK.
; (NOTE: If you send the abort flag back as non-zero, the quit will *not* 
; continue, so if you do this, you should notify the user somehow). The process
; will be notified by a MSG_META_QUIT_ACK with the QuitLevel set to QL_UI.
;
; Context:	Application "Quit" mechanim
; Source:	Unrestricted
;
; (if sent to GenApplication to initiate this sequence):
; Destination:	GenApplication
; Pass 		nothing
;
; 
; (if sent to a process):
; Destination:	process
; Pass:	 dx - QuitLevel (if sent to a process)
;		if QuitLevel = QL_AFTER_DETACH
;			SI:CX - Ack OD to be passed on to MSG_META_QUIT_ACK
;			   (Can use CX, since it is illegal to abort here)
;		else (QuitLevel != QL_AFTER_DETACH
;			cx - clear (can just send MSG_META_QUIT_ACK without
;			   clearing)
;
; (if sent to a normal object):
; Destination:	any object on application active list
; Pass: 	^lCX:DX - object to send MSG_META_QUIT_ACK to	
;
; (all cases):
; Return: 	nothing
;		ax, cx, dx, bp - destroyed

MSG_META_QUIT_ACK		message
;
; Sent to a process in response to a MSG_META_QUIT. Process responds by
; incrementing DX and sending MSG_META_QUIT to itself.
;
; Context:	Application "Quit" mechanim
; Source:	Any object having received MSG_META_QUIT
; Destination:	ACK OD passed in MSG_META_QUIT
; Pass:		dx - QuitLevel acknowledging (if a responding to a process)
;		cx - abort flag (non-zero if you want to abort the quit)
;		NOTE for processes subclassing MSG_META_QUIT:
;		  You cannot abort the quit at the QL_DETACH stage or later.
; Return:	nothing
;		ax, cx, dx, bp - destroyed
;

QuitLevel	etype	word
	QL_BEFORE_UI	enum	QuitLevel
		;Quit message sent out before MSG_QUITs are sent to the
		; items on the active list. 
	QL_UI		enum	QuitLevel
		;Default handler for this method sends MSG_META_QUIT to the 
		; application object for the process.
	QL_AFTER_UI	enum	QuitLevel
		;Quit message sent out before MSG_META_DETACH is sent to the 
		; process.
	QL_DETACH	enum	QuitLevel
		;Default handler for this method sends MSG_META_DETACH to the
		; process.

	QL_AFTER_DETACH	enum	QuitLevel
		;Default handler for this method doesn't really do anything.
		; Why is it still around? You'll understand when you're older.


;-------------------------------------------
;	Events
;-------------------------------------------

MSG_META_DISPATCH_EVENT		message
;
; A general method for causing an object to send/call a method of another
; object.  Useful for getting an object run by a different thread to call
; yet another object, or send a reply to the first object.
; No warrantee is expressed nor implied with this mechanism --
; it is strictly up to the caller to make sure that the detination object
; exists, that the MessageFlags passed are reasonable and do not result
; in deadlock situations, etc.
;
; Context:	Object system utility message
; Source:	Unrestricted
; Destination:	Any object
; Interception:	Unecessary, as MetaClass does the right thing.
; Pass:		^hcx - Event
;		dx - MessageFlags to pass to ObjDispatchMessage
; Return:	If MF_CALL specified:
;			carry, ax, cx, dx, bp - return values
;		Otherwise:
;			ax, cx, dx, bp - destroyed
;		(event freed)



;-------------------------------------------
;	ClassedEvents
;-------------------------------------------

ClassedEvent	type hptr
;
; A ClassedEvent is actually a handle to a recorded message which has
; the unique characteristic of having the Class of the message stored
; with it, in the field which normally holds the destination optr.
; To create a ClassedEvent, you need to call ObjMessage, passing the
; message & data you'd like to deliver, with the following exceptions:
;
;	* Pass MessageFlags with the MF_RECORD bit set
;
;	* In place of the usual destination optr in bx:si, pass the 
;	  Class of the object that is required to handle the
;	  message being passed.  For instance, if the message is
;	  MSG_VIS_TEXT_SET_POINT_SIZE, then bx:si should be VisTextClass
;
; Now, why might you want to create one of these?  Well, because it is an
; easy way to package up any message into a single word, so to speak, for
; passing around between objects, in particular using one of the following
; messages, which operate on ClassedEvents:
;
; 	MSG_META_GCN_LIST_SEND
; 	MSG_META_SEND_CLASSED_EVENT
; 	MSG_VIS_VUP_CALL_OBJECT_OF_CLASS
; 	MSG_VIS_VUP_SEND_TO_OBJECT_OF_CLASS
; 	MSG_VIS_VUP_CALL_WIN_GROUP
; 	MSG_VIS_VUP_SEND_TO_WIN_GROUP
; 	MSG_VIS_CALL_PARENT
; 	MSG_VIS_SEND_TO_PARENT
; 	MSG_GEN_CALL_PARENT
; 	MSG_GEN_SEND_TO_PARENT
; 	MSG_GEN_SEND_TO_CHILDREN
; 	MSG_GEN_GUP_CALL_OBJECT_OF_CLASS
; 	MSG_GEN_GUP_SEND_TO_OBJECT_OF_CLASS
; 	MSG_GEN_CALL_APPLICATION
; 	MSG_GEN_CALL_SYSTEM
; 	MSG_GEN_OUTPUT_ACTION
; 	MSG_GEN_PROCESS_SEND_TO_APP_GCN_LIST
;
; If you're passing a ClassedEvent around yourself, & finally decided to
; deliver it to an object, the easiest way to do so is to use 
; MSG_META_SEND_CLASSED_EVENT.
;
;Sample Code/Programming Tips
;----------------------------
; The following example routine will create a ClassedEvent which holds the
; message for requesting a text object to change the current selection to
; be 18 points in size:
;
; GetTextSet18PointSizeClassedEvent	proc	near
;	sub	sp, size VisTextSetPointSizeParams
;	mov	bp, sp
;	mov	ss:[bp].VTSPSP_range.VTR_start, VIS_TEXT_CHANGE_SELECTION
;	mov	ss:[bp].VTSPSP_range.VTR_end, 0
;	mov	ss:[bp].VTSPSP_pointSize.WBF_int, 18
;	mov	ss:[bp].VTSPSP_pointSize.WBF_frac, 0
;	mov	ax, MSG_VIS_TEXT_SET_POINT_SIZE
;	mov	dx, size VisTextSetPointSizeParams
;	mov	bx, segment VisTextClass
;	mov	si, offset VisTextClass
;	mov	di, mask MF_RECORD or mask MF_STACK or mask MF_FIXUP_DS
;	call	ObjMessage
;	add	sp, size VisTextSetPointSizeParams
;
;	; ^hdi = ClassedEvent
;
;	ret
; GetTextSet18PointSizeClassedEvent	endp
;



MSG_META_SEND_CLASSED_EVENT		message
;
; This message's interesting behavior is actually added by the UserInterface,
; which define new & wonderful TravelOption types.  See the message definition
; in GenClass for exciting details.  The default behavior provided here in
; MetaClass is destroy the event if TO_NULL passed, else to deliver the event
; to itself, i.e the object receiving this message, if it is capable of
; handling it, i.e. it is a member of the class stored with the event.  The
; event is always freed, whether or not deliverable.
;
; Context:	Symbolic messaging mechanism
; Source:	Unrestricted
; Destination:	Any object
; Interception:	Default MetaClass handler deals correctly with just the most
;		primitive of TravelOptions.  Object classes can add
;		new TravelOption types, but must then intercept this message
;		to implement them (calling the superclass if it doesn't
;		recognize the TravelOption passed)
; Pass:		^hcx	- ClassedEvent
;		dx	- TravelOption
; Return:	nothing
;		ax, cx, dx, bp - destroyed
;		(event freed)
;

TravelOption     etype   word, 0
;
; Options provided by MetaClass:
;
TO_NULL		enum TravelOption
; No object to deliver message to, the event should be destroyed.

TO_SELF		enum TravelOption
; No additional UI behavior requested -- allow MetaClass handler to dispatch
; event if possible, else destroy it.

TO_OBJ_BLOCK_OUTPUT	enum TravelOption
; Sends event to Object Block output, if any, otherwise destroys the event.

TO_PROCESS	enum TravelOption
; Sends event to the process owning the UI block.

; Object classes may extend the delivery types by defining new levels starting
; at the same number as their first method number
;
;
;
;Sample Code/Programming Tips
;----------------------------
; Events are stored mysteriously in ways that only the Kernel knows.
; To create a ClassedEvent, you need to call ObjMessage, passing the
; message & data you'd like to deliver, with the following exceptions:
;
;	* Pass MessageFlags with the MF_RECORD bit set
;
;	* In place of the usual destination optr in bx:si, pass the 
;	  Class of the object that is required to handle the
;	  message being passed.  For instance, if the message is
;	  MSG_VIS_TEXT_SET_POINT_SIZE, then bx:si should be VisTextClass
;
; It is very important that the Event is freed up at some point.  The
; responsibility relies on the recipients of this method, which must either
; allow the MetaClass handler to deal with it, or call ObjDispatchMessage to
; dispatch the event, or ObjFreeMessage to destroy it.
;


MSG_META_GET_OPTR	message
;
; A method used to get the optr of an object.  Useful when combined with
; MSG_GEN_GUP_CALL_OBJECT_OF_CLASS to get the optr of an object of a given
; class somewhere up in the Generic tree.
; Note that MSG_GEN_GUP_CALL_OBJECT_OF_CLASS will FatalError if an object of
; the given class doesn't exists.  Use MSG_GEN_GUP_TEST_FOR_OBJECT_OF_CLASS
; before using MSG_GEN_GUP_CALL_OBJECT_OF_CLASS if there is some question as
; to whether an object of a given class exists.
;
; Context:	Object system utility message
; Source:	Unrestricted
; Destination:	Any object
; Interception:	Unecessary, as MetaClass does the right thing.
; Pass:		nothing
; Return:	^lcx:dx - optr of object
;		ax, bp - destroyed
;


MSG_META_GET_TARGET_AT_TARGET_LEVEL	message
;
; Fetch target object. Normally intercepted by UI to look down the target
; hierarchy.  -- MetaClass hander simply returns info about the current
; object, presuming it must be the target, since the method was not
; intercepted & handled differently
;
; Context:	UI library Target mechanism
; Source:	Unrestricted
; Destination:	Any object
; Interception:	Must be handled by target nodes to correctly pass the request
;		on down to the next target below current node in hierarchy.
; Pass:		cx	- 0 for leaf, otherwise TargetLevel, as defined by UI
; Return:	^lcx:dx	- optr of object
;		ax:bp	- class of object
;

;------------------------------------------
;		Object Variable Storage methods
;-----------------------------------------

MSG_META_ADD_VAR_DATA		message
;
; Add variable data type for an object.  Replaces any existing entry.
;
; Context:	Utility message for adding variable data entry
; Source:	Anyone
; Destination:	Any object
; Interception:	Generally not intercepted, default MetaClass handling
;		performs the desired function
; Pass:		dx	- size AddVarDataParams
;		ss:bp	- ptr to AddVarDataParams
;		NOTE: 	AVDP_dataType should have VDF_SAVE_TO_STATE set as
;				       desired.  VDF_EXTRA_DATA is ignored, 
;				       it will be set correctly by this
;				       routine.
; Return:	object marked dirty even if data type already exists
;		ax, cx, dx, bp - destroyed
;
AddVarDataParams	struct
	AVDP_data	fptr
	; Null if no extra data or data should be left initialized to all
	; 0's.  If AVDP_dataSize is non-zero, then may be a pointer to  data
	; to intitialize the data entry with.

	AVDP_dataSize	word
	; Size of data, if any

	AVDP_dataType	word
	; VarData type

AddVarDataParams	ends


MSG_META_DELETE_VAR_DATA		message
;
; Delete variable data type and extra data (if any).
;
; Context:	Utility message for deleting an object's variable data
; Source:	Anyone
; Destination:	Any object
; Interception:	Generally not intercepted, default MetaClass handling
;		performs the desired function
; Pass:		cx - data type to delete
;			VarDataFlags ignored
; Return:	carry clear if data deleted
;		carry set if not found
;		object marked dirty if data type found and deleted
;		ax, cx, dx, bp - destroyed
;

;
; Variable data types for MetaClass -- usable for all objects
;
; The hints for each class start at the same value as the methods for that
; class.
;


MSG_META_INITIALIZE_VAR_DATA		message
;
; Sent to an object having a variable data entry which is code somewhere is
; attempting to access via ObjVarDerefData.  It is the object that defines
; the variable data entry type's responsibility to create the data entry
; and initialize it at this time, and to return a pointer to the extra
; data, as returned by ObjVarAddData.
;
;
; Context:	Part of Object Variable Data storage mechanism.  In
;		particular, for use on variable data types which represent
;		an extension of the instance data for the object.
; Source:	ObjVarDerefData routine.  Should not be used as a replacement
;		for ObjVarAddData, or MSG_ADD_VAR_DATA_ENTRY, but may
;		be used anytime code is ready to access a particular piece
;		of variable data instance data, knows that the variable
;		data has not yet been created, & wishes to ensure that it
;		does exist.
; Destination:	Any object stored in an LMem Object block
; Interception:	Required by any class which defines a variable data entry
;		type that needs to be initialized before usage.  Objects
;		handling this message should first compare cx agains
;		variable data types it understands, and pass any unkown
;		types onto the superclass for handling.
; Pass:		cx - variable data type
; 		dx, bp - as passed to ObjVarDerefData
; Return:	ax - offset to extra data created (or, if no extra data,
;		     the start of data entry + size VarDataEntry). 
;		     Normally, this would just be the offset returned in bx
;		     by the call to ObjVarAddData.
;		cx, dx, bp - destroyed


;-----------------------------------------------------------------------------
;		General purpose notification messages
;-----------------------------------------------------------------------------

;
; Custom change types passed in MSG_META_NOTIFY and MSG_META_NOTIFY_WITH_DATA_BLOCK
;
NotificationType	struct
	NT_manuf	ManufacturerID
	NT_type		word
NotificationType	ends

MSG_META_NOTIFY				message
;
; General notification message.  Meaning depends on Notification type passed.
; Since Notification Type includes a ManufacturerID, this message is nearly
; infinitely expandable.  Each manufacturer is responsible for maintaining
; the enumerated <ManufacturerID>NotificationType for their ManufacturerID
; to avoid collisions between notification types.  One word of notification
; data is allowed, but this should NOT reference a handle which must at some
; point be destroyed.  See MSG_META_NOTIFY_WITH_DATA_BLOCK for such requirements.
;
; Context:	All purpose MetaClass expansion message.  Frequently used
;		in conjunction with GCN mechanism
; Source:	Anyone
; Destination:	Any object, or any of the GCNListSend routines
; Interception:	No general requirements, though particular NotificationTypes
;		may place restrictions or requirements on such handling
; Pass:		cx:dx - NotificationType
;			cx - NT_manuf
;			dx - NT_type
;		bp - change specific data
; Return:	nothing
;		ax, cx, dx, bp - destroyed
;

MSG_META_NOTIFY_WITH_DATA_BLOCK		message
;
; Like MSG_META_NOTIFY, but allows passing a block of data.  The data block must
; be set up to use the Block "reference count" mechanism, i.e. be sharable
; & initialized with MemInitRefCount.  Details on the count are noted below.
;
; IMPORTANT! this message must eventually reach the default MetaClass handler,
; so that the block can be freed when no longer referenced.
;
; Context:	All purpose MetaClass expansion message.  Frequently used
;		in conjunction with GCN mechanism
; Source:	Anyone
; Destination:	Any object, or any of the GCNListSend routines
; Interception:	Message MUST eventually arrive at the MetaClass handler,
;		with the handle to the data block w/reference count intact,
;		in order for the block to be freed when no longer referenced.
;		Failure to do so will result in garbage being left on the
;		heap, which will kill the system with repetitive occurences.
;		
; Pass:		cx:dx - NotificationType
;			cx - NT_manuf
;			dx - NT_type
;		^hbp - SHARABLE data block having a "reference count" 
;		       initialized via MemInitRefCount.
;		NOTE on data block reference counts:
; 		The reference count should hold the total number of references
; 		ox this data block -- should be incremented before sending a
; 		message holding a reference to this block
;		(using MemIncRefCount).  Any messages passing such reference
;		must have a MetaClass handler which decrements this count and
;		frees the block if it is reaches zero, -OR- must call
;		MemDecRefCount (which does exactly that) GCNListSend &
;		relatives adds in the # of optrs in any list to which a
;		message referring to this block is sent -- thus, when creating
;		a block which will only be sent using GCNListSend, this count
;		should be initialized to zero.  If the block is to be sent to
;		one or more objects or GCNListSend calls, the calling routine
;		should call MemIncRefCount before making the calls, being
; 		sure to call MemIncRefCount additionally for any objects that
; 		the message is sent to, and then call MemDecRefCount after the
; 		calls, to balance the Inc call at the start.
;
; Return:	nothing
;		ax, cx, dx, bp - destroyed
;

;------------------------------------------------------------------------------
;	General Change Notification system  --
;	Common structures & equates (Used by MetaClass & Kernel GCN routines)
;------------------------------------------------------------------------------

;
; List types used with GCN routines & messages
;
GCNListType     struct
	GCNLT_manuf     ManufacturerID
	GCNLT_type      word
GCNListType     ends

;
; Set this flag for the GCN list type when adding an optr to a GCN list to have
; that *list* saved to state on a shutdown
;
GCNListTypeFlags	record
	; high bits hold list type
	:15
	GCNLTF_SAVE_TO_STATE:1
	; set to indicate that list should be saved to state
GCNListTypeFlags	end

;
; Structure of an element in a GCN List
;
GCNListElement	struct
	GCNLE_item	optr
GCNListElement	ends

;
; Structure of a single GCN list (resides in a chunk)
;
GCNListHeader	struct
	GCNLH_meta		ChunkArrayHeader
	GCNLH_statusEvent	hptr
	; Copy of the last notification event sent to this list via
	; GCNListSendStatus.  Will be sent automatically to any
	; object adding itself to the list.   (NOT YET USED)
	GCNLH_statusData	hptr
	; Copy of extra data block, if any, passed in the above status event.
	; This data block must be sharable, & have a reference count.
	GCNLH_statusCount	word
	; Incremented each time status is set for this list.  Used in UI to
	; avoid setting status of NULL between changes in target.  How, might
	; you ask?  If GCNLSF_IGNORE_IF_STATUS_TRANSITIONING is set in a 
	; Send request, GenApplication will only set a NULL status if no status
	; updates have been made after the time it takes to clear the
	; process's queue from when an object loses the target.

GCNListHeader	ends

;
; Structure of an element in the list of GCN Lists
;
GCNListOfListsElement	struct
	GCNLOLE_ID		GCNListType
	GCNLOLE_list		lptr.GCNListHeader
GCNListOfListsElement	ends

;
; Structure of the GCN list of lists (resides in a chunk)
;
GCNListOfListsHeader	struct
	GCNLOL_meta	ChunkArrayHeader
	GCNLOL_data	label	GCNListOfListsElement
	; Start of GCNListOfListsElement's
GCNListOfListsHeader	ends


;------------------------------------------------------------------------------
;	General Change Notification system --
;	MetaClass structures & constants
;------------------------------------------------------------------------------

; Variable data type used for implementing per-object general notification
; system.  Data holds GCN list-of-lists chunk.
;

TempMetaGCNFlags	record
	TMGCNF_RELOCATED:1		; set if relocated
	:7
TempMetaGCNFlags	end

TempMetaGCNData	struct
	TMGCND_listOfLists	lptr.GCNListOfListsHeader
	TMGCND_flags		TempMetaGCNFlags
	; chunk handle holding GCN list of lists
TempMetaGCNData	ends

TEMP_META_GCN 	vardata	TempMetaGCNData
TEMP_META_QUIT_LIST	vardata	lptr.ChunkArrayHeader



GCNListParams	struct
	GCNLP_ID	GCNListType
	; List Identifier, breaks down into:
	; <Manufacturer ID><Manufacturer List Type>

	GCNLP_optr	optr
	; optr of Object to be added/removed from list

GCNListParams	ends

MSG_META_GCN_LIST_ADD		message
;
; Equivalent of GCNListAdd.   Adds an element to the general change
; notification list.   
;
; Context:	Object system utility message
; Source:	Unrestricted
; Destination:	Object providing GCN services
; Interception:	Unecessary, as MetaClass does the right thing.
; Pass:		dx	- size GCNListParams
;		ss:bp	- ptr to GCNListParams
; Return:	carry	- set if optr added
;			- clear if optr is already there and not added
;		ax, cx, dx, bp - destroyed


MSG_META_GCN_LIST_REMOVE	message
;
; Equivalent of GCNListRemove.    Removes an object from the general change
; notification list, if there.
;
; Context:	Object system utility message
; Source:	Unrestricted
; Destination:	Object providing GCN services
; Interception:	Unecessary, as MetaClass does the right thing.
; Pass:		dx	- size GCNListParams
;		ss:bp	- ptr to GCNListParams
; Return:	carry	- set if optr found & removed
;			- clear if not found
;		ax, cx, dx, bp - destroyed


GCNListSendFlags	record
	GCNLSF_SET_STATUS:1
	; Additionally saves the message as the list's current "status".
	; The "status" message is automatically sent to any object
	; adding itself to the list at a later point in time.
	;
	GCNLSF_IGNORE_IF_STATUS_TRANSITIONING:1
	; Optimization bit used to avoid lull in status when transitioning
	; between two different sources -- such as when the source is the
	; current target object, and one has just lost, & another may soon
	; gain, the exclusive.  (The bit should be set only when sending
	; the "null"/"lost"/"not selected" status, as this is the event that
	; should be tossed if another non-null status comes along shortly)
	; Implementation is NOT provided by the kernel primitive routines,
	; which ignore this bit, but may be provided by objects managing
	; their own GCN lists.  GenApplication responds to this bit by
	; delaying the request until after the UI & app queues have been
	; cleared, & then only sets the status as indicated if no other
	; status has been set since the first request.  Other objects
	; may use their own logic to implement this optimization as is 
	; appropriate.  Mechanisms which can not tolerate the delayed status
	; setting nature of this optimization, or require that all changes
	; are registered, should not pass this bit set.

	GCNLSF_FORCE_QUEUE:1
	; Place the message on the event queue for the destination, even
	; if the destination is run by the same thread as that sending the
	; message.

	:13

GCNListSendFlags	end


GCNListMessageParams	struct
	GCNLMP_ID	GCNListType
	; List Identifier, breaks down into:
	; <Manufacturer ID><Manufacturer List Type>

	GCNLMP_block	hptr.GCNDataBlockHeader
	; Handle of extra data block, if used, else 0.  Blocks of this
	; type must have a reference count, which may be initialized
	; w/MemInitRefCount, & incremented for any new usage with
	; w/MemIncRefCount.  Methods in which they are passed are considered
	; such a new usage, & must have MetaClass handlers which
	; call MemDecRefCount.  Current messages supported:
	;
	; MSG_META_NOTIFY_WITH_DATA_BLOCK
	; MSG_NOTIFY_FILE_CHANGE

	GCNLMP_event	hptr		; to ClassedEvent
	; Classed event to send to the list

	GCNLMP_flags	GCNListSendFlags
	; Flags to pass on to GCNListSend or primtive thereof

GCNListMessageParams	ends

MSG_META_GCN_LIST_SEND		message
;
; Equivalent of GCNListSend.   Sends a message to each element of a general
; change notification list.
;
;	NOTE:  If Block w/reference count is passed in, its in-use
;	       count should be incremented by one before the call
;	       to this routine, as this routine decrements the count
;	       by one upon completion (and destroys the block if
;	       count reaches zero)
;
; Context:	Object system utility message
; Source:	Unrestricted
; Destination:	Object providing GCN services
; Interception:	Unecessary, as MetaClass does the right thing.
; Pass:		dx	- size GCNListMessageParams
;		ss:bp	- ptr to GCNListMessageParams
;
; Return:	nothing
;		ax, cx, dx, bp - destroyed
;		(event freed, block ref count decremented)


MSG_META_GCN_LIST_DESTROY		message
;
; Completely destroys GCN system for object;  Frees all GCN lists, cached
; events, & overhead data storage associated with GCN system, in addition to
; the TEMP_META_GCN variable data storage element.  Should be called from
; MSG_META_FINAL_OBJ_FREE interception handler for any object which uses
; GCN lists, to make sure that stray chunks are left around after the object's
; death.
;
; Context:	Object system utility message
; Source:	Object providing GCN services
; Destination:	self
; Interception:	Unecessary, as MetaClass does the right thing.
; Pass:		nothing
; Return:	nothing
;		ax, cx, dx, bp - destroyed


;------------------------------------------------------------------------------
;		Options-related messages
;------------------------------------------------------------------------------

MSG_META_SAVE_OPTIONS			message
;
; Save options to the .ini file for an object.  This message is sent out
; by the UI via the active list mechanism.
;
; Context:	User preference/options support mechanism
; Source:	Unrestricted
; Destination:	GenApplication object, which in turn broadcasts to everything
;		on list of objects having options needing to be saved
; Interception:	Objects having options to save should intercept this & do so.
;		Superclass should be called in case any of the superclasses
;		needs similiar notification
; Pass: 	none
; Return: 	none
;		ax, cx, dx, bp - destroyed


INI_CATEGORY_BUFFER_SIZE =	64	;Max size of a .ini category for
					;MSG_META_GET_INI_CATEGORY

MSG_META_GET_INI_CATEGORY	message
;
; Get the geos.ini file category
;
; Context:	User preference/options support mechanism
; Source:	Unrestricted, though generally self
; Destination:	Object having options
; Interception:	Default handler walks up tree, eventually finding name of
;		application.  Can be intercepted at any level to change the
;		category for a branch.
; Pass:		cx:dx - buffer for .ini category
; Return:	cx:dx - filled (NULL string for none)
;		carry - set if filled
;		ax, bp - destroyed


;-----------------------------------------------------------------------------
;		Messages for suspend/unsuspend
;-----------------------------------------------------------------------------
;
; MSG_META_SUSPEND and MSG_META_UNSUSPEND work togather to allow objects to
; optimize recalculation when doing a series of actions.  These messages are
; implemented by various objects in the system (such as the text object and
; the grob body).  This mechanism is used by GenControlClass to optimize
; recalculation stemming from multiple controller outputs.
;
; An object typically implements these messages by keeping a suspend count and
; a record of the calculations that were aborted because the object was
; suspended.  When the suspend count reaches zero, the object will perform
; the calculations.
;
; An object implementing this mechanism should always call its superclass
; since mutliple class levels could be implementing this mechanism.

MSG_META_SUSPEND				message
;
; Suspend calculation in an object.
;
; Context: 	Part of the SUSPEND/UNSUSPEND mechanism described above.
; Source: 	Normally sent by a controller object but can be sent by
;		anything.
; Destination: 	Any object that implements the SUSPEND/UNSUSPEND mechanism.
; Interception: An object that wants to implement the SUSPEND/UNSUSPEND
;		mechanism should implement this as described above.
; Pass:		nothing
; Return: 	nothing
;		ax, cx, dx, bp - destroyed
;

MSG_META_UNSUSPEND				message
;
; Unsuspend calculation in an object.
;
; Context:	Part of the SUSPEND/UNSUSPEND mechanism described above.
; Source: 	Normally sent by a controller object but can be sent by
;		anything.
; Destination: 	Any object that implements the SUSPEND/UNSUSPEND mechanism.
; Interception: An object that wants to implement the SUSPEND/UNSUSPEND
;		mechanism should implement this as described above.
; Pass: 	nothing
; Return: 	nothing
;		ax, cx, dx, bp - destroyed
;

MSG_META_LOAD_OPTIONS	message
;
; Load the settings/options for this object from the .INI file
;
; Context:	Part of the LOAD/SAVE options mechanism.	
; Source:	Sent to all objects on the active list during ATTACH.
;		Can also be sent to objects directly by the application.
; Destination:  Any object
; Interception: Any object that wants to load its options should intercept this.
;		Behavior is currently implemented for the Gen class objects.
; Pass:		nothing 
; Return:	nothing 
;		ax, cx, dx, bp - destroyed



MSG_META_GET_VAR_DATA		message
;
; Fetch variable data of a given type from an object.
;
; Context:	Utility message for fetching variable data entry
; Source:	Anyone
; Destination:	Any object
; Interception:	Generally not intercepted, default MetaClass handling
;		performs the desired function
;
; Pass:		dx	- size GetVarDataParams
;		ss:bp	- ptr to GetVarDataParams
; Return:	Buffer referred to in GetVarDataParams filled with data
;		ax	- # of bytes copied into buffer
;			  (or -1 if VarData entry was not found)
;		ax, cx, dx, bp - destroyed
;
GetVarDataParams	struct
	GVDP_buffer	fptr
	; Pointer to buffer to fill with data from VarData entry.
	; Must be passed unless GVDP_bufferSize is 0.

	GVDP_bufferSize	word
	; Size of above buffer (to allow us to prevent overflow).  Must be
	; set to zero if no buffer passed.

	GVDP_dataType	word
	; VarData type whose data should be returned

GetVarDataParams	ends


MSG_META_NOTIFY_OBJ_BLOCK_INTERACTIBLE	message
MSG_META_NOTIFY_OBJ_BLOCK_NOT_INTERACTIBLE	message
;
; Context:	PC/GEOS Object System 
; Source:	Kernel
; Destination:	Object which is set as the output of an Object Block resource
;		ether by ObjBlockSetOutput, or by being pre-defined in an
;		application resource.
; Interception: May be intercepted to learn about change in object block
;		interactible status.
;		No default handling is provided, though you may wish to
;		pass the message onto the superclass in case it is
;		interested in this data as well.
; Pass:		cx	- handle of object block
; Return:	nothing
;		ax, cx, dx, bp - destroyed


MSG_META_OBJ_FLUSH_INPUT_QUEUE		message
;
; Queue-flushing mechanism used in Window, Object, & Object Block death 
; mechanisms.  Flushes the complete input chain, then dispatches the passed
; event. 
;
; NOTE:  This is a queue flushing mechanism.  Objects that implement "hold up
;	 input" queues MUST redirect this message through that queue, so that
;	 it is flushed as well.
;
; Context:	Object/Window System death mechanism
; Source:	Kernel (WinClose/WinSetInfo/ObjFreeObjBlock/
;				MSG_META_OBJ_FREE/MSG_META_BLOCK_FREE
; Destination:	May be sent to any object with ObjFlushInputQueueNextStop = 0
;		to start a flush sequence.  The input manager queue is the
;		first thing to be flushed.  The message is then relayed
; 		first to the System InputObj (usually the GenSystemClass
;		object), then to the Geode InputObj (usually a
;		GenApplicationClass object), & finally to the owning process,
;		which dispatches the passed event.
; Interception: Default MetaClass handler implements relay of message from
;		one object to the next, & concludes with dispatches passed
;		event.  MUST be intercepted by any input-flow
;		controlling objects (System object, VisContent) which 
;		implement "hold-up" queues that hold up input-related
;		messages.  The handlers in such cases should pipe this
;		method through the hold up queue as it does with the other
;		messages, & finish up when it comes out by sending this
;		message, with all data intact, to the superclass for 
;		continued default processing.
; Pass:		cx	- Event to dispatch upon conclusion of queue flushing
;		dx	- Block Handle that flushing is being performed for
;			  (Generally the handle of the destination object
;			  in the above Event).  This is the block from
;			  which the "OWNING GEODE", as referenced in the
;			  ObjFlushInputQueueNextStop enumerated type, is
;			  determined.
;		bp	- ObjFlushInputQueueNextStop (Zero should be passed
;			  in call to first object, from there is sequenced
;			  by default MetaClass handler)
; Return:	nothing
;
ObjFlushInputQueueNextStop	etype	word, 0, 2

	OFIQNS_INPUT_MANAGER		enum	ObjFlushInputQueueNextStop
	; FORCE_QUEUE message to the Kernel's Input Manager thread, passing
	; OFIQNS_SYSTEM_INPUT_OBJ.

	OFIQNS_SYSTEM_INPUT_OBJ		enum    ObjFlushInputQueueNextStop
	; FORCE_QUEUE message to the System InputObj (usually the GenSystem
	; object), passing OFIQNS_INPUT_OBJ_OF_OWNING_GEODE.

	OFIQNS_INPUT_OBJ_OF_OWNING_GEODE enum	ObjFlushInputQueueNextStop
	; FORCE_QUEUE message next to the InputObj of the geode owning the block
	; that the object is in, passing OFIQNS_PROCESS_OF_OWNING_GEODE.

	OFIQNS_PROCESS_OF_OWNING_GEODE	enum    ObjFlushInputQueueNextStop
	; FORCE_QUEUE message next to the process of the geode owning the block
	; that the object is in, passing OFIQNS_DISPATCH.

	OFIQNS_DISPATCH			enum    ObjFlushInputQueueNextStop
	; Queues are flushed, so FORCE_QUEUE dispatch passed Event.

MSG_META_WIN_DEC_REF_COUNT		message
;
; INTERNAL Window system mechanism.  Decrements reference count of the
; passed Window.   Windows ensure that they are not referenced before nuking
; themselves by incrementing their ref count, recording this message, destined
; for the object that may reference it, & passes that in
; MSG_META_OBJ_FLUSH_INPUT_QUEUE to cause the input queue for that object ot
; be flushed before the matching decrement to the reference count is made.
;
; Context:	Window system death mechanism
; Source:	Window system
; Destination:	Window's InputObj or ExposureObj, arrived at via
;		MSG_META_OBJ_FLUSH_INPUT_QUEUE
; Interception:	Unecessary, as default MetaClass handler does the right thing.
; Pass:		^hcx	- Window to dec reference count for
; Return:	nothing


;
; Flags for MSG_META_UPDATE_WINDOW.  These are set by the UI.  If
; MSG_META_UPDATE_WINDOW is initially sent by an application (i.e. not
; passing on to superclass), none of these should be set.
;
UpdateWindowFlags	record
	UWF_ATTACHING:1
		; set if MSG_META_UPDATE_WINDOW is being sent because
		; application is attaching
	UWF_DETACHING:1
		; set if MSG_META_UPDATE_WINDOW is being sent because
		; appliation is detaching
	UWF_RESTORING_FROM_STATE:1
		; set if application is restoring from state (will only
		; be set if UWF_ATTACHING is also set, i.e. application is
		; attaching)
	UWF_FROM_WINDOWS_LIST:1
		; set if MSG_META_UPDATE_WINDOW is sent to this object
		; because this object was on the GenApplication's
		; GAGCNLT_WINDOWS GCN list, and not from a subsequent
		; "build-on-demand" request (will only be set if
		; UWF_ATTACHING is also set, i.e. application is attaching)
	:12
UpdateWindowFlags	end

MSG_META_UPDATE_WINDOW			message
;
; Context:	Window update mechanism
; Source:	Sent when GenApplication object becomes usable
; Destination:	Sent to entries on GAGCNLT_WINDOW_LIST GCN list
; Interception:	Not normally intercepted
; Pass:		cx - UpdateWindowFlags
;		dl - VisUpdateMode
; Return:	nothing

MSG_META_FINISH_QUIT		message
;
; Context:	Quit mechanism
; Source:	Sent when quit is aborted or finished
; Destination:	Any object
; Interception:	Can be intercepted to do additional handling for aborted or
;		finished quit.  Default handler just cleans up quitting state.
;		Thus, if this is intercepted, calling superclass is normally
; 		required.
; Pass:		cx - abort flag (non-zero to abort)
; Return:	nothing

MSG_META_SET_OBJ_BLOCK_OUTPUT	message
;
; Context:	Utility message for setting object block output
; Source:	Anyone
; Destination:	Any object except a process object
; Interception:	Not normally intercepted
; Pass:		^lcx:dx - object to send output to
; Return:	nothing

MSG_META_GET_HELP_FILE					message
;
; Get the name of the help file to use
;
; Context:	Help object mechanismm
; Source:	Unrestricted, though generally self
; Destination:	Object tree having help
; Interception:	Default handler walks up tree, eventually finding name of
;		application.  Can be intercepted at any level to change the
;		help file for a branch.
; Pass:		cx:dx - buffer for help file name (FILE_LONGNAME_BUFFER_SIZE)
; Return:	cx:dx - filled (NULL string for none)
;		carry - set if filled
;		ax - destroyed
;

MSG_META_GET_HELP_TYPE					message
;
; Get the type of the help to use
;
; Context:	Help object mechanism
; Source:	Unrestricted, though generally self
; Destination:	Object tree having help
; Interception:	Default handler walks up tree. Can be intercepted at any
;		level to change the help type for a branch.
; Pass:		none
; Return:	carry - set if HelpType found
;		dl - HelpType (if found)
;		ax - destroyed
;

MSG_META_GET_OBJ_BLOCK_OUTPUT	message
;
; Context:	Utility message for getting object block output
; Source:	Anyone
; Destination:	Any object except a process object
; Interception:	Not normally intercepted
; Pass:		nothing
; Return:	^lcx:dx - block output

MSG_META_RESET_OPTIONS	message
;
; Reset the options to the initial state
;
; Context:	Part of the LOAD/SAVE options mechanism.	
; Source:	Sent to all objects on the self-load-options and
;		startup-load-iotions lists on "Rset Options"
;		Can also be sent to objects directly by the application.
; Destination:  Any object
; Interception: Any object that wants to reset its options should
;		intercept this.
;		Behavior is currently implemented for the Gen class objects.
; Pass:		nothing 
; Return:	nothing 
;		ax, cx, dx, bp - destroyed

MSG_META_BRING_UP_HELP					message
;
; Find a help context for the current object tree and send a notification
; to bring up help.
;
; Context:	Help object mechanism
; Source:	Unrestricted, though generally self
; Destination:	Object tree having help
; Interception:	Default handler walks up *vis* tree, eventually finding
;		a Gen class object with ATTR_GEN_HELP_CONTEXT.
;		Can be intercepted at any level to change the help context
;		for a branch.
; Pass:		none
; Return:	none
;		ax - destroyed
;


MSG_META_SET_HELP_FILE					message
;
; Set the name of the help file to use
;
; Context:	Help object mechanismm
; Source:	Unrestricted, though generally self
; Destination:	Object tree having help
; Interception:	Not normally intercepted
;		help file for a branch.
; Pass:		cx:dx - fptr to help file name (FILE_LONGNAME_BUFFER_SIZE)
; Return:	nothing
;

MSG_META_GCN_LIST_FIND_ITEM				message
;
; Look to see if an item is on a particular list
;
; Context:	Object system utility message
; Source:	Unrestricted
; Destination:	Object providing GCN services
; Interception:	Unecessary, as MetaClass does the right thing.
; Pass:		dx	- size GCNListParams
;		ss:bp	- ptr to GCNListParams
; Return:	carry	- set if item found
;			- clear if item not found.
;		ax, cx, dx, bp - destroyed

MSG_META_TRANSPARENT_DETACH				message
; Passed to applications on the system's TRANSPARENT_DETACH GCN list if
; they must detach.
;
; Context:	Transparent launch model implementation
; Source:	Internally only.  Applications should not send this.
; Destination:	GenApplicationClass (or other object on TRANSPARENT_DETACH list)
; Interception:	Not generally intercepted.
;
; Pass:		nothing
; Return:	nothing
;		ax, cx, dx, bp - destroyed


MSG_META_REMOVING_DISK				message
; Passed to applications or document controls in the system`s REMOVABLE_DRIVE 
; GCN list if their disk is being removed and they must shut themselves down.
; 
; Context:	Temporary drive model (i.e. PCMCIA) implementation
; Source:	Internally only.  Applications should not send this.
; Destination:	GenApplicationClass or GenDocumentControlClass
; Interception:	Not generally intercepted.
;
; Pass:		cx -- handle of disk being removed.
; Return:	nothing
;		ax, cx, dx, bp - destroyed
; 

MSG_META_VM_FILE_SET_INITIAL_DIRTY_LIMIT	message
;
; This message is sent to a process whenever it opens a VM file.  By
; default it calls VMSetDirtyLimit with a limit of 0, causing system
; defaults to be used.  The primary purpose of the method is to
; provide apps with input into the matter through sub-classing - just
; move the file handle from cx to bx, load your desired dirty limit
; into cx, and call VMSetDirtyLimit.  Note, a dirty limit of -1 will
; disable the TempAsync feature.
;
; Source:	Kernel VM code
; Destination:  ProcessClass
; Interception: May be intercepted at process to do whatever the app
; 		desires with the dirtly limit of its files.
;
; 		NOTE: If you are using the GenDocumentControl and its
;		subsidiary objects, you should set the dirty limit in your
;		MSG_GEN_DOCUMENT_INITIALIZE_DOCUMENT_FILE method, rather
;		than waiting for this message to arrive. Calling VMSetDirtyLimit
;		after the MSG_GEN_DOCUMENT_NEW (which calls the initialize
;		method) will cause the document to be marked dirty when it's
;		not supposed to be.
;
; Pass:		cx - File Handle
; Return:	nothing
;
;

MSG_META_VM_FILE_AUTO_SAVE	message
;
; This message is sent to a process whenever the VM Temp Async
; mechanism needs to queue up an autosave to terminate the temporary
; asynchronous update mode
;
; Source:	Kernel VM code
; Destination:  ProcessClass
; Interception: probably not
;
; Pass:		cx - file handle of file to autosave
; Return:	nothing
;
;


;----------------------------------------
;	Buffer to allow easy adding of
;	messages to MetaClass. DECREASE
;	IF YOU ADD A NEW MESSAGE.
;----------------------------------------

MetaMessages	= MetaMessages+4

;----------------------------------------
; 	Ranges exported for other uses
;----------------------------------------

	;	Window methods

MetaWindowMessages	export DEFAULT_EXPORTED_MESSAGES

	;	Input-related methods

MetaInputMessages	export DEFAULT_EXPORTED_MESSAGES

	;	UI-related methods (give 200)

MetaUIMessages		export DEFAULT_EXPORTED_MESSAGES*4

	;	Specific-UI related methods

MetaSpecificUIMessages	export DEFAULT_EXPORTED_MESSAGES

	;	Application related methods

MetaApplicationMessages	export DEFAULT_EXPORTED_MESSAGES*3

	;	Methods for Graphic-Object library

MetaGrObjMessages	export DEFAULT_EXPORTED_MESSAGES

	;	Methods for Spool/PrintControl library

MetaPrintMessages	export DEFAULT_EXPORTED_MESSAGES

	;	Methods for Search/Replace/SpellCheck library

MetaSearchSpellMessages	export DEFAULT_EXPORTED_MESSAGES

	;       Methods for Genreal Change Notification mechanism

MetaGCNMessages		export DEFAULT_EXPORTED_MESSAGES

	;       Methods for Text Object Library

MetaTextMessages		export DEFAULT_EXPORTED_MESSAGES

	;       Methods for Styles Library

MetaStylesMessages	export DEFAULT_EXPORTED_MESSAGES

	;       Methods for Color Library 

MetaColorMessages	export DEFAULT_EXPORTED_MESSAGES

	;	Methods for the Float Library

MetaFloatMessages	export DEFAULT_EXPORTED_MESSAGES

	;	Methods for the Spreadsheet Library

MetaSpreadsheetMessages	export DEFAULT_EXPORTED_MESSAGES

	;	Messages for IACP

MetaIACPMessages	export DEFAULT_EXPORTED_MESSAGES

	;	Messages for system inbox / outbox

MetaMailboxMessages	export DEFAULT_EXPORTED_MESSAGES

;------------------------------------------
;		Detach
;-----------------------------------------

global ObjInitDetach:far
global ObjIncDetach:far
global ObjEnableDetach:far
ObjAckDetach equ <ObjEnableDetach>

;
; Data is stored in the variable data storage area of the object that called
; ObjInitDetach. This holds the data passed to MSG_META_DETACH for when the
; detach is finally complete.
;
DetachDataEntry	struct
    DDE_ackCount	word
    DDE_callerID	word
    DDE_ackOD		optr
    DDE_completeMsg	word	; message to send self when ackCount goes to 0
DetachDataEntry	ends

DETACH_DATA	vardata	DetachDataEntry

;--------------------------------------------------------
;		Other VarData
;--------------------------------------------------------

TEMP_EC_IN_USE_COUNT	 	vardata	word
; Used to keep track of In-use count on a per-object basis, in EC code only,
; to help in the tracking down of UI_BAD_IN_USE_COUNT fatal errors.

TEMP_EC_INTERACTIBLE_COUNT 	vardata	word
; Used to keep track of In-use count on a per-object basis, in EC code only,
; to help in the tracking down of UI_BAD_INTERACTIBLE_COUNT fatal errors.

EnsureActiveFTPriorityPreferenceData	struct
	EAFTPPD_priority	word
	EAFTPPD_avoidOptr	optr
EnsureActiveFTPriorityPreferenceData	ends

TEMP_META_ENSURE_ACTIVE_FT_LAYER_PRIORITY_PREFERENCE	vardata EnsureActiveFTPriorityPreferenceData
; Used internally to specify a preferred Layer Priority to check first when
; finding a new object to give focus/target to.  Avoid the given object,
; as it is the one that just gave up the focus/target.

DebugObjDuplicateResourceInfo	struct
	DODRI_tempOwner	char    GEODE_NAME_SIZE dup(?)
	; The permanent name of the geode owning the template that this block
	; was duplicated from.
	DODRI_tempResource	word
	; The handle of the template resource, unrelocated relative to the
	; above.
DebugObjDuplicateResourceInfo	ends

DEBUG_META_OBJ_DUPLICATE_RESOURCE_INFO	vardata	DebugObjDuplicateResourceInfo
; Info used to allow the debugger to print symbolic information for objects
; in the block this object lies in.  The EC version of ObjDuplicateResource,
; after duplicating an object block, finds the first object & adds this piece
; of vardata to it, thereby tagging the block for the debugger with info
; regarding where it came from.  The data stored is the unrelocated library,
; & unrelocated resource within that library, so that the entry is valid 
; across sessions.  The debugger, when displaying info about an object in
; a block that doesn't have a symbol, uses this to be able to show a 
; reference like:
;
;	^h4020h:EditCopyTrigger
;

MetaClass	endc

;------------------------------------------
;		Linkable
;-----------------------------------------

LinkPart	struct
    LP_next		optr	; Low bit: clear for sibling optr,
					; 	   set for parent optr.
					; 0 = object not in composite
LinkPart	ends

LP_IS_PARENT	=	1		;low bit is parent flag

global ObjLinkCallNextSibling:far
global ObjLinkCallParent:far
global ObjLinkFindParent:far

;--------------------------------------------------------
;		Composite Routines and Constants
;--------------------------------------------------------
global ObjCompFindChild:far
global ObjCompAddChild:far
global ObjCompRemoveChild:far
global ObjCompMoveChild:far

global ObjCompProcessChildren:far

CompPart		struct
    CP_firstChild	optr		;0 = no children
CompPart		ends

CompChildFlags	record
	CCF_MARK_DIRTY:1,		;Marks chunk and modified objects as
					; dirty
	CCF_REFERENCE:15		;Object # we should add new object 
					; before (if > # objects, then add new
					; object last)
CompChildFlags	end
CCO_FIRST	equ	0x0000		;
CCO_LAST	equ	0x7FFF		;NOTE - will not work if the object
					; already has 32767 children:)

InsertChildOption	etype	byte
	ICO_FIRST		enum	InsertChildOption
	ICO_LAST		enum	InsertChildOption
	ICO_BEFORE_REFERENCE	enum	InsertChildOption
	ICO_AFTER_REFERENCE	enum	InsertChildOption

InsertChildFlags	record
	ICF_MARK_DIRTY:1,		;Marks chunk and modified object as 
					; dirty
	:13,
	ICF_OPTIONS InsertChildOption:2;Options for how to add the child

InsertChildFlags	end
;	Type passed to ObjCompCallChildren

ObjCompCallType 			etype word, 0, 2
OCCT_SAVE_PARAMS_TEST_ABORT		enum ObjCompCallType
OCCT_SAVE_PARAMS_DONT_TEST_ABORT	enum ObjCompCallType
OCCT_DONT_SAVE_PARAMS_TEST_ABORT	enum ObjCompCallType
OCCT_DONT_SAVE_PARAMS_DONT_TEST_ABORT	enum ObjCompCallType
OCCT_ABORT_AFTER_FIRST			enum ObjCompCallType
OCCT_COUNT_CHILDREN			enum ObjCompCallType


;---

global OBJINITDETACH:far
global OBJINCDETACH:far
global OBJENABLEDETACH:far
global OBJACKDETACH:far
global OBJLINKFINDPARENT:far
global OBJCOMPFINDCHILDBYOPTR:far
global OBJCOMPFINDCHILDBYNUMBER:far
global OBJCOMPADDCHILD:far
global OBJCOMPREMOVECHILD:far
global OBJCOMPMOVECHILD:far
global OBJCOMPPROCESSCHILDREN:far

EndKernel
