#!/usr/public/perl

# $Id: stats,v 1.22 96/12/12 12:34:10 chris Exp $
################################
#	Stats
################################

&NGetOpt("v=s", "b=s", "g=s", "z=s", "n", "e=s@", "a", "r", "l", "f", "t", "x", "s", "i", "o", "u=s@", "h") || die "can't grab options";

$SIG{'INT'}	= 'cleanup';
$SIG{'TERM'}	= 'cleanup';
$SIG{'QUIT'}	= 'cleanup';
$SIG{'HUP'}	= 'cleanup';

#$PP_DIR		= '/tmp';	# where everything is stored
$PP_LOCK_FILE	= $PP_DIR . "/TEMPLOCK"; 	# prevent multiple access 
$PP_LOG_FILE	= $PP_DIR . "/log"; 	# file containg raw info
$CLASSNAME_FILE = $PP_DIR . "/classes";	# file containing power rating classes
$NUM_CLASS_ENTRIES = 19;		# entries in each table of class names
$PP_MAX_SCORE	= 60;			# maximum possible score (generous)

$FISH		= 'no-one';		# no one has the fish by default
$LAST_FISH	= 'no-one';		# no one has the fish by default

#
# convert _alt to -alt in any names that might have been in the options
#
$opt_z =~ s/_alt/-alt/;
if ($opt_g) {
	$gameName = $opt_g;
} else {
	$gameName = $defaultGame;
}

foreach $name (@opt_u)
{
  $name =~ s/_alt/-alt/;
}


if ($opt_a) {
   $WINNING_SCORE = 15;
} else {
   $WINNING_SCORE = 21;			# score you need to achieve to win
}

if ($opt_o) {
   $PRINTING_ALT_SCORES = 1;
   $opt_s = 1;
}

################################
#	Main Code
################################

#
# If user requested help, list the options for them.
#

if ($opt_h) {
    print <<EOM;
$0: The $defaultGame score keeper.
    With no options names and scores are prompted for to add to the log.

    options:
	-h  this help screen
	-s  report stats on playing records of everyone
	-r  prints only recent stats (over the last month)
	-x  prints a chart of wins by everyone (it's big)
	-u  <name>, when combined with -s or -r, displays stats vs. that player
	-a  Asthmatic-style (games to 15 pts)
	-z  <name> prints out the list of heads you own, and who has your head
	-g  <game name> sets the name of the game, for mail purposes
	-v  when logging a score, allows you to specify a verb string
	    (note, you can use \@w and \@l to insert the winner's and loser's
	     name in your string)
	-b  when logging a score, allows you to completely specify the verb
	    string (\@w and \@l are ignored)
	-i  while calculating stats, shows movement of the fish
	-o  display alt scores

    Tournament options:
	-t  uses tournament file/rules to log/read game scores and stats
	-l  prints out information about the current tournament (who is left)
	-f  forfeits a player out of the current tournament
	-n  starts a new "round-robin" tournament
	-e  <numPlayers> begins a single-elimination tournament with the 
	    specified number of players

EOM
	exit 0;
}


#
# Make sure we create world-readable files and such.
#
umask 002;
srand(time());

if ($opt_t || $opt_f || $opt_l || $opt_n || defined(@opt_e)) {
	$opt_t = 1;
	$PP_LOG_FILE	= $PP_DIR . "/tlog"; # file containg raw info
}
#
# Wait for the lock file to disappear.  Then create the lock file right
# quick (not using flock() 'cuz it doesn't work over NFS, right?)
#
while (-e $PP_LOCK_FILE) {
    print "File locked -- sleeping...\n";
    sleep 5;
}

#
#  If they want recent stats, but didn't specify players,
#  just print out all the scores.
#
if ($opt_r || defined(@opt_u)) {
   $opt_s = 1;
}
open (LOCK, ">$PP_LOCK_FILE") || die "can't open lock file: $PP_LOCK_FILE";
$rw = ($opt_s || defined(@opt_u) || $opt_x || $opt_z) ? "<" : "+>>"; # open read or write?
open (LOG, $rw . $PP_LOG_FILE) || &doDie("can't open log file: $PP_LOG_FILE");

if ($opt_s) {
    #
    #  Normal score-printing
    #
    if (defined(@opt_u) && (@opt_u > 1)) {
	    &outputstats($opt_u[0], $opt_u[1], 0);
    } else {
	    &outputstats(1);
    }

} elsif ($opt_l) {
    #
    # Print out the current status of the tournament
    #
    &tourneystatus();
} elsif ($opt_f) {
    #
    # FORFEIT MODE
    #
    $forfeiter = &getplayer("forfeiting");
    print LOG "FORFEIT ", $forfeiter, "\n"

} elsif ($opt_n) {
    print LOG "ROUND_ROBIN\n"
} elsif (defined(@opt_e)) {
    print LOG "SINGLE_ELIMINATION ", $opt_e[0], "\n"
} elsif ($opt_z) {
    #
    # Keep track of the winner of the most recent games
    #
    while (<LOG>) {
	/^\s*$opt_z\s+([^\s]+)\s+\d+/ && ($heads{$1}=1);
	/^\s*([^\s]+)\s+$opt_z\s+\d+/ && ($heads{$1}=0);
    }
    print "Heads $opt_z owns:\n";
    for $p (sort keys %heads) {
    	if ($heads{$p} == 1) {
		print $p, "\n";
	}
    }
    print "\nPeople who own ",$opt_z, "'s head:\n";
    for $p (sort keys %heads) {
    	if ($heads{$p} == 0) {
		print $p, "\n";
	}
    }
#} elsif (defined(@opt_u)) {
#    #
#    # Print out record of wins and losses and who they were to.
#    #
#    $u = $opt_u[0];
#   if (defined($opt_u[1])) {
#	&outputstats($u,$opt_u[1],0);
#   } else {
#    	$forfeits = 0;
#	while (<LOG>) {
#	    /^\s*$u\s+([^\s]+)\s+\d+/ && $wins{$1}++;
#	    /^\s*([^\s]+)\s+$u\s+\d+/ && $losses{$1}++;
#	    /^\s*FORFEIT\s+$u/ && $forfeits++;
#	}
#
#	print "$u has beaten:\n";
#	for $p (sort keys (%wins)) {
#	    print "\t", $p, "(", $wins{$p}, ")\n";
#	}
#	print "$u has lost to:\n";
#	for $p (sort keys (%losses)) {
#	    print "\t", $p, "(", $losses{$p}, ")\n";
#	}
#	if ($forfeits == 1) {
#	    printf "$u has 1 forfeit\n";
#	} elsif ($forfeits > 1) {
#	    printf "$u has %d forfeits\n", $forfeits;
#	}
#    }
#
} elsif ($opt_x) {
    while (<LOG>) {
	if (($winner, $loser) = /\s*([^\s]+)\s+([^\s]+)/) {
	    $players{$winner} = 1;
	    $players{$loser} = 1; # just to keep track...
	    eval "\$$winner\{$loser\}++";
	}
    }
    &chart(keys %players);
} elsif ($#ARGV == -1) {
    # 
    # Prompt the user for some info and add it to the log file.
    # 
    do {
	$winner = &getplayer("winning");
	$loser = &getplayer("losing");
    } while ($winner eq $loser);

    #
    # Keep prompting for scores until we get two possible ones.
    #
    do {
	$wscore = &getscore($winner);
	$lscore = &getscore($loser);
    } while !(&legalscore($wscore, $lscore));

    &logscore($winner, $wscore, $loser, $lscore);

} else {
    #
    #  Handle entries of the form "pp user1 score1 user2 score2."
    #
    while ($#ARGV >= 3) {
    	$winner = shift(@ARGV);
	$wscore = shift(@ARGV);
	$loser = shift(@ARGV);
	$lscore = shift(@ARGV);

	$winner =~ s/_alt/-alt/;	# for some reason kertes types _ not -
	$loser  =~ s/_alt/-alt/;

	($winnerLogin = $winner) =~ s/-alt//;
	($loserLogin = $loser) =~ s/-alt//;
	
	if (($winnerLogin ne $winner) || ($loserLogin ne $loser)) {
		$PRINTING_ALT_SCORES = 1;
	}

	if (($winner ne "test") && !getpwnam($winnerLogin)) {
		&doDie("$winner is not a valid name");
	}
	if (($loser ne "test") && !getpwnam($loserLogin)) {
		&doDie("$loser is not a valid name");
	}

	if ($winner eq $loser) {
		&doDie("$winner cannot beat himself (at least, not in public)");
	}

	#
	# If the user entered the loser first, switch them.
	#
	if ($wscore < $lscore) {
		$temp = $winner;
		$winner = $loser;
		$loser = $temp;
		$temp = $wscore;
		$wscore = $lscore;
		$lscore = $temp;
	}
	#
	# Make sure the scores are valid (the winner won by 2, the winner
	# had >= 21 points, if the score was more than 21, then make sure
	# he won by exactly 2 points.
	#
	if ($checkPPScore && (!&legalscore($wscore, $lscore))) {
		&doDie("$wscore-$lscore is not a valid score");
	}
	printf("Logging score: $winner beat $loser, $wscore-$lscore\n");
	&logscore($winner, $wscore, $loser, $lscore);
    }
    if ($#ARGV != -1) {
    	printf("ERROR - invalid number of arguments to pp script\n");
    }
}

close (LOG);

#
# Remove the lock file.  Unlink first, tror jeg.
#
unlink ($PP_LOCK_FILE);		# order okay here?
close (LOCK);

exit 0;

################################
#	Subroutines
################################

sub logscore {

    local($winner) = $_[0];
    local($wscore) = $_[1];
    local($loser) = $_[2];
    local($lscore) = $_[3];

    local($winnerMail);
    local($loserMail);

    #
    # Nuke the "-alt" that might be there, prior to mailing.
    #
    ($loserMail = $loser) =~ s/-alt//;
    ($winnerMail = $winner) =~ s/-alt//;

    #
    # Write the results to the log file.
    #
    $time = &curtime();
    print LOG $winner, " ", $loser, " ", $wscore, " ", $lscore, $time, "\n";

    #
    # Mail the winner and loser of the game.
    #

    $strippedGameName = $gameName;
    $strippedGameName =~ s/'//g;
    if (($loser eq "test") || ($winner eq "test")) {
    	print "Testing script - redirecting mail to stdout\n";
    	open (MAIL, "| cat");
    } else {
        open (MAIL, "|mail -s '$strippedGameName Score' " . $winnerMail . "," . $loserMail)
	    || die "can't mail";
    }
    $verbed = &selectverb($wscore, $lscore);

    # If there is one or more @l in the string, replace them all with the name
    # of the loser, else append the loser to the end.

    if (!$opt_b) {
        if (!($verbed =~ s/\@l/$loser/eg)) {
            if (!($verbed =~ s/\@L//eg)) {
    	        $verbed = $verbed . " " . $loser;
	    }
        }

    # If there is one or more @w in the string, replace them all with the name
    # of the winner, else prepend the winner.

        if (!($verbed =~ s/\@w/$winner/eg)) {
            if (!($verbed =~ s/\@W//eg)) {
                $verbed = $winner . " " . $verbed;
            }
        }
    }

    if ($opt_t) {
	$gamestr = "tournament $gameName";
    } else {
	$gamestr = "$gameName";
    }

    print MAIL <<EOM;

$verbed in a game of $gamestr!
The score was $wscore to $lscore.
The date was $time.

$fishString

Yours Truly,

The $gameName Scorekeeper

EOM
#
# Output the stats as well
#
    select(MAIL);
    if ($opt_t) {
	$opt_r = 1;
    }
    &outputstats($winner, $loser, 1);

    #
    # Figure out whether the fish is changing hands.
    #
    if ($loser eq $LAST_FISH) {
	printf("\n\n-- $loser must keep the fish another day. --\n\n");
    } elsif ($winner eq $LAST_FISH) {
	printf("\n\nFISHFISHFISHFISHFISHFISHFISHFISHFISHFISHFISHFISH\n");
	printf("FISHFISH                                FISHFISH\n");
	printf("           $loser now has the FISH!    \n");
	printf("FISHFISH                                FISHFISH\n");
	printf("FISHFISHFISHFISHFISHFISHFISHFISHFISHFISHFISHFISH\n");
    }

    select(STDOUT);
    close (MAIL);
    
    if ($opt_t) {
	#
	# Check for the end of the tournament...
	#
	&tourneyend;
    }
}
sub chooseclass {
#
# Map a power rating to a class string;
#
    local($rating) = $_[0];
    local($player) = $_[1];
    local($index);

    if ($rating > 100) {
	$rating = 100;
    }
    if ($rating > 100) {
	return("Cheater");
    } else {
	if (!defined(@classes)) {
		if (defined($ENV{'PP_CLASSNAME_FILE'})) {
			$CLASSNAME_FILE = $ENV{'PP_CLASSNAME_FILE'};
		}
		open (CLASSNAMES, "<" . $CLASSNAME_FILE) 
			|| die "can't open class name file: $CLASSNAME_FILE";
		$i=0;
		#
		# Read entries from file, and put in $classes array
		#
		while(<CLASSNAMES>) {
		    #
		    # Match any string of chars (.+) preceded
		    # by optional whitespace \s*, which is ignored
		    #
		    if (/^\s*(.+)/) {
			$classes[$i] = $1;
			$i++;
		    }
		}
		close(CLASSNAMES);
		if (defined($ENV{'PP_EXTRA_CLASSNAME_FILE'})) {
			open (CLASSNAMES, "<".$ENV{'PP_EXTRA_CLASSNAME_FILE'})
				|| die "can't open extra class name file: $ENV{'PP_EXTRA_CLASSNAME_FILE'}";
			#
			# Read entries from file, and put in $classes array
			#
			while(<CLASSNAMES>) {
			    #
			    # Match any string of chars (.+) preceded
			    # by optional whitespace \s*, which is ignored
			    #
			    if (/^\s*(.+)/) {
				$classes[$i] = $1;
				$i++;
			    }
			}
		}
		if ((($#classes+1) % $NUM_CLASS_ENTRIES) != 0) {
			&doDie("Class tables must have exactly $NUM_CLASS_ENTRIES entries each");
		}
		local($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
		localtime(time());
		
		$numClasses = ($#classes+1)/$NUM_CLASS_ENTRIES;
		$offset = ($mon % $numClasses) * $NUM_CLASS_ENTRIES;
#		print($mon % $numClasses);
#		$offset = int(rand(($#classes+1)/$NUM_CLASS_ENTRIES)) * $NUM_CLASS_ENTRIES;

	};
	if ($rating < -500) {
	    $index = 1;
	} elsif ($rating < 0) {
	    $index = 0;
	} else {
	    $index = int($rating/6)+2;
	}
	if ($player eq $FISH) {
		return('FISH');
	} else {
		return($classes[$index+$offset]);
	}
    }
}
sub outputstats {
    #
    # Get the players.  If $pstats is true then we'll print
    # the big stat table (otherwise just series stats).
    #
    $pstats = pop(@_);
    $player1 = $_[0];
    $player2 = $_[1];
    if (defined($player1)) {
	$player1 =~ s/_alt/-alt/;	# for some reason kertes types _ not -
    };
    if (defined($player2)) {
	$player2 =~ s/_alt/-alt/;
    };
    $- = 0;		# Force a top-of-form, so the top of page stuff
    			# (see "format top" below) will get written out

    
    seek(LOG,0,0);
    $reset = 1;

    # 
    # Read in stats from the log file.
    # 
    while (<LOG>) {

	if (/^\s*FISH\s+([^\s]+)/) {
 	    $LAST_FISH = $FISH;
	    &changeFish($1, $mon, $day, $year);
    	} elsif (/^END/) {
	    if ($opt_r) {
		$reset = 1;
	    }
	} elsif (/^\s*([^\s]+)\s+([^\s]+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+):(\d+):(\d+)\s+\d\d(\d+)/) {

	#
	#  Read in the match from the logfile and process it.
	#
 	($winner, $loser, $wscore, $lscore, $mon, $day, $hour, $min, $sec, $year) = ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10);
	if ($reset) {
	    undef(%twinstreak);
	    undef(%tlosestreak);
	    undef(%history);
	    undef(%serieswins);
	    undef(%closewins);
	    undef(%closelosses);
	    undef(%seriestotalscore);
	    undef(%serieswinstreak);
	    undef(%serieswinskunk);
	    undef(%twins);
	    undef(%tlosses);
	    undef(%tmargin);
	    undef(%toffense);
	    undef(%tdefense);
	    undef(%powerrating);
	    undef(%tskunks);
	    undef(%trouts);
	    undef(%tgotskunked);
	    undef(%tgotrouted);
	    undef($gamehist);
	    undef($seriesgames);
	    undef($seriesskunks);
	    undef($seriesrouts);
	    undef($clutchPlayer);
	    $longestWinStreak = 0;
	    $longestLossStreak = 0;
	    $longestScore = 0;
	    $biggestWin = 0;
	    $smallestScore = 1000;
	    $reset = 0;
	    $FISH = 'no-one';
    	} 

	if (!$opt_t && $opt_r && !(&recentscore($mon, $day, $year))) {
	    next;
	}

	if ((defined(@opt_u)) && !($winner eq $opt_u[0]) && !($loser eq $opt_u[0])) {
	    next;
	}

	#
	# Update fish status if needed.
	#
 	$LAST_FISH = $FISH;

	if ($winner eq $FISH) {
	    &changeFish($loser, $mon, $day, $year);
	}

	#
	#  Update winning/losing streaks for the players of
	#  the match we're looking at.
	#
	$twinstreak{$winner} += 1;
	$twinstreak{$loser} = 0;
	$tlosestreak{$winner} = 0;
	$tlosestreak{$loser} += 1;
	$history{$winner} = $history{$winner}."W";
	$history{$loser} = $history{$loser}."L";

	if (&skunked($wscore, $lscore)) {
	    $tskunks{$winner} += 1;
	    $tgotskunked{$loser} += 1;
	}
	if (&routed($wscore, $lscore)) {
	    $trouts{$winner} += 1;
	    $tgotrouted{$loser} += 1;
	}
	$tskunks{$winner} += 0;			# ensure defined
	$tskunks{$loser} += 0;			# ditto
	$tgotskunked{$winner} += 0;		# ditto ditto
	$tgotskunked{$loser} += 0;		# ditto ditto ditto

	$trouts{$winner} += 0;			# ensure defined
	$trouts{$loser} += 0;			# ditto
	$tgotrouted{$winner} += 0;		# ditto ditto
	$tgotrouted{$loser} += 0;		# ditto ditto ditto


	#
	#  If we're printing out stats for nobody in particular,
	#  or we're looking at a former match between the people
	#  who played just now, gather some statistics about
	#  the match we're looking at.
	#
	if (!defined($player1) || 
	    ($loser eq $player1 && $winner eq $player2) ||
	    ($winner eq $player1 && $loser eq $player2)) {
		if ($wscore - $lscore >= $biggestWin) {
		    $biggestWin = $wscore - $lscore;
		    $bigwinner = $winner;
		    $bigloser = $loser;
		    $biggestWinScore = $wscore;
		    $biggestLoseScore = $lscore;
		}
		if (($lscore < $smallestScore) || ($lscore == $smallestScore && (($wscore-$lscore) > $smallestLoseScore - $smallestScore))) {
		    $smallestScore = $lscore;
		    $smallestLoseScore = $wscore;
		    $smallWinner = $winner;
		    $smallLoser = $loser;
		}
		if ($wscore >= $longestScore) {
		    $longestScore = $wscore;
		    $longestLoseScore = $lscore;
		    $longwinner = $winner;
		    $longloser = $loser;
		}
		if ($wscore - $lscore <= 2) {
		    $closewins{$winner}++;
		    $closelosses{$loser}++;
		}
		if (defined($player1)) {
		    #
		    # $gamehist holds information about the games in the
		    # series as a string made up of "W" and "L"
		    #
		    if ($winner eq $player1) {
			$gamehist = $gamehist."W";
		    } else {
			$gamehist = $gamehist."L";			    
		    }
		    $seriesgames++;
		    $serieswins{$winner}++;

		    #
		    #  Deal with skunks.  Ignore for avg. margin.
		    #  (Added skunks back in.  cbh)
		    #
		    if (&skunked($wscore, $lscore)) {
			$seriesskunks++;
			$serieswinskunk{$winner}++;
			$serieswinskunk{$loser} += 0;	# ensure defined
		    } 
		    $seriestotalscore{$winner} += $wscore;
		    $seriestotalscore{$loser} += $lscore;
		    #
		    #  Deal with routs.
		    #
		    if (&routed($wscore, $lscore)) {
			$seriesrouts++;
			$serieswinrout{$winner}++;
			$serieswinrout{$loser} += 0;	# ensure defined
		    }
		    $serieswinstreak{$winner}++;
		    $serieswinstreak{$loser} = 0;
		    if ($serieswinstreak{$winner} > $longestWinStreak) {
			$longestWinStreak = $serieswinstreak{$winner};
			$longestWinner = $winner;
		    }
		} else {
		    if ($twinstreak{$winner} > $longestWinStreak) {
				$longestWinStreak = $twinstreak{$winner};
				$longestWinner = $winner;
		    }
		    if ($tlosestreak{$loser} > $longestLossStreak) {
			$longestLossStreak = $tlosestreak{$loser};
			$longestLoser = $loser;
		    }
		}
	
	}  # end of series-stats updating
	
	#
	# Update various other stats for the winner & loser.
	#
	$twins{$winner}++;
	$tlosses{$loser}++;
	$twins{$loser} += 0;		# ensure defined
	$tlosses{$winner} += 0;		# ditto

	#
	#  Have the margin calculations ignore skunks, as they
	#  screw up people's average margins.    (Added skunks
	#  back in -- chris)
	#
	$tmargin{$winner} += $wscore - $lscore;
	$toffense{$winner} += $wscore;
	$tdefense{$winner} += $lscore;
	
	$tmargin{$loser} += $lscore - $wscore;
	$toffense{$loser} += $lscore;
	$tdefense{$loser} += $wscore;
      }		# end of reading/processing a logfile match
    }

    for $p (keys (%tmargin)) {
	$pct{$p} = $twins{$p}/($twins{$p}+$tlosses{$p});
    }
    $clutchPct = 0;
    $leastClutchPct = 100;
    for $p (keys (%closewins)) {
	if ($closewins{$p} + $closelosses{$p} < 5) {
	    next;
	}
	$cpct = $closewins{$p}/($closewins{$p}+$closelosses{$p});
	if ($cpct > $clutchPct) {
	    $clutchPct = $cpct;
	    $clutchPlayer = $p;
	}
	if ($cpct < $leastClutchPct) {
	    $leastClutchPct = $cpct;
	    $leastClutchPlayer = $p;
	}
#	$clutch{$p} = $closewins{$p}/($closewins{$p}+$closelosses{$p});
	
    }

#
# 	Don't print out clutch pct, for now
#
#    for $p (sort numerically (keys %clutch)) {
#	printf ("$p -- %3.2f\n", $clutch{$p});
#    }

    &createpowerratings();


    # 
    # Print them out nicely.
    #
    if ($pstats != 0) {
	for $p (sort bypower (keys (%powerrating))) {
	    ($pLogin = $p) =~ s/-alt//;
#
# We want to print both alt and non-alt scores when adding a score for a
# tournament (to deal with mixed tournaments).
#

# Remove these lines to allow alts to be listed with non-alts.
# {
	    if (!($opt_t && $opt_r && !$PRINTING_ALT_SCORES)) {
		if ($PRINTING_ALT_SCORES) {
		    if ($pLogin eq $p) {
			next;
		    }	
	       } else {
		    if ($pLogin ne $p) {
			next;
	            }	
	        }
	    }
# }

	    #
	    # If doing a player's stats, don't do the player himself.
	    #
	    if (defined(@opt_u)) {
		if ($p eq $opt_u[0]) {
			next;
		}
	    }

	    if ($twinstreak{$p} > 0) {
		$streaktype = W;
		$streak = $twinstreak{$p};
	    } else {
		$streaktype = L;
		$streak = $tlosestreak{$p};
	    }
	    if (!defined($player1)) {
		$select = "";
	    } elsif (($p eq $player1) || ($p eq $player2)) {
		$select = ">";
	    } else {
		$select = " ";
	    }
	    #
	    # Calculate the # losses in the last 10 games
	    #
	    # 1) Truncate the history array to the last 10 games
	    # 2) Count the # wins and losses in the last 10 games
	    #
	    if (length($history{$p}) > 10) {
		$history{$p} = substr($history{$p},-10);
	    }
	    $i = 0;
	    $wins = 0;
	    $losses = 0;
	    while ($i < length($history{$p})) {
		if (substr($history{$p},$i,1) eq "W") {
		    $wins++;
		} else {
		    $losses++;
		}
		$i++;
	    }
	    $games = $twins{$p} + $tlosses{$p};

	    if (!($games)) {
		next;
	    }

            $pct = $twins{$p}/$games;

	    #
	    # If they have a powerrating below -100, it means they are an 
	    # inexperienced player, so just put out ----- as their rating.
	    #
	    if ($powerrating{$p} > -100) {
		$pwr = sprintf("%3.2f\n", $powerrating{$p});
	    } else {
		$pwr = "-----";
	    }
	    #
	    #  Ignore skunks in average-margin calculation.
	    #  No longer -- cbh
	    #
	    if ($games == 0) {
		$avgMargin = 0;
	    } else {
		$avgoffense = $toffense{$p}/$games;
		$avgdefense = $tdefense{$p}/$games;
		$avgmargin = int($toffense{$p}/$games*10+.5)-int($tdefense{$p}/$games*10+.5);
		$avgmargin = $avgmargin/10;

	    }
	    $class = &chooseclass($powerrating{$p}, $p);
	    write;
	}
	printf("\n");
    }

    if ($opt_t) {
        $gamestr = "tournament game";
        $winstr = "tournament win";
    } else {
        $gamestr = "game";
        $winstr = "win";
    }
    if (defined($player1)) {
    	if ($opt_t) {
	    $seriesstr = "Tournament stats";
	} else {
	    $seriesstr = "Series stats";
	}
	if ($seriesgames > 1) {
	    printf("---- $seriesstr - $player1 vs $player2 (%d %ss total) ----\n\n", $seriesgames, $gamestr);
	} elsif ($seriesgames == 1) {
	    printf("---- $seriesstr - $player1 vs $player2 (first %s ever) ----\n\n", $gamestr);
	} else {
	    printf("No %ss recorded between $player1 and $player2\n", $gamestr);
	    return;
	}
	if ($longestWinStreak == $seriesgames) {
	    printf("$longestWinner has won every %s\n\n", $gamestr);
	} else {
	    #
	    # Print out the series
	    #
	    if ($serieswins{$player1} == $serieswins{$player2}) {
		printf("The series is tied, %d $gamestr", $serieswins{$player1});
		if ($serieswins{$player1} == 1) {
		    printf(" each\n\n");
		} else {
		    printf("s each\n\n");
		}
	    } else {
		if ($serieswins{$player1} > $serieswins{$player2}) {
		    $winPlayer = $player1;
		    $losePlayer = $player2;
		} else {
		    $winPlayer = $player2;
		    $losePlayer = $player1;
		}
		printf("$winPlayer leads the series, %d %ss", $serieswins{$winPlayer}, $winstr);
		printf(", %d loss",$serieswins{$losePlayer});
		if ($serieswins{$losePlayer} != 1) {
		    printf("es");
		}
		printf(" (%2.0f%%)\n\n", $serieswins{$winPlayer}*100/($serieswins{$winPlayer}+$serieswins{$losePlayer}));
	    }
	    #
	    # We only care about the last 10 games, so truncate the "gamehist" 
	    # array down to that amount, and count the # wins in those games
	    #
	    $lastten = $gamehist;
	    if (length($lastten) > 10) {
		$lastten = substr($lastten, -10);
	    }
	    $i = 0;
	    $numWinsInLastten = 0;
	    while ($i < length($lastten)) {
		if (substr($lastten,$i,1) eq "W") {
		    $numWinsInLastten++;
		}
		$i++;
	    }
	    if ($longestWinStreak > 1) {
		printf("%s has the longest winning streak - %d %ss\n\n",
		$longestWinner, $longestWinStreak, $gamestr);
	    }
	    if ($serieswinstreak{$player1} > 1) {
		printf("$player1 has won the last %d %ss (%d of the last %d)\n\n", 
		$serieswinstreak{$player1}, $gamestr, 
		$numWinsInLastten, length($lastten));
	    } elsif ($serieswinstreak{$player2} > 1) {
		printf("$player2 has won the last %d %ss (%d of the last %d)\n\n", 
		$serieswinstreak{$player2}, $gamestr, 
		length($lastten) - $numWinsInLastten, length($lastten));
	    } elsif (length($gamehist) > length($lastten)) {
		printf("$player1 has won %d of the last %d %ss\n\n", 
		$numWinsInLastten, length($lastten), $gamestr);		
	    }
	}

	#
	# Print out the average margin, ignoring any skunks.
	#
	$scoreDiff = int($seriestotalscore{$player1}/$seriesgames*10+.5)-int($seriestotalscore{$player2}/$seriesgames*10+.5);
	$scoreDiff = $scoreDiff/10;

	#
	# Gratuitous code to add more precision when players are very close
	# in scoring margin.
	#
	$scoreDiffAvg = sprintf ("%2.1f", $scoreDiff);
	$negScoreDiffAvg = sprintf ("%2.1f", 0-$scoreDiff);
	$player1Avg = sprintf ("%2.1f", $seriestotalscore{$player1}/$seriesgames);
	$player2Avg = sprintf ("%2.1f", $seriestotalscore{$player2}/$seriesgames);

	if (($scoreDiffAvg eq "0.0") || ($negScoreDiffAvg eq "0.0") || ($player1Avg eq $player2Avg)) {
	    $player1Avg = sprintf ("%1.2f", $seriestotalscore{$player1}/$seriesgames);
	    $player2Avg = sprintf ("%1.2f", $seriestotalscore{$player2}/$seriesgames);
	    $scoreDiffAvg = sprintf ("%1.2f", $player1Avg-$player2Avg);
	    $negScoreDiffAvg = sprintf ("%1.2f", $player2Avg-$player1Avg);
	}
			     
	if ($seriestotalscore{$player1} > $seriestotalscore{$player2}) {
	    print("$player1 has scored an average of $scoreDiffAvg points more than $player2 ($player1Avg - $player2Avg)\n\n");

	} elsif ($seriestotalscore{$player1} < $seriestotalscore{$player2}) {
	    print("$player2 has scored an average of $negScoreDiffAvg points more than $player1 ($player2Avg - $player1Avg)\n\n");
	}

	#
	#  Print out the skunk stats.
	#
	if ($seriesskunks != 0) {
	    #
	    #  Print how many times player1 has skunked player2.
	    #
	    if ($serieswinskunk{$player1} == 1) {
		printf("$player1 has skunked $player2 1 time\n\n");
	    } elsif ($serieswinskunk{$player1} > 1) {
		printf("$player1 has skunked $player2 %d times\n\n",
		$serieswinskunk{$player1});
	    }
	    #
	    #  Print how many times player2 has skunked player1.
	    #
	    if ($serieswinskunk{$player2} == 1) {
		printf("$player2 has skunked $player1 1 time\n\n");
	    } elsif ($serieswinskunk{$player2} > 1) {
		printf("$player2 has skunked $player1 %d times\n\n",
		$serieswinskunk{$player2});
	    }
	}

	#
	#  Print out the rout stats.
	#
	if ($seriesrouts != 0) {
	    #
	    #  Print how many times player1 has routed player2.
	    #
	    if ($serieswinrout{$player1} == 1) {
		printf("$player1 has routed $player2 1 time\n\n");
	    } elsif ($serieswinrout{$player1} > 1) {
		printf("$player1 has routed $player2 %d times\n\n",
		$serieswinrout{$player1});
	    }
	    #
	    #  Print how many times player2 has routed player1.
	    #
	    if ($serieswinrout{$player2} == 1) {
		printf("$player2 has routed $player1 1 time\n\n");
	    } elsif ($serieswinrout{$player2} > 1) {
		printf("$player2 has routed $player1 %d times\n\n",
		$serieswinrout{$player2});
	    }
	}

	#
	# Print out who won the longest game in the series.
	#
	if ($longestScore > $WINNING_SCORE) {
	    printf("%s won the longest $gamestr in the series, %d - %d\n\n",$longwinner, $longestScore, $longestLoseScore);
	}

	#
	# Print out the clutch player
	#
	if (defined($clutchPlayer)) {
		printf("$clutchPlayer is the most clutch player, winning %2.0f%% of his close games (%d of %d) \n\n", $clutchPct*100, $closewins{$clutchPlayer}, $closelosses{$clutchPlayer} + $closewins{$clutchPlayer});
	}

	#
	# Print out who had the biggest win.
	#
	printf("$bigwinner had the biggest $winstr, %d - %d\n\n", $biggestWinScore, $biggestLoseScore);

	#
	# Print out who had the best defense...
	#
	printf("$smallWinner had the best defense when beating $smallLoser (%d - %d)\n\n", $smallestLoseScore, $smallestScore);
    } else {
    	if ($opt_r) {
	    $sincestr = "in the last month";
	} else {
	    $sincestr = "ever";
	}
	#
	# Print out overall stats 
	#
	unless ($opt_t && $opt_r) {
	    printf("%s has the longest winning streak $sincestr - %d %ss\n\n",$longestWinner, $longestWinStreak, $gamestr);
	    printf("%s has the longest losing streak $sincestr - %d %ss\n\n",$longestLoser, $longestLossStreak, $gamestr);
	    if ($longestScore > $WINNING_SCORE) {
		    printf("The longest $gamestr $sincestr was when %s beat %s (%d - %d)\n\n",$longwinner, $longloser, $longestScore, $longestLoseScore);
	    }
	#
	# Print out the clutch player
	#
	if (defined($clutchPlayer)) {
		printf("$clutchPlayer is the most clutch player, winning %2.0f%% of his close games (%d of %d) \n\n", $clutchPct*100, $closewins{$clutchPlayer}, $closelosses{$clutchPlayer} + $closewins{$clutchPlayer});
		printf("$leastClutchPlayer is the least clutch player, winning %2.0f%% of his close games (%d of %d) \n\n", $leastClutchPct*100, $closewins{$leastClutchPlayer}, $closelosses{$leastClutchPlayer} + $closewins{$leastClutchPlayer});
	}

        printf("The biggest $winstr $sincestr was when %s beat %s (%d - %d)\n\n",$bigwinner, $bigloser, $biggestWinScore, $biggestLoseScore);

	printf("$smallWinner had the best defense when beating $smallLoser (%d - %d)\n\n", $smallestLoseScore, $smallestScore);

            if ($opt_t) {
	        &outputwinners();
	    }
	}
    }
}

sub recentscore {
    $mn = @_[0];
    # The passed-in month is 1-based, the month returned
    # from localtime is 0-based, so we just compare the numeric values...

    $dy = @_[1];
    $yr = @_[2];

    if (!defined($today)) {
	# Calculate an integer that uniquely identifies today...
	local($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
		localtime(time());
	$today = $mday + 32*$mon + 12*32 * $year;
#	print "TODAY =", $today, "\n";
    }
#    if ($mn > 11) {
#	    $foo = ($dy + 32*$mn + 13*32 * $year); #Return value of this expr
#	    print "$dy/$mn/$year, $foo, $today \n";
#	    
#    }
#    if ($today < ($dy + 32*$mn + 12*32 * $year)) {
#	print "recent score - $mn/$dy/$year\n";
#    }
    $today < ($dy + 32*$mn + 12*32 * $year); #Return value of this expr
}
sub createpowerratings {
    #
    # Go back to the start of the LOG file
    #
    seek (LOG,0,0);
    $reset = 1;
    $pos = 0;
    if (!defined($aprilFools)) {
	local($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
		localtime(time());
	if (($mon == 3) && ($mday == 1)) {
		$aprilFools = 1;
	} else {
		$aprilFools = 0;
	}
    }

    # calculate recent wins/losses
    while (<LOG>) {
    	if (/^END/) {
	    if ($opt_r) {
	    #
	    # We only want the most recent tournament scores, so keep track
	    # of the last end of the tournament...
	    #
	        $pos = tell(LOG);
		$reset = 1;
	    }
	} elsif (/^\s*([^\s]+)\s+([^\s]+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+):(\d+):(\d+)\s+\d\d(\d+)/) {
	    ($winner, $loser, $wscore, $lscore, $mon, $day, $hour, $min, $sec, $year) = ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10);
	    if ($aprilFools) {
		$temp = $winner;
		$winner = $loser;
		$loser = $temp;
	    }
	    if ($reset) {
	    	$reset = 0;
	    	$realpos = $pos;
	    	undef(%recentwins);
		undef(%recentlosses);
	    }
	    if ($opt_t || &recentscore($mon, $day, $year)) {
		$recentwins{$winner}++;
		$recentwins{$loser}+=0;
		$recentlosses{$loser}++;
		$recentlosses{$winner}+=0;
	    }
        }
    }
    
    #
    # Create a power rating based on the winning percentages of the opponents
    #
    # Basically, the power rating for a player is determined by adding the
    # winning percentages of all the opponents s/he beat, - (1.5 - winning %
    # of players s/he lost to).
    #
    # Losing to a player hurts your power rating more than beating
    # that player will.
    #
    seek (LOG,$realpos,0);
    while (<LOG>) {
	if (/^\s*([^\s]+)\s+([^\s]+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+):(\d+):(\d+)\s+\d\d(\d+)/) {
	    ($winner, $loser, $wscore, $lscore, $mon, $day, $hour, $min, $sec, $year) = ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10);
	    if ($aprilFools) {
		$temp = $winner;
		$winner = $loser;
		$loser = $temp;
	    }
	    if ($opt_t || &recentscore($mon, $day, $year)) {
		$powerrating{$winner} += $recentwins{$loser}/($recentwins{$loser} + $recentlosses{$loser});
		$powerrating{$loser} += $recentwins{$winner}/($recentwins{$winner} + $recentlosses{$winner}) - 1.3;
	#
	# Give the winner a little boost for winning by more than 10 points
	# (or skunking them), and penalize the loser.
	#
		if ($wscore-$lscore > 10 || &skunked($wscore, $lscore)) {
		    $powerrating{$loser} += $recentwins{$winner}/($recentwins{$winner} + $recentlosses{$winner}) - 1;
		    $powerrating{$winner} += $recentwins{$loser}/($recentwins{$loser} + $recentlosses{$loser});
		}
	    }
# For debugging, to see how power points change with each game
#	    print ($winner, " ", $powerrating{$winner}, " ", $loser, $powerrating{$loser}, "\n");
	}
    }
    #
    # Finalize the power ratings, by getting an "average power points per game"
    # (which ranges from -1.5 to 1) and changing that to a range of 0-100.
    #
    for $p (sort keys (%powerrating)) {
	$powerrating{$p} = 60+($powerrating{$p}/($recentwins{$p} + $recentlosses{$p}))*110;
	if (!$opt_t) {

	    # If the player has < 5 games experience, then move him to the 
	    # bottom of the list, by making his power rating very low, but
	    # still keep inexperienced players in sorted order amongst
	    # themselves.
	    #
	    # This check is not done in tournament play, of course...
	    #

	    if (($recentwins{$p} + $recentlosses{$p}) < 5) {
		$powerrating{$p} -= 1000;
	    }
	}
    }
}

sub read_tourney_info {
    seek(LOG,0,0);
    while(<LOG>) {
	if (/^END/) {
	    undef(%losscount);
	    undef(%numGames);
	    undef(%currentPlayers); 
	    undef($roundRobin);
	    undef($singleElim);
	} elsif (/^\s*FORFEIT\s+([^\s]+)/) {
	    $numGames{$1} += 0;
	    $losscount{$1} = 2;
	} elsif (/^ROUND_ROBIN/) {
	    $roundRobin = 1;
	} elsif (/^SINGLE_ELIMINATION\s+([\d]+)/) {
	    undef(%currentPlayers);
	    undef(%losscount);
	    undef($roundRobin);
	    $singleElim = $1;
	} elsif (/^\s*([^\s]+)\s+([^\s]+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+):(\d+):(\d+)\s+\d\d(\d+)/) {

	    ($winner, $loser, $wscore, $lscore, $mon, $day, $hour, $min, $sec, $year) = ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10);

	    $numGames{$winner} += 1;
	    $numGames{$loser} += 1;
	    $currentPlayers{$winner} = 1;
	    $currentPlayers{$loser} = 1;
	    $losscount{$winner} += 0; #Make sure this value exists...	
	    $losscount{$loser}++;
	    if (defined($singleElim)) {
		$singleElim--;
		if ($losscount{$loser} != 1) {
		    &doDie("Log error - $loser has more than one loss");
		}
		if ($losscount{$winner} != 0) {
		    &doDie("Log error - $winner has already been eliminated");
		}
		if ($singleElim < 1) {
		    &doDie("Log error - single elimination tournament had too many games");
		}
	    }
		
	    if ($losscount{$loser} > 2 && !defined($roundRobin) && !defined($singleElim)) {
		&doDie("Log error - $loser has more than 2 losses");
	    }
	}
    }
}
sub tourneystatus {
    &read_tourney_info;
    $numSurvivors = 0;
    for $p (keys %losscount) {
	$numSurvivors++;    
    }
    if (defined ($singleElim)) {
	    printf("Single-elimination tournament participants (%d total)\n", $numSurvivors)
    } elsif (defined($roundRobin)) {
    	    printf("Round-robin tournament participants (%d total)\n", $numSurvivors);
    } else {
	    printf("Double-elimination tournament participants (%d total)\n", $numSurvivors);
    }
    for $p (keys %losscount) {
    	print $p, "\t(", $numGames{$p}-$losscount{$p}, " win";
	if ($numGames{$p}-$losscount{$p} != 1) {
		print "s";
	}
	print ", ", $losscount{$p}, " loss";
	if ($losscount{$p} != 1) {
		print "es";
	}
	print ")\n";
	$totalGames += $numGames{$p};
    }
    if (defined($roundRobin)) {
    	print $totalGames/2, " game";
	if ($totalGames != 2) {
		print "s";
	}
	print " total\n";
    }

    if (defined($singleElim)) {
        printf("\nPlayers still active\n");
	for $p (keys %currentPlayers) {
	    if ($losscount{$p} == 0) {
	    	print $p, "\n";
	    }	
	}

        printf("\nPlayers that have been eliminated\n");
	for $p (keys %currentPlayers) {
	    if ($losscount{$p} != 0) {
	    	print $p, "\n";
	    }	
	}

    } elsif (!defined($roundRobin)) {
	printf("\nPlayers in winners bracket\n");
	for $p (keys %currentPlayers) {
	    if ($losscount{$p} == 0) {
	        print $p, "\n";
	    }
	}
	printf("\nPlayers in losers bracket\n");
	for $p (keys %currentPlayers) {
	    if ($losscount{$p} == 1) {
	        print $p, "\n";	
    	    }
        }
        printf("\nPlayers that have been eliminated\n");
        for $p (keys %currentPlayers) {
	    if ($losscount{$p} == 2) {
	        print $p, "\n";	
            }
        }
    }
}

sub tourneyend {
    &read_tourney_info;
    #
    # Scan through the array of losses, and count how many losses there are
    # per person - the tournament is over when all but one person has 2 losses.
    #
    $numSurvivors = 0;
    for $p (keys %currentPlayers) {
	if (!defined($singleElim)) {
	    if ($losscount{$p} != 2) {
		$numSurvivors++;
		$survivor = $p;
	    }
        } else {
	    if ($losscount{$p} != 1) {
		$numSurvivors++;
		$survivor = $p;
	    }
	}

	($pMail = $p) =~ s/-alt//;
	$maillist = $maillist.$pMail.", ";
    }
    if ((defined($singleElim) && ($singleElim == 1)) || 
    	(!defined($singleElim) && !defined($roundRobin) && ($numSurvivors == 1))) {
        #
	# There is only one survivor, so mark the end of the tournament
	#
	print LOG "END\n";
	printf("END OF TOURNAMENT\n\n");
	open (MAIL, "|mail -s '$gameName Score' " . $maillist) 
	    || die "can't mail";
	print MAIL <<EOM;

Shockingly, $survivor won the Tournament!

Yours Truly,

The $gameName Scorekeeper

EOM

	select(MAIL);
	&outputstats(1);
	select(STDOUT);
	close (MAIL);
    }
}
sub outputwinners {
    seek(LOG,0,0);
    if ($PRINTING_ALT_SCORES) {
    	printf("Alt Tournament Winners\n");
	printf("----------------------\n");
    } else {
        printf("Tournament Winners\n");
        printf("------------------\n");
    }
    while (<LOG>) {
	if (/^END/) {
	    ($temp = $winner) =~ s/-alt//;
	    if (($PRINTING_ALT_SCORES && ($temp ne $winner)) ||
		(!$PRINTING_ALT_SCORES && ($temp eq $winner))) {
	        printf("$winner    \t($mon/$day/$year)\n");
	    }
	} elsif (/^\s*([^\s]+)\s+([^\s]+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+):(\d+):(\d+)\s+\d\d(\d+)/) {
	    ($winner, $loser, $wscore, $lscore, $mon, $day, $hour, $min, $sec, $year) = ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10);
	}
    }
    printf("\n");
}
sub numerically {
		$clutch{$b} <=> $clutch{$a}
};

sub bypower {
	$powerrating{$b}<=>$powerrating{$a};
}
sub byavgmargin {
	($tmargin{$b}/($twins{$b}+$tlosses{$b}))<=>($tmargin{$a}/($twins{$a}+$tlosses{$a}));
}
sub selectverb {
    local($winnerscore) = $_[0];
    local($loserscore) = $_[1];
    @skunkverbs = ('skunked');
    @squeaked = ('squeaked by', 'outlasted', 'ground out a win over');
    @verbs = ('upset', 'ousted', 'topped', 'curtailed', 'slapped', 'spanked', 'cowed', 'buffeted', 'thumped', 'laid into', 'clouted', 'drubbed', 'smoked', 'beat', 'busted', 'blasted', 'defeated', 'squashed', 'wrecked', 'swatted', 'flogged', 'abused', 'overwhelmed', 'clobbered', 'walloped', 'whupped', 'whipped', 'whacked', 'thwacked', 'licked', 'hurt', 'tormented', 'pummeled', 'wasted', 'decimated', 'scourged', 'devoured', 'smote', 'slammed', 'hammered', 'battered', 'pounded', 'smashed', 'shredded', 'thrashed', 'trashed', 'crushed', 'humiliated', 'mutilated', 'routed', 'tortured', 'destroyed', 'demolished', 'massacred', 'annihilated', 'slew', 'beat the crap out of');

    if ($opt_b) {
        return($opt_b);
    } elsif ($opt_v) {
    	return($opt_v);
    }    
    if ($loserscore == 0 || &skunked($winnerscore, $loserscore)) {
	return($skunkverbs[rand($#skunkverbs+1)]);
    } elsif ($loserscore > 19) {
    	return($squeaked[rand($#squeaked+1)]);
    } else {
    #	
    # The winner won by 2-20 points - convert this to an array index into
    # the verbs array.
    #
    	$arraywidth = int(($#verbs+1)/18);
	$diff = ($winnerscore - $loserscore -2);
	if ($diff < 0) {
		$diff = 0;
	} elsif ($diff > 18) {
		$diff = 18;
	}
	$index = $diff * $arraywidth + int(rand($arraywidth));
	return($verbs[$index]);
    }    
    
}
sub getplayer {
    local($type) = @_;
    local($resp);
    local($respLogin);

    # 
    # Prompt 'em for a name until it's a real login name.   (Now allows
    # "-alt" to be tacked on.)
    #
    do {
	print "Enter the ", $type, " player's login name: ";
	chop($resp = <STDIN>);
	($respLogin = $resp) =~ s/-alt//;
    } while (($resp ne "test") && !getpwnam($respLogin));

    if ($respLogin ne $resp) {
	$PRINTING_ALT_SCORES = 1;
    }

    return $resp;
}

sub getscore {
    local($name) = @_;
    local($resp);

    # 
    # Prompt 'em for a score until it's a reasonable one.
    # 
    do {
	print "Enter ", $name, "'s score: ";
	chop($resp = <STDIN>);
    } while ($resp !~ /^\d+$/);

    return $resp;
}

#
#  Tell us whether the score entered was a legal one.
#
sub legalscore {
    local($wscore) = $_[0];
    local($lscore) = $_[1];

    if (!$checkPPScore) {
		return 1;
    } elsif (&skunked($wscore, $lscore)) {
		return 1;
    } elsif ($wscore - $lscore < 2
	|| $wscore < $WINNING_SCORE
	|| ($wscore > $WINNING_SCORE && $wscore - $lscore > 2)
	|| $wscore > $PP_MAX_SCORE) {
		return 0;
    } else {
		return 1;
    }
}

sub changeFish {
    local($name) = $_[0];
    local($month) = $_[1];
    local($day) = $_[2];
    local($year) = $_[3];
    if ($opt_i) {
 	printf("Fish changed from $FISH to $name, on $month/$day/$year\n");
    }
    $FISH = $name;
    return 0;
}

sub skunked {
    local($wscore) = $_[0];
    local($lscore) = $_[1];
    #
    #  Not score-checking, anything with loser=0 works.
    #
    if (! $checkPPScore) {
	if ($lscore == 0)  {
		return 1;
	} else {
		return 0;
        }
    #
    #  Check if it was a skunk (not legal for tournaments unless
    #  it's 21-0).
    #
    } elsif (!$opt_t) {
      if (($wscore == 7 && $lscore == 0) ||
  	  ($wscore == 11 && $lscore == 1)) {
	  return 1;
      }
    } else {
	if ($wscore == $WINNING_SCORE && $lscore == 0) {
	  return 1;
	}
    }
    return 0;
}

sub curtime {
    local($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
	localtime(time());
    $mon = $mon + 1;
    return sprintf("%s %s %2d %02d:%02d:%02d %d",
		   $days[$wday], $mon, $mday, $hour, $min, 
		   $sec, $year + 1900);
}

sub cleanup {
    unlink $PP_LOCK_FILE;
    close LOCK;
    exit 0;
}

$IN = "\033(0";
$OUT = "\033(B";

$BR = '\152';
$TR = '\153';
$TL = '\154';
$BL = '\155';
$CR = '\156';
$TL = '\157';
$HT = '\160';
$HH = '\161';
$HM = '\162';
$HL = '\163';
$L3 = '\164';
$R3 = '\165';
$B3 = '\166';
$T3 = '\167';
$VV = '\170';

sub chart {
    local(@players) = @_;
    local($maxlen);		# the longest username
    local($p, $i, $j);
    local(@padded);

    $maxlen = length($players[$[]);
    @players = sort @players;
    for (@players) {
	$maxlen = ($maxlen > length) ? $maxlen : length;
    }

    local($lSpacePad) = ' ' x $maxlen . " ";
    local($lPlusPad) = ' ' x $maxlen . " +";

    # 
    # Make a padded version of each player's string.
    # 
    for $i (0 .. $#players) {
	$padded[$i] = " " x ($maxlen - length($players[$i])) . $players[$i];
    }

    #
    # Print out top row.
    #
    for $i (0 .. $maxlen - 1) {
	print $lSpacePad;
	for $j (0 .. $#players) {
	    $char = substr($padded[$j], $i, 1);
	    print "   \u$char";
	}
	print "\n";
    }

    print " " x $maxlen, " ";
    print "\033(0";
    print "\154";		# top left corner
    print "\161\161\161\167" x $#players;
    print "\161\161\161\153";
    print "\033(B\n";
    #
    # Print out each row.
    #
    for $p (@players) {		# $p == player for this row
	printf "%$maxlen" . "s \033(0\170\033(B", $p;
	for $o (@players) {	# $o == opponent for this column
	    eval "\$$p\{$o\} += 0"; # make sure it's at least defined
	    printf("%3d\033(0\170\033(B", eval "\$$p\{$o\}");
	}
	print "\n";
	if ($p ne $players[$#players]) {
	    print " " x $maxlen, " ";
	    print "\033(0";
	    print "\164";		
	    print "\161\161\161\156" x $#players;
	    print "\161\161\161\165";
	    print "\033(B\n";
	}
    }
    print " " x $maxlen, " ";
    print "\033(0";
    print "\155";		# top left corner
    print "\161\161\161\166" x $#players;
    print "\161\161\161\152";
    print "\033(B\n";
}



sub doDie {
	local($message) = @_;
	unlink ($PP_LOCK_FILE);		# order okay here?
	close (LOCK);
	die($message);
}

