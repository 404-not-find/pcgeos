table enter $fatalerr_info_table geos::GRAPHICS_BAD_FONT_PATH { Either there are no fonts in USERDATA\FONT, the standard path set
 for fonts is pointing off to oblivion, or the right file system
 driver isn't downloaded.  This last will only happen in the non-EC,
 as error checking code in the EC will catch the case otherwise.}
table enter $fatalerr_info_table geos::NO_ONE_TO_SEND_SHUTDOWN_ACK_TO_ALAS { Someone called SysShutdown(SST_CLEAN/SST_SUSPEND), passing cx==0, after the
 UI has exited, or before it started up.
 }
table enter $fatalerr_info_table geos::NOT_ALLOWED_TO_PSEM_IN_INTERRUPT_CODE { You are attempting to P a semaphore of some sort while in interrupt code
 or a critical section (defined by a call to SysEnterInterrupt or
 SysEnterCritical having been called). This is not allowed, as if the semaphore
 is already grabbed, the system will come to a screeching halt.
 }
table enter $fatalerr_info_table geos::TOO_MANY_LOCKS { A memory block may only have at most 254 locks placed on it, and you're on
 your 255th, or you're attempting to lock a fixed block. If the former, you're
 probably missing a MemUnlock for one of your MemLocks. If the latter, 
 remember the tale of the person who told the doctor, "it hurts when I do
 this."}
table enter $fatalerr_info_table geos::BAD_UNLOCK { You are attempting to unlock an unlocked block.}
table enter $fatalerr_info_table geos::CANNOT_CHANGE_OWNER { You are attempting to change the owner of a non-sharable handle you do not
 own. Most likely, the handle whose ownership you think you're changing has
 long since been freed and re-used.}
table enter $fatalerr_info_table geos::HANDLE_SHARING_ERROR { You are attempting to lock down a memory block owned by another geode that
 isn't marked HF_SHARABLE. Either you've got the wrong handle (e.g. you're
 using a handle for a block you freed, which was recycled by the system),
 or you need to mark this block HF_SHARABLE.}
table enter $fatalerr_info_table geos::ALLOC_ZERO { You are not allowed to allocate a zero-sized block of memory. Allocate
 something HF_DISCARDED with a non-zero size if you just wish to reserve
 a memory handle for later use.}
table enter $fatalerr_info_table geos::MEM_FREE_BLOCK_DATA_NOT_CC { This error is trigged when ec +heapFree is enabled and indicates that
 something has written outside the bounds of one of its blocks into
 unallocated memory. The system fills free blocks with 0xcc bytes and regularly
 checks all free memory to make certain all the bytes remain 0xcc. es:di-2
 or es:di-1 is the first non-cc byte in the free block (the system checks
 for 0xcccc words, you see). What next? You should look at the data to see
 if they look like anything you might be creating (e.g. a recognizable text
 string), then look at blocks that fall just before the free block to see
 who allocated them and for what purpose, then take a look at the code that
 would be manipulating those blocks and see if they might scribble like
 this.
 }
table enter $fatalerr_info_table geos::ECF_UNLOCK_MOVE_FAILED_SORRY { This indicates that the memory being moved because of ECF_UNLOCK_MOVE being
 set was swapped out and could not be swapped back in again, due to an
 error declared by the swap driver.}
table enter $fatalerr_info_table geos::MEM_REFERENCE_COUNT_NEVER_INITIALIZED {
 MemIncRefCount was called on a block with a refCount of 0 - MemInitRefCount
 was never called on the block
}
table enter $fatalerr_info_table geos::FAKE_BLOCK_DOESNT_COVER_ENTIRE_NEW_HEAP_SEGMENT { A swap driver is attempting to extend the heap with a segment that must
 already part of the heap, as the block that intersects the start of segment
 being added doesn't cover the entire extent of the segment being added.
 }
table enter $fatalerr_info_table geos::LOCKING_DISCARDED_CORE_BLOCK { there's a bad interaction happening between unlockMove/lmemMove EC code and
 some other EC code such that someone is attempting to lock down a core block
 that's in the process of being moved}
table enter $fatalerr_info_table geos::FREEING_ACTIVE_STACK { attempting to free a memory block that is some thread's stack. usually
 this means the reference count for the thread's geode has been hosed.}
table enter $fatalerr_info_table geos::OBJ_BAD_DEREF { You called ObjDerefGen, ObjDeref1 or one of their friends but
 the master offset you are derefing does not have the master offset
 you are derefing.
 i.e. You are using the wrong deref routine.}
table enter $fatalerr_info_table geos::SOMETHING_LEFT_ON_STACK_BEFORE_STACK_SPACE_RETURN { You called ThreadRestoreStackSpace with something left on the stack that you
 pushed after calling ThreadBorrowStackSpace. This is a bozo no no.
 }
table enter $fatalerr_info_table geos::THREAD_STACK_NOT_IN_LIST { The list of thread stack blocks has been corrupted, possibly by someone
 calling HandleP on a geode's dgroup handle.}
table enter $fatalerr_info_table geos::TIMER_BAD_YEAR { TimerSetDateAndTime() was passed a year outside the range (1980-2099)}
table enter $fatalerr_info_table geos::TIMER_BAD_MONTH { TimerSetDateAndTime() was passed a month outside the range (1-12)}
table enter $fatalerr_info_table geos::TIMER_BAD_DAY { TimerSetDateAndTime() was passed a day outside the range (1-31)}
table enter $fatalerr_info_table geos::TIMER_BAD_HOUR { TimerSetDateAndTime() was passed an hour outside the range (0-23)}
table enter $fatalerr_info_table geos::TIMER_BAD_MINUTE { TimerSetDateAndTime() was passed a minute outside the range (0-59)}
table enter $fatalerr_info_table geos::TIMER_BAD_SECOND { TimerSetDateAndTime() was passed a second outside the range (0-59)}
table enter $fatalerr_info_table geos::TIMER_MISSED { There's a bug in the timer code such that a timer with a time-remaining
 of 0 was placed on the timer list. This should not happen. It's not
 your fault :)}
table enter $fatalerr_info_table geos::TIMER_SET_RTC_RETURNED_ERROR { The BIOS call to set the real time clock returned an error.}
table enter $fatalerr_info_table geos::LIBRARY_ENTRY_NUMBER_TOO_LARGE { Calling ProcGetLibraryEntry with an exported-entry number larger than the
 number of entry points exported by the library (si holds requested number).}
table enter $fatalerr_info_table geos::LOADED_GEODE_STILL_UNREFERENCED { You have called GeodeLoad on a driver or library that is not also a process.
 You need to call GeodeUseDriver for a driver or GeodeUseLibrary for a library.
 This will also check the protocol number, which is a Good Thing.}
table enter $fatalerr_info_table geos::UNKNOWN_HANDLE_TYPE_IN_HANDLE_TABLE { FreeGeodeBlocks is running through the handle table and has hit a handle
 that is not one of the known non-memory handles. The handle table has
 been scribbled on.}
table enter $fatalerr_info_table geos::CANNOT_CALL_MOVABLE_ROUTINE_AFTER_FILESYSTEM_SHUT_DOWN { Something in a system driver is attempting to call, during its DR_EXIT
 function, something that's in movable memory. This is not allowed, as all
 open files have been closed, making it impossible to ensure that the
 function in question is in memory (b/c it can't be loaded if it's not).}
table enter $fatalerr_info_table geos::GRAPHICS_CANT_CREATE_ZERO_SIZED_BITMAP { You can't pass zero width or height to GrCreateBitmap}
table enter $fatalerr_info_table geos::GRAPHICS_PATTERN_CUSTOM_PATTERN_TOO_BIG { The custom pattern (either a HatchPattern or Bitmap) is too large to be
 used. A 16K limit is enforced for custom patterns, as these are stored in
 the GState segment.}
table enter $fatalerr_info_table geos::GRAPHICS_HATCH_PATTERN_DELTA_Y_CANT_BE_ZERO { The HL_deltaY is defined to be in the rotated coordinate space of the hatch
 line (although the rotation may be zero), so it never makes sense to
 have a line that continually draws on top of itself.}
table enter $fatalerr_info_table geos::GRAPHICS_MUST_PASS_OD_TO_CREATE_BITMAP { You must pass a non-zero exposure OD to GrCreateBitmap as the object
 that will handle any MSG_META_EXPOSED messages caused by bitblts and the
 like within the bitmap.}
table enter $fatalerr_info_table geos::GRAPHICS_BITMAP_ALREADY_COMPACTED { GrCompactBitmap must be passed an uncompacted bitmap}
table enter $fatalerr_info_table geos::GRAPHICS_BITMAP_MUST_BE_PACKBITS { GrUncompactBitmap must be passed a compacted bitmap in the PackBits format}
table enter $fatalerr_info_table geos::GRAPHICS_CANT_DO_THIS_WITH_COMPACTED_BITMAP { Can't call GrClearBitmap or GrEditBitmap with a compacted bitmap.}
table enter $fatalerr_info_table geos::GRAPHICS_DEFINING_PATH_CANT_SET_DEFAULT_STATE { You shouldn't be calling GrSetDefaultState while defining a path}
table enter $fatalerr_info_table geos::GRAPHICS_UNBALANCED_SAVE_RESTORE_STATE { There is an unbalanced GrSaveState/RestoreState pair.  Perhaps you are
 calling GrNewPage with saved states.}
table enter $fatalerr_info_table geos::GRAPHICS_BITMAP_RESOLUTION_CANT_BE_ZERO { The bitmap resolution stored in the complex bitmap structure is zero,
 an invalid value.  This may mean that the BMT_COMPLEX bit was set
 in the B_type field of the bitmap header when it shouldn't be.}
table enter $fatalerr_info_table geos::GRAPHICS_SENTINEL_FOR_BITMAP_COMPRESSION_CORRUPTED { The sentinel word stored at the end of the buffer used to compress
 a bitmap has been corrupted, indicating an internal error in
 GrCompactBitmap}
table enter $fatalerr_info_table geos::GRAPHICS_SENTINEL_FOR_BITMAP_BUFFER_CORRUPTED { The sentinel word stored at the end of the buffer used for drawing
 complex bitmaps has been corrupted, indicating an internal error in
 either how the size of the buffer was calculated, or how someone is
 writing into the buffer.}
table enter $fatalerr_info_table geos::GRAPHICS_POLYLINE_SPECIAL_SHOULDNT_HAVE_FAILED { A call to CheckThinLine() indicated a fat line would be drawn, but
 PolylineSpecial returned that a thin line would actually suffice. The
 logic to determine a thin line must be the same in each of these routines.}
table enter $fatalerr_info_table geos::FONTMAN_FIND_OUTLINE_DATA_CALLED_WITH_BITMAP_FONT { FontDrFindOutlineData() was called with a bitmap font.  It is
 intended for use by font drivers, and therefore should only
 be called for fonts that have outline font data available.}
table enter $fatalerr_info_table geos::FONTMAN_BAD_ENUM_FLAG_PASSED_TO_IS_FONT_AVAIL { GrCheckFontAvail() cannot alphabetize fonts.}
table enter $fatalerr_info_table geos::FONTMAN_BAD_FONT_INFO_FOR_ADD_FONT { GrAddFont() was called with a bogus FontInfo() entry.}
table enter $fatalerr_info_table geos::FONTMAN_FONT_FILE_DELETED { The font file was deleted between the time it was first used and
 the time the font manager attempted to reload a font from it.
 This probably indicates a bug in the font manager.}
table enter $fatalerr_info_table geos::FONTMAN_COULDNT_OPEN_FONT_FILE { The font file couldn't be opened to reload a font from it.
 This probably indicates a bug in the font manager.}
table enter $fatalerr_info_table geos::FONTMAN_BAD_FONT_FILE_READ { The file read of the font file failed.
 This probably indicates a trashed font file.}
table enter $fatalerr_info_table geos::FONTMAN_FONT_DRIVER_NOT_FOUND { The font driver for this font couldn't be found.
 Is the driver specified in the geos.ini file?
 Is the (correct version of) the driver in the SYSTEM\FONT directory?}
table enter $fatalerr_info_table geos::FONTMAN_NEED_FEF_OUTLINES_OR_FEF_BITMAPS { GrCheckFontAvail() and GrEnumFonts() need at least one of
 FEF_OUTLINES or FEF_BITMAPS set in the FontEnumFlags, otherwise no
 fonts will ever match.}
table enter $fatalerr_info_table geos::FONT_INIT_NO_POINTSIZE_FOUND { No pointsize could be found for the default font.  Something may
 be wrong with the file of the default font, such as a bad header.}
table enter $fatalerr_info_table geos::FONT_INIT_IN_USE_CHUNK_NOT_EMPTY { The FontsInUse chunk was not empty during initialization.  Something
 is probably wrong in GrInitDefaultFont() or GrInitFonts().}
table enter $fatalerr_info_table geos::FONT_BAD_WEIGHT { You should not use FontWeights in the range FW_ULTRA_LIGHT to FW_BLACK.
 These are provided for backwards compatibility only.}
table enter $fatalerr_info_table geos::FONTMAN_FILE_CACHE_CORRUPTED { The font file cache was somehow corrupted (eg. a font in the cache
 didn't exist, was listed in the cache twice, etc.)}
table enter $fatalerr_info_table geos::WIN_INPUT_OBJ_MUST_BE_RUN_BY_SAME_THREAD_AS_GEODE_INPUT_OBJ { This is an error that WinOpen generates if the passed "InputOD" & "owner"
 for geode are not compatible.  Any non-NULL InputOD passed must be run by the 
 same thread as runs the owner-to-be's geode's input object, by default
 the geode's GenApplication object.  This is necessary not because of a kernel
 requirement, but because GenApplication expects to be able to call any
 InputOD of a window that it has received input for.}
table enter $fatalerr_info_table geos::WIN_ERROR_MOVING_WINDOW_ALREADY_IN_BACK_TO_BACK { A window or window layer, after being moved to the back, was found to have
 no siblings to its/their right before beingmoved.  Code earlier in the
 routine is supposed to have bailed out in this case with nothing to do.}
table enter $fatalerr_info_table geos::WIN_BAD_ASSUMPTION { Bad assumption internal to window system code}
table enter $fatalerr_info_table geos::OBJ_FLUSH_INPUT_QUEUE_BAD_NEXT_STOP { Result of default MetaClass handler for MSG_META_OBJ_FLUSH_INPUT_QUEUE being
 called with bogus ObjFlushInputQueueNextStop value}
table enter $fatalerr_info_table geos::OBJ_ILLEGAL_REFERENCE_TO_DYING_OBJECT_BLOCK { Object block being tested has had MSG_META_BLOCK_FREE or ObjFreeObjBlock
 called on, is no longer marked as "in use", & will be nuked from memory the
 moment the queues have finished being flushed.  The current operation being
 performed requires this NOT to be the case.  One example is "WinClose", which
 requires that the exposureObj & inputObj's not already be dying.  This can
 be corrected by first closing the window, or changing its inputObj or
 exposureObj to NULL, & THEN destroying the object, or object block.

 More in-depth info:  This error checking routine
 is called by the system when it is about to start another queue-flushing
 sequence to an object, to make sure that it's going to be around to be able
 to receive the message -- if the block's about to be freed within one 
 queue flush, then the new flush doesn't stand any chance of being able to
 finish without crashing.
 }
table enter $fatalerr_info_table geos::OWNER_CORE_BLOCK_NOT_LOCKED { The kernel is unrelocating a handle and has found that the core block for
 the owner of the block being unrelocated is not, in fact, locked.
}
table enter $fatalerr_info_table geos::VM_FILE_MUST_BE_CLOSED_WITH_VM_CLOSE { A geode tried to close a VM file by calling FileClose instead of VMClose.
 This often happens if a geode has a VM file open, and exits without closing
 it.}
table enter $fatalerr_info_table geos::ATTEMPTED_TO_PERFORM_UNSUPPORTED_FUNCTION_BEFORE_APPROPRIATE_IFS_DRIVER_WAS_LOADED { The skeleton IFS driver was called to perform a function it does not support.
 The likeliest cause is that the proper filesystem driver for the drive in
 question didn't get loaded (i.e. it was missing from the system::fs key in
 the .ini file)}
table enter $fatalerr_info_table geos::INVALID_FSDRIVER_OFFSET { Called FSDUnregister with an offset that's not a registered FS driver, as
 returned by FSDRegister.}
table enter $fatalerr_info_table geos::FSIR_MAY_NOT_BE_LOCKED { FileGetDestinationDisk has been called with the FSInfoResource locked in
 some way. This can lead to deadlock, however, when the disk for a drive
 specifier is registered.
 }
table enter $fatalerr_info_table geos::VM_BLOCK_DIRTY_WHEN_IT_SHOULD_NOT_BE { This seems to indicate that you ran out of disk space.}
table enter $fatalerr_info_table geos::VM_READ_FILE_WORD_ERROR { A call to VMFileReadWord() returned an error.  Given that this is simply
 doing a file pos, and then reading from a portion of the VM header which
 is assumed to exist, an error is a bad thing.  See Tony.}
table enter $fatalerr_info_table geos::VM_ATTACH_BLOCK_CANNOT_BE_DETACHABLE { A block that is passed to VMAttach must be NOT_DETACHABLE, so as to avoid
 confusing the application state file mechanism, which will expect to be able
 to save the block to the state file when the application is detached.

 The NOT_DETACHABLE attribute can be set in a .ui file with
 "start Resource, notDetachable" or in a .goc file with
 "@start Resource, notDetachable;"}
table enter $fatalerr_info_table geos::VMEM_GENERIC_OBJECTS_CANNOT_BE_UPDATED_ASYNCHRONOUSLY { The file whose handle is in BX has VMA_COMPACT_OBJ_BLOCK set without
 having VMA_SYNC_UPDATE set. This is illegal, as it implies that whenever
 a block containing generic objects is off-screen, it can be compacted,
 thereby losing all non-save-to-state vardata and other things that could
 well be vital to bringing the objects back on-screen.
}
table enter $fatalerr_info_table geos::CANNOT_TRUNCATE_MULTI_REFERENCED_VM_FILE { Someone has called VMTruncateAndClose for a VM file that has been opened
 by more than one application. Since VMTruncateAndClose is an extremely
 destructive operation, rendering the VM file invalid, the kernel refuses to
 perform it unless it knows only one process is using the file.}
table enter $fatalerr_info_table geos::DB_UNGROUP_NOT_LOCKED { VMMarkUngroupAvail has been called passing the handle of a group block that's
 not locked. This is illegal, as the handle for the block could go away at
 any time... this is an internal error in the kernel DB code.}
table enter $fatalerr_info_table geos::UNGROUPED_GROUP_MAY_NOT_BE_PASSED_AS_AN_EXPLICIT_GROUP { DBAlloc was called passing a group in AX that is a member of the set of
 groups used to satisfy requests for DB_UNGROUPED allocations. For various
 reasons, this is against the rules. Use DB_UNGROUPED instead, or create your
 own group (if you need to have items end up in the same group, for some
 reason).}
table enter $fatalerr_info_table geos::BAD_CLASS { This error happens frequently when an object or object block is freed before
 a message in the queue destined for it is delivered.  Always use as high a
 level of object/block destruction mechanism as you can -- The highest
 object-level routine in the UI is MSG_GEN_DETROY, in vis, MSG_VIS_DESTROY.
 Lower is MSG_META_OBJ_FREE, which first flushes queues after which a 
 MSG_META_FINAL_OBJ_FREE is sent to the object.  The handlers for this last
 message are allowed to use ObjFreeChunk & LMemFree.  On the block side,
 once all objects within the block have been taken out of any tree they
 resided in, MSG_META_BLOCK_FREE & ObjFreeObjBlock are the high-level
 message/routine to use.  MSG_META_FINAL_BLOCK_FREE ends up being called only
 after the queues have been flushed out, which in turn is allowed to actually
 nuke the block.
}
table enter $fatalerr_info_table geos::BAD_RELOCATION_CANNOT_FIND_VM_HANDLE { This means some unrelocated handle indicates it should be set from the
 handle for some VM block, but the block holding the unrelocated handle
 is not in a VM file, nor is the VM block handle for a valid block from a
 state file. As a result, the kernel hasn't a clue what to relocate the
 unrelocated handle to.

 If you free a VM block in a document after some object that refers to that
 block has been written to the VM file, you'll get this when the object
 gets brought back into memory.

 More likely, if you detach after running something that restored from state
 for a while, the state file could well have been written out with the
 state block for a duplicated block having been freed from the state file. The
 state block for a non-duplicated resource will remain in the file, however,
 so you'll die with this error. The only thing to do is delete the state
 file and start over.
}
table enter $fatalerr_info_table geos::LMEM_BAD_INSERT_OFFSET { LMemInsertAt() was passed a bad offset.  The offset passed should
 be the offset from the start of the chunk you are inserting in.}
table enter $fatalerr_info_table geos::LMEM_BAD_DELETE_OFFSET { LMemDeleteAt() was passed a bad offset.  The offset passed should
 be the offset from the start of the chunk you are deleting in.}
table enter $fatalerr_info_table geos::LMEM_BAD_DELETE_SIZE { LMemDeleteAt() was passed a bad size.  The passed size to delete was
 larger than the existing chunk.}
table enter $fatalerr_info_table geos::LMEM_BAD_DELETE_COMBINATION { LMemDeleteAt() was passed a bad offset/size comibination.  The offset
 plus the size extends beyond the end of the chunk.}
table enter $fatalerr_info_table geos::OBJ_BLOCK_BAD_IN_USE_COUNT { Each object block contains an "in-use" count, which is stored in the
 ObjLMemBlockHeader (The field is OLMBH_inUseCount).   The count starts out
 as 0, indicating objects are not active, climbs during usage, & must return
 to 0 before the block may be destroyed.  If you've gotten this error, it
 is because the count went negative, or became far to large to be a reasonable
 value.  The most common cause of this is intercepting & not passing on
 to the superclass a method which inc/decs this count.

 So, which methods might these be?  The count is incremented each time
 an object becomes active in some new way in the system, & is decremented
 each time an object is no longer active in that way.  Currently, there
 are the following pairs:

	1) Incremented whenever a window is created for visible objects having
	   the VTF_IS_WINDOW bit, & decremented in the default handler for
	   MSG_META_WIN_DEAD. 

	2) Inc in MSG_META_OBJ_FREE (sent when objects are being destroyed)/
	   Dec in MSG_META_FINAL_OBJ_FREE (sent out after queues interacting with
	   object have been cleared)

 	3) New object classes are free to inc/dec this count as well, using
 	   ObjIncInUseCount & ObjDecInUseCount, but must do so in pairs, or this
          fatal error may be the result.

 Also -- note that if a decrement does not occur for each increment, then
 the count never reaches zero, resulting in the block never getting free/
 application never exiting.}
table enter $fatalerr_info_table geos::OBJ_BAD_IN_USE_COUNT { Indicates if in-use count has gone negative for this particular object (The
 EC code only keeps track of the in-use count on a per-object basis).  See
 above OBJ_BLOCK_BAD_IN_USE_COUNT for more info.}
table enter $fatalerr_info_table geos::OBJ_BLOCK_BAD_INTERACTIBLE_COUNT { Each object block contains an "interactible" count, which is stored in the
 ObjLMemBlockHeader (The field is OLMBH_interactibleCount).   The count
 starts out as 0, & becomes non-zero as objects in the block become visible,
 or need to have current status information reflected in their state.
 GenControl objects are not updated unless this value is non-zero.  This
 error occurs only if the value goes negative, which should never happen,
 as the count should only be changed by in/dec pairs.

 So, which methods might these be? Currently, there are the following pairs:

	1) Incremented whenever a window is created for visible objects having
	   the VTF_IS_WINDOW bit, & decremented in the default handler for
	   MSG_META_WIN_DEAD. }
table enter $fatalerr_info_table geos::OBJ_BAD_INTERACTIBLE_COUNT { Indicates if interactible count has gone negative for this particular object
 (The EC code only keeps track of the interactible count on a per-object
 basis).  See above OBJ_BLOCK_BAD_INTERACTIBLE_COUNT for more info.}
table enter $fatalerr_info_table geos::OBJ_RELOCATION_TO_INVALID_LIBRARY_NUMBER { The application is probably restoring from state and one of its libraries,
 or its libraries' libraries exports an object class an instance of which
 was saved to state, but now one of the libraries or libraries' libraries
 has changed what libraries it imports without having increased the
 protocol number, so the state file is invalid.}
table enter $fatalerr_info_table geos::BAD_TABLE_SIZE_PASSED_TO_OBJ_VAR_SCAN_DATA { The # of VarDataHandlers passed to ObjVarScanData is unreasonable (0, or
 very large)}
table enter $fatalerr_info_table geos::BAD_SIZE_PASSED_TO_OBJ_VAR_ADD_DATA { Size of extra data passed to ObjVarAddData is unreasonably large}
table enter $fatalerr_info_table geos::CLASS_AT_DS_SI_MARKED_NEVER_SAVED_SO_WHY_AM_I_RELOCATING_OR_UNRELOCATING_IT_BUB? { One of the classes of an object that's in a resource or being saved to state
 or a VM file has been marked as NEVER_SAVED, when in fact it is. The
 programmer has been a boob.
 }
table enter $fatalerr_info_table geos::OBJ_SHUTDOWN_OR_DETACH_WHILE_OTHER_STILL_ACTIVE { ObjInitDetach was called for an object while a previous MSG_META_DETACH or
 MSG_META_APP_SHUTDOWN was still active for the object, and the message
 passed to ObjInitDetach is different from when ObjInitDetach was first called
 for the object (e.g. a MSG_META_APP_SHUTDOWN was received before the object
 sent MSG_META_ACK back to the object that sent it a MSG_META_DETACH). You
 might also have trashed AX before calling ObjInitDetach, so it didn't
 receive the message number your object actually received.}
table enter $fatalerr_info_table geos::FSD_LOADED_BUT_NOT_REGISTERED {	When restoring a disk handle, was able to find the core block for
	the IFS driver, but not its  FSDriver record. Likely the FSDriver
	chain has been corrupted.
}
table enter $fatalerr_info_table geos::SAVED_DISK_HAS_NO_DRIVE_SPECIFIER_FOR_DRIVE_NAME {	When trying to locate the drive for a saved disk handle, we
	were told the saved drive name, which should always be a name followed
	by a colon (aka a drive specifier), had no drive specifier. Either
	DiskSave screwed up or, more likely, the saved data have been corrupted
	by the application.
}
table enter $fatalerr_info_table geos::DRIVE_NOT_LOCKED_EXCLUSIVE {	You are attempting to release exclusive access on a drive that is
	marked as being locked for shared access.
}
table enter $fatalerr_info_table geos::INK_ENUM_EXCEEDED_END_OF_BUFFER { We tried to terminate a line segment, but there were no points in the
 point buffer.
}
table enter $fatalerr_info_table geos::NUM_INK_POINTS_IS_ZERO { We are sending ink off, and the # points is 0. This shouldn't happen.}
table enter $fatalerr_info_table geos::INK_Y_COORD_IS_NEGATIVE { Somehow, an ink point had a negative Y coord
}
table enter $fatalerr_info_table geos::CANNOT_DELETE_MORE_POINTS_THAN_EXIST { For some strange reason, the code tried to delete more points from the
 input manager ink buffer than actually existed.}
table enter $fatalerr_info_table geos::INK_DATA_EXCEEDED_BOUNDS_OF_BUFFER { More ink points have been stored in the ink buffer than should be able
 to fit.}
table enter $fatalerr_info_table geos::NO_INK_GSTATE { MSG_IM_INK_REPLY was received but there was no inkGState for some reason
}
table enter $fatalerr_info_table geos::IM_ERROR_BAD_PTR_IMAGE_VALUE { Indicates that ImSetPtrImage was called with cx = 0, but dx was not set
 to a legal PtrImageValue.
}
table enter $fatalerr_info_table geos::IM_MEMLOCK_FAILURE { Internal IM problem}
table enter $fatalerr_info_table geos::IM_BAD_SETPTR_PARAMS { Internal IM problem}
table enter $fatalerr_info_table geos::IM_MONITOR_ALREADY_IN_MONITOR_CHAIN { You have attempted to call ImAddMonitor passing a Monitor structure that
 is already in the monitor chain. You need to have called ImRemoveMonitor
 on the Monitor before you can add it back in again.}
table enter $fatalerr_info_table geos::DB_NO_MAP_BLOCK { The groups free list contains a bad ptr.
 The free-list holds a non-free block.}
table enter $fatalerr_info_table geos::GCN_BAD_USAGE_COUNT { Result of NDBH_usageCount within a NotificationDataBlock having an
 abnormally large number in it.}
table enter $fatalerr_info_table geos::GCN_UNRELOCATING_GCN_LIST_WITH_UNOWNED_OPTR { Cannot unrelocate a GCN list with optrs that are owned by someone other than
 the owner of the GCN list itself.}
table enter $fatalerr_info_table geos::FSD_ES_ISNT_SHARED_FSIR { A routine was expecting FSInfoResource to have been locked shared and
 its segment loaded into ES.
}
table enter $fatalerr_info_table geos::OVS_BAD_HANDLER_TABLE { The pointer passed to ObjVarScanData does not point to a valid
 VarDataHandlerTable or VarDataCHandlerTable.
}
table enter $fatalerr_info_table geos::OVS_SIZE_OF_VAR_DATA_ENTRIES_GREATER_THAN_VAR_DATA_AREA { The variable data storage area of the object has been corrupted -- the
 sum of the sizes of the individual entries exceeds the total size of the
 variable data storage area.
}
table enter $fatalerr_info_table geos::OVS_CORRUPTED_VAR_DATA_ENTRY { The VDE_entrySize field was 0, which is illegal.  This field must
 be at least (size VDE_entrySize + size VDE_dataType).
}
table enter $fatalerr_info_table geos::OVS_VAR_DATA_HANDLER_CHANGED_DATA_ENTRY { A VarDataHandler or VarDataCHandler has changed the data entry it is
 handling.  This is illegal.  A VarDataHandler or VarDataCHandler is not
 allowed to change the data entry or add or remove data entries.

 A data entry size of 0 or 2 was passed to ObjVarAddDataEntry.
 ObjVarAddDataEntry is only used to add a data type with extra data.  If a
 data type with no extra data is to be added, use ObjVarAddDataType.
}
table enter $fatalerr_info_table geos::OVS_BAD_MSG_META_INITIALIZE_VAR_DATA_HANDLER { MSG_META_INITIALIZE_VAR_DATA has been called on an object to get a 
 particular variable data type created & initialized, and ds:ax has NOT
 been returned, as is required, pointing to the extra data of the new
 data entry (Should match return value of ObjVarFindData for the given
 data type)
}
table enter $fatalerr_info_table geos::OVS_VAR_DATA_HANDLER_ADDED_OR_REMOVED_DATA_ENTRY { After calling a VarDataHandler or VarDataCHandler, the size of the vardata
 area for the object has changed.  It is not allowed for a handler to do
 anything which can cause this to happen, such as add or remove vardata
 entries to/from the current object.  For this reason, it is also not 
 advisable to make any message calls from within a handler, unless it is
 known that no current or future handlers for that message would be adding/
 removing vardata entries to/from this object.
 }
table enter $fatalerr_info_table geos::BAD_DETACH_MSG { ObjInitDetach was called with AX != MSG_META_DETACH or MSG_META_APP_SHUTDOWN}
table enter $fatalerr_info_table geos::META_INTERNAL_QUIT_PROBLEM { Internal quit problem, consult a physician}
table enter $fatalerr_info_table geos::NON_SEMAPHORE_PASSED_TO_SEM_ROUTINE { A non-semaphore handle was passed to ThreadPSem/VSem
}
table enter $fatalerr_info_table geos::NO_VIDEO_DRIVER_LOADED_YET { The system tried to make a call to the video driver before it was
 loaded.
}
table enter $fatalerr_info_table geos::PROCESS_CLASS_ASKED_TO_SEND_TO_OBJ_BLOCK_OUTPUT { This is not allowed.  Find out who is sending what event to where and
 make sure it is correct.
}
table enter $fatalerr_info_table geos::CANNOT_CALL_GEODE_PRIV_WRITE_ON_KERNEL_GEODE { It is not allowed to write data to the kernel geode priv area.
}
table enter $fatalerr_info_table geos::TIMER_VALUE_SLOWER_THAN_60_HZ { Due to a problem with the timer routine, someone wanted to program
 the timer to generate the next interrupt at an interval larger
 than 60 times a second.}
table enter $fatalerr_info_table geos::C_METHOD_HANDLER_TRASHED_DI { A C message handler returns DI as the "MethodParameterDef", which contains
 information about what kind of data is being returned by the handler, and
 how to map that data into the appropriate registers. This FatalError is
 hit if an invalid type is returned in DI. This usually means that DI was
 changed by the method handler.}
table enter $fatalerr_info_table geos::BAD_C_METHOD_PARAMETER_DEF { This usually means that the parameter data stored in a class' method
 table has been trashed somehow.
}
table enter $fatalerr_info_table geos::FILE_STANDARD_PATH_DIRECTORY_INVALID_STANDARD_PATH { Either FileAddStandardPathDirectory() or FileDeleteStandardPathDirectory()
 was passed a value for a StandardPath that is not a valid StandardPath.}
table enter $fatalerr_info_table geos::FILE_STANDARD_PATH_DIRECTORY_INVALID_PATH_STRING { Either FileAddStandardPathDirectory() or FileDeleteStandardPathDirectory()
 was passed a string for the path that was ridicuously long, and therefore
 probably not the string the caller had in mind.}
table enter $fatalerr_info_table geos::VMO_OPEN_AND_VMO_NATIVE_WITH_EXT_ATTRS_NOT_ALLOWED { You can not pass VMO_OPEN and VMO_NATIVE_WITH_EXT_ATTRS_NOT_ALLOWED
 as the flags to VMOpen. You can only use VMO_NATIVE_WITH_EXT_ATTRS_NOT_ALLOWED
 with the VMO_CREATE* options}
table enter $fatalerr_info_table geos::VMO_TEMP_FILE_AND_VMO_NATIVE_WITH_EXT_ATTRS_NOT_ALLOWED { You can not pass VMO_TEMP_FILE and VMO_NATIVE_WITH_EXT_ATTRS_NOT_ALLOWED
 as the flags to VMOpen. You can only use VMO_NATIVE_WITH_EXT_ATTRS_NOT_ALLOWED
 with the VMO_CREATE* options}
table enter $fatalerr_info_table geos::OBJECT_PASSED_TO_ObjCallSuperNoLock_IS_NOT_OF_PASSED_CLASS { The object passed to ObjCallSuperNoLock is not of the class passed to
 ObjCallSuperNoLock.	
}
table enter $fatalerr_info_table geos::COORDINATE_VALUE_OVERFLOW { The X coord of the current point was out of bounds (more than +/-32767) after
 the brush width was subtracted. The brush width may have been invalid.}
table enter $fatalerr_info_table geos::PTR_EVENT_WITH_NEGATIVE_COORDINATE { A pointer event with a negative coordinate came in to the ink collection
 code - this should not be possible, as we force all events to conform to
 the screen bounds - perhaps a memory trashing bug destroyed screenXMin/Max
 or screenYMin/Max?}
table enter $fatalerr_info_table geos::INK_NUM_STROKES_MUST_BE_NON_ZERO { The # ink strokes was non-zero when it should not have been. This can
 only happen if one of the points in the ink data had the high bit set
 (signifying the end of an ink stroke), but the collection code never
 set it (perhaps a memory trashing bug)?}
table enter $fatalerr_info_table geos::INVALID_MSG_PASSED_TO_INK_REPLY_HANDLER { An invalid value in AX was passed to InkReplyHandler - I have no idea how
 this could happen}
table enter $fatalerr_info_table geos::CANNOT_DISCARD_DUPLICATED_BLOCK { You cannot discard a duplicated block, as the system has no idea where to
 read the data in from when you lock it.}
table enter $fatalerr_info_table geos::CANNOT_DISCARD_NON_OBJ_BLOCK { MSG_PROCESS_OBJ_BLOCK_DISCARD only works on LMem blocks of type
 LMEM_TYPE_OBJ_BLOCK.}
table enter $fatalerr_info_table geos::CANNOT_DISCARD_BLOCK_THAT_IS_IN_USE { The OLMBH_inUseCount was non-zero in the block passed to
 MSG_PROCESS_OBJ_BLOCK_DISCARD}
table enter $fatalerr_info_table geos::CANNOT_DISCARD_ALLOCATED_OBJ_BLOCK { The passed obj block had the OLMBH_resourceSize field set to 0, which
 signifies that the block was not read from a resource, and so cannot
 be discarded.}
table enter $fatalerr_info_table geos::TOTAL_HEAP_SPACE_IN_USE_EXCEEDED_64_MEGS { For some reason the amout of heapspace in use by all apps was calculated
 to exceed 64 megs - unless some magical system has 64 megs of heap space,
 this is likely due to some other error, like memory trashing.}
table enter $fatalerr_info_table geos::ILLEGAL_INIT_FILE_STRING { Strings in a DBCS GEOS.INI file are stored as a string of hex digits.
 Either an illegal character was found (non-hex) or the string was not
 a multiple of 4 characters long.}
table enter $fatalerr_info_table geos::UNCONVERTABLE_DOS_CHARACTER_FOR_BOOT { A character value > 127 was found at boot time, when certain strings
 need to be converted from DOS to GEOS before the FSD has been loaded.}
table enter $fatalerr_info_table geos::UNCONVERTABLE_GEOS_CHARACTER_FOR_SKELETON_FSD { A character value > 127 was passed to the skeleton FSD.  This is the
 kernel's file system driver that it uses to load the real FSD, and
 until the real FSD is loaded, non-ASCII characters cannot be used.}
table enter $fatalerr_info_table geos::CHARACTER_VALUE_TOO_LARGE { A character value > 255 was encountered.  Internally to the kernel,
 single-byte strings are used for certain operations.}
table enter $fatalerr_info_table geos::FUNCTION_NOT_SUPPORTED_IN_DBCS { A function that is not used in DBCS was called.}
table enter $fatalerr_info_table geos::ILLEGAL_CHAR_TYPE_TABLE { There is an error in a CharTypeTable used by the LocalIsAlpha(), etc.
 routines.  Either an entry is out of order or illegal flags are set.}
table enter $fatalerr_info_table geos::ILLEGAL_CHAR_CASE_TABLE { There is an error in a CharCaseTable used by the LocalUpcaseChar(), etc.
 routines.  Either an entry is out of order or illegal flags are set.}
table enter $fatalerr_info_table geos::ILLEGAL_CHAR_SORT_TABLE { There is an error in a CharSortTable used by LocalCmpStrings(), etc.
 routines.  Either an entry is out of order or illegal flags are set.}
table enter $fatalerr_info_table geos::FONTMAN_FONT_BUF_CORRUPTED { There is a FontBuf in memory which has been corrupted.  This is likely
 either a memory-trashing bug from any part of the system, or depending
 on when the corruption was found, possibly a bug in a particular font
 driver.}
table enter $fatalerr_info_table geos::LOCAL_TOO_MANY_KINSOKU_CHARS { LocalSetKinsoku() was called with too long of a string.  The maximum
 number of characters permitted is MAX_KINSOKU_CHARS.}
table enter $fatalerr_info_table geos::EMMXIP_EMM_ERROR { The EMM driver used to map in XIP resources returned an error from one
 of its calls}
table enter $fatalerr_info_table geos::INVALID_XIP_RESOURCE_OFFSET { The offset of an XIP resource did not lie on a paragraph boundary}
table enter $fatalerr_info_table geos::ILLEGAL_PREALLOCATED_COREBLOCK_HANDLE { The geode handle preallocated for the first coreblock in the system lies
 in the range of handles that lie in the XIP image, which is illegal. This
 usually happens if the primary file system driver is present in the XIP
 image, but a version is on the disk as well, so the kernel tries to use
 the version on the disk, even though it has the coreblock handle of the
 XIP version stuffed in its GH_geodeHandle field.

 The solution is to either remove the FSD from the disk, or if you are
 debugging a file system driver, you need to remake a version of the
 XIP image that does not have the file system driver in it.}
table enter $fatalerr_info_table geos::COULD_NOT_DISCARD_COREBLOCK { For some reason, we could not discard the coreblock for a geode when
 freeing the geode.}
table enter $fatalerr_info_table geos::PRE_LOADING_NON_FIXED_RESOURCE_IN_XIP_GEODE { Somehow a resource snuck into the XIP image that was not fixed, and
 yet was not marked discarded, and so the system tried to preload it}
table enter $fatalerr_info_table geos::FREEING_XIP_RESOURCE { A resource in an XIP geode is being freed (this isn't allowed, as XIP
 handles should never be freed.}
table enter $fatalerr_info_table geos::XIP_FAR_POINTER_PASSED_TO_MOVABLE_XIP_RESOURCE { A routine in a movable XIP resource was passed a far pointer to
 another movable XIP resource.  This is bad as the previous mocable
 XIP resource is probably paged out, rendering the pointer invalid.}
table enter $fatalerr_info_table geos::SYS_COPY_TO_STACK_ERROR_BOTTOM_OF_STACK_MANGLED { A parameter block was copied to the base of the stack, but when it was
 to be freed, the token stored at the end of the parameter block was
 not what we expected, indicating someone is destroying the parameter
 stack (and thus the base of the stack).}
table enter $fatalerr_info_table geos::SYS_COPY_TO_STACK_ERROR_NO_RESTORE_REGS_ROUTINE { No routine was specified to restore registers after doing a SysCopyToStack.
 Most likely, someone called SysRemoveFromStackPreserveRegs after calling
 SysCopyToStack, not SysCopyToStackPreserve<regs>.}
table enter $fatalerr_info_table geos::HANDLE_TO_ID_PASSED_NON_RESIDENT_COREBLOCK { If we pass a coreblock handle to HandleToID, something is hideously wrong, as
 we should change the caller to detect coreblock handles and do something
 special with them.}
table enter $fatalerr_info_table geos::HEAP_END_COMES_AFTER_START_OF_XIP_READ_ONLY_RESOURCES { On XIP systems, the read-only resources are assumed to lie after the heap.}
table enter $fatalerr_info_table geos::XIP_PAGE_NUMBER_NOT_IN_VALID_RANGE { The page number passed to ECCheckXIPPageNumber was not valid for the
 given device.}
table enter $fatalerr_info_table geos::XIP_MAP_ERROR { The system tried to map in the InitGeos code, but did not find the special
 tag value it expects. This is likely because of a bug in MapInXIPResource.}
table enter $fatalerr_info_table geos::CANNOT_LOAD_XIP_GEODE_ON_NON_XIP_SYSTEM { An XIP geode was loaded by a non-XIP kernel.}
table enter $fatalerr_info_table geos::FAR_POINTER_TO_MOVABLE_XIP_RESOURCE { It is not kosher to pass a pointer to a movable XIP resource, as it could
 be mapped out if the routine you pass it to is in the XIP image as well,
 and is in movable memory.}
table enter $fatalerr_info_table geos::RELOCATING_XIP_GEODE { A resource from a geode marked as being XIPed is being relocated, which
 should never happen.}
table enter $fatalerr_info_table geos::LOADING_XIP_RESOURCE_FROM_NON_XIP_GEODE { A resource in an XIP geode has a handle in the range of handles used by
 the XIP image.}
table enter $fatalerr_info_table geos::MAPPING_HANDLE_OUTSIDE_OF_XIP_IMAGE { We are trying to map in a handle that does not lie in the XIP image}
table enter $fatalerr_info_table geos::FONT_ADD_FAILED { The it seemed the font file was added, but it did not appear on
 the FontsAvailList.  Indicates a bug in the font manager.}
table enter $fatalerr_info_table geos::SEGMENT_PASSED_TO_LOAD_RESOURCE_LOW_NOT_IN_HEAP { LoadResourceLow was passed a segment value outside the bounds of the heap.
 This can happen if someone tries to load a fixed read-only XIP resource.}
table enter $fatalerr_info_table geos::DISABLE_APO_COUNT_OVERFLOW { count that keeps track of how many requests to disable the auto
 power off feature have been made, has overflowed.
 SysEnableAPO or SysDisableAPO have been called in a sequence such
 that the counter has overflowed.
 MSG_GEN_APPLICATION_MARK_APP_COMPLETELY_BUSY and  
 MSG_GEN_APPLICATION_MARK_BUSY call SysDisableAPO and 
 ..._MARK_NOT_BUSY and .._MARK_APP_NOT_COMPLETELY.. call SysEnableAPO}
table enter $fatalerr_info_table geos::PATCH_FILE_ERROR { The Patch file contains invalid information}
table enter $fatalerr_info_table geos::CLASS_MUST_BE_IN_FIXED_RESOURCE {A object's class structure was not in a fixed resource}
table enter $fatalerr_info_table geos::FONTMAN_FONT_HAS_NEGATIVE_REFERENCE_COUNT { The reference count on a font has gone negative.  This generally means
 that either the mechanism for reference counts on fonts is not working
 correctly, or someone has done something illegal like free a GState
 directly.}
table enter $fatalerr_info_table geos::GRAPHICS_ILLEGAL_TEXT_MISC_MODE_BITS_SET { Unused bits in the TextMiscModeFlags in a GState were non-zero.
 Probably indicates in a problem in GrSetTextSpacePad() or the text object.}
table enter $fatalerr_info_table geos::MSG_META_EXPOSED_NOT_HANDLED_ON_INPUT_MANAGER_THREAD { An FEP or similar driver has opened a window with the expose OD set
 to the input manager thread.  In such situations, the FEP is required
 to handle and consume all MSG_META_EXPOSED events that arrive on the
 IM thread for any such windows.  This means the FEP must have an
 InputMonitor active before any such windows are opened.}
table enter $fatalerr_info_table geos::LMEM_INVALID_BLOCK_SIZE { The LMBH_blockSize field didn't match the true size of the block}
table enter $fatalerr_info_table geos::PATCH_FILE_NAME_ERROR { A patch filename is invalid in some way.}
table enter $fatalerr_info_table geos::RESOURCE_NOT_SNATCHABLE { GeodeSnatchResource cannot load dgroup or the core block}
table enter $fatalerr_info_table geos::LMF_IN_RESOURCE_FLAG_SET_ON_NON_OBJECT_BLOCK { The LMF_IN_RESOURCE flag should only be set on object blocks}
table enter $fatalerr_info_table geos::DISCARDING_VM_BLOCK_INCORRECTLY { VM blocks should be discarded via the VM system, but this one
 is being discarded by DoDiscard, which doesn't update the VMHeader.}
table enter $fatalerr_info_table geos::ILLEGAL_RESERVATION { Either an app called GeodeRequestSpace, or a "reservation handle" was
 trashed.}
table enter $fatalerr_info_table geos::ODD_LMEM_TOTAL_FREE_SIZE { LMem blocks are not allowed to be odd.  This can mean that someone somewhere
 is trashing these elements of a local heap.
}
table enter $fatalerr_info_table geos::NO_PEN_SUPPORT_IN_THIS_KERNEL { Someone is trying to use the pen support in the kernel, despite the fact
 that the NO_PEN_SUPPORT flag has been turned on}
table enter $fatalerr_info_table geos::STRING_SORT_STACK_CAN_ONLY_HAVE_TWO_STRINGS { On removing the strings copied to the stack to translate special
 characters, two is the maximum number.}
table enter $fatalerr_info_table geos::NOT_ENOUGH_HEAPSPACE_TO_LOAD_UI { There is not enough heapspace to load the UI geode, so something has gone
 tragically awry...}
table enter $fatalerr_info_table geos::VM_CANT_GRAB_BLOCK_SO_DISCARD_FAILED { A VM block is locked by another thread and can't be grabbed exclusively
 by this thread which wants to discard it.  VMDiscardDirtyBlocks will
 fail, leaving the file in a bad state.
}
table enter $fatalerr_info_table geos::XIP_RESOURCE_LEFT_LOCKED_WHEN_GEODE_EXITED { A resource in the XIP image was left locked when the geode exited}
table enter $fatalerr_info_table geos::INVALID_HANDLE_FLAGS_STORED_IN_XIP_IMAGE { Invalid bits were set in the flags for the handles of a geode in the XIP
 image}
table enter $fatalerr_info_table geos::RESIDENT_RESOURCE_BEING_CHANGED_TO_BE_DISCARDED { A resident resource was being marked "discarded", which is illegal}
table enter $fatalerr_info_table geos::INVALID_HANDLE_SIZE_STORED_IN_XIP_IMAGE { A resource was allocated to be more than 64K}
table enter $fatalerr_info_table geos::CHANGING_SIZE_OF_RESIDENT_RESOURCE { The size of a resident resource of an XIP geode changed from one launch
 to another.}
table enter $fatalerr_info_table geos::ILLEGAL_RESOURCE_COUNT { A geode had no resources, or > 0x8001 resources...}
table enter $fatalerr_info_table geos::INVALID_POINTER_INTO_STACK { A pointer into the unused stack portion was passed to ECCheckStack
 (DS:SI lies above TPD_stackBot, but below SP)...	}
table enter $fatalerr_info_table geos::GRAPHICS_BAD_BITMAP_FORMAT { The format of the bitmap is either invalid or unsupported by the system.
}
table enter $fatalerr_info_table geos::VM_WRITE_BLOCK_SWAPPED { You can't write out a swapped block, silly.}
table enter $fatalerr_info_table geos::VM_HANDLE_MISMATCH { For some reason, calling VMLock/Unlock changed the handle stored for a
 resident block.	}
table enter $fatalerr_info_table geos::REQUESTED_PROC_CALL_FIXED_OR_MOVABLE_TO_LEAP_INTO_SPACE { The caller passed a zero for the virtual segment of ProcCallFixedOrMovable().
 Make sure you're passing a valid virtual segment and offset for the routine.}
table enter $fatalerr_info_table geos::THREAD_PRIORITY_OVERFLOW { A thread's priority wrapped to 0.}
table enter $fatalerr_info_table geos::TRAP_NOT_SET { We are doing single-step debugging, and yet the trap flag *IS NOT SET*!}
table enter $fatalerr_info_table geos::BAD_ELEMENT_PASSED_TO_CHUNK_ARRAY_RESIZE { The element number passed to ChunkArrayElementResize is beyond the end
 of the chunk array.}
table enter $fatalerr_info_table geos::UTIL_WINDOW_BAD_WINDOW_NUMBER { The window number passed to SysMapUtilWindow must be in the range
 0 -> ((number of windows returns by SysGetUtilWindowInfo) - 1)}
table enter $fatalerr_info_table geos::UTIL_WINDOW_UNMATCHED_UNMAP { SysUnmapUtilWindow was called without a previous SysMapUtilWindow.}
table enter $fatalerr_info_table geos::UTIL_WINDOW_EMM_ERROR { Error using EMM function for utility mapping window.}
table enter $fatalerr_info_table geos::UTIL_WINDOW_BAD_ADDRESS { The address passed to SysMapUtilWindow must be 220000h or greater.}
table enter $fatalerr_info_table geos::IM_SETUP_DIGITIZER_COORDS_BUFFER_WAS_CALLED_TWICE { and it shouldn't be. Duh.}
table enter $fatalerr_info_table geos::INK_RECEIVED_UNEXPECTED_MSG_IM_READ_DIGITIZER_COORDS { A MSG_IM_READ_DIGITIZER_COORDS was received by the InkInputMonitor
 when it was in a state that was not expecting it.}
table enter $fatalerr_info_table geos::ERROR_ATTEMPTED_TO_MAP_IN_A_COMPRESSED_XIP_RESOURCE { The kernel attempted to map in a compressed XIP resource.
 Most likely there is a problem with the XIP image.}
table enter $fatalerr_info_table geos::ERROR_COMPRESSED_XIP_IMAGE_IS_HOSED { There's something wrong with the XIP image.}
table enter $fatalerr_info_table geos::ERROR_COMPRESSED_VM_DATA_IS_CORRUPT { The compressed data in the VM block is corrupt.}
table enter $fatalerr_info_table geos::ERROR_VM_BLOCK_DATA_IS_COMPRESSED { The data in the VM block has been marked compressed, but this kernel
 does not support compressed VM files.}
table enter $fatalerr_info_table geos::NOT_ALLOWED_TO_CALL_MOVABLE_ROUTINE_IN_INTERRUPT_CODE { You are attempting to call a movable routine while in interrupt code
 or a critical section (defined by a call to SysEnterInterrupt or
 SysEnterCritical having been called). This is not allowed, as if the system
 needs to bring the movable resource into memory, it needs to grab
 semaphores, which is not allowed.}
table enter $fatalerr_info_table geos::THAI_CHAR_NOT_HANDLED_IN_TRANFORMATION_TABLE { The character in al needs transformation, but the transformation
 table does not have the info. The character should be changed by
 other code.}
table enter $fatalerr_info_table geos::THAI_ILLEGAL_CHAR_DURING_TRANSFORMATION { Null char found during Thai transformation. The transformation table
 needs to be checked.}
table enter $fatalerr_info_table geos::RCI_CALL_WANTS_TO_LEAP_INTO_SPACE {RCI was going to make a call to a null segment.  This is a bad thing and
makes backtracing impossible.  Maybe the handle handle table was corrupted, or
a discarded/swapped block failed to load.}
table enter $fatalerr_info_table geos::PCFOM_CALL_WANTS_TO_LEAP_INTO_SPACE {PCFOM was going to make a call to a null segment.  This is a bad thing and
makes backtracing impossible.  Maybe the handle handle table was corrupted, or
a discarded/swapped block failed to load.}
