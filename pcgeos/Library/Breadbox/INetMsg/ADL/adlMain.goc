/**************************************************************************
*
*   Copyright (C) 1999  Breadbox Computer Company
*                       All Right Reserved
*
*   PROJECT:    Automatic Decoder Library
*   FILE:       Main/mAPI.goc
*   AUTHOR:     TZZ, FR, 26th April, 1999
*
*   DESCRIPTION:
*       This is the Automatic Decoder Library main API file.
*
**************************************************************************/


/**************************************************************************
*   INCLUDES
**************************************************************************/

/* standard include file for GEOS applications */
@include <stdapp.goh> 
#include <localize.h> 

/* library definition header */
@include "INetMsg/ADL.goh" 

/* ANSI C functions */
#include <Ansi/stdio.h>  
#include <Ansi/string.h> 


/**************************************************************************
*   STRINGS RESOURCE
**************************************************************************/

@start StringResource, data ;

@chunk char QUOTED_PRINTABLEString[] = "QUOTED_PRINTABLE" ;

@chunk char BEGIN_String[] = "BEGIN " ;

@chunk char MULTIPART_String[] = "MULTIPART/" ;

@chunk char _PARTIALString[] = "/PARTIAL" ;

@chunk char NAMEString[] = "NAME" ;

@chunk char FILENAMEString[] = "FILENAME" ;

@chunk char BOUNDARYString[] = "BOUNDARY" ;

@chunk char CHARSETString[] = "CHARSET" ;

@chunk char INLINEString[] = "INLINE" ;

@chunk char CONTENT_TRANSFER_ENCODING_String[] = 
                        "CONTENT-TRANSFER-ENCODING:" ;

@chunk char CONTENT_TYPE_String[] = 
                        "CONTENT-TYPE:" ;

@chunk char NUMBERString[] = "NUMBER" ;

@chunk char TOTALString[] = "TOTAL" ;

@chunk char IDString[] = "ID" ;

@chunk char CONTENT_DISPOSITION_String[] = 
                        "CONTENT-DISPOSITION:" ;

@chunk char CONTENT_MD5_String[] = 
                        "CONTENT-MD5:" ;

@chunk char CONTENT_ID_String[] = 
                        "CONTENT-ID:" ;

@chunk char CONTENT_DESCRIPTION_String[] = 
                        "CONTENT-DESCRIPTION:" ;

@chunk char ENDString[] = 
                        "END" ;

@chunk char BITString[] = 
                        "BIT" ;

@chunk char BASE64String[] = 
                        "BASE64" ;

@chunk char BINARYString[] = 
                        "BINARY" ;

@chunk char MIME_VERSION__1_0String[] =
                        "MIME-Version: 1.0" ;

@end StringResource ;


/**************************************************************************
*   LOCAL TYPE DEFINITIION
**************************************************************************/

typedef struct {

    ADState         adH_state ;                 /* state of the decoder */
    ADLevelState    adH_level[
                        AD_MAX_MESSAGE_LEVEL] ; /* state of levels of
                                                 * the decoding document */
    Boolean         adH_gettingHeader ;         /* TRUE if we expect
                                                 * header information */
    word            adH_length[ADV_FIRST_FREE] ;    
                                                /* size of data returned */
    word            adH_offset[ADV_FIRST_FREE] ;    
                                                /* offset to data block */

} adHandle ;

#define isoctalchar(c)              (((c) >= '0') && ((c) <= '7'))

#define hexchar(c)                  (((c) >= '0') && ((c) <= '9')) ?    \
                                        ((c) - 48) :                    \
                                        (LocalUpcaseChar((byte) (c)) - 55)
#define dec(c)                      (((c) - ' ') & 077)


/**************************************************************************
*   LOCAL FUNCTION DEFINITION
**************************************************************************/

/*-------------------------------------------------------------------------
 *  Operates just like strstr, except that it is case insensitive.
 *  Copies the original strings for safekeeping, then runs
 *  LocalUpcaseString on them, and then runs strstr.  Finally, it
 *  copies the original strings back - but the pointers returned
 *  by strstr are still valid.
 *-----------------------------------------------------------------------*/
 
 TCHAR *                        /* ptr to found accurance of the param 
                                 * or 0 for not found */
strstri(
    TCHAR   *p_line,            /* ptr to line to search in */
    TCHAR   *p_param            /* string to find */
)
/*-----------------------------------------------------------------------*/
{
    word cmpLen ;
    word lineLen ;
    word loopCount ;
    TCHAR *retValue = 0 ;

    cmpLen = strlen(p_param) ;
    lineLen = strlen(p_line) ;
    
    if(lineLen >= cmpLen) {

        lineLen -= cmpLen ;

        loopCount = 0 ;
        do {
            
            if(!LocalCmpStringsNoCase(
                        p_line + loopCount, p_param, cmpLen)) { 
             
                retValue = p_line + loopCount ;
                break ;
            }

            loopCount++ ;

        } while(loopCount < lineLen) ; 
    }

    return(retValue) ;
}

/*************************************************************************/

/*-------------------------------------------------------------------------
 *  Decoded a Base64 character into a binary character.
 *-----------------------------------------------------------------------*/
 
 byte                       /* represented 6 bit value or 127 for error */

base64binary(
    TCHAR   c               /* encoded base64 character */
)
/*-----------------------------------------------------------------------*/ 
{

    byte retValue = 127 ;

    /* this table has 64 elements, so it had to be shortened at the
     * expense of readability */
    if((c > 64) && (c < 91))  {
        
        retValue =  c - 65 ;
    
    } else if((c > 96) && (c < 123)) {
        
        retValue = c - 71 ;
    
    } else {
        
        switch (c) {
            
            case 43: 
                retValue = 62 ;
                break ;

            case 47: 
                retValue = 63 ;
                break ;

            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
                retValue = c + 4 ;
                break ;
        }
    }

    return(retValue) ;    
}

/*************************************************************************/

/*-------------------------------------------------------------------------
 *  Frees the var given by freeing the memory in the handles data block
 *  and ajusting the offsets of other upcoming vars.
 *-----------------------------------------------------------------------*/
 
 void                       /* no return value */

IFreeVar(
    ADHandle    handle,     /* handle to free an internal var for */
    word        var         /* var to free */
)
/*-----------------------------------------------------------------------*/
{
    word dataSize ;
    word loopCount ;
    byte *p_data ;
    word moveOffset ;
    adHandle *p_handle ;

    p_handle = (adHandle *) MemLock(handle) ;

    dataSize = 0 ;
    loopCount = 0 ;
    while(loopCount < ADV_FIRST_FREE) {
    
        /* if this var is used */
        if(p_handle->adH_length[loopCount]) {
        
            dataSize += p_handle->adH_length[loopCount] ;
        }

        loopCount++ ;
    }

    moveOffset = p_handle->adH_offset[var] + p_handle->adH_length[var] ;

    if(moveOffset < dataSize) {
        
        p_data = &p_handle[1] ;

        /* shrunk the handle block size */
        memmove(
            &p_data[p_handle->adH_offset[var]], 
            &p_data[moveOffset], dataSize - moveOffset) ;
        
        dataSize -= p_handle->adH_length[var] ;

        MemReAlloc(handle, dataSize + sizeof(adHandle), 0) ;

        p_handle = MemDeref(handle) ;

        /* adjust other data item's offset */
        loopCount = 0 ;
        while(loopCount < ADV_FIRST_FREE) {
    
            if(p_handle->adH_offset[loopCount] >= moveOffset) {
            
                p_handle->adH_offset[loopCount] -= 
                                            p_handle->adH_length[var] ;
            }

            loopCount++ ;
        }
    }

    p_handle->adH_offset[var] = 0 ;
    p_handle->adH_length[var] = 0 ;

    MemUnlock(handle) ;
}

/*************************************************************************/

/*-------------------------------------------------------------------------
 *  Stored the string for a variable.
 *  This might invalidate the handle ptr. Add the new var at the end
 *  of the handles data block and set the offset.
 *  terminating 0 is no stored 
 *-----------------------------------------------------------------------*/
 
 void                           /* nothing returned here */

ISetVar(
    ADHandle    handle,         /* handle to set the var for */
    word        var,            /* var id (index) to set */
    TCHAR       *p_string,      /* string to set for var */
    word        len             /* len of data to store */
)
/*-----------------------------------------------------------------------*/
{
    word dataSize ;
    word loopCount ;
    byte *p_data ;
    adHandle *p_handle ;

    if(!len) {
        
        len = strlen(p_string) ;
    }

    p_handle = (adHandle *) MemLock(handle) ;

    if(p_handle->adH_length[var]) {

        IFreeVar(handle, var) ;
    }

    dataSize = 0 ;
    loopCount = 0 ;
    while(loopCount < ADV_FIRST_FREE) {
    
        /* if this var is used */
        if(p_handle->adH_length[loopCount]) {
        
            dataSize += p_handle->adH_length[loopCount] ;
        }

        loopCount++ ;
    }

    MemReAlloc(handle, dataSize + sizeof(adHandle) + len, 0) ;

    p_handle = MemDeref(handle) ;

    p_handle->adH_offset[var] = dataSize ;
    p_handle->adH_length[var] = len ;

    p_data = &p_handle[1] ;

    /* shrunk the handle block size */
    memcpy(
        &p_data[dataSize], 
        p_string, len) ;

    MemUnlock(handle) ;
}

/*************************************************************************/

/*-------------------------------------------------------------------------
 *  Skip whitespace and RFC-822 comments in a string.
 *-----------------------------------------------------------------------*/

 TCHAR *                            /* returns ptr to start of data */

ISkipWhitespace(
    TCHAR   *p_string               /* string to skip the whitespace in */
)
/*-----------------------------------------------------------------------*/
{
    word commentLevel = 0 ; 

    while((*p_string) && 
                (isspace(*((byte *) p_string)) || ((*p_string) == '('))) {
	
        if((*p_string) == '(') {
	    
            p_string++ ;
	        commentLevel++ ;
	    
            while(commentLevel) {
		    
                switch(*p_string) {
		        
                    case '\0':
		                return(0) ;

		            case '\\':
		                p_string++ ;
		                break ;

		            case '(':
		                commentLevel++ ;
		                break ; 

		            case ')':
		                commentLevel-- ;
		                break ;
		        }
		        
                p_string++ ;
	        }
	    
        } else {
            
            p_string++ ;
        }
    }

    return(p_string) ;
}

/*************************************************************************/

/*-------------------------------------------------------------------------
 *  Checks if the MIME header string will continue.  The string must
 *  be null-terminated, or memory violations may happen.  The 
 *  function looks for a semicolon at the end of the string, optionally
 *  followed by space (according to the GOC isspace() function) or '\n'
 *  characters.
 *-----------------------------------------------------------------------*/
 
 Boolean                    /* TRUE if the line is continued */

ICheckContinue(
    TCHAR   *p_line         /* ptr of line to check for continue */
)
/*-----------------------------------------------------------------------*/
{
    /* since we don't have strrchr, this will have to do */
    Boolean continued = FALSE ;
    TCHAR *p_start;

    p_start = p_line ;

    /* if we have a line */
    if('\0' != (*p_line)) {
        
        /* find the end of the scratch string */
        while('\0' != (*p_line)) {
        
            p_line++ ;
        }

        /* step one char back to the last valid character in scratch */
        p_line-- ;

        /* look for the first non-space character */
        while(
                (p_line != p_start) && (
                    ('\n' == (*p_line)) || 
                    ('\r' == (*p_line)) || 
                    isspace(*((byte *) p_line))
                 ) ) {
            
            p_line-- ;
        }
    }
    /* abort if the scratch string's length is 0 */

    /* if we got the semicolon at the end of the string, return 1 */
    if((p_line != p_start) && (';' == (*p_line))) {
        
        continued = TRUE ;
    }

    return(continued) ;
}

/*************************************************************************/

/*-------------------------------------------------------------------------
 *  Checks if the uppercased string contains the "MULTIPART/" string,
 *  which is the MIME indicator that content will be multipart.
 *  This functions expects the string resource to be locked 
 *-----------------------------------------------------------------------*/

 Boolean                    /* TRUE if this header signals multipart 
                             * part */

ICheckMultipart(
    TCHAR   *p_line         /* ptr to header line to check this for */
)
/*-----------------------------------------------------------------------*/
{
    Boolean multipart = FALSE ;

    if(p_line) {

        if(strstri(p_line, LMemDeref(@MULTIPART_String))) {

            multipart = TRUE ;
        }
    }

    return(multipart) ;
}

/*************************************************************************/

/*-------------------------------------------------------------------------
 *  Checks if the uppercased string contains the "/PARTIAL" string,
 *  which is the MIME indicator that content will be partial.
 *  This function expects the string resource to be locked 
 *-----------------------------------------------------------------------*/
 
 Boolean                    /* TRUE if this header line signals an
                             * upcoming partial message part */

ICheckPartial(
    TCHAR *p_line           /* ptr to header line to check this for */
)
/*-----------------------------------------------------------------------*/
{
    Boolean partial = FALSE ;

    if(p_line) {

        if (strstri(p_line, LMemDeref(@_PARTIALString))) {

            partial = TRUE ;
        }
    }

    return(partial) ;
}

/*************************************************************************/

/*-------------------------------------------------------------------------
 *  Checks if a line is the "BEGIN ..." header of an uuencoded file.
 *  This functions need the string resource to be locked 
 *-----------------------------------------------------------------------*/
 
 TCHAR *                    /* ptr to file name found */

ICheckUUBegin(
    TCHAR *p_line           /* ptr to expected UU BEGIN line */
)
/*-----------------------------------------------------------------------*/
{
    TCHAR *retValue = 0 ;

    p_line = ISkipWhitespace(p_line) ;
    
    if(p_line) {
 
        if(strlen(p_line) > 11) {

            if(!LocalCmpStringsNoCase(p_line, 
                                LMemDeref(@BEGIN_String), 6)) {

                if( isoctalchar(p_line[6]) &&
                    isoctalchar(p_line[7]) &&
                    isoctalchar(p_line[8])  ) {
                    
                    retValue = p_line + 10 ;
                }
            }
        }
    }

    /* will be valid, at least a '\0' */
    return(retValue) ; 
}

/*************************************************************************/

/*-------------------------------------------------------------------------
 *  Finds a parameter in the xxx=yyy formnat in the line passed.
 *  Returns null if the parameter was not found.
 *  Skips comments as much as possible.  Does not handle escaped
 *  quotes, so name="alpha\"" will return "alpha\" as the parameter
 *  value.
 *-----------------------------------------------------------------------*/
 
 TCHAR *                    /* ptr to found parameter value string */

IFindParameter(
    TCHAR   *p_line,        /* ptr to line to check for parameter */
    TCHAR   *p_param,       /* parameter string to check for */
    word    *length         /* place to return found parameter value
                             * string length */
)
/*-----------------------------------------------------------------------*/
{
    Boolean quoted = FALSE ;
    TCHAR *p_pos ;
    TCHAR *retValue = 0 ;

    (*length) = 0 ;

    p_pos = strstri(p_line, p_param) ;

    /* is the parameter in the line? */
    if(p_pos) {
        
        /* advance past the parameter */  
        p_pos += strlen(p_param) ;      

        /* skip the whitespace */
        p_pos = ISkipWhitespace(p_pos) ;
        
        /* check for validity */
        if(p_pos && (*p_pos)) {
        
            /* check that the character is the '=' */
            if((*p_pos) ==  '=') {
  
                /* move past the '=' */
                p_pos++ ;
                
                if(*p_pos) {
                    
                    p_pos = ISkipWhitespace(p_pos) ;
                    
                    if(p_pos && (*p_pos)) {
  
                        /* we are now at the beginning of the 
                         * parameter value */
                        
                        /* advance past the first quote */
                        if((*p_pos) == 34) {
                        
                            quoted = TRUE ;
                            p_pos++ ;
                        }

                        retValue = p_pos ;
                        (*length) = 0 ;
                        
                        /* go to the end of the parameter value */
                        
                        if (quoted) {
                            
                            /* just look for the next quote */
                            while('\0' != (*p_pos) && 34 != (*p_pos)) {
                            
                                p_pos++ ;
                                (*length)++ ;
                            }
                        
                        } else {
                            
                            /* look for the next space, '(', or ';' */
                            while(
                                ('\0' != (*p_pos)) && 
                                !isspace(*((byte *)p_pos)) && 
                                '(' != (*p_pos) &&
                                ';'  != (*p_pos)) {
                                
                                p_pos++ ;
                                (*length)++ ;
                            }
                        }
                        
                        if(!(*length)) {
                            
                            retValue = 0 ;
                        } 
                    }
                }
            }
        }
    }  

    return(retValue) ;
}

/*************************************************************************/

/*-------------------------------------------------------------------------
 *  Parse the parameter following the Content-Transfer-Encoding header,
 *  as an uppercase string passed in.
 *  Returns the appropriate encoding char (see ADEN_ definitions).
 *  This function expects the string resource to be locked 
 *-----------------------------------------------------------------------*/

 ADEncoding                 /* detected encoding type */
     
IParseEncoding(
    TCHAR *p_string         /* ptr to line to get the encoding type from */
)
/*-----------------------------------------------------------------------*/
{
    ADEncoding encoding = ADEN_PLAIN ;

    p_string = ISkipWhitespace(p_string) ;
    
    if(p_string) {

	    switch(LocalUpcaseChar(*((byte *)p_string))) {
	
        case 'Q':
	        if(!LocalCmpStringsNoCase(
                p_string, LMemDeref(@QUOTED_PRINTABLEString), 16) && (
                    ('\0' == p_string[16]) || 
                    isspace((byte) p_string[16]) || 
                    (p_string[16] == '(') )   
            ) {

		        encoding = ADEN_QP ;
	        }
	        break ;

	    case '7':
	    case '8':
	        if(!LocalCmpStringsNoCase(
                p_string + 1, LMemDeref(@BITString), 3) && (
                    ('\0' == p_string[4]) || 
                    isspace((byte) p_string[4]) || 
                    (p_string[4] == '(') )
            ) {
		
                encoding = ADEN_PLAIN ;
	        }
	        break ;

	    case 'B':
	        if(!LocalCmpStringsNoCase(
                p_string, LMemDeref(@BASE64String), 6) && (
                    ('\0' == p_string[6]) || 
                    isspace((byte) p_string[6]) || 
                    (p_string[6] == '(') )
            ) {
		        encoding = ADEN_BASE64 ;
	        
            } else if(!LocalCmpStringsNoCase(
                p_string, LMemDeref(@BINARYString), 5) && (
                    ('\0' == p_string[6]) || 
                    isspace((byte) p_string[6]) || 
                    (p_string[6] == '(') )
            ) {
		        
                encoding = ADEN_PLAIN;
	        }
    	}
    }

    return(encoding) ; 
}

/*************************************************************************/

/*-------------------------------------------------------------------------
 *  Decodes a line in UUencoded format.  Returns the binary result in a
 *  local buffer.
 *-----------------------------------------------------------------------*/
 
 byte *                     /* ptr to buffer of decoded data */

IDecodeUU(
    TCHAR   *p_line,        /* input text line to decode */
    byte    *p_out,         /* output buffer to store decoded input */
    word    *p_length       /* place to store the output data length */
)
/*-----------------------------------------------------------------------*/
{
    byte p_buffer[100] ;
    word pos = 0 ;
    byte c ;
    byte *retValue = 0 ;
    word len ;

    (*p_length) = 0 ;

    /* lines can't be longer than 89 chars */
    if (strlen(p_line) <= 90) {
    
        /* we get the length of the line from its first char */
        len = dec(*p_line++) ; 
 
        if(len <= 90) {
        
            (*p_length) = len ;
        
            while(len) {
                
                c = (dec(*p_line) << 2) | (dec(p_line[1]) >> 4) ;
                p_buffer[pos++] = c ;
                
                if(--len) {
   
                    c = (dec(p_line[1]) << 4) | (dec(p_line[2]) >> 2) ;
                    
                    p_buffer[pos++] = c ;
                    
                    if (--len) {
                    
                        c = (dec(p_line[2]) << 6) | (dec(p_line[3])) ;
                        
                        p_buffer[pos++] = c ;
                        len-- ;
                    }
                }
                
                p_line += 4 ;
            }
          
            memcpy(p_out, p_buffer, pos) ;
            
            retValue = p_out ;
            (*p_length) = pos ;
        }
    }

    return(retValue) ;
}

/*************************************************************************/

/*-------------------------------------------------------------------------
 *  Decodes a line in Quoted-Printable format.  Returns the binary result
 *  in a local buffer.  Note the insertCRLF flag, which is the only
 *  time we need to insert a \n character into the ADL output ourselves
 *  after decoding (we also do it for plain text, but that's not decoded).
 *-----------------------------------------------------------------------*/

 byte *                     /* ptr to buffer of decoded data */

IDecodeQuotedPrintable(
    TCHAR   *p_line,        /* input text line to decode */
    byte    *p_out,         /* output buffer to store decoded input */
    word    *p_length       /* place to store the output data length */
)
/*-----------------------------------------------------------------------*/
{
    byte p_buffer[100] ;
    word pos = 0 ;
    byte c1, c2 ;
    Boolean insertCRLF = TRUE ;
    byte *retValue  = 0 ;
    
    (*p_length) = 0 ;
 
    /* lines can't be longer than 89 chars */
    if(strlen(p_line) <= 90) {
 
        c1 = *(p_line++) ;

        /* we'll exit when we reach the end of the line */
        while ('\0' != c1) {
        
            if('=' == c1) {
                
                c1 = *(p_line++) ;
   
                /* a '=' at the end of the string is not decoded at all */
                if(c1 != '\0') {
                
                    c2 = *(p_line++) ;
                    
                    c1 = hexchar(c1) ;
                    c2 = hexchar(c2) ;
                    p_buffer[pos++] = (c1 << 4) | c2 ;
                
                } else {
                    
                    /* do no insert a \n at the end of the cycle */                    
                    insertCRLF = FALSE ; 
                }
            
            } else {
                
                /* no special handling, c1 is not the escape character */
  
                p_buffer[pos++] = c1 ;
            }
  
            c1 = *(p_line++) ;
        }

        /* this is needed, because the ReadLine routine will strip
         * off the last \n or \r from the string, and QP needs it.
         * We increment the length, and put a \n at the end of the string */
        if(insertCRLF) {

            p_buffer[pos++] = '\n' ;
        }

        memcpy(p_out, p_buffer, pos) ;
        (*p_length) = pos ;

        retValue = (byte *) p_out ;
    }

    return(retValue) ;
}

/*************************************************************************/

/*-------------------------------------------------------------------------
 *  Decodes a line in Base64 format.  Returns the binary result
 *  in a local buffer.
 *-----------------------------------------------------------------------*/

 byte *                     /* ptr to buffer of decoded data */

IDecodeBase64(
    TCHAR   *p_line,        /* input text line to decode */
    byte    *p_out,         /* output buffer to store decoded input */
    word    *p_length       /* place to store the output data length */
)
/*-----------------------------------------------------------------------*/
{
    byte p_buffer[100] ;
    word pos = 0 ;
    Boolean done = FALSE ;
    word c1, c2, c3, c4 ;

    (*p_length) = 0 ;

    /* get the first character */
    c1 = (*p_line) ; 
    p_line++ ;

    /* go until the end of the line */
    while(c1 != '\0')  {
  
        if('=' != c1 && 127 == base64binary(c1)) {
            
            /* get the first character */
            c1 = (*p_line) ; 
            p_line++ ;
            
            /* skip bad characters */
            continue ; 
        }
        
        if(done) {
            
            /* get the first character */
            c1 = (*p_line) ; 
            p_line++ ;

            /* end of data was already reached */
            continue ; 
        }

        if(pos > 95) {

            /* get the first character */
            c1 = (*p_line) ; 
            p_line++ ;
            
            /* avoid data overruns on the text buffer */
            continue ; 
        }
        
        /* get 2nd valid char */
        do  {
            
            c2 = (*p_line) ;
            p_line++ ;
        
        } while(('\0' != c2) && ('=' != c2) && 
                                  (127 == base64binary(c2))) ;

        /* get 3rd valid char */
        do  {
            
            c3 = (*p_line) ;
            p_line++ ;
        
        } while(('\0' != c3) && ('=' != c3) && 
                                    (127 == base64binary(c3))) ;

        /* get 4th valid char */
        do {
            
            c4 = (*p_line) ;
            p_line++ ;
        
        } while(('\0' != c4) && ('=' != c4) && 
                                    (127 == base64binary(c4))) ;

        /* BASE64 data must come in multiples of 4 characters */
        if ('\0' == c2 || '\0' == c3 || '\0' == c4) {
            
            break;
        }

        /* go on, we got a boundary */
        if ('=' == c1 || '=' == c2) { 
            
            done = TRUE ; 
            continue ; 
        }

        c1 = base64binary(c1) ;
        c2 = base64binary(c2) ;

        /* get first data byte */
        p_buffer[pos++] = (((c1 << 2) | ((c2 & 0x30) >> 4)) & 0xFF) ; 
        
        if ('=' == c3) {
            
            done = TRUE ;
        
        } else {
            
            c3 = base64binary(c3) ;

            /* second data byte */
            p_buffer[pos++] = ((((c2 & 0x0F) << 4) | 
                                    ((c3 & 0x3C) >> 2)) & 0xFF); 
            
            if ('=' == c4) {
                
                done = TRUE ;
            
            } else {

                c4 = base64binary(c4) ;

                p_buffer[pos++] = ((((c3 & 0x03) << 6) | c4) & 0xFF) ;
            }
        }

        c1 = (*p_line) ;
        (p_line)++ ;
    }

    memcpy(p_out, p_buffer, pos) ;
    (*p_length) = pos ;
    
    return(p_out) ;
}

/*************************************************************************/

/*-------------------------------------------------------------------------
 *  Decodes a lines main parameter following the header line name
 *  for instance "Content-Type:" and returns the string.
 *-----------------------------------------------------------------------*/

 TCHAR *                    /* ptr to decoded string */

IGetNextElement(
    TCHAR   *p_line,        /* line to decode the main parameter from
                             * start after the header line header */
    word    *length         /* place to store the length of the decoded
                             * main parameter value */
) 
/*-----------------------------------------------------------------------*/
{
    TCHAR *retValue ;

    /* find next element start */
    while(isspace((byte) *p_line)) {

        p_line++ ;
    }

    retValue = p_line ;
     
    (*length) = 0 ;
    while(  ('\0' != (*p_line)) && 
            !isspace((byte) *p_line) &&
            (';' != (*p_line)) ) {

        p_line++ ;
        (*length)++ ;
    }

    if(!(*length)) {
    
        retValue = 0 ;
    }

    return(retValue) ;
}


/**************************************************************************
*   GLOBAL FUNCTION DEFINITION
**************************************************************************/

/*-------------------------------------------------------------------------
 *  Creates a new decoder and returns an handle
 *-----------------------------------------------------------------------*/
 extern _pascal
 ADHandle                   /* handle of sucessful created decoder or
                             * 0 if the creation failed and an error
                             * error code is returned */
ADCreate(
    ADError     *error      /* place to return a creation error code,
                             * if 0 no error code is required */
) 
/*-----------------------------------------------------------------------*/
{
    ADError stat = ADE_NO_ERROR ;
    MemHandle handle ;
    adHandle *p_handle ;

    handle = MemAlloc(sizeof(adHandle), HF_SWAPABLE, HAF_ZERO_INIT) ;

    /* set new and header start */
    p_handle = (adHandle *) MemLock(handle) ;

    p_handle->adH_gettingHeader = TRUE ;

    MemUnlock(handle) ;

    if(error) {
        
       (*error) = stat ;
    }
    
    return(handle) ;
}

/*************************************************************************/

/*-------------------------------------------------------------------------
 *  This function puts in one line of the input document and decoder
 *  extract needed structure and data information. If the user want
 *  to really decode data the result will be returned into the buffer
 *  given.
 *
 * OLD HANDLING USED AS FRAME FOR THIS FUNCTION NOT ALL INFORMATION
 * APPLY HERE!!
***************************************************************************

  The routine called to make the ADL process input data.
  It operates in various stages, described below.

  1) initialization - sets all internal variabled to 0/null, as needed.

  2) state machine validity check - makes sure the state machine is valid.

  3) state check - MSG_ADL_PUT_LINE should only be called when the state
     machine is in the @ADLS_EMPTY state.  Unless the state is @ADLS_ERROR
     already, the state will be set to @ADLS_ERROR and the error to
     @ADL_ERR_ALREADY_FULL if that happens.

  4) input line length check - check that the input line is not more than
     1000 characters.  If it is, the @ADL_ERR_LINE_TOO_LONG error is set,
     and the state becomes @ADLS_ERROR.

  5) check if the input is a MIME boundary.  If so, save the boundary
     string, and lose all encoding information.  If this is the last
     MIME boundary in a series, also lose the filename information.

  6) process headers

  6.1) if the line can be a continued MIME header, check for the
       name, filename, and boundary parameters (number/total are not
       handled on continued header lines for simplicity).  The
       boundary parameter is only examined if this is known to be
       a multipart message (which is OK, since the multipart specification
       is done by the same Content-type header that specifies the
       boundary name).

  6.2) if header is "Content-Transfer-Encoding," get encoding.

  6.3) if header is "Content-Type," get name, boundary, number, total, and
       id parameters (processing those in any way is left up to the
       library's user).

  6.4) if header is "Content-Disposition," get filename parameter.

  6.5) if header is "Content-ID," "Content-MD5," or "Content-Description,"
       do nothing.

  6.6) if header is "BEGIN..." as per CheckUUBegin(), get the name
       of the UUencoded file.  If the name is already known, set the
       @ADL_ERR_BAD_ID error.  Note than a null filename will be
       returned by the library as "Unknown".  Sets the state to @ADLS_NEW.

  7) decode line.  If the line was a header that was processed earlier,
     skip it.  Otherwise, decode the line with the appropriate decoding
     method, and set the state to @ADLS_FULL.  If the line is "END" and
     the encoding method is UUencode, then the @ADL_FLAG_HAVENAME flag
     is turned off and the state remains @ADLS_EMPTY.  Note also that
     a '\n' is inserted after plain text, to compensate for the
     ReadLine routine's stripping off the '\n' character.
***************************************************************************
 * OLD HANDLING USED AS FRAME FOR THIS FUNCTION NOT ALL INFORMATION
 * APPLY HERE!!
 *-----------------------------------------------------------------------*/
 extern _pascal
 ADError                        /* error code if operation fails */

ADPutLine(
    ADHandle        handle,     /* handle of decoder */
    TCHAR           *p_in,      /* text line of input data, maximum 1024 
                                 * characters long */
    byte            *p_out,     /* buffer for deocded data, length 
                                 * 1025 byte */ 
    ADState         *p_state,   /* place to return status information */
    ADPutLineFlags  flags       /* flags for decoding handling */
) 
/*-----------------------------------------------------------------------*/
{
    ADError stat = ADE_NO_ERROR ;
    adHandle *p_handle ;
    Boolean headerContinued = FALSE ;
    word length = 0 ;
    TCHAR *p_text ;
    byte *p_temp ;
    byte level ;

    /* lock the handle to access the data */
    p_handle = (adHandle *) MemLock(handle) ;

    /* lock the string resource */
    MemLock(HandleOf(@BOUNDARYString)) ;

    /* reset state */
    p_handle->adH_state.ADS_flags &= (~ADSF_NEW) ;
    p_handle->adH_state.ADS_flags &= (~ADSF_LEVEL_END) ;
    p_handle->adH_state.ADS_length = 0 ;
    level = p_handle->adH_state.ADS_lev ;

    /* 
     * check if the line is of an allowed size 
     */
    if(strlen(p_in) > AD_MAX_IN_LINE_LENGTH) {
  
        stat = ADE_LINE_TOO_LONG ;
        goto errorEnd ;
    }

    /* 
     * check for boundaries, only if message is a multipart and
     * we are not parsing header right now 
     */
    if( !p_handle->adH_gettingHeader &&
        (p_handle->adH_level[level].ADLS_flags & ADLSF_MULTIPART) && (
            (p_in[0] == '=' && p_in[1] == '=') || 
            (p_in[0] == '-' && p_in[1] == '-') ) 
    ) {
   
        byte boundaryLevel ;
        Boolean endFlag = FALSE ;
        Boolean found = FALSE ;

        /* find the level of this boundary */
        boundaryLevel = level ;
        do {

            MemHandle dataBlock ;

            /* get this levels boundary */
            dataBlock = ADGetVar(
                            handle, ADV_BOUNDARY + boundaryLevel, 0) ;
            
            if(dataBlock) {

                word len, len2 ;

                len = strlen(MemDeref(dataBlock)) ;
                len2 = strlen(p_in + 2) ;

                if(len2 >= len) {

                    /* compare */

                    /* if equal */
                    if(!LocalCmpStringsNoCase(
                            MemDeref(dataBlock), p_in + 2, len)) {
                
                        if(!(*(p_in + len + 2))) {

                            found = TRUE ;
                            MemFree(dataBlock) ;
                            break ;
                        
                        } else if(        
                            (   p_in[len + 2] == '=' && 
                                p_in[len + 3] == '=' &&
                                p_in[len + 4] == 0  ) ||
                            (   p_in[len + 2] == '-' && 
                                p_in[len + 3] == '-' &&
                                p_in[len + 4] == 0  ) 
                        ) {
                        
                            endFlag = TRUE ;
                            found = TRUE ;
                            MemFree(dataBlock) ;
                
                            break ;
                        }
                    }
                }

                MemFree(dataBlock) ;
            }

            if(boundaryLevel) {

                boundaryLevel-- ;
            }

        } while(boundaryLevel) ;

        /* if this is a valid boundary level */
        if(found) {

            if(!endFlag) {
            
                boundaryLevel++ ;
            }

            if(endFlag || (boundaryLevel < level)) {
            
                p_handle->adH_state.ADS_flags |= ADSF_LEVEL_END ;

            } else {

                if(!(p_handle->adH_level[level].ADLS_flags &
                                                ADLSF_PARTIAL)) {
    
                    p_handle->adH_state.ADS_flags |= ADSF_LEVEL_END ;
                }
            }

            /* close open levels if needed */
            while(level > boundaryLevel) {

                /* remove strings */
                IFreeVar(handle, ADV_FILENAME + level) ;
                IFreeVar(handle, ADV_BOUNDARY + level) ;
                IFreeVar(handle, ADV_MIME_ID + level) ;
                IFreeVar(handle, ADV_NUMBER + level) ;
                IFreeVar(handle, ADV_TOTAL + level) ;
                IFreeVar(handle, ADV_CONTENT_TYPE + level) ;
                IFreeVar(handle, ADV_CHAR_SET + level) ;

                /* reset flags */
                p_handle->adH_level[level].ADLS_flags = 0 ;
                p_handle->adH_level[level].ADLS_encoding = ADEN_NONE ;

                level --;
            }

            /* lose encoding information */
            p_handle->adH_level[level].ADLS_encoding = ADEN_NONE ;
            p_handle->adH_gettingHeader = TRUE ;
            p_handle->adH_state.ADS_flags &= (~ADSF_LINE_CONT) ;

            /* no data */
            length = 0 ;

            goto errorEnd ;
        }
    } 

    /* skip the whitespace, ptr advanced */
    p_temp = (byte *) ISkipWhitespace(p_in) ; 

    /*
     *  handle UUENCODE BEGIN
     */
    if( !p_handle->adH_gettingHeader &&
        (LocalUpcaseChar(*p_temp) == 'B') &&
        !(p_handle->adH_state.ADS_flags & ADSF_MIME )) {
        
        /* only found in UUencoded "begin ..." as far as we know */
        p_text = ICheckUUBegin(p_in) ;

        if(NULL != p_text) {

            level++ ;

            p_handle->adH_level[level].ADLS_encoding = ADEN_UU ;

            // nasty bug: v_filename will return "Unknown" 
            // when null,
            // so we use the optr

            if(p_handle->adH_length[ADV_FILENAME + level]) {

                stat = ADE_ILLEGAL_UU_BEGIN ;
                goto errorEnd ;
        
            } else {

                byte *p_temp2 ;

                length = 0;

                p_temp2 = (byte *) p_text ;

                /* Parse for part i/j information.  
                 * First two numbers are extracted.*/
                /* advance to the first space */
                while(('\0' != (*p_text)) && !isspace((byte) *p_text)) {

                    p_text++ ;
                }

                /* advance to the first digit */
                while(('\0' != (*p_text)) && !isdigit((byte) *p_text)) {
    
                    p_text++ ;
                }

                if(isdigit(*p_text)) {

                    length = 1 ;

                    /* find out where this digit ends */
                    while(isdigit(*(p_text + length))) {
        
                        length++ ;
                    }

                    ISetVar(handle, ADV_NUMBER + level, p_text, 
                                                            length) ;

                    /* advance to the next non-digit */
                    while(isdigit(*p_text)) {
    
                        p_text++ ;
                    }

                    while(('\0' != (*p_text)) && 
                                            !isdigit(*p_text)) {
        
                        p_text++ ;
                    }

                    if(isdigit(*p_text)) {

                        length = 1 ;

                        while(isdigit(*(p_text + length))) {
                
                            length++ ;
                        }
                    }
                }

                /* Note *everything* is copied to user */
                ISetVar(handle, ADV_FILENAME + level, (TCHAR *) 
                                                    p_temp2, 0) ;

                p_handle = MemDeref(handle) ;
                p_handle->adH_state.ADS_flags |= ADSF_NEW ;
            }

            length = 0 ;

            goto errorEnd ;
        }
    }

    /* 
     * process continued header lines
     */
    if(p_handle->adH_gettingHeader) {

        if(p_handle->adH_state.ADS_flags & ADSF_LINE_CONT) {
    
            /* possible continued header, inspect it */

            /* looks for the "name=" parameter */
            p_text = IFindParameter(
                            p_in, LMemDeref(@NAMEString), &length) ;

            if(NULL != p_text) {
        
                ISetVar(handle, ADV_FILENAME + level, p_text, length) ;
                p_handle = MemDeref(handle) ;
            }

            /* looks for the "filename=" parameter */
            p_text = IFindParameter(
                            p_in, LMemDeref(@FILENAMEString), &length) ;

            if(NULL != p_text) {

                ISetVar(handle, ADV_FILENAME + level, p_text, length) ;
                p_handle = MemDeref(handle) ;
            }

            /* looks for the "charset=" parameter */
            p_text = IFindParameter(
                        p_in, LMemDeref(@CHARSETString), &length) ; 
    
            if(NULL != p_text) {

                ISetVar(handle, 
                        ADV_CHAR_SET + level, p_text, length) ;
                p_handle = MemDeref(handle) ;
            }

            if (p_handle->adH_level[level].ADLS_flags & ADLSF_MULTIPART) {

                p_text = IFindParameter(
                            p_in, LMemDeref(@BOUNDARYString), &length) ;

                if(NULL == p_text) {
        
                    IFreeVar(handle, ADV_BOUNDARY + level) ;
    
                } else {
 
                    ISetVar(handle, ADV_BOUNDARY+ level, p_text, length) ;
                    p_handle = MemDeref(handle) ;
                }
            }

            /* check if the header further continues */
            if(!ICheckContinue(p_in)) {

                /* turn off the ADL_FLAG_LINE_CONT flag */
                p_handle->adH_state.ADS_flags &= ~ADSF_LINE_CONT ;
            }
        }

        /*
         * process new header lines
         */
        switch(LocalUpcaseChar(*p_temp)) {

            case 'C':
                /* we have 1 of 4 possible Content- headers */

                if (!LocalCmpStringsNoCase(p_in, 
                        LMemDeref(
                            @CONTENT_TRANSFER_ENCODING_String), 26)) {
 
                    p_handle->adH_level[level].ADLS_encoding =
                                                IParseEncoding(p_in + 26) ;
                
                } else if(  !LocalCmpStringsNoCase(p_in, 
                        LMemDeref(@CONTENT_TYPE_String), 13) ||
                    (p_handle->adH_state.ADS_flags & ADSF_LINE_CONT) ) {

                    /* get the content type */
                    p_text = IGetNextElement(p_in + 13, &length) ;

                    if(NULL != p_text) {
  
                        ISetVar(handle, 
                                ADV_CONTENT_TYPE + level, p_text, length) ;
                        p_handle = MemDeref(handle) ;
                    }

                    /* looks for the "name=" parameter */
                    p_text = IFindParameter(
                                p_in, LMemDeref(@NAMEString), &length) ; 
            
                    if(NULL != p_text) {
  
                        ISetVar(handle, 
                                ADV_FILENAME + level, p_text, length) ;
                        p_handle = MemDeref(handle) ;
                    }

                    /* looks for the "charset=" parameter */
                    p_text = IFindParameter(
                                p_in, LMemDeref(@CHARSETString), &length) ; 
            
                    if(NULL != p_text) {
  
                        ISetVar(handle, 
                                ADV_CHAR_SET + level, p_text, length) ;
                        p_handle = MemDeref(handle) ;
                    }

                    if(ICheckMultipart(p_in)) {

                        p_handle->adH_level[level].ADLS_flags |= 
                                                        ADLSF_MULTIPART ;

                        /* get the boundary */
                        p_text = 
                            IFindParameter(
                                p_in, LMemDeref(
                                            @BOUNDARYString), &length) ;

                        if(NULL == p_text) {
   
                            IFreeVar(handle, ADV_BOUNDARY + level) ;
                
                        } else {

                            ISetVar(handle, ADV_BOUNDARY + level, 
                                                    p_text, length) ;
                            p_handle = MemDeref(handle) ;
                        }
                    }

                    if(ICheckPartial(p_in)) {

                        TCHAR *number_text, *total_text, *id_text ;
                        word number_length, total_length, id_length ;

                        p_handle->adH_level[level].
                                        ADLS_flags |= ADLSF_PARTIAL ;

                        number_text = 
                            IFindParameter(
                                    p_in, LMemDeref(@NUMBERString), 
                                                &number_length) ;
                        total_text = 
                            IFindParameter(
                                    p_in, LMemDeref(@TOTALString), 
                                                &total_length) ;
                        id_text = 
                            IFindParameter(
                                    p_in, LMemDeref(@IDString), 
                                                &id_length) ;

                        /* we must get a number and an id */
                        if((NULL != number_text) && 
                                                (NULL != id_text)) {

                            /* save number / id / total information */
                            ISetVar(
                                handle, ADV_MIME_ID + level, 
                                id_text, id_length) ;
                            ISetVar(
                                handle, ADV_NUMBER + level, 
                                number_text, number_length) ;

                            if(NULL != total_text) {
                        
                                ISetVar(
                                    handle, ADV_TOTAL + level, 
                                    total_text, total_length) ;
                            }

                            p_handle = MemDeref(handle) ;
                        }
                    }
                
                    /* this header may continue later */
                    headerContinued = TRUE ;

                } else if(!LocalCmpStringsNoCase (p_in, 
                        LMemDeref(@CONTENT_DISPOSITION_String), 20)) {

                    /* get the inline flag */
                    p_text = IGetNextElement(p_in + 20, &length) ;

                    if(NULL != p_text) {
  
                        if(!LocalCmpStringsNoCase(
                                p_text, 
                                    LMemDeref(@INLINEString), length)) {

                        
                            p_handle->adH_level[level].ADLS_flags =
                                                            ADLSF_INLINE ;
                        }
                    }


                    /* looks for the "filename=" parameter */
                    p_text = 
                        IFindParameter(
                            p_in, LMemDeref(@FILENAMEString), &length) ; 

                    if (NULL != p_text) {

                        ISetVar(handle, ADV_FILENAME + level, 
                                                    p_text, length) ;
                        p_handle = MemDeref(handle) ;
                    }

                    /* this header may continue later */
                    headerContinued = TRUE ; 

                } else if(!LocalCmpStringsNoCase(
                            p_in, LMemDeref(@CONTENT_MD5_String), 12)) {
 
                    /* Content-MD5 not used right now */
        
                } else if(!LocalCmpStringsNoCase(
                            p_in, LMemDeref(@CONTENT_ID_String), 10)) {
 
                    /* Content-ID header is not used by our decoder */
        
                } else if(!LocalCmpStringsNoCase(p_in, LMemDeref(
                                    @CONTENT_DESCRIPTION_String), 19)) {
 
                    /* Content-Description header is not used by our 
                     * decoder */
                }
                break ;

            case 'M':
                /* check for 'MIME-Version: 1.0' */
                if (!LocalCmpStringsNoCase(p_in, 
                        LMemDeref(@MIME_VERSION__1_0String), 17)) {
                
                    /* set the flag we have a MIME document */
                    p_handle->adH_state.ADS_flags |= ADSF_MIME ;
                }
                break ;

            case 0:
                /* header end */
                p_handle->adH_gettingHeader = FALSE ;
                p_handle->adH_state.ADS_flags &= (~ADSF_LINE_CONT) ;
                
                if(!(p_handle->adH_level[level].
                                        ADLS_flags & ADLSF_PARTIAL)) {

                    p_handle->adH_state.ADS_flags |= ADSF_NEW ;
                }
                
                /* if we have no mime then the basic level is plain text */
                if(!(p_handle->adH_state.ADS_flags & ADSF_MIME)) {

                    p_handle->adH_level[level].ADLS_encoding = 
                                                        ADEN_PLAIN ;
                }
                break ;

            default: 
                /* do nothing! we don't care; if this is data we will 
                 * handle it in the next block */
                break;
        }
    
        /* check if header may be continuing in the next line */
        if (headerContinued && ICheckContinue(p_in)) {

            p_handle->adH_state.ADS_flags |= ADSF_LINE_CONT ;
        }

        /* no data */
        length = 0 ;

    } else {

        /* 
         * decoding block if not already handled differently
         */
        length = 0 ;
    
        if( (p_handle->adH_level[level].
                        ADLS_encoding != ADEN_NONE) &&
                                        (flags & ADPLF_DECODE) ) {
    
            /* since we have the encoding, decode a line,
             * using the appropriate method */
            if(p_handle->adH_level[level].
                                    ADLS_encoding == ADEN_BASE64) {
   
                /* skip the whitespace, ptr advanced */
                p_temp = (byte *) ISkipWhitespace(p_in); 

                IDecodeBase64(p_in, p_out, &length) ;

            } else if(p_handle->adH_level[level].
                                    ADLS_encoding == ADEN_BASE64) {
        
                IDecodeQuotedPrintable(p_in, p_out, &length) ;
            
            } else if(p_handle->adH_level[level].
                                    ADLS_encoding == ADEN_UU) {
   
                IDecodeUU(p_in, p_out, &length) ;

                if(!LocalCmpStringsNoCase(p_in, 
                                        LMemDeref(@ENDString), 3)) {
            
                    /* mark that the file is done - 
                     * turn off the HAVENAME flag */
                    IFreeVar(handle, ADV_FILENAME + level) ;
                    p_handle->adH_level[level].
                                            ADLS_encoding = ADEN_NONE ;

                    /* no data to write */
                    length = 0 ;

                    /* free the filename */
                    /* uuencoding has no other var set */
                    IFreeVar(handle, ADV_FILENAME) ;

                    if(level) {

                        level-- ;
                    }

                    p_handle->adH_state.ADS_flags |= ADSF_LEVEL_END ;
                }
       
            } else if(p_handle->adH_level[level].
                                            ADLS_encoding == ADEN_PLAIN) {
   
                /* Decode plain data - just copy it using strcpy */
                strcpy((TCHAR *) p_out, p_in) ;

                /* insert a carriage return here, since it was stripped 
                 * off by the ReadLine routine.  The insertion of a '\0' 
                 * character is not strictly necessary, but is here for 
                 * completeness.
                 */
                length = strlen((TCHAR *) p_out) ;
            
                p_out[length] = '\r' ;
                p_out[length + 1] = '\0' ;
                length++ ;
            }
        }

        /* if we have data do char code set conversion if needed */
        if(length && (flags & ADPLF_CHAR_SET)) {

            /*  if mime document */
            if(p_handle->adH_state.ADS_flags & ADSF_MIME) {

                MemHandle charSetString ;

                charSetString = ADGetVar(
                                    handle, 
                                    ADV_CHAR_SET + level,
                                    0) ;
                if(charSetString) {
                
                    /* XXX
                     * this should be used for char set translation later
                      TCHAR *p_charSetString ;

                      p_charSetString = MemDeref(charSetString) ;
                    */

                    /* decide what char set conversion we need */
                    /* do windows char set for now */
                    LocalCodePageToGeos(
                            (TCHAR *) p_out, 
                            length, 
                            CODE_PAGE_LATIN_1, '?') ;

                    MemFree(charSetString) ;
                }

            } else {
            
                /* if level 0 then convert windows to geos here */
                LocalCodePageToGeos(
                        (TCHAR *) p_out, 
                        length, 
                        CODE_PAGE_LATIN_1, '?') ;
            }
        }
    }


errorEnd:

    /* update state state information */
    p_handle->adH_state.ADS_length = length ;
    p_handle->adH_state.ADS_lev = level ;

    /* transfer state information as return values */
    (*p_state) = p_handle->adH_state ;
    p_state->ADS_level = p_handle->adH_level[level] ;

    MemUnlock(HandleOf(@BOUNDARYString));
    MemUnlock(handle) ;    

    return(stat) ;
}

/*************************************************************************/

/*-------------------------------------------------------------------------
 *  Destroys the decoder if we finsihed using it after the document
 *  was decoded sucessfully or an error stoped the decoding process.
 *-----------------------------------------------------------------------*/
 extern _pascal
 ADError                    /* error code if operation fails */

ADDestroy(
    ADHandle handle         /* handle to destroy */
) 
/*-----------------------------------------------------------------------*/
{
    MemFree(handle) ;

    return(ADE_NO_ERROR) ;
}

/*************************************************************************/

/*-------------------------------------------------------------------------
 *  This function gets an variables string content in a allocated block
 *  which is locked. 
 *-----------------------------------------------------------------------*/
 extern _pascal
 MemHandle                          /* handle of allocated and locked 
                                     * containing the string information,
                                     * 0 if variable is not set */
ADGetVar(
    ADHandle    handle, 
    ADVariable  var,
    ADError     *error
) 
/*-----------------------------------------------------------------------*/
{
    ADError stat = ADE_NO_ERROR ;
    adHandle *p_handle ;
    MemHandle retValue = 0 ;

    p_handle = (adHandle *) MemLock(handle) ;

    if(p_handle->adH_length[var]) {

        TCHAR *p_data ;

        retValue = MemAlloc(
                        p_handle->adH_length[var] + 1,
                        HF_SWAPABLE, HAF_LOCK | HAF_ZERO_INIT) ;
   
        p_data = p_handle + 1 ;

        memcpy(
            MemDeref(retValue), 
            &p_data[p_handle->adH_offset[var]],
            p_handle->adH_length[var]) ;            
    }

    MemUnlock(handle) ;

    if(error) {
    
        (*error) = stat ; 
    }

    return(retValue) ;
}


/***************************************************************************
 *  EOF:  ADL.GOC
 ***************************************************************************/
