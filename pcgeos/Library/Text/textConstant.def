COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) Berkeley Softworks 1991 -- All Rights Reserved

PROJECT:	PC GEOS
MODULE:		Text Library
FILE:		textConstants.def

AUTHOR:		Doug Fults, July 19, 1991

	
REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	doug	 7/19/91	Initial revision


DESCRIPTION:
	Internal constants and structures for the text library.
	Hi john (yes, I'm testing the remote-install stuff)
		
	$Id: textConstant.def,v 1.1 97/04/07 11:19:13 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@


;----------------------------------------------------------------------
; By default, the following flags are "off". If you need any of the
; following features, then you can set the particular flags "on". Nike
; is an example.
;
; _CHAR_LIMIT	:	If this flag is "on", the text library will limit
;			the number of chars stored in the text object.
;			This is only needed for large text objects - small text
;			objects can use VTI_maxLength to do the same thing.
;			The maximum number of chars is set in the charLimit
;			key of the text category in the .ini file.
;
; _REGION_LIMIT	:	If this flag is "on", the text library will limit
;			the number of regions in the text objects.
;			This is used only for large text objects.
;			
; _TEXT_NO_INK :	If this flag is "on," the text library will
; 			not accept ink even if it's a pen-based system.
;
; CHAR_JUSTIFICATION: 	Turns on or off support for character-level
; 			(as opposed to word-level) justification.
; 			This also needs similar constants turned on in
; 			the kernel and video drivers. 

	_CHAR_LIMIT		= 	FALSE
	_REGION_LIMIT		= 	FALSE
	_TEXT_NO_INK		=	FALSE
	CHAR_JUSTIFICATION	=	FALSE


;
;	DBCS:
;
; These things should move eventually...
;
if DBCS_PCGEOS
BYTES_PER_CHAR		=	2
CHAR_TYPE		equ	wchar
else
BYTES_PER_CHAR		=	1
CHAR_TYPE		equ	char
endif

WINDOWS_STYLE_CURSOR_KEYS	=	FALSE
PASTE_ERROR_BOXES	=	TRUE
; PASTE_ERROR_BOXES: if true, paste errors are reported via error boxes. If
; false, they are reported via beeps.
;

;	WINDOWS_STYLE_CURSOR_KEYS: Set to true if we want windows-style
;	prev/next word cursor handling.	If you hit the "next word" key, it'll
;	take you to the start of the next word, not the end of the current
;	one...

;------------------------------------------------------------------------------
;  RESPONDER: 
;------------------------------------------------------------------------------
	; USE_COLOR_FOR_DISABLED_GADGETS: turns on or off support for
	; disabled text drawn in a solid color, rather than in a 50%
	; mask. Similar constants exist in Specific UI (Rudy).
	USE_COLOR_FOR_DISABLED_GADGETS	=	FALSE

if USE_COLOR_FOR_DISABLED_GADGETS
	DISABLED_COLOR			=	C_LIGHT_GREY
endif
;------------------------------------------------------------------------------
;  PIZZA : Japanese version, including character-justification
;------------------------------------------------------------------------------
ifdef DO_PIZZA
	CHAR_JUSTIFICATION		=	TRUE
	USE_FEP				=	foo
endif

;------------------------------------------------------------------------------
;  DOVE : We want character-justification and no ink.
;------------------------------------------------------------------------------
if	_DOVE
	USE_FEP				=	foo
endif

;------------------------------------------------------------------------------
;  PENELOPE : We want no ink.
;------------------------------------------------------------------------------


;------------------------------------------------------------------------------
;  FULL_EXECUTE_IN_PLACE : Indicates that the text lib is going to
;	be used in a system where all geodes (or most, at any rate)
;	are to be executed out of ROM.  
;------------------------------------------------------------------------------
ifndef FULL_EXECUTE_IN_PLACE
	FULL_EXECUTE_IN_PLACE		equ	FALSE
endif

;------------------------------------------------------------------------------
;  The .GP file only understands defined/not defined;
;  it can not deal with expression evaluation.
;  Thus, for the TRUE/FALSE conditionals, we define
;  GP symbols that _only_ get defined when the
;  condition is true.
;-----------------------------------------------------------------------------
if	FULL_EXECUTE_IN_PLACE
	GP_FULL_EXECUTE_IN_PLACE	equ	TRUE
endif

;------------------------------------------------------------------------------
;  NO_TAB_IS_RIGHT_MARGIN: Indicates behavior when "None" is set for default
;  tabs.  If there is no tab stop on a line, NO_TAB_IS_RIGHT_MARGIN=TRUE means
;  that a tab will move the cursor to the right margin.  Otherwise, the cursor
;  is moved to .25 inch (i.e. no tabs = tabs every 1/4 inch)
;------------------------------------------------------------------------------
NO_TAB_IS_RIGHT_MARGIN	equ	TRUE


;
; The maximum scale factor that can be applied to a large object.
;
MAX_SCALE_FACTOR	=	4

;
; The maximum amount which we can legally blt.
;
LARGEST_BLT_VALUE	=	(LARGEST_POSITIVE_COORDINATE / MAX_SCALE_FACTOR)

;------------

BETA_ERROR_CHECKING	=	FALSE	; TRUE to include error checking that
					; is sometimes needed in non-ec
					; versions

TEXT_PERFORMANCE_CHECKING =	FALSE	; TRUE to include performance analysis
					; code in VisTextKbd

TEXT_IGNORE_BACKLOG	=	FALSE	; TRUE to ignore event backlog when
					; processing characters

;-----------------------------------------------------------------------------
;	Text Fatal errors
;-----------------------------------------------------------------------------

if	ERROR_CHECK

BAD_VIS_TEXT_FILTER					enum FatalErrors
CANNOT_COALESCE_GRAPHICS_RUNS				enum FatalErrors
CANNOT_SUBSTITUTE_IN_DO_SINGLE_CHAR_ATTR_CHANGE		enum FatalErrors
CANNOT_SUBSTITUTE_IN_DO_SINGLE_PARA_ATTR_CHANGE		enum FatalErrors
GRAPHIC_RUN_BAD_GRAPHIC_TYPE				enum FatalErrors
ILLEGAL_TEXT_RANGE_CONTEXT				enum FatalErrors
INSERT_TAB_DUPLICATE					enum FatalErrors
INVALID_TEXT_KEY_FUNCTION				enum FatalErrors
MSG_REQUIRES_GRAPHIC_RUNS				enum FatalErrors
NAME_SHOULD_NOT_HAVE_EXISTED				enum FatalErrors
NO_GRAPHIC_RUN_AT_GIVEN_POSITION			enum FatalErrors
OBJECT_IS_NOT_A_VIS_TEXT				enum FatalErrors
PARA_ATTR_RUN_NOT_POSITIONED_AT_CR			enum FatalErrors
TEXT_HEIGHT_GREATER_THAN_OBJECT_HEIGHT			enum FatalErrors
TEXT_INVERT_RANGE_NO_NEXT_LINE				enum FatalErrors
TEXT_INVERT_RANGE_START_PAST_END_SHOULD_NOT_BE_POSSIBLE	enum FatalErrors
TEXT_RUN_AFTER_END_OF_TEXT				enum FatalErrors
TEXT_RUN_CONSECUTIVE_ELEMENTS_EQUAL			enum FatalErrors
TEXT_RUN_CONSECUTIVE_ELEMENTS_SWAPPED			enum FatalErrors
TEXT_RUN_FIRST_POSITION_NOT_0				enum FatalErrors
TEXT_RUN_NULL_RUN					enum FatalErrors
TEXT_SAVED_HEIGHT_IS_NOT_COMPUTED_HEIGHT		enum FatalErrors
UI_NEGATIVE_GSREFCOUNT_IN_TEXT_OBJ			enum FatalErrors
UI_TEXT_ILLEGAL_TAB_TYPE				enum FatalErrors
VIS_TEXT_CANNOT_CHANGE_THESE_TYPE_FLAGS			enum FatalErrors
VIS_TEXT_CHAR_ATTR_HAS_REF_COUNT_OVER_10000		enum FatalErrors
VIS_TEXT_CHAR_ATTR_RESERVED_MUST_BE_0			enum FatalErrors
VIS_TEXT_CHAR_ATTR_RUNS_CANNOT_BE_DELETED		enum FatalErrors
VIS_TEXT_CLOSE_BAD_GS_REF_COUNT				enum FatalErrors
VIS_TEXT_DELETE_COUNT_TOO_LARGE				enum FatalErrors
VIS_TEXT_EXPECTED_NEXT_OBJECT				enum FatalErrors
VIS_TEXT_GAINED_FOCUS_ALREADY_FOCUS			enum FatalErrors
VIS_TEXT_GAINED_TARGET_ALREADY_TARGET			enum FatalErrors
VIS_TEXT_GEOMETRY_VALID_BUT_BAD_SIZE			enum FatalErrors
VIS_TEXT_GET_CHAR_ATTR_FOR_POSITION_ILLEGAL_TYPE	enum FatalErrors
VIS_TEXT_GIVE_OR_TAKE_TEXT_DELETE_COUNT_TOO_LARGE	enum FatalErrors
VIS_TEXT_GIVE_OR_TAKE_TEXT_POSITION_TOO_LARGE		enum FatalErrors
VIS_TEXT_GRAPHIC_CANNOT_HAVE_SIZE_0			enum FatalErrors
VIS_TEXT_HAS_NO_LINE_STRUCTURES				enum FatalErrors
VIS_TEXT_ILLEGAL_BORDER_BITS_SET			enum FatalErrors
VIS_TEXT_ILLEGAL_COLOR_UNUSED_BYTES_MUST_BE_0		enum FatalErrors
VIS_TEXT_ILLEGAL_GRAY_SCREEN				enum FatalErrors
VIS_TEXT_ILLEGAL_GS_REF_COUNT				enum FatalErrors
VIS_TEXT_ILLEGAL_LEADING				enum FatalErrors
VIS_TEXT_ILLEGAL_LEFT_MARGIN				enum FatalErrors
VIS_TEXT_ILLEGAL_LINE_SPACING				enum FatalErrors
VIS_TEXT_ILLEGAL_PARA_ATTR_ATTRIBUTE_BITS_SET		enum FatalErrors
VIS_TEXT_ILLEGAL_PARA_MARGIN				enum FatalErrors
VIS_TEXT_ILLEGAL_POINT_SIZE				enum FatalErrors
VIS_TEXT_ILLEGAL_RIGHT_MARGIN				enum FatalErrors
VIS_TEXT_ILLEGAL_TAB_POSITION				enum FatalErrors
VIS_TEXT_ILLEGAL_TEXT_POSITION				enum FatalErrors
VIS_TEXT_ILLEGAL_TRACK_KERNING				enum FatalErrors
VIS_TEXT_INSERT_POSITION_TOO_LARGE			enum FatalErrors
VIS_TEXT_INVALID_SCROLL_OPERATION			enum FatalErrors
VIS_TEXT_LINE_SPACING_CAUSED_OVERFLOW			enum FatalErrors
VIS_TEXT_LOST_FOCUS_NOT_FOCUS				enum FatalErrors
VIS_TEXT_LOST_TARGET_NOT_TARGET				enum FatalErrors
VIS_TEXT_MAKE_POINT_SIZE_LARGER_ILLEGAL_MAXIMUM_VALUE	enum FatalErrors
VIS_TEXT_MAKE_POINT_SIZE_SMALLER_ILLEGAL_MINIMUM_VALUE	enum FatalErrors
VIS_TEXT_OFFSET_PAST_END_OF_LAST_OBJECT			enum FatalErrors
VIS_TEXT_OFFSET_PAST_END_OF_NON_DOCUMENT_OBJECT		enum FatalErrors
VIS_TEXT_OPEN_BAD_GS_REF_COUNT				enum FatalErrors
VIS_TEXT_PARA_ATTR_HAS_REF_COUNT_OVER_10000		enum FatalErrors
VIS_TEXT_PARA_ATTR_HAS_TOO_MANY_TABS			enum FatalErrors
VIS_TEXT_PARA_ATTR_RESERVED_MUST_BE_0			enum FatalErrors
VIS_TEXT_PARA_ATTR_RUNS_CANNOT_BE_DELETED		enum FatalErrors
VIS_TEXT_RANGE_END_BEFORE_START				enum FatalErrors
VIS_TEXT_REMOVE_RUNS_EXPECTS_MULTIPLE_EVERYTHING	enum FatalErrors
VIS_TEXT_REPLACE_NULL_BYTE_IN_INSERT_TEXT		enum FatalErrors
VIS_TEXT_REPLACE_OBJECT_MAY_NOT_HAVE_GRAPHICS		enum FatalErrors
VIS_TEXT_REPLACE_OFFSET_OUTSIDE_OF_BLOCK		enum FatalErrors
VIS_TEXT_REPLACE_SEGMENT_HAS_NO_HANDLE			enum FatalErrors
VIS_TEXT_REPLACE_TEXT_MUST_BE_IN_DIFFERENT_BLOCK	enum FatalErrors
VIS_TEXT_SEEMS_TO_HAVE_LOST_LAST_LINE			enum FatalErrors
VIS_TEXT_SET_SELECTION_EXPECTS_ORDERED_OFFSETS		enum FatalErrors
VIS_TEXT_SIZE_WOULD_EXCEED_MAXIMUM_LENGTH		enum FatalErrors
VIS_TEXT_TYPE_BAD_ATTRIBUTES				enum FatalErrors
VIS_TEXT_TYPE_HAS_REF_COUNT_OVER_10000			enum FatalErrors
VIS_TEXT_TYPE_RUNS_CANNOT_BE_DELETED			enum FatalErrors
VIS_TEXT_UNABLE_TO_CALCULATE				enum FatalErrors
VM_OVERRIDE_SAVE_ERROR					enum FatalErrors
WRONG_CHUNK_HANDLE_ALLOCATED				enum FatalErrors
END_RUN_TOKEN_MUST_BE_CA_NULL_ELEMENT			enum FatalErrors
ILLEGAL_RUN_TYPE					enum FatalErrors
TEXT_PARA_ATTR_RUN_NOT_AT_PARAGRAPH_BOUNDRY		enum FatalErrors
ELEMENT_ARRAY_UNLOCK_PASSED_BAD_DATA			enum FatalErrors
DOUBLE_BYTE_NOT_SUPPORTED				enum FatalErrors
VIS_TEXT_BAD_LINE_NUMBER				enum FatalErrors
TS_LOCK_TEXT_PTR_INVALID_RETURN_VALUE			enum FatalErrors

VIS_TEXT_REACHED_END_OF_DOCUMENT_WHILE_GETTING_CHARS_IN_SELECTION enum FatalErrors
SCO_CHECK_SELECTION_AND_NUM_CHARS_BOTH_SET		enum FatalErrors
COUNT_REAL_NUMBER_OF_CHARS_END_OF_DOCUMENT_REACHED	enum FatalErrors
VIS_TEXT_MESSAGE_REQUIRES_ATTR_STYLE_ARRAY		enum FatalErrors
VIS_TEXT_BAD_TEXT_REFERENCE_TYPE			enum FatalErrors
VIS_TEXT_OBJECT_IS_ALREADY_LARGE			enum FatalErrors
VIS_TEXT_OBJECT_CANNOT_BE_MADE_LARGE			enum FatalErrors
VIS_TEXT_ILLEGAL_BITS_TO_SET				enum FatalErrors
VIS_TEXT_ILLEGAL_PARAMETER				enum FatalErrors
ELEMENTS_MUST_BE_VM_IF_RUNS_ARE				enum FatalErrors
VIS_TEXT_VAR_DATA_DOES_NOT_MATCH_STORAGE_FLAGS		enum FatalErrors
VIS_TEXT_SUSPEND_LOGIC_ERROR				enum FatalErrors
VIS_TEXT_SUSPEND_COUNT_SEEMS_TOO_HIGH			enum FatalErrors
VIS_TEXT_MUST_PASS_QUALIFIED_RANGE			enum FatalErrors
VIS_TEXT_GEOMETRY_VALID_ERROR				enum FatalErrors
VIS_TEXT_BAD_REPLACE_FLAGS				enum FatalErrors
VIS_TEXT_PARA_ATTRS_HAVE_NO_INSERTION_ELEMENT		enum FatalErrors
BAD_VIS_TEXT_FEATURES					enum FatalErrors
VIS_TEXT_ILLEGAL_LANGUAGE				enum FatalErrors
VIS_TEXT_CANNOT_GO_BEYOND_LAST_ELEMENT			enum FatalErrors
VIS_TEXT_TEXT_CHECK_CAN_DRAW_MUST_HAVE_GSTATE		enum FatalErrors
VIS_TEXT_BAD_NUMBER_TYPE				enum FatalErrors
TEXT_DRAW_BAD_LINE_NUMBER_ASSUMPTION			enum FatalErrors
MEM_LOCK_RETURNED_ERROR_CALL_TONY			enum FatalErrors
VIS_TEXT_ILLEGAL_REGION_PASSED__MAYBE_BAD_SECTION_BREAK	enum FatalErrors
TEXT_ATTRIBUTE_ELEMENT_IS_FREE				enum FatalErrors


;Search Replace Box Fatal Errors

NO_TARGET						       enum FatalErrors
MONIKER_OF_PRIMARY_IS_TOO_LARGE				       enum FatalErrors
BAD_DYNAMIC_BOX_OPEN_STATE				       enum FatalErrors
BAD_FOCUS_INFO						       enum FatalErrors
NO_SEARCH_STRING					       enum FatalErrors
SEARCH_STRING_TOO_LARGE					       enum FatalErrors
REPLACE_STRING_TOO_LARGE				       enum FatalErrors
END_OFFSET_IS_GREATER_THAN_THE_STRING_SIZE		       enum FatalErrors
SEARCH_EXTENDED_BEYOND_END_OFFSET			       enum FatalErrors
SEARCH_EXTENDED_BEYOND_STRING_SIZE			       enum FatalErrors
SEARCH_EXTENDED_BEYOND_END_OF_BLOCK			       enum FatalErrors
NULL_STRING_PASSED_TO_TEXT_SEARCH_IN_STRING		       enum FatalErrors
CUR_OFFSET_IS_BEYOND_END_OFFSET			       	       enum FatalErrors
SEARCH_EXCEEDED_BLOCK_BOUNDS			       	       enum FatalErrors
NON_32_BIT_OBJECT_HAS_32_BIT_OFFSETS		       	       enum FatalErrors
PASSED_OFFSET_DOES_NOT_EXIST_IN_HUGE_ARRAY	       	       enum FatalErrors
START_PTR_MUST_BE_IN_SAME_SEGMENT_AS_END_PTR	       	       enum FatalErrors
BAD_SEARCH_FLAGS					       enum FatalErrors
MISSPELLED_WORDS_CONTAINED_INVALID_CHAR			       enum FatalErrors

UNLOCK_PASSED_WRONG_SEGMENT				       enum FatalErrors
OFFSET_FOR_SMALL_OBJECT_IS_TOO_LARGE			       enum FatalErrors
VM_OVERRIDE_FILE_CANNOT_BE_SET				       enum FatalErrors
CANNOT_USE_A_POINTER_TO_TEXT_IN_SAME_BLOCK_AS_TEXT_OBJECT       enum FatalErrors
POSITION_FOR_CHANGE_IS_BEYOND_END_OF_TEXT		       enum FatalErrors
CANNOT_DELETE_PAST_END_OF_OBJECT			       enum FatalErrors
POSITION_HIGH_WORD_NON_ZERO_FOR_SMALL_TEXT_OBJECT	       enum FatalErrors
INSERTION_COUNT_HIGH_WORD_NON_ZERO_FOR_SMALL_TEXT_OBJECT       enum FatalErrors
DELETION_COUNT_HIGH_WORD_NON_ZERO_FOR_SMALL_TEXT_OBJECT	       enum FatalErrors
SIZE_CHANGE_WOULD_EXCEED_MAXLENGTH			       enum FatalErrors
PASSED_SEGMENT_HAS_NO_HANDLE				       enum FatalErrors
PASSED_SEGMENT_IN_UNLOCKED_BLOCK			       enum FatalErrors
PASSED_OFFSET_PAST_END_OF_BLOCK				       enum FatalErrors
COPY_FROM_LARGE_TEXT_OBJECT_NOT_SUPPORTED		       enum FatalErrors
OFFSET_FOR_POINTER_REFERENCE_IS_TOO_LARGE		       enum FatalErrors
OFFSET_FOR_SEGMENT_CHUNK_REFERENCE_IS_TOO_LARGE		       enum FatalErrors
OFFSET_FOR_BLOCK_REFERENCE_IS_TOO_LARGE			       enum FatalErrors
OFFSET_FOR_VM_BLOCK_REFERENCE_IS_TOO_LARGE		       enum FatalErrors
OFFSET_FOR_DB_ITEM_REFERENCE_IS_TOO_LARGE		       enum FatalErrors
CAN_NOT_SKIP_MORE_THAN_64K_IN_SMALL_OBJECT		       enum FatalErrors
RANGE_START_TOO_LARGE_FOR_SMALL_OBJECT			       enum FatalErrors
COUNT_TOO_LARGE_FOR_SMALL_OBJECT			       enum FatalErrors
CANNOT_ALLOCATE_SPACE_FOR_POINTER_REFERENCE		       enum FatalErrors
CANNOT_ALLOCATE_CHUNK_TO_SIZE_OVER_64K			       enum FatalErrors
CANNOT_ALLOCATE_BLOCK_TO_SIZE_OVER_64K			       enum FatalErrors
CANNOT_ALLOCATE_VM_BLOCK_TO_SIZE_OVER_64K		       enum FatalErrors
CANNOT_ALLOCATE_DB_ITEM_TO_SIZE_OVER_64K		       enum FatalErrors
CANNOT_RESIZE_A_POINTER_REFERENCE			       enum FatalErrors
CANNOT_RESIZE_CHUNK_TO_SIZE_OVER_64K			       enum FatalErrors
CANNOT_RESIZE_BLOCK_TO_SIZE_OVER_64K			       enum FatalErrors
CANNOT_RESIZE_VMBLOCK_TO_SIZE_OVER_64K			       enum FatalErrors
CANNOT_RESIZE_DBITEM_TO_SIZE_OVER_64K			       enum FatalErrors
RESIZING_A_HUGE_ARRAY_DOES_NOT_MAKE_SENSE		       enum FatalErrors
CAN_NOT_SET_MAX_LENGTH_FOR_LARGE_TEXT_OBJECT		       enum FatalErrors
ILLEGAL_CHARACTER_CLASS					       enum FatalErrors
CANNOT_GET_CLASS_OF_NULL				       enum FatalErrors
MORE_THAN_16_BITS_OF_LINE_COUNT_IS_NOT_ALLOWED		       enum FatalErrors
LINE_REFERENCE_TOO_LARGE_FOR_SMALL_OBJECT		       enum FatalErrors
LINE_DELETE_COUNT_TOO_LARGE				       enum FatalErrors
LINE_DOES_NOT_EXIST					       enum FatalErrors
INSERT_COUNT_TOO_LARGE_FOR_SMALL_OBJECT			       enum FatalErrors
LINE_NUMBER_BEYOND_LAST_LINE				       enum FatalErrors
POSITION_IS_LARGER_THAN_16_BITS				       enum FatalErrors
SHOULD_NEVER_GET_HERE					       enum FatalErrors
CANNOT_BLT_A_NEGATIVE_HEIGHT				       enum FatalErrors

REGION_NUMBER_FOR_SMALL_OBJECT_MUST_BE_ZERO		       enum FatalErrors
REGION_HAS_MORE_THAN_64K_LINES				       enum FatalErrors
REGION_FOR_SMALL_OBJECT_MUST_BE_ZERO			       enum FatalErrors
SMALL_OBJECT_HEIGHT_PASSED_NOT_VTI_HEIGHT		       enum FatalErrors

;
; TextStorage fatal errors
;
VIS_TEXT_REQUIRES_SMALL_TEXT_OBJECT			       enum FatalErrors
VIS_TEXT_REQUIRES_LARGE_TEXT_OBJECT			       enum FatalErrors

;
; TextRegion fatal errors
;
VIS_TEXT_REGION_MUST_CONTAIN_LINE			       enum FatalErrors
VIS_TEXT_LARGE_OBJECT_MUST_HAVE_REGION_ARRAY		       enum FatalErrors
VIS_TEXT_CANNOT_CHANGE_FIRST_REGIONS_OFFSET		       enum FatalErrors
VIS_TEXT_REACHED_LAST_REGION_WITHOUT_FINDING_NEEDED_COUNTS       enum FatalErrors
VIS_TEXT_REACHED_FIRST_REGION_WITHOUT_FINDING_NEEDED_COUNTS       enum FatalErrors

LINE_SUM_GREATER_THAN_32_BITS_CAN_HOLD			       enum FatalErrors
SUM_OF_LINE_HGTS_IN_REGION_DOES_NOT_MATCH_STORED_COMPUTED_HGT  enum FatalErrors
SUM_OF_VARIOUS_HEIGHTS_IS_NOT_RIGHT			       enum FatalErrors
;
; During calculation the text object assumes that the following value:
;	SUM(cached region heights) + insertedSpace - deletedSpace - rippleHeight
; will be the same as:
;	SUM(line heights)
;
; The insertedSpace is the amount of space inserted into the current region.
;
; The deletedSpace is the amount of space deleted at the end of the current
; region.
;
; The rippleHeight is the amount of space which has been rippled backwards
; from later regions. These lines are accounted for in the insertedSpace, so
; this value should balance those already accumulated lines.
;
MULTIPLE_LINE_HGTS_IN_REGION_GREATER_THAN_REGION_HGT	       enum FatalErrors
SUM_OF_REGION_CHARS_IS_GREATER_THAN_32_BITS_CAN_HOLD	       enum FatalErrors
SUM_OF_REGION_LINES_IS_GREATER_THAN_32_BITS_CAN_HOLD	       enum FatalErrors
SUM_OF_REGION_LINES_IS_NOT_SAME_AS_LINE_COUNT		       enum FatalErrors
SUM_OF_REGION_CHARS_IS_NOT_SAME_AS_CHAR_COUNT		       enum FatalErrors
REGION_WITH_NO_LINES_SHOULD_HAVE_NO_CHARACTERS		       enum FatalErrors
SUM_OF_REGION_LINE_CHARS_IS_NOT_SAME_AS_REGION_CHARS	       enum FatalErrors

CHAR_PRECEDING_LINE_SHOULD_BE_PARAGRAPH_ENDING_CHARACTER       enum FatalErrors
OFFSET_OF_ZERO_IMPLIES_THAT_LINE_MUST_START_A_PARAGRAPH	       enum FatalErrors
LINE_NUMBER_OF_ZERO_IMPLIES_THAT_LINE_MUST_START_A_PARAGRAPH       enum FatalErrors
CHAR_PRECEDING_LINE_SHOULD_NOT_BE_PARAGRAPH_ENDING_CHARACTER       enum FatalErrors
CHAR_AT_END_OF_LINE_SHOULD_BE_PARAGRAPH_ENDING_CHARACTER       enum FatalErrors
EMPTY_LINE_AT_END_OF_TEXT_MUST_END_IN_NULL		       enum FatalErrors
EMPTY_LINE_AT_END_OF_TEXT_MUST_HAVE_ONLY_ONE_FIELD	       enum FatalErrors
EMPTY_LINE_AT_END_OF_TEXT_CAN_NOT_HAVE_A_FIELD_WITH_TEXT_IN_IT       enum FatalErrors
LINE_AT_END_OF_TEXT_MUST_END_A_PARAGRAPH		       enum FatalErrors
LAST_LINE_MUST_END_A_PARAGRAPH				       enum FatalErrors
CHAR_AT_END_OF_LINE_SHOULD_NOT_BE_PARAGRAPH_ENDING_CHARACTER       enum FatalErrors
LINE_THAT_ENDS_IN_CR_MUST_ALSO_END_PARAGRAPH		       enum FatalErrors
ONLY_ONE_OF_THE_ENDSIN_LINE_FLAGS_CAN_BE_SET_AT_ONE_TIME       enum FatalErrors
LINE_AT_END_OF_TEXT_CAN_NOT_END_IN_CR			       enum FatalErrors
LAST_LINE_CAN_NOT_END_IN_CR				       enum FatalErrors
LAST_CHARACTER_IS_NOT_A_CR_AND_IT_SHOULD_BE		       enum FatalErrors
LAST_CHARACTER_IS_A_CR_AND_IT_SHOULD_NOT_BE		       enum FatalErrors
LINE_THAT_ENDS_IN_COLUMN_BREAK_MUST_ALSO_END_PARAGRAPH	       enum FatalErrors
LINE_AT_END_OF_TEXT_CAN_NOT_END_IN_COLUMN_BREAK		       enum FatalErrors
LAST_LINE_CAN_NOT_END_IN_COLUMN_BREAK			       enum FatalErrors
LAST_CHARACTER_IS_NOT_A_COLUMN_BREAK_AND_IT_SHOULD_BE	       enum FatalErrors
REGION_OF_NEXT_LINE_DOES_NOT_FOLLOW_IMMEDIATELY_AFTER_REGION_OF_LINE_ENDING_IN_COLUMN_BREAK    enum FatalErrors
LAST_CHARACTER_IS_A_COLUMN_BREAK_AND_IT_SHOULD_NOT_BE	       enum FatalErrors
LINE_THAT_ENDS_IN_SECTION_BREAK_MUST_ALSO_END_PARAGRAPH	       enum FatalErrors
LINE_AT_END_OF_TEXT_CAN_NOT_END_IN_SECTION_BREAK	       enum FatalErrors
LAST_LINE_CAN_NOT_END_IN_SECTION_BREAK			       enum FatalErrors
LAST_CHARACTER_IS_NOT_A_SECTION_BREAK_AND_IT_SHOULD_BE	       enum FatalErrors
REGION_OF_NEXT_LINE_DOES_NOT_FOLLOW_AFTER_REGION_OF_LINE_ENDING_IN_SECTION_BREAK    enum FatalErrors
LINE_ENDING_IN_SECTION_BREAK_IS_NOT_IN_LAST_REGION_OF_SECTION       enum FatalErrors
LINE_ENDING_IN_SECTION_BREAK_CAN_NOT_BE_IN_VERY_LAST_REGION       enum FatalErrors
LAST_CHARACTER_IS_A_SECTION_BREAK_AND_IT_SHOULD_NOT_BE	       enum FatalErrors
LAST_LINE_IN_SECTION_MUST_END_IN_SECTION_BREAK		       enum FatalErrors
LINE_THAT_ENDS_IN_NULL_MUST_ALSO_END_PARAGRAPH		       enum FatalErrors
LINE_ENDING_IN_NULL_MUST_END_AT_END_OF_TEXT		       enum FatalErrors
LINE_WHICH_ENDS_IN_NULL_MUST_BE_LAST_LINE		       enum FatalErrors
LINE_THAT_DOES_NOT_END_IN_NULL_CAN_NOT_START_AT_TEXT_END       enum FatalErrors
LINE_THAT_DOES_NOT_END_IN_NULL_CAN_NOT_END_AT_END_OF_TEXT       enum FatalErrors
LINE_WHICH_DOES_NOT_END_IN_NULL_CAN_NOT_BE_LAST_LINE	       enum FatalErrors
LAST_CHARACTER_IS_NOT_AN_OPTIONAL_HYPHEN_AND_IT_SHOULD_BE       enum FatalErrors
LAST_CHARACTER_IS_AN_OPTIONAL_HYPHEN_AND_IT_SHOULD_NOT_BE       enum FatalErrors
FIRST_LINE_MUST_START_A_PARAGRAPH			       enum FatalErrors
LAST_LINE_MUST_END_IN_NULL				       enum FatalErrors
LAST_LINE_CAN_NOT_END_IN_CR_OR_COLUMNxSECTION_BREAK	       enum FatalErrors
FIELD_POSITION_IS_NOT_BEYOND_PREVIOUS_FIELD_POSITION	       enum FatalErrors
FIELD_POSITION_PLUS_FIELD_WIDTH_IS_BEYOND_NEXT_FIELD_POSITION       enum FatalErrors
PREVIOUS_FIELD_CONTAINS_INTRINSIC_TAB_AND_CURRENT_ONE_DOES_NOT       enum FatalErrors
FIRST_CHAR_OF_ALL_FIELDS_AFTER_THE_FIRST_MUST_BE_A_TAB	       enum FatalErrors
ONLY_FIRST_FIELD_CAN_CONTAIN_RULER_TAB_TO_LINE_LEFT	       enum FatalErrors
FIRST_FIELD_MUST_START_WITH_TAB_IF_NOT_RULER_TAB_TO_LINE_LEFT       enum FatalErrors
FIELD_SET_TO_RULER_TAB_TO_LINE_LEFT_CAN_NOT_START_WITH_TAB       enum FatalErrors
ILLEGAL_CHARACTER_FOUND_INSIDE_LINE			       enum FatalErrors
VIS_TEXT_REGION_ASSUMPTION_FAILED			       enum FatalErrors
OFFSET_INTO_WORD_IS_GREATER_THAN_64K			       enum FatalErrors
REGION_WIDTH_IS_NOT_REASONABLE				       enum FatalErrors

;
; UI controller fatal errors
;
CONTROLLER_OBJECT_INTERNAL_ERROR			       enum FatalErrors
FID_CONTROLLER_TOO_MANY_FONTS				       enum FatalErrors
; The font controller was told to build a list with too many entries.
; The FontCreateList() routine may have been passed garbage.
FID_CONTROLLER_CUSTOM_FONT_ENTRY_BAD_LENGTH		       enum FatalErrors
; The geos.ini file for the font controller contained a bad custom font
; entry ("fontmenu="). The string is a series of 4-digit hex values, and
; hence should be a multiple of 4 bytes long.
FID_CONTROLLER_CUSTOM_FONT_ENTRY_BAD_CHAR		       enum FatalErrors
; The geos.ini file for the font controller contained a bad custom font
; entry ("fontmenu="). The string is a series of hex values, and hence
; should only contain characters in [0-9,a-f].
FID_CONTROLLER_BAD_FONT_HINT				       enum FatalErrors
; The font controller was given a hint that specified something not
; applicable, like FEF_STRING.

;
; Name & type fatal errors
;
VIS_TEXT_NAME_NOT_FOUND_FOR_INDEX			       enum FatalErrors
; The text object was unable to map a specified index to a name.
VIS_TEXT_NAME_CANT_MODIFY_CURRENT_FILE			       enum FatalErrors
; The "current file" entry is not a real name, but an attempt was made to
; modify it.

;
; Pen code fatal errors
;
VIS_TEXT_INVALID_GESTURE				       enum FatalErrors

;
; Name and type fatal errors
;
VIS_TEXT_OBJECT_MUST_HAVE_NAME_ARRAY			       enum FatalErrors
; The caller attempted to perform a name operation on a text object that does
; not have a name array.

;
; Undo code fatal errors
;

UNDO_NOT_TURNED_ON					       enum FatalErrors
; An undo routine was called when VTF_ALLOW_UNDO was not set.
;

CACHED_UNDO_ITEM_NOT_DELETED				       enum FatalErrors
; After starting a new undo item, the old undo item did not get deleted	
;

CANNOT_UPDATE_TYPING_UNDO_ACTION			       enum FatalErrors
; An internal error has occurred in trying to update a typing undo action
;

ALL_OBJECTS_IN_REPLACE_ALL_MUST_HAVE_SAME_VTF_ALLOW_UNDO_VALUE       enum FatalErrors
; A replace all spanned multiple objects, and VTF_ALLOW_UNDO was not clear
; or set in all the objects (the bits must be the same in each object).
;

UNDOABLE_OBJECT_MUST_BE_RUN_BY_PROCESS_THREAD		       enum FatalErrors
; An object that was run on the UI thread has undo.
;

BAD_TEXT_UNDO_TYPE					       enum FatalErrors
; A MSG_VIS_TEXT_UNDO message was sent to this object with an unrecognized
; UAS_appType field.

UNDO_INFO_CONTAINS_NO_RUNS				       enum FatalErrors
; An undo huge array is empty - this is an invalid state, as it should never
; have been added if there were no runs in it.

NO_RUNS_IN_RANGE					       enum FatalErrors
; While creating an undo huge array, we find that there are no runs to put in
; it, which is an invalid state (we should have checked this before calling
; TA_AppendRunsInRangeToHugeArray()).

UNDO_RESOURCE_LOADED_EVEN_THOUGH_IGNORING_UNDO		       enum FatalErrors
; An undo routine was called while the app is ignoring undo actions. This
; should have been caught earlier, so the undo resource would not be loaded
; in.

NO_CHAR_CHOICES						       enum FatalErrors
; The HWR library returned *no* character choices to the FilterChar routine.

TOO_MANY_CHAR_CHOICES					       enum FatalErrors
; The HWR library returned > 200 character choices to the FilterChar routine.

INSERTING_NULL_CHARACTER				       enum FatalErrors
; VTFInsert was called with DL = 0

INK_RECEIVED_BY_NON_EDITABLE_OBJECT			       enum FatalErrors
; An ink notification was received by a non-editable object

BAD_CONTEXT_LOCATION					       enum FatalErrors
; A bad ContextLocation etype was passed with MSG_META_GET_CONTEXT

BAD_CONTEXT_POSITION					       enum FatalErrors
; An invalid GCP_position value was passed in

BAD_VIS_TEXT_REPLACE_FLAGS				       enum FatalErrors
; Bad VisTextReplaceFlags were passed to the run code

BAD_TEXT_REFERENCE_TYPE					       enum FatalErrors
; A bad TextReferenceType was passed to the run code

BAD_VIS_TEXT_INT_FLAGS					       enum FatalErrors
; VTI_intFlags had an invalid value for the VTIF_ACTIVE_SEARCH_SPELL field

GRAPHIC_IN_TRANSFER_ITEM_NOT_VM_BASED_GSTRING			enum FatalErrors
; A CIF_TEXT transfer format was created for a single C_GRAPHIC character, and
; the associated gstring-based graphic is not simply a VM based graphic string,
; but is either an lmem- or db-based graphic string. This could only come
; about (I hope) if the message to create the format was subclassed.
; 

TOO_MANY_FORMATS_IN_TRANSFER_ITEM				enum FatalErrors
; About to add a CIF_GRAPHICS_STRING format to a transfer item and found there
; are already the max number in the item.

BAD_VIS_TEXT_HWR_FLAGS						enum FatalErrors
; Bad VisTextHWRFlags were passed to MSG_VIS_TEXT_REPLACE_WITH_HWR
;

APPENDING_TOO_MANY_SPACES					enum FatalErrors
; VisTextReplaceWithHWR was called with AX > 50
;

MUST_BE_FOCUS_TO_GENERATE_CONTEXT_NOTIFICATION			enum FatalErrors
; MSG_META_GENERATE_CONTEXT_NOTIFICATION was received by a non-focus text
; object.

CUSTOM_FILTER_START_RANGE_IS_AFTER_END_RANGE			enum FatalErrors
; A ATTR_VIS_TEXT_CUSTOM_FILTER was added with invalid ranges VTCFD_endOfRange
; had a value that was less than VTCFD_startOfRange

TEXT_STRING_CONTAINS_NULL					enum FatalErrors
; A text string was passed with an invalid length - there was a null byte
; before the end of the string.


; CompressGraphic fatal errors
;
BAD_COMPRESS_GRAPHIC_PARAMS_STRUCT			enum FatalErrors
;
; The CompressGraphicFrame structure on the stack has been corrupted. (EC only)

VIS_TEXT_BAD_BITMAP_COMMAND				enum FatalErrors
;
; In the process of compressing a bitmap, an unknown graphic bitmap command
; was encountered in the original gstring which can't be reproduced in the
; compressed gstring.

VIS_TEXT_CAN_ONLY_LOAD_GSTRING_FROM_VMBLOCK		enum FatalErrors
;
; An attempt was made to load a graphic gstring which is not stored in a 
; VMBlock.  VisTextGraphic gstrings are only stored in VMBlocks.

VIS_TEXT_ILLEGAL_BITMAP_FORMAT				enum FatalErrors
; The passed format cannot be used to compress bitmaps.
;

VIS_TEXT_BAD_GRAPHIC_ELEMENT				enum FatalErrors
; The passed VisTextGraphic contains invalid data.
;

VIS_TEXT_GRAPHIC_BAD_GSTRING_ELEMENT			enum FatalErrors
; In the process of parsing a VisTextGraphic gstring to compress its
; bitmaps, an unexpected gstring element was encountered.
;

if DBCS_PCGEOS

ODD_SIZE_FOR_DBCS_TEXT						enum FatalErrors
; The text stored for an object in DBCS is an odd number of bytes.  This should
; never happen, as in DBCS all characters are two bytes.  It is likely something
; that has not been converted to DBCS yet.

ILLEGAL_WORD_PART_TYPE						enum FatalErrors
; An illegal value for WordPartType was passed to one of the word selection
; routines.

endif

if FULL_EXECUTE_IN_PLACE
TEXT_FAR_POINTER_TO_MOVABLE_XIP_RESORCE			enum FatalErrors
; This means that a fptr to a movable code segment was passed to a function
; that does not like that.  
;
endif

VIS_TEXT_UPDATE_GRAPHIC_FLAGS_INVALID			enum FatalErrors
; Invalid flags were passed to VisTextUpdateGraphicElement
;

VIS_TEXT_GRAPHIC_ELEMENT_FREED_UNEXPECTEDLY		enum FatalErrors
; Removing a reference to a graphic caused it to be removed, but
; its reference count should not have gone to zero because it was
; greater than 1 before removing the reference.
;

VIS_TEXT_NAME_NOT_IN_USE_IN_CLIPBOARD			enum FatalErrors
; A name array element that was not in use got copied to the clipboard
; and now it is trying to be pasted from the clipboard.

VIS_TEXT_CANNOT_REVERT_SMALL_TEXT_OBJECT		enum FatalErrors
; There was an error trying to add another region to the text object
; and the text library is going to force the document to revert, but this
; text object is not a large text object, so there should never have
; been an error adding a region.


COULD_NOT_FIND_WORD_EDGE				enum FatalErrors
; For some reason, we FindNextWordEdge or FindPrevWordEdge returned an offset
; that was not at a word edge.

;------------------------------------------------------------------------------
;		Text Warnings
;------------------------------------------------------------------------------

WARNING_SPECIAL_CASE_FOR_LARGE_DELETE_INVOKED		       enum Warnings
; A completely non-intuitive hack is happening in the text-rippling code
; in the routine FigureNextRegionChangeAndComputeRippleHeight().
; This hack appears to help when deleting large amounts of space from
; documents.

WARNING_SPECIAL_CASE_FOR_FORWARD_RIPPLE_INVOKED			enum Warnings
; Another completely non-intuitive hack is happening in the rippling code.
; In the routine FigureNextRegionChangeAndComputeRippleHeight we are making
; a special case of the situation where we are rippling lines forward into
; an empty region, when the lines in question came from a region beyond the
; region we are rippling into rather than a region from before the one in
; question.

VIS_TEXT_GET_LINE_HEIGHT_CALLED_ON_MULTI_LINE_OBJECT		enum Warnings
; MSG_VIS_TEXT_GET_LINE_HEIGHT is being sent to an object that is *not* a 
; single line text object, so the wrong result will be returned

if DBCS_PCGEOS

WARNING_TEXT_AT_ODD_ADDRESS					enum Warnings
; The text is stored at an odd address.  This is less efficient than storing
; the text at an even address on 8086s and 8088s.

endif

WARNING_CANNOT_SET_HYPERLINK_ON_NIL_TEXT_RANGE			enum Warnings
; The start and end of the range specified as that on which to set a
; new hyperlink are identical. No hyperlink will be set.
;


endif

;---------------------------------------------------------------------------

; Flags sent to GetStyleForPosition

GetStyleForPositionTypes	etype	byte
GSFPT_RIGHT			enum	GetStyleForPositionTypes
GSFPT_LEFT			enum	GetStyleForPositionTypes
GSFPT_LEFT_OR_INSERTION		enum	GetStyleForPositionTypes

;
; Constant for a word-sized integer.fraction value with 13 bits of integer
; and 3 bits of fraction.
;
ThirteenIntThreeFrac	record
    TITF_INT:13			; Integer
    TITF_FRAC:3			; Fraction
ThirteenIntThreeFrac	end

ElevenIntFiveFrac	record
    EIFF_INT:11			; Integer
    EIFF_FRAC:5			; Fraction
ElevenIntFiveFrac	end

;
; Flags sent to TextClearBehindLine
;
TextClearBehindFlags	record
    TCBF_MSG_DRAW:1		;Set if responding to MSG_VIS_DRAW
    TCBF_DRAW_ALL_LINES:1	;Set if we want to draw all lines.
    TCBF_PRINT:1		;Set if we are printing (DF_PRINT)
    :5
TextClearBehindFlags	end

;------------------------------------------------------------------------------
;		classes
;------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
;		Macros
;-----------------------------------------------------------------------------

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		ExtractField
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Extract a field from a record.

PASS:		byteWord= "byte" or "word" depending on the record size
		rec	= Address of record to extract
		field	= Field of the record to extract
		reg	= Destination register for the extracted field.
			  (prefer al/ax)
		trash	= Register that can be nuked. (prefer cl/cx)

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	jcw	11/21/91	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
ExtractField	macro	byteWord, rec, field, reg, trashreg
	;;
	;; Extract the field into the register
	;;
ifdif	<reg>,<rec>
	mov	reg, rec
endif
	and	reg, mask field

if (offset field eq 0)
	;; Do nothing
elif (offset field le 5)
	rept	offset field
	shr	reg, 1
	endm
else
	;;
	;; This is the complicated case
	;;

;;----------------------------------------------------------------------
;; Get the masked record into al/ax and save the register in al/ax
;;----------------------------------------------------------------------
  ifidn <reg>,<ax>
	;; Do nothing
  else
    ifidn <reg>,<al>
	;; Do nothing
    else
      ifidn <byteWord>, <byte>
	xchg	al, reg
      else
	xchg	ax, reg
      endif
    endif
  endif

;;----------------------------------------------------------------------
;; Save cx/cl if it isn't the trash register
;;----------------------------------------------------------------------
  ifnb <trashreg>
    ifidn <trashreg>,<cx>
	;; Do nothing
    else
      ifidn <trashreg>, <cl>
	;; Do nothing
      else
        ifidn <byteWord>, <byte>
	  xchg	cl, trashReg
	else
	  xchg	cx, trashReg
	endif
      endif
    endif
  else
	push	cx
  endif

;;----------------------------------------------------------------------
;; Shift the masked record (in al/ax) by some amount
;;----------------------------------------------------------------------
	;;
	;; ax/al= Record masked with field (if offset field != 0)
	;; reg	= Saved value of ax (if reg != ax)
	;; cx/cl= Saved in trashreg or on stack
	;;
  ifidn <byteWord>, <byte>
	mov	cl, offset field
	shr	al, cl
  else
	mov	cl, offset field
	shr	ax, cl
  endif

;;----------------------------------------------------------------------
;; Restore cx/cl if it wasn't the trash register
;;----------------------------------------------------------------------
  ifnb <trashreg>
    ifidn <trashreg>,<cx>
	;; Do nothing
    else
      ifidn <trashreg>, <cl>
	;; Do nothing
      else
        ifidn <byteWord>, <byte>
	  xchg	cl, trashReg
	else
	  xchg	cx, trashReg
	endif
      endif
    endif
  else
	pop	cx
  endif

;;----------------------------------------------------------------------
;; Restore ax/al if it wasn't the destination register
;;----------------------------------------------------------------------
  ifidn <reg>,<ax>
	;; Do nothing
  else
    ifidn <reg>,<al>
	;; Do nothing
    else
      ifidn <byteWord>, <byte>
	xchg	al, reg
      else
	xchg	ax, reg
      endif
    endif
  endif
endif

endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

MACRO:		movcb

DESCRIPTION:	Load a callback address into a dword.

ARGUMENTS:
	dest	   - Destination for the move
	callback   - Routine to use as callback
		     Assumed to be a far routine in the current code segment

CAVEATS:
	geos.def must be loaded before this macro is defined. If it isn't
	esp will choke when it sees _ParseDWordArg.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
movcb	macro	dest, callback
	local	drl, drh, regcnt

regcnt = 0
_ParseDWordArg	dest, drl, drh, regcnt, <movcb>

if (regcnt eq 1)
	mov	drl, cs
	mov	drh, offset cs:callback
else
	mov	dest.segment, cs
	mov	dest.offset,  offset cs:callback
endif

endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

MACRO:		movcbx

DESCRIPTION:	Load a callback address into a dword.  If XIP enabled then
		it will load the virtual address of the callback into the
		dword.

ARGUMENTS:
	dest	   - Destination for the move
	callback   - Routine to use as callback
		     Assumed to be a far routine in the current code segment

CAVEATS:
	geos.def must be loaded before this macro is defined. If it isn't
	esp will choke when it sees _ParseDWordArg.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
movcbx	macro	dest, callback
	local	drl, drh, regcnt

regcnt = 0
_ParseDWordArg	dest, drl, drh, regcnt, <movcb>

if (regcnt eq 1)
	mov	drl, SEGMENT_CS
	mov	drh, offset cs:callback
else
	mov	dest.segment, SEGMENT_CS
	mov	dest.offset,  offset cs:callback
endif

endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

MACRO:		DefTextCall

DESCRIPTION:	Do a call near/far in a fixed amount of space.

ARGUMENTS:
	target	   - Routine to call

CAVEATS:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
DefTextCall	macro	target
ifndef target
ErrMessage <argument cannot be a forward reference>
endif
	local	start
start:
	call	target
	ret
	org	start+6
endm

TextCallPlaceHolder	macro	target
	local	start
start:
	org	start+6
endm

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

MACRO:		ConvertReferenceTypeToCallOffset

DESCRIPTION:	Convert a register holding a TextReferenceType into an
		offset into a list of DefTextCall handlers.

ARGUMENTS:
	reg	- Register containing the TextReferenceType

CAVEATS:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
ConvertReferenceTypeToCallOffset	macro	reg
    ifidn <reg>, <ax>
	ErrMessage	"ConvertReferenceTypeToCallOffset cannot use ax"
    endif

	;;
	;; TextReferenceType is stepped by 2. A DefTextCall requires 6 bytes.
	;; This means we need to multiply by 3. The best way to do this is
	;; to shift the value left once and add it to itself.
	;;
	push	ax		;; Save ax
	mov	ax, reg		;; ax <- reg
	shl	ax, 1		;; ax <- reg*2
	add	reg, ax		;; reg <- reg*3
	pop	ax		;; Restore ax
endm
