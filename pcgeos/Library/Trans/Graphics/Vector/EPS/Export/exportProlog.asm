
COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) Berkeley Softworks 1991 -- All Rights Reserved

PROJECT:	PC GEOS
MODULE:		PostScript Translation Library
FILE:		exportProlog.asm

AUTHOR:		Jim DeFrisco, 21 Feb 1991

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Jim	2/91		Initial revision


DESCRIPTION:
	This file contains the prolog that defines the PostScript procedures
	used by the library.
		

	$Id: exportProlog.asm,v 1.1 97/04/07 11:25:45 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	OK, so what is a prolog ?

	In the words of Adobe:

		A page description can be organized as a prolog and a script,
		as discussed in section 2.4.2 "Program Structure."  The 
		prolog contains application-dependent definitions.  The script
		describes the particular desired results in terms of those
		definitions.  The prolog is written by a programmer, stored
		in a place accessible to an application program, and 
		incorporated as a standard preface to each page description 
		created by the application.  The script is usually generated 
		automatically by an application program.
				Adobe PostScript Language Reference Manual
				Second Edition

	For our purposes, this prolog will contain procedure definitions and
	variables that will be used by the code that generates the script.
	The script itself is what describes the page, and is generated by 
	the translation library.    This prolog will be part of any PostScript
	that is generated by the library.
				
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

;-----------------------------------------------------------------------
;	An abbreviated function header has been adopted for use here.
;	There are three parts to the header:  
;		SYNOPSIS: 	As before, this contains a brief description 
;			  	of the function
;		STACK USAGE:	As PostScript is a stack-based language,
;				this field effectively describes what is 
;				passed and what is returned.  The form of
;				this line is
;					<arg> <arg> ..  FUNCTION  <retvalue>..
;				So, the items to the left of the FUNCTION
;				name are items passed on the stack, the 
;				rightmost item in the list is the item on
;				the top of the stack.  The FUNCTION is the
;				actual function name, and the items to the
;				right are the items left on the stack when
;				the operation is completed.  Again, the right-
;				most item is the topmost item on the stack.
;				If there are no arguments or return values,
;				a dash is used instead.  As an example, the
;				PostScript operator "moveto", which consumes
;				two integers on the stack would be represented
;				as
;					<x> <y> moveto -
;
;		SIDE EFFECTS:	This section describes any other effects the
;				procedure might have, such as altering other
;				variables defined in this prolog.
;
;
;	A few coding conventions:
;		Procedure Names	- all uppercase, no more than 3 characters
;		Variable Names	- all lowercase, no more than 3 characters
;
;		The reason that the names are so short is to decrease the
;		amount of data sent to the printer.
;-----------------------------------------------------------------------


PSProlog	segment	resource



;-----------------------------------------------------------------------
;	Procedure Definitions
;-----------------------------------------------------------------------

beginPSProlog	label	byte

	char	"%%BeginProlog", NL
	char	"%%BeginResource: procset GeoWorks_PCGEOS 0 0", NL
	char	"% Copyright (c) 1991,1993 GeoWorks Incorporated.", NL
	char	"% All Rights Reserved", NL

	; allocate space for 250 items in our dictionary
	char	"/GWDict dup 250 dict def load begin", NL


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Variable Definitions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	These are a few variables used by other procedures

STACK USAGE:	none

SIDE EFFECTS:	none

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	char	"/ver 2 def /rev 0 def", NL	; version number

	char	"/cpt matrix def", NL		; current page transform
	char	"/tm matrix def", NL		; temporary matrix
	char	"/ptm matrix def", NL		; temporary matrix for paths
	char	"/ot matrix def", NL		; current object transform
	char	"/mcf 100 72 div def", NL	; mask correction factor
	char	"/xmn 0 def /xmx 0 def", NL	; xmin, xmax temps
	char	"/ymn 0 def /ymx 0 def", NL	; ymin, ymax temps

	char	"/ph 792 def /pw 612 def", NL	; page height, width
	char	"/tmp 0 def", NL		; arbitrary temp
	char	"/dm [(\377\377)(\377\377)(\377\377)(\377\377)", NL
	char	"(\377\377)(\377\377)(\377\377)(\377\377)] def", NL


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		bdef	(BindDef)
		ldef	(LoadDef)
		xdef	(eXchDef)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	A few shortcuts for procedure/variable definition
		And a few utility routines

STACK USAGE:	<key> <procedure> bdef -
		<key> <procedure> ldef -
		<value> <key>     xdef -

SIDE EFFECTS:	none

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	char	"/bdef {bind def} bind def", NL
	char	"/ldef {load def} bdef", NL
	char	"/xdef {exch def} bdef", NL


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		SO	(StartObject)
		EO	(EndObject)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	These are the start/end object brackets.  The should be 
		used around each drawn object that is emitted.

STACK USAGE:	- SO -
		- EO -

SIDE EFFECTS:	none

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	; SO (StartObject)
	; - SO -
	char	"/SO {gsave} bdef", NL

	; EO (EndObject)
	; - EO -
	char	"/EO {grestore} bdef", NL


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		BP	(BeginPage)
		EP	(EndPage)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	These are the start/end page brackets.  The should be 
		used around each page that is emitted.  

STACK USAGE:	- BP -
		- EP -

SIDE EFFECTS:	none

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	; concat procs.  this is out of the blue book, page 149.
	; {proc} {proc} CP {newproc}
	char	"/CP {/proc2 exch cvlit def /proc1 exch cvlit def", NL
	char	"/newproc proc1 length proc2 length add array def", NL
	char	"newproc 0 proc1 putinterval newproc proc1 length", NL
	char	"proc2 putinterval newproc cvx} bdef", NL

						; don't want to bdef this, 
						; since the printer drivers may 
						; supply a different definition
						; for CFL and SDC
	; BP (Begin Page)
	; - BP -
	char	"/BP {/fc [] def CFL SDC} def", NL  

	; EP (EndPage)
	; - EP -
	char	"/EP {} bdef", NL


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		SPT	(SetPageTransform)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Set the "cpt" variable

STACK USAGE:	<matrix> SPT -

SIDE EFFECTS:	none

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	char	"/SPT {/cpt xdef} bdef", NL


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		SDT	(SetDefaultTranform)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Set a new default (window) transformation for the page

STACK USAGE:	- SDT -

SIDE EFFECTS:	this takes whatever is defined by the "cpt" variable and
		concats it to the matrix required to invert the coordinate
		system.  This is called right before any objects are drawn,
		and defines the default (equivalent to PC/GEOS window-)
		transform.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	char	"/SDT {0 ph translate 1 -1 scale cpt concat} bdef", NL


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		SPS	(SetPageSize)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Set a new page height

STACK USAGE:	<width> <height> SPS -

SIDE EFFECTS:	set the "ph" and "pw" variables

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	char	"/SPS {/ph xdef /pw xdef} bdef", NL


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		SOT	(SetObjectTransform)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Set the transformation for an individual object

STACK USAGE:	<matrix> SOT -

SIDE EFFECTS:	none

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	char	"/SOT {SM dup /ot xdef concat} bdef", NL


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		SM	(SaveMatrix)
		RM	(RestoreMatrix)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Save/Restore the current transformation matrix

STACK USAGE:	- SM -
		- RM -

SIDE EFFECTS:	the variable "tm" is used to save/restore the matrix

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	char	"/SM {/tm tm currentmatrix def} bdef", NL
	char	"/RM {tm setmatrix} bdef", NL
	char	"/SPM {/ptm ptm currentmatrix def} bdef", NL
	char	"/RPM {ptm setmatrix} bdef", NL

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		L?	(Set Line Attributes)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	A few shortcuts for attribute setting routines

STACK USAGE:	<attribute> L? -
		<dash array> <offset> LD

SIDE EFFECTS:	none

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	char	"/LW /setlinewidth ldef", NL
	char	"/LJ /setlinejoin ldef", NL
	char	"/LC /setlinecap ldef", NL
	char	"/LM /setmiterlimit ldef", NL
	char	"/LD /setdash ldef",NL

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		M	(Moveto)
		L	(Lineto)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	To handle rounding errors in PostScript

STACK USAGE:	<x> <y> L -
		<x> <y> M -

SIDE EFFECTS:	none

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	char	"/T {transform round exch round exch itransform} bdef", NL
	char	"/M {T moveto} bdef", NL
	char	"/L {T lineto} bdef", NL
	char	"/RMT {T rmoveto} bdef", NL
	char	"/RLT {T rlineto} bdef", NL

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		SGC	(Set GEOS Color)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Some color related routines.  We set colors using RGB, and
		supply some default color transfer operators, under-color
		removal and black generation in the form of a procedure called
		SDC (SetupDeviceColor).  This procedure should be replaced by
		the printer driver (or other user of the translation library)
		to achieve better color output.  The procedure is invoked
		at the beginning of each page.

		PRINTER DRIVERS: should define their own SDC function, which
		should consist of invocations of the setundercolorremoval,
		setblackgeneration and setcolortransfer operators, to achieve
		proper color reproduction.

STACK USAGE:	<R> <G> <B> SGC -

SIDE EFFECTS:	none

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	
	char	"/SDC {} bdef", NL
	char	"/SGC {255 div 3 1 roll 255 div 3 1 roll 255 div 3 1 roll", NL
	char	"setrgbcolor} bdef", NL


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		DL	(DrawLine)
		DPL	(DrawPolyline)
		FPW	(FillPolygon - winding rule)
		FPO	(FillPolygon - odd-even rule)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	draw a {line,polyline,polygon}, attributes already setup

STACK USAGE:	      <x1> <y1> <x2> <y2> DL -
		.... <xn> <yn> <#coords> PDL -
		.... <xn> <yn> <#coords> FPW -
		.... <xn> <yn> <#coords> FPO -

SIDE EFFECTS:	none

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	; CPP (CalcPolyPath)
	char	"/CPP {3 1 roll M {L} repeat} bdef", NL

	; CPCP (CalcPolyCurvePath)
	char	"/CPCP {3 1 roll M 3 div {T 4 2 roll T 6 -2 roll", NL
	char	" T curveto} repeat} bdef", NL

	; CPRCP (CalcPolyRelCurvePath)
	char	"/CPRCP {3 div {T 4 2 roll T 6 -2 roll T curveto}", NL
	char	" repeat} bdef", NL

	char	"/DL {newpath M L RM stroke} bdef", NL
	char	"/DLT {newpath L RM stroke} bdef", NL
	char	"/DRLT {newpath RLT RM stroke} bdef", NL

	; FPMO (FillPolyMaskOdd}
	; fill a polyon with a draw mask, using odd-even fill rule
	char	"/FPMO {/dm xdef newpath CPP closepath pathbbox eoclip MCP} bdef", NL

	; FPMW (FillPolyMaskWinding}
	; fill a polyon with a draw mask, using winding fill rule
	char	"/FPMW {/dm xdef newpath CPP closepath pathbbox clip MCP} bdef", NL

	; DML (DrawMaskLine)
	char	"/DML {/dm xdef newpath M L FLM} bdef", NL
	; DMPL (DrawMaskPolyline)
	char	"/DMPL {/dm xdef newpath CPP FLM} bdef", NL
	; DMPG (DrawMaskPolygon)
	char	"/DMPG {/dm xdef newpath CPP closepath FLM} bdef", NL

	; DPL (DrawPolyline)
	char	"/DPL {newpath CPP RM stroke} bdef", NL
	; DPG (DrawPolygon)
	char	"/DPG {newpath CPP closepath RM stroke} bdef", NL
	; FPW (FillPolygonWinding)
	char	"/FPW {newpath CPP fill} bdef", NL
	; FPO (FillPolygonOddEven)
	char	"/FPO {newpath CPP eofill} bdef", NL

	; DS (DrawSpline)
	char	"/DS {newpath CPCP RM stroke} bdef", NL
	; DST (DrawSplineTo)
	char	"/DST {newpath CPRCP RM stroke} bdef", NL
	; DMS (DrawMaskSpline)
	char	"/DMS {/dm xdef newpath CPCP FLM} bdef", NL
	; DMST (DrawMaskSplineTo)
	char	"/DMST {/dm xdef newpath CPRCP FLM} bdef", NL

	; FPaW	(FillPath (winding rule))
	char	"/FPaW {closepath RPM fill} bdef", NL
	; FPaO	(FillPath (odd/even rule))
	char	"/FPaO {closepath RPM eofill} bdef", NL
	; FPaMW (FillPathMask (winding rule))
	char	"/FPaMW {/dm xdef closepath RPM pathbbox clip MCP} bdef", NL
	; FPaMO (FillPathMask (odd/even rule))
	char	"/FPaMO {/dm xdef closepath RPM pathbbox eoclip MCP} bdef", NL


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FR	(FillRect)
		DR	(DrawRect)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	draw/fill/set-clip-path to a rect, attributes already setup

STACK USAGE:	<x2> <y2> <x1> <y1> FR -
		<x2> <y2> <x1> <y1> DR -
	<width> <height> <xpos> <ypos> <mask array> <x2> <y2> <x1> <y1> FMR -

SIDE EFFECTS:	none

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	; CRP (CalcRectPath)
	char	"/CRP {4 copy 4 1 roll exch M exch 4 2 roll"
	char	" L L L closepath} bdef", NL

	; FR (FillRect)
	char	"/FR {newpath CRP fill} bdef", NL
	; DR (DrawRect)
	char	"/DR {newpath CRP RM stroke} bdef", NL

	; SRC (SetRectClip)
	; sets a rectangular clip path
	char	"/SRC {currentpoint 6 2 roll newpath CRP clip M} bdef", NL

	; XC
	; Transform Coords
	; transforms coords by current object transform and converts to int
	char	"/XC {ot transform round cvi exch round cvi exch} bdef", NL

	; DIS
	; CalcCoordDistance
	; calculate distance between two coords.  Takes 2 coord pairs on stack
	char	"/DIS {XC 4 2 roll XC exch 4 1 roll sub 3 1 roll", NL
	char	"sub dup mul exch dup mul add sqrt round cvi} bdef", NL

	; MinXY
	; gets the minimum x and y values from rectangle parameters on the stack
	char	"/MXY {3 index 2 index gt {1 index}{3 index}ifelse", NL
	char	"3 index 2 index gt {1 index}{3 index}ifelse} bdef", NL

	; DeltaXY
	; gets the delta-x and delta-y values from rectangle parameters 
	; on the stack
	char	"/DXY {3 index 2 index sub abs 3 index 2 index sub abs} bdef",NL

	; MCP 
	; MaskClipPath
	; this is used to mask out an area defined by the current clippath
	char	"/MCP {MXY translate DXY scale 4 copy pop 1 index", NL
	char	"DIS 5 1 roll exch pop 2 index exch DIS mcf mul round cvi", NL
	char	"dup /dy xdef exch mcf mul round cvi 15 add 15 not and", NL
	char	"dup 16 idiv dup /dx xdef /xt xdef", NL
	char	"exch true [ 3 index 0 0 5 index 0 0 ]", NL
	char	"{dm dy 7 and get xt 1 sub dup 0 eq {pop dy 1 sub /dy xdef", NL
	char	"dx}if /xt xdef} bind imagemask} bdef", NL

	; FLM (FinishLineMask)
	; common code for finishing mask
	char	"/FLM {RM strokepath ot concat flattenpath pathbbox"
	char	" clip MCP} bdef", NL

	; DMR (DrawMaskRect)
	; This is used by code that needs to set a draw mask.  It takes 
	; rectangle bounds and a mask array on the stack
	char	"/DMR {/dm xdef newpath CRP FLM} bdef", NL
	; FMR (FillMaskRect)
	char	"/FMR {/dm xdef newpath CRP pathbbox clip MCP} bdef", NL


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		DC	(DrawCurve)
		DMC	(DrawMaskCurve)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	draw a curve, attributes already setup

STACK USAGE:	<x3> <y3> <x1> <y1> <x2> <y2> <x0> <y0> DC -

SIDE EFFECTS:	none

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	; CCTP (CreateCurvePath)
	char	"/CCTP {T 6 2 roll T 6 2 roll T curveto} bdef", NL

	; CCP (CreateCurvePath)
	char	"/CCP {M CCTP} bdef", NL

	; DC (DrawCurve)
	char	"/DC {newpath CCP RM stroke} bdef", NL

	; DRC (DrawRelCurve)
	char	"/DRC {newpath rcurveto RM stroke} bdef", NL

	; DMC (DrawMaskCurve)
	; <x3> <y3> <x1> <y21 <x2> <y2> <x0> <y0> [mask array] DMC -
	char	"/DMC {/dm xdef newpath CCP FLM} bdef", NL


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FE	(FillEllipse)
		DE	(DrawEllipse)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	draw/fill an ellipse, attributes already setup

STACK USAGE:	<x2> <x1> <y2> <y1> FE -
		<x2> <x1> <y2> <y1> DE -
		
		RC function helps calculate center and radius

		<x2> <x1> RC <abs deltaX> <midpoint (X2,X1)>

SIDE EFFECTS:	none

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	; "RC" calculates the radius and center of the ellipse
	;  <x2> <x1> RC <abs deltaX> <midpoint>
	char	"/RC {dup 3 1 roll sub 2 div dup abs 3 1 roll add} bdef", NL

	; CEP (CalcEllipsePath)
	char	"/CEP {RC 4 2 roll RC 2 index translate 3 1 roll pop"
	char	" scale 0 0 1 0 360 arc closepath} bdef", NL

	; FE (FillEllipse)
	char	"/FE {newpath CEP fill} bdef", NL
	; DE (DrawEllipse)
	char	"/DE {newpath CEP RM stroke} bdef", NL

	; DME (DrawElllipseMask)
	; This is used by code that needs to set a draw mask.  
	char	"/DME {/dm xdef newpath CEP FLM} bdef", NL

	; FME (FillMaskEllipse)
	char	"/FME {/dm xdef 4 copy newpath CEP clip 4 copy RC 4 2 roll", NL
	char	"RC 2 index 5 2 roll 3 1 roll pop 1 exch div exch", NL
	char	"1 exch div exch scale exch neg exch neg translate", NL
	char	"exch 4 -1 roll exch MCP} bdef", NL


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		DA	(DrawArc)
		FA	(FillArc)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	draw/fill an ellipse, attributes already setup

STACK USAGE:	<ang1> <ang2> <x2> <x1> <y2> <y1> DA -
		<ang1> <ang2> <x2> <x1> <y2> <y1> FA -

SIDE EFFECTS:	none

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	; MP1 (MovePoint1)
	; Moves to the first point along an arc.  <ang1> <ang2> on stack
	char	"/MP1 {exch dup dup cos exch sin M exch} bdef", NL

	; SA (StartArc)
	; Initial common stuff for all three arc types
	char	"/SA {RC 4 2 roll RC 2 index translate 3 1 roll pop"
	char	" scale 0 0 1 5 -2 roll} bdef", NL

	; CAP (CalcArcPath)
	; "CAPO" calculates the arc path, open style
	; "CAPP" calculates the arc path, pie style
	; "CAPC" calculates the arc path, chord style
	char	"/CAPO {SA MP1 arc} bdef", NL
	char	"/CAPP {SA 0 0 M arc closepath} bdef", NL
	char	"/CAPC {SA MP1 arc closepath} bdef", NL

	; DA (DrawArc) three versions for three arc types (Open, Pie, Chord)
	char	"/DAO {newpath CAPO RM stroke} bdef", NL
	char	"/DAP {newpath CAPP RM stroke} bdef", NL
	char	"/DAC {newpath CAPC RM stroke} bdef", NL

	; DMA (DrawMaskArc) 3 versions for three arc types (Open, Pie, Chord)
	char	"/DMAO {/dm xdef newpath CAPO FLM} bdef", NL
	char	"/DMAP {/dm xdef newpath CAPP FLM} bdef", NL
	char	"/DMAC {/dm xdef newpath CAPC FLM} bdef", NL

	; FA (FillArc) two versions for two arc types (Pie, Chord)
	char	"/FAP {newpath CAPP fill} bdef", NL
	char	"/FAC {newpath CAPC fill} bdef", NL

	; FMA (FillMaskArc} 2 versions (PIE, CHORD)
	char	"/FMAP {/dm xdef newpath CAPP RM pathbbox clip MCP} bdef", NL
	char	"/FMAC {/dm xdef newpath CAPC RM pathbbox clip MCP} bdef", NL

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		DRR	(DrawRoundedRect)
		FRR	(FillRoundedRect)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	draw/fill a rounded rectangle, attributes already setup

STACK USAGE:	<x1+r> <y1+r> <x2-r> <y2-r> <r> DRR -
		<x1+r> <y1+r> <x2-r> <y2-r> <r> FRR -

		<(deltaX/2)-r> <(deltaY/2)-r> <r> <xcenter> <ycenter> DRR -
		<(deltaX/2)-r> <(deltaY/2)-r> <r> <xcenter> <ycenter> FRR -

SIDE EFFECTS:	none

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	; CRRP (CalcRoundRectPath)
	char	"/CRRP {translate 3 copy 3 -1 roll add exch M",NL
	char	"3 copy exch neg exch 0 270 arcn 2 index neg 2 index neg 2",NL
	char	"index 270 180 arcn 3 copy 3 -1 roll neg 3 1 roll 180 90",NL
	char	"arcn 90 0 arcn closepath} bdef", NL

	; DRR (DrawRoundRect)
	char	"/DRR {newpath CRRP RM stroke} bdef", NL

	; DMRR (DrawMaskRoundRect)
	char	"/DMRR {/dm xdef newpath CRRP FLM} bdef", NL

	; FRR (FillRoundRect)
	char	"/FRR {newpath CRRP fill} bdef", NL

	; FMRR (FillMaskRoundRect)
	char	"/FMRR {/dm xdef newpath CRRP pathbbox clip MCP} bdef", NL

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Font Encoding
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	table of encodings for GEOS fonts

STACK USAGE:	<geosvec> <new name> <PostScript font name> REF -
		<PS font name> FF <boolean>
		<PS font name> MNF <new name>
			
SIDE EFFECTS:	none

NOTE:
		The strategy we will use to build/cache fonts is this:
		We'll keep an array that is formatted as follows:

		[ <fontname> <fontname> ...]

		where:	<fontname> - is the new (re-encoded) name of the 
				     font (/_Helvetica == /Helvetica, for
				     example)

		when a request for a new font comes down the pike, we'll
		look it up first here.  If it is already in the array, then
		we don't need to build it, else we build it and add it to
		the array.  Eventually, we may implement some maximum
		number of fonts allowed to be cached, if a large number has
		some bad effects on the amount of memory available.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	; CreateFontList (CFL)
	; use a kind of generic method for getting a list of all the fonts
	; that are available on the device.  This function will likely be
	; overwritten by a function provided by a printer driver.
	; This one will get all the font names defined in the font directory,
	; but may miss fonts available on other storage devices (like an 
	; attached hard disk).  The printer-driver-supplied version can add
	; this functionality (which is device dependent).  It creates a 
	; variable called "fl" which holds an array of font names.
	char	"/CFL {mark FontDirectory {pop} forall", NL
	char	"/filenameforall where {pop (fonts/*)", NL
	char	"{dup length 6 sub 6 exch getinterval cvn} bind", NL
	char	"128 string filenameforall} if", NL
	char	"counttomark array astore /fl xdef pop} bdef", NL

	; SAE (Search Array for an Element)
	; <array> <any> SAE <boolean>
	; routine searches passed array for passed element, returns a boolean
	; value
	char	"/SAE {/tmp xdef mark false 3 -1 roll {tmp eq {cleartomark", NL
	char	"true exit}if}forall{true}{cleartomark false}ifelse}bdef", NL

	; FAF (FindAdobeFont)
	; <PS font name> FAF <boolean>
	; routine to find a font name in the fontlist (fl) that we've built.
	; like FF, you pass a font name.
	char	"/FAF {fl exch SAE} bdef", NL

	; new character encoding vector.
	char	"/geosvec [30 /hyphen 128 /Adieresis/Aring", NL
	char	"/Ccedilla/Eacute/Ntilde", NL
	char	"/Odieresis/Udieresis/aacute/agrave/acircumflex/adieresis", NL
	char	"/atilde/aring/ccedilla/eacute/egrave/ecircumflex", NL
	char	"/edieresis/iacute/igrave/icircumflex/idieresis/ntilde", NL
	char	"/oacute/ograve/ocircumflex/odieresis/otilde/uacute", NL
	char	"/ugrave/ucircumflex/udieresis/dagger/degree/cent", NL
	char	"/sterling/section/bullet/paragraph/germandbls/registered", NL
	char	"/copyright/trademark/acute/dieresis/notequal/AE", NL
	char	"/Oslash/infinity/plusminus/lessequal/greaterequal/yen", NL
	char	"/mu/partialdiff/Sigma/Pi/pi/integral", NL
	char	"/ordfeminine/ordmasculine/Omega/ae/oslash/questiondown", NL
	char	"/exclamdown/logicalnot/radical/florin/approxequal/Delta", NL
	char	"/guillemotleft/guillemotright/ellipsis", NL
	char	"/space/Agrave/Atilde/Otilde/OE/oe", NL
	char	"/endash/emdash/quotedblleft/quotedblright/quoteleft", NL
	char	"/quoteright/divide/lozenge/ydieresis", NL
	char	"/Ydieresis/fraction/currency/guilsinglleft/guilsinglright", NL
	char	"/yacute/Yacute/daggerdbl/periodcentered", NL
	char	"/quotesinglbase/quotedblbase/perthousand", NL
	char	"/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute ", NL
	char	"/Icircumflex/Idieresis/Igrave/Oacute/Ocircumflex/.notdef", NL
	char	"/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex", NL
	char	"/tilde/macron/breve/dotaccent/ring/cedilla", NL
	char	"/hungarumlaut/ogonek/caron] def", NL

	; REF (Re-Encode Font)
	; geosvec <new name> <PostScript font name> REF -
	; routine to re-encode a font. This code is directly out of 
	; PostScript Language Program Design, page 116.
	char	"/REF {findfont begin currentdict dup length dict begin", NL
	char	"{1 index /FID ne {def} {pop pop} ifelse} forall", NL
	char	"/FontName xdef dup length 0 ne {/Encoding Encoding 256", NL
	char	"array copy def 0 exch {dup type /nametype eq", NL
	char	"{Encoding 2 index 2 index put pop 1 add}{exch pop}ifelse}", NL
	char	"forall}if pop currentdict dup end end /FontName get", NL
	char	"exch definefont pop} bdef", NL

	; CFN (CreateFontName)
	; <PS font name> MFN <new font name>
	; Takes an adobe name and prepends an underscore character.
	char	"/CFN {dup length dup 1 add string /ts xdef string cvs", NL
	char	"1 exch ts 3 1 roll putinterval ts 0 (_) putinterval", NL
	char	"ts cvn} bdef", NL

	; FF (FindFont)
	; <PS font name> FF <boolean>
	; this is one of the font caching routines.  It checks the "fc"
	; variable (an array, defined above) to see if the passed font
	; is already built.  If so, it returns TRUE, else it returns FALSE
	char	"/FF {CFN fc exch SAE}bdef", NL
		
	; MNF (MakeNewFont)
	; <PS font name> MNF <new font name>
	; this is another of the font-caching related routines.  It takes an 
	; Adobe font-name and creates a new re-encoded font and adds it into 
	; the font cache array. Eventually, we may have this routine do some 
	; garbage collection when we've built out too many fonts.  Since 
	; we're gonna use the font right away, this routine leaves the name 
	; of the new font on the stack
	char	"/MNF {dup dup FAF not {pop /Courier}if exch CFN", NL
	char	"dup 2 index geosvec 3 1 roll REF dup fc aload length", NL
	char	"1 add array astore /fc xdef exch pop}bdef", NL


	; these procedures for type3 font downloading
	char	"/MFC {dup /Courier geosvec 3 1 roll REF fc aload length", NL
	char	"1 add array astore /fc xdef} bdef", NL

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Text Setting support routines
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	There are a bunch of routines here, all designed to get
		text out.

STACK USAGE:	<string> SPC <int>
		<track kern> <fontname> <StdEncode?> <pointsize> SF -
		[style-run] CM -
		[style-run] DSR -
		[style-run] PSR -
		[style-group] <space-pad> <string-width> x y DSG -
		[style-group] <space-pad> <string-width> x y PSG -
		<y offset> SS -
		<length> <y offset> <thickness> UL -
		<sp_padX> <sp_padY> <space> <t_kernX> <t_kernY> (string) PAWS -

SIDE EFFECTS:	none

NOTES:
		For GrDrawTextField elements, the text is drawn as a group
		of consecutive style runs (a style group).  A style group 
		represents an entire GrDrawTextField element.

		Each style group is passed on the stack as an array of 
		style runs.  Each style run is an array of other info.  The
		structure of a style run is:

	[(string) {attr-info} <track kern> <font> <size> <style matrix> ]

		where:
			(string)	- the text string to draw, in parens
			{attr-info}	- commands to set attributes, in curly
					  braces
			<track kern>	- track kerning for style run
			<font>		- a valid PostScript font name
			<boolean>	- true if font is encoded w/Standard
					  encoding
			<size>		- the current pointsize
			<style-matrix>	- transformation matrix to effect the
					  current style

		These style runs are then strung together on the stack:

		[ [style-run] [style-run] ... ]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	; allocate space for some variables we use here

	char	"/ps 0 def", NL		; point size
	char	"/ctw 0 def", NL	; current text width
	char	"/gtw 0 def", NL	; geos text width
	char	"/ccl 0 def", NL	; current character length
	char	"/csc 0 def", NL	; current space count
	char	"/psp 0 def", NL	; passed space padding
	char	"/rtk 0 def", NL	; run track kerning (for style run)
	char	"/ntk 0 def", NL	; net track kerning (for style group)

	; SPC (SPaceCount)
	; count spaces in a string
	char	"/SPC {0 exch (\040) {search {pop 3 -1 roll 1 add 3 1 roll}"
	char	" {pop exit} ifelse} loop} bdef", NL

	; SF (SetFont)
	; set a new font and pointsize
	char	"/SF {/ps xdef {dup FF {CFN}{MNF}ifelse}if", NL
	char	"findfont [ps 0 0 0 ps sub 0 0] makefont setfont /rtk",NL
	char	"xdef} bdef", NL

	; ITC (InitTextCalcs)
	; initialize some running variables
	char	"/ITC {/ctw 0 def /ccl 0 def /csc 0 def /ntk 0 def} bdef", NL

	; CMR (CalcMetrics-for-a-Run)
	; calculate values need for metrics calculations: #chars, #spaces, 
	; current text width.  a style run is on the stack.
	char	"/CMR {aload pop 7 1 roll SF pop dup 3 1 roll", NL
	char	"stringwidth 3 -1 roll transform pop ctw", NL
	char	"add /ctw xdef dup SPC csc add /csc xdef length dup", NL
	char	"ccl add /ccl xdef pop} bdef", NL

	; DSR (DrawStyleRun)
	; draw a style run.
	char	"/DSR {aload pop SM concat SF exec psp 0 32 ntk 0 6 -1", NL
	char	"roll awidthshow RM} bdef", NL

	; CMG (CalcMetrics-for-a-Group)
	; calculate metrics for a styles group
	char	"/CMG {{CMR} forall psp csc mul ctw add /ctw xdef } bdef", NL

	; DSG (DrawStylesGroup)
	; draw a style group.  This involves quite a bit of stuff, including
	; calculating text metrics, setting fonts, implementing styles, 
	; drawing the strings...
	char	"/DSG {M /gtw xdef /psp xdef ITC dup ", NL
	char	"CMG gtw ctw sub ccl dup 0 ne {div}{pop pop 0}ifelse", NL
	char	"/ntk xdef {DSR} forall} bdef", NL

	; SS (Sub/Superscript Motion)
	; local movement (RMT) to place sub/superscript text
	char	"/SS {0 exch RMT} bdef", NL

	; UL (UnderLine)
	; also used for strikethru.  thickness, length and y offset passed 
	; on stack.
	char	"/UL {gsave currentpoint newpath moveto RM setlinewidth",NL
	char	"0 exch RMT 0 RLT stroke grestore} bdef", NL

	; PAWS (PathAWidthShow)
	; implements a subset of the "awidthshow" function, but adds the
	; chars to the current path instead of drawing them.
	; (string) <sp_padX> <t_kernX> PAWS -
	char	"/PAWS {/tkx xdef /spx xdef /cidx 0 def dup length {dup",NL
	char	"cidx 1 getinterval dup true charpath tkx 0 rmoveto (\040)",NL
	char	"eq {spx 0 rmoveto}if /cidx cidx 1 add def}repeat pop} bdef",NL

	; PSR (PathStyleRun)
	; Similar to DrawStyleRun, but adds the run to the current path
	char	"/PSR {aload pop SM concat SF exec psp ntk PAWS RM} bdef",NL
	
	; PSG (PathStyleGroup)
	; This is a companion to the DrawStyleGroup function, which will add
	; the style group to the current path instead of drawing it.  This
	; is quite a bit trickier, since there is no function like awidthshow
	; that will do what it does to the current path.  Sigh.  
	; So we have to simulate that function here.
	char	"/PSG {M /gtw xdef /psp xdef ITC dup ", NL
	char	"CMG gtw ctw sub ccl dup 0 ne {div}{pop pop 0}ifelse", NL
	char	"/ntk xdef {PSR} forall} bdef", NL


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		DMB	(DrawMonoBitmap)
		DCB	(DrawColorBitmap)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Draw a monochrome or color image (bitmap)

STACK USAGE:	<width> <height> <linesize> <xscale> <yscale> \
				<xpos> <ypos> DMB data -
		<width> <height> <linesize> <xscale> <yscale> \
				<xpos> <ypos> DCB data -

SIDE EFFECTS:	none

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	; DrawMonoBitmap
	; This draws a plain vanilla monochrome bitmap
	; Changed to send mixed binary/ascii data in an attempt to
	; speed up bitmap printing.  jimw 10/15/96
	; char	"/DMB {translate scale /bms exch string def", NL
	; char	"true [ 3 index  0 0 5 index  0 0]", NL
	; char	"{currentfile bms readhexstring pop} bind imagemask} bdef", NL

	; readnextbyte reads the next byte, skipping any CR/LF
	; this is needed to allow line breaks between binary encoded lines
	char	"/readnextbyte % skip CR/LF and return next byte", NL
	char	"{ 1 index read pop dup 10 eq { pop readnextbyte }", NL
	char	"{ dup 13 eq { pop readnextbyte } if } ifelse", NL 
	char	"} bdef", NL

	; readmixedstring reads a tag byte to decide whether to call
	; readstring (bin) or readhexstring (ascii).

	char	"/readmixedstring    % file string -> substring bool", NL
	char	"{ readnextbyte 66 eq { readstring } { readhexstring }", NL
	char	"ifelse} bdef", NL

	; DrawMonoBitmap
	; This draws a fax bitmap using readmixedstring above.  This allows us
	; to take advantage of sending less data (binary) while avoiding
	; potential escape code character problems that occur.  See
	; EmitMonoBitmap for more info.
	char	"/DMB {translate scale /bms exch string def", NL
	char	"true [3 index  0 0 5 index  0 0]", NL
	char	"{ currentfile bms readmixedstring pop } bind imagemask} bdef", NL

	; Draw4BitGreyBitmap
	; This draws a 4 bit greyscale bitmap
	char	"/DGB {translate scale /bms exch string def 4", NL
	char	"[ 3 index  0 0 5 index  0 0]", NL
	char	"{currentfile bms readhexstring pop} bind image} bdef", NL

	; Draw8BitGreyBitmap
	; This draws a 4 bit greyscale bitmap
	char	"/DXB {translate scale /bms exch string def 8", NL
	char	"[ 3 index  0 0 5 index  0 0]", NL
	char	"{currentfile bms readhexstring pop} bind image} bdef", NL

	; UCB
	; UncompactColorBitmap
	; This function uncompacts a color bitmap.  It takes an string on
	; the stack into which a scan line of the bitmap will be placed.  The
	; string should be sized to one byte per pixel.
	char	"/s1 1 string def", NL
	char	"/UCB {dup /sl xdef length /ll xdef /cp 0 def", NL
	char	"{cp ll ge {exit}if", NL		; if done uncompacting
	char	"currentfile s1 readhexstring pop 0 get dup", NL
	char	"127 le", NL
	char	"{1 add dup currentfile sl cp 4 -1 roll getinterval", NL
	char	" readhexstring pop sl cp 3 -1 roll putinterval}", NL
	char	"{257 exch sub dup currentfile s1 readhexstring pop 0 get", NL
	char	" exch cp add 1 sub cp 1 3 -1 roll", NL
	char	" {sl exch 2 index put}for pop}",NL
	char	"ifelse cp add /cp xdef} loop sl} bdef", NL

	; DrawColorBitmap
	; This draws a color bitmap
	char	"/DCB {translate scale dup dup string /rs xdef string", NL
	char	"/gs xdef string /bs xdef 8 [ 3 index 0 0 5 index 0 0 ]", NL
	char	"{rs UCB}bind {gs UCB}bind {bs UCB}bind", NL
	char	"true 3 colorimage} bdef", NL

;	this marks the end of the GWDict dictionary
;
	char	"end", NL
	char	"%%EndResource", NL
endPSProlog	label	byte



PSProlog	ends
