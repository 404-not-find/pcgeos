COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) Berkeley Softworks 1990 -- All Rights Reserved

PROJECT:	PC GEOS
MODULE:		
FILE:		parseConstants.def

AUTHOR:		John Wedgwood, Jan 16, 1991

	
REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	jcw	 1/16/91	Initial revision


DESCRIPTION:
	Constants and structures for the parser library.
		
	$Id: parseConstants.def,v 1.1 97/04/05 01:27:14 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

	_SMART_PERCENT		equ	FALSE


PARSE_SEGMENT_HAS_NO_HANDLE			enum FatalErrors
PARSE_SEGMENT_IN_UNLOCKED_BLOCK			enum FatalErrors
PARSE_PASSED_OFFSET_PAST_END_OF_BLOCK		enum FatalErrors
FORMAT_ILLEGAL_PARSER_TOKEN_TYPE		enum FatalErrors
ILLEGAL_ERROR_CODE				enum FatalErrors
EVAL_ILLEGAL_PARSER_TOKEN			enum FatalErrors
EVAL_BAD_ARGUMENT_TYPE				enum FatalErrors
EVAL_BAD_OPERATOR_TYPE				enum FatalErrors
EVAL_NOT_ENOUGH_STACK_SPACE			enum FatalErrors
EVAL_TOP_OF_OPSTACK_NOT_OPERATOR_OR_FUNCTION	enum FatalErrors
EVAL_OPEN_PAREN_SHOULD_NOT_BE_ON_OPERATOR_STACK	enum FatalErrors
EVAL_CANT_POP_ARGUMENT_TOP_OF_STACK		enum FatalErrors
EVAL_CANT_POP_OPERATOR_TOP_OF_STACK		enum FatalErrors
EVAL_CANT_POP_AND_EVAL_TOP_OF_STACK		enum FatalErrors
EVAL_SUCCESSFUL_BUT_TOP_OF_STACK_NOT_FOUND	enum FatalErrors
EVAL_UNEXPECTED_OPERATOR_TYPE			enum FatalErrors
PARSER_CURRENT_ROW_BEYOND_MAX_ROW		enum FatalErrors
PARSER_CURRENT_COLUMN_BEYOND_MAX_COLUMN		enum FatalErrors
PARSER_TEXT_CONTAINS_ILLEGAL_CONTROL_CHARACTERS	enum FatalErrors
EVAL_EXPECTED_A_RANGE_TO_EXTEND			enum FatalErrors
EVAL_EXPECTED_A_RANGE_TO_EXTEND_WITH		enum FatalErrors

DEPENDENCY_ERROR				enum FatalErrors
CANT_REMOVE_DEPENDENCY_FROM_NON_EXISTENT_CELL	enum FatalErrors
DEPENDENCY_LIST_ITEM_SHOULD_NOT_EXIST		enum FatalErrors
DEPENDENCY_LIST_ITEM_MUST_EXIST			enum FatalErrors
CELL_MUST_EXIST_TO_ADD_DEPENDENCY		enum FatalErrors
EVAL_LEFT_TOO_MANY_ARGUMENTS			enum FatalErrors
NESTING_LEVEL_SHOULD_BE_ZERO			enum FatalErrors
ARG_COUNT_IS_VERY_UNREASONABLE			enum FatalErrors
CELL_MUST_EXIST_TO_REMOVE_DEPENDENCY		enum FatalErrors
ILLEGAL_TOKEN_TYPE_IN_DEPENDENCY_BLOCK		enum FatalErrors
ILLEGAL_ARGUMENT_TO_GET_ARG_SIZE		enum FatalErrors
ILLEGAL_DEPENDENCY_TYPE				enum FatalErrors

FUNCTION_BAD_DATE				enum FatalErrors
FUNCTION_BAD_TIME				enum FatalErrors
BOOLEAN_FUNCTION_EXPECTED_A_NUMBER		enum FatalErrors
FUNCTION_ASSERTION_FAILED			enum FatalErrors
FUNCTION_BAD_FP_STACK_DEPTH			enum FatalErrors

POINTER_SEGMENT_NOT_SAME_AS_STACK_FRAME		enum FatalErrors
; This error occurs in a C stub when the caller passes a pointer
; that should be in the current stack frame (which is done by declaring
; a local variable in a C function then passing a pointer to the variable).

PARSE_STRING_SEGMENT_FAILED_ASSERTION		enum FatalErrors
; A segment register was assumed to still be pointing at the string
; that was passed for parsing. It is no longer the case, and is
; probably becase of a missed reference to the earlier
; ERROR_DIFFERENT_SEGMENT_BOGOSITY problem. Or a memory trashing bug
; that has overwritten part of the stack.

FORMAT_BUFFER_TOO_SMALL				enum FatalErrors
; A passed buffer to receive the results of a formatting operation
; is too small.

ILLEGAL_FUNCTION_INDEX				enum FatalErrors
; An illegal index was specified when requesting a function moniker,
; argument list or description.

PARSE_STRING_TOO_LONG				enum FatalErrors
; A string, either passed or generated by a parse library function,
; grew past the limit of MAX_STRING_LENGTH.

ODDSIZED_DBCS_STRING				enum FatalErrors
;	A string has an odd byte size, which shouldn't exist under DBCS.


;
; we have functions for Standard Deviation and Variance that
; work on entire populations in addition to working on samples of
; a population
;
VarianceFlags	record
	VF_FOR_ENTIRE_POPULATION:1
VarianceFlags	end

;
; Flags for use in the comparison routines. These must match the
; processor flags for equal and carry.
;
CompareFlags	record
    CF_SIGN:1			; Set: Return true if arg1 < arg2
    CF_ZERO:1			; Set: Return true if arg1 = arg2
    :5				; (?, Aux carry, ?, Parity, ?)
    :1				; Carry
CompareFlags	end

LookupSearchFlags	record
    LSF_VERTICAL:1		; Set: search in the vertical direction
				; else search horizontally
LookupSearchFlags	end

;*******************************************************************************
;	STACK FRAMES
;*******************************************************************************

FUNCTION_IRR_THRESHOLD_EXP	= 5	; done if result if within 1/10^this

FUNCTION_IRR_LOOP_COUNT		= 40

functionEnv	struct
    ;
    ; stuff from PopOperatorAndEval
    ;
    FE_argStack		fptr	; es:bx
    FE_numArgs		word	; cx		necessary???
    FE_evalParams	word	; bp

    ;
    ; the operation that will be performed with each cell
    ;
    FE_argProcessingRoutine	dword
    FE_argsReqForProcRoutine	word
				; number of args that FE_argProcessingRoutine
				; routine requires before commencing operations
    FE_returnSingleArg	byte
				; boolean - if there is a single argument, do
				; we return it?
    FE_nearRoutine	byte	; boolean - is FE_argProcessingRoutine near?
    FE_ignoreEmpty	byte	; boolean - do we work on empty cells?
				; default is yes
    FE_nonNumsOK	byte	; boolean - ok to ignore non numbers?
    ;
    ; other useful things that are tracked
    ;
    FE_curArgType	EvalStackArgumentType
    FE_cellRef		RangeEnumFlags	; work on new cells?
    FE_cellCount	word	; count of the number of cells processed
    FE_numCount		word	; count of the number of numbers processed
    FE_errorCode	byte	; =ParserScannerEvaluatorError except 0 = no err
    FE_errorPropagated	byte	; is error new / propagated?
    ;
    ; intermediate results
    ; intransitive operations or operations that leave more than
    ;     1 intermediate result cannot leave intermediate results
    ;     on the fp stack (eg. STD(a1, a2) ), so...
    ;
    FE_threshold	label FloatNum	; used in FunctionIRR
    FE_result1	FloatNum

    FE_lowerBound	label FloatNum	; used in FunctionIRR
    FE_result2	FloatNum

    FE_upperBound	label FloatNum	; used in FunctionIRR
    FE_result3	FloatNum
    ;
    ; routines may use this flag to signal different things
    ;
    FE_miscFlag	byte

    FE_loopCount	word		; used in FunctionIRR
functionEnv	ends

;
; Buffer size for maximum length string.  Add space for the NULL,
; and round up to force it to be even.
;
SBCS<MAX_STRING_LENGTH_BUF_SIZE	equ	(MAX_STRING_LENGTH+1+1)/2*2	>
DBCS<MAX_STRING_LENGTH_BUF_SIZE	equ	(MAX_STRING_LENGTH+1)*(size wchar) >

strBuf	struct
SBCS<	SB_buf		char MAX_STRING_LENGTH_BUF_SIZE dup (?)		>
DBCS<	SB_buf		wchar MAX_STRING_LENGTH_BUF_SIZE/(size wchar) dup (?)	>
	SB_saveBP	word
	;
	; misc storage
	;
SBCS<	SB_str1		fptr.char				>
DBCS<	SB_str1		fptr.wchar				>
	SB_str1Len	word
SBCS<	SB_str2		fptr.char				>
DBCS<	SB_str2		fptr.wchar				>
	SB_str2Len	word

	SB_wd1		word
	SB_wd2		word
strBuf	ends

rangeInfoStruct	struct
	RIS_rowTop		word
	RIS_columnLeft		word
	RIS_rowBot		word
	RIS_columnRight		word
	RIS_rowOffset		word
	RIS_colOffset		word
	RIS_saveBP		word

	;
	; the following fields are for the LOOKUP functions
	;
	RIS_searchFlag		byte
	RIS_curRow		word
	RIS_curCol		word
rangeInfoStruct	ends
