******************************************************************************

This document will probably make more sense if you understand the basics
of scanners and parsers.

$Id: THOUGHTS,v 1.1.35.1 97/03/29 03:48:34 canavese Exp $

******************************************************************************

The geoCalc language is embodied in the scanner, parser, and evaluator.

The scanner is responsible for identifying items in the text and
communicating them to the parser. The scanner has no knowledge of the
current context, it simply grabs the next logical item from the text stream
interprets it (eg: converting a string to a number) and returns the type
of the item and any data associated with that item to the parser.

The parser is responsible for making sense out of the input. It maintains
a concept of the current context and makes sure that the expression entered
by the user is legal.

Type checking of function arguments is done at the time that the expression
is evaluated. While it might be possible to do a fairly complete job of
type checking arguments while the parsing is going on, it isn't possible
to do it completely. The user could pass a cell-reference as an argument
and then go change the data in that cell so that it is illegal. Because
of this, all type checking is done at evaluation time.

So... If the user entered:
	)Avg( 2.34, "honk", +/ "p" *(
The scanner would accept it without error. The reason is that all the items
in the input stream are legal:
	)
	Avg
	(
	2.34
	,
	"honk"
	,
	+
	/
	"p"
	*
	(
The parser would complain because while the individual items make sense,
they are formed into a meaningless expression.

If the user entered:
	Avg( 1, 2, 3, "honk" )
both the scanner and parser would report no errors. An error would be
generated by the evaluator when it checked the type of the 4th argument
("honk") and discovered that it wasn't a number.

For more information on how this is implemented see below.

******************************************************************************

Language Definition for the geoCalc expression parser:
------------------------------------------------------
These are the token classes for the scanner:
	Functions		Cell References		Range Separators
	Constants		Strings			Operators
	List Separators		Named Data

These are the token classes for the parser:
	Functions		Cell References		Cell Ranges
	Constants		Strings			Operators
	List Separators		Named Data

******************************************************************************

Language Definition:
--------------------
**
** An arithmetic expression is what the parser expects to find when it starts
** parsing. All valid expressions must spring from an arithmetic_expresssion
**
expr:
	"(" expr ")"
	"-" expr
	FUNCTION function_args
	base_item
	base_item more_expr

more_expr:
	<empty>
	"%" more_expr		<- Percent operator
	BINARY_OP expression
	
function_args:
	()
	( arg_list )

arg_list:
	arg
	arg "," arg_list

arg:
	STRING
	expression

base_item:
	NUMBER
	CELL_REF
	NAMED_DATA

**
** These are the operators
**
Unary operators:
	-	(negation)
	%	(percent)

Binary operators:
	:	(range separator)
	%	(modulo)
	-	(subtraction)

	*	(multiplication)
	/	(division)
	+	(addition)
	^	(exponentiation)

	<	(less than)
	>	(greater than)
	=	(equality)
	<=	(less than or equal)
	>=	(greater than or equal)
	<>	(not equal)


**
** Some notes on tokens returned from the scanner.
**
constant:
	All constants are floating point numbers.

string:
	Strings are defined as a sequence of characters between double
	quotes ("). The backslash character (\) can be used to escape
	a quote. A string containing a single double quote would be
	defined by:
		"\""
	In addition the following can also be used in a string:
		\n	- Newline (Ctrl-J)
		\t	- Tab (Ctrl-I)
		\f	- Form-feed (Ctrl-L)
		\b	- Backspace (Ctrl-H)
		\\	- Backslash
		\ddd	- Octal character value, always three digits

cell reference:
	Cell references are returned by the scanner and are a row/column
	reference to a cell of data. Flags tell whether or not the
	references are absolute or relative.

******************************************************************************

The only recognized separator is a <space> character.

All operators produce floating point results.

All logical and relational operations produce floating point results:
	1.0	==> True
	0.0	==> False

Functions can take as arguments numbers, ranges, or strings.

Functions can return one of:
	Floating point result
	String Sesult
	Cell Reference
	Range

Functions can return one or more of these error messages:
	NA:		Not Available

	DIV/0:		Divide by Zero
	RANGE:		Bad Numeric Argument
	REF:		Illegal Cell Reference
	TYPE:		Bad Argument (mismatched argument type)
	2MANY:		Too Many Arguments
	2FEW:		Too Few Arguments
	ERROR:		General error (non-specific)

A function must always return a value. More than one error may be reported
by the function, but only one error at a time will be reported to the
user.

******************************************************************************

Examples of built in functions:
	IF( condition, then_expression, else_expression )
	SUM( expression_list )
	AVG( expression_list )
	APPEND( expression_list )

******************************************************************************

Cell Data Structures:
---------------------

Floating Point Numbers:
	These are stored as 64 bit "Long Reals". The format is the same
	as that used by the 8087 math coprocessor:
		Bit(s)		Use
		------		---
		63		Sign bit
		62-52		Biased Exponent
		51-0		Significand

When expressions are parsed, a list of tokens is created.

The list contains structures that look like:
	Token Type	(Constant, String, Cell, Range, Function, etc...)
	Token Data

"Token Data" is a variable size field.
	Token Type	Token Data
	----------	----------
	Constant	The value of the constant (8 byte floating point)
	String		Length of string followed by string data.
			The size is unknown, but always >2 bytes
	Cell		The cell reference, flags, row & column (5 bytes)
	Range		Bounding cells (10 bytes)
	Function	The function-ID (1 word)
	CloseFunction	Marks the end of a function invocation
	ArgEnd		Marks the end of an function argument
	Operator	The operator (1 byte)
	EndOfExpr	Marks the end of the expression
	OpenParen	Start of a parenthesized expression
	CloseParen	End of a parenthesized expression
	
The function-IDs are divided into a few classes:
	ID #			Reserved for
	----			------------
	0x0000...0x7fff		Built in functions
	0x8000...0xffff		User defined functions

Parsing Example:
----------------
The text:
	SUM(1, b3:f3, c15, AVG(c1:h1), 2/3+4)
parses to this:
	FUNCTION		sum
	    CONSTANT			1
	    END_OF_ARG
	    
	    CELL_REFERENCE		b3
	    OPERATOR			:
	    CELL_REFERENCE		f3
	    END_OF_ARG
	    
	    CELL			c15
	    END_OF_ARG
	    
	    FUNCTION			avg
		    CELL_REFERENCE	c1
		    OPERATOR		:
		    CELL_REFERENCE	h1
		    END_OF_ARG
	    CLOSE_FUNCTION
	    END_OF_ARG
	    
	    CONSTANT			2
	    OPERATOR			/
	    CONSTANT			3
	    OPERATOR			+
	    CONSTANT			4
	    END_OF_ARG
	CLOSE_FUNCTION
	END_OF_EXPRESSION

******************************************************************************

The evaluator has rules it follows for every token it encounters.

Token:		Rule:
------		-----
OpenParen	Push OpenParen on OperatorStack

CloseParen	Eval until OpenParen reaches top of OperatorStack
		Pop OpenParen from OperatorStack

Operator	If precedence of operator less than precedence of top of
		OperatorStack then Eval top of OperatorStack, else
		Push operator on OperatorStack.

Function	Push function on OperatorStack.

CloseFunc	Evaluate function on OperatorStack.
		Pop function from OperatorStack.

ArgEnd		Evaluate operators on OperatorStack until a function is at
		the top of the stack. Increment the nArgs of the function at
		the top of OperatorStack. 

Number		Push number on ArgumentStack.

String		Push string on ArgumentStack.

CellRef		Push cell-data on ArgumentStack.

EndOfExpr	Evaluate operators on OperatorStack until the stack is empty.


Operator Precedence: (Listed from highest precedence to lowest)
--------------------
	:	RANGE_SEPARATOR

	-	NEGATION
	%	PERCENT

	^	EXPONENTIATION
	*	MULTIPLICATION
	/	DIVISION
	%	MODULO
	+	ADDITION
	-	SUBTRACTION

	=	EQUAL
	<>	NOT_EQUAL
	<	LESS_THAN
	>	GREATER_THAN
	<=	LESS_THAN_OR_EQUAL
	>=	GREATER_THAN_OR_EQUAL


The evaluator has two stacks, the OperatorStack and the ArgumentStack.
They reside in the same buffer, one growing up and the other growing down.
When they collide an error is generated. With some trial and error we should
be able to establish a reasonable size for the buffer. Obviously there is
an upper limit of  65,535 bytes of combined stack size.

The things on the OperatorStack are:
	Operators:
		OperatorID, (implies the precedence)	1 byte
	Functions:
		FunctionID				1 word
		Number of arguments			1 word

The things on the ArgumentStack are:
	Numeric Constant:
		Reference to coprocessor stack		1 word
	String Constant:
		Length of String			1 word
		String data				x bytes
	Cell:
		Cell Reference				5 bytes
	Range:
		First Cell Reference			5 bytes
		Last Cell Reference			5 bytes
	NotAvailable:
		NA Error Code				0 bytes

NotAvailable is placed on the stack when pushing a cell that is marked as
NotAvailable, or when a function returns NotAvailable. Functions, if they
encounter NotAvailable as an argument can attempt to handle it, they
can propogate it, or they can report a different error.

There are certain errors that will cause a complete abort of the evaluation.
They are:
	Bad Argument Type:
		The wrong type of argument was supplied to a function.
	Too Many Arguments:
	Too Few Arguments:
		The wrong number of arguments were supplied to a function.
	Illegal Cell Reference:
		A cell reference which is out of bounds was encountered.
	Argument Out Of Range:
		A numeric argument was out of the acceptable range.
	Divide By Zero:
		Division by zero was encountered in an expression.
	General Error:
		General errors can't be propogated because they are specific
		to the function.

******************************************************************************

The scanner understands very few things. It can identify the following:
	Floating Point Numbers
	Strings
	Cell References
	Function names
	End of Expression
	Open paren
	Close paren
	Operators
	List Separators

The scanner attempts to match identifiers to a list of known functions.
If a match is found, then the identifier is determined to be a function
and the function token is returned.

If the identifier does not match the list of known functions, it is passed
back to the application which can attempt to match the identifier to
whatever it likes. If the application finds a match, it should return
the token. Possible uses for this filter mechanism includes cell names
and user defined functions.

The evaluator will call back to the application to evaluate any function
which it does not handle internally.

******************************************************************************

To make the process of evaluation faster, numeric constants are not actually
copied from from the stream into the arg-stack. Instead the constants
are loaded into the coprocessor stack and a reference to the stack is
stored in the arg-stack. This is a shortcut to speed up evaluation.
The constants will need to be loaded eventually (assuming that they are
used).

******************************************************************************

Error checking of expressions is done when the cell is evaluated. Because
of this, functions must check the number of arguments passed and must also
type-check the arguments.

******************************************************************************

The parser structure looks a lot like the language definition at the top
of this file. The parser can request the scanner to look-ahead if it
wants it to.

******************************************************************************

It is not legal for an identifier to be named in a manner where it might
be mistaken for a cell reference.

Since cell reference are always of the form [A-Z]+[0-9]+, the application
should not allow identifiers to be prefixed by this form.

I suggest that applications simply not allow identifiers to contain
numeric digits (0-9). This is the easiest way to solve the problem that
I can think of.

******************************************************************************

To add an operator, you need to edit one of the tables in parseVariable.asm.
There is one table for two character operators (eg: <>). There is another
table for one character operators (eg: +). The tables are made up of a list
of bytes. Since the code uses the "size" operator to know how long the lists
are, you should add the items to the lists. You shouldn't add another "byte"
statement. In addition to adding the operator to the list, you need to
add a constant for the parser to use.

Of course you will need to modify the parser too...

******************************************************************************

Here are some useful rules for the parser to follow:

1)	An expression always begins with one of:
		CONSTANT
		CELL_REFERENCE
		FUNCTION
		OPEN_PAREN
	When looking ahead to see if the next item in the stream might
	be an expression, one of these indicates that an expression
	follows.

******************************************************************************

Things to test in the scanner:
------------------------------

Does it return every token?
	SCANNER_TOKEN_NUMERIC_CONSTANT		(eg: 123.456)
	SCANNER_TOKEN_STRING_CONSTANT		(eg: "honk")
	SCANNER_TOKEN_CELL_REFERENCE		(eg: $c1)
	SCANNER_TOKEN_FUNCTION			(eg: Avg)
	SCANNER_TOKEN_END_OF_EXPRESSION
	SCANNER_TOKEN_OPEN_PAREN
	SCANNER_TOKEN_CLOSE_PAREN
	SCANNER_TOKEN_RANGE_SEPARATOR		(eg: ":" or "..")
	SCANNER_TOKEN_OPERATOR			(eg: +-/*)
	SCANNER_TOKEN_LIST_SEPARATOR		(eg: ",")

Does it generate every error?
	SCANNER_ERROR_BAD_NUMBER		(eg: 1.1.1)
	SCANNER_ERROR_BAD_CELL_REFERENCE	(eg: c1$c)
	SCANNER_ERROR_NO_CLOSE_QUOTE		(eg: "honk)
	SCANNER_ERROR_UNKNOWN_IDENTIFIER	(eg: HiJohn)

Things to test in the parser:
-----------------------------

Does it handle each individual type of expression?
	Numbers:			123.45
	Cells:				$c1
	Parens:				(1)
	Empty function call:		sum()
	Function with args:		sum(1,2,3,4)
	Function with string arg:	sum("honk")
	Operators:			1+2+3
	Function with expr arg:		sum(1+2/3)

Does it generate every error?
	PARSER_ERROR_TOO_MANY_TOKENS		hard to generate
	PARSER_ERROR_BAD_FUNCTION_CALL		eg: "sum(1,2"
	PARSER_ERROR_BAD_EXPRESSION		eg: "1+--"
	PARSER_ERROR_MISSING_CLOSE_PAREN	eg: "(1+2*(3)"
	PARSER_ERROR_BAD_ARGUMENT		eg: sum(1,,)

Some special cases:
	- Expressions as arguments
	- Function call as argument to a function
	- Bad function call as argument to a function
	- 2 numbers separated by a space

******************************************************************************

Converting column reference (eg: AC) into column numbers.

	Column		Column
	Reference	Number
	---------	------
	A		1
	Z		26
	AA		27
	AZ		52
	BA		53

The basic rule is:
    column = 0
    foreach letter
    	column *= 26
	column += letter - 'A' + 1
    end

------------------------------------------------------------

Converting column number into a column reference (eg: AC):

	Column	Column  
	Number	Reference
	------	---------
	1	A
	26	Z
	27	AA
	52	AZ
	53	BA

	nDigits = 0
	while (column != 0) do
	    column&digit = column/26		(Divide and save remainder)

	    if (digit == 0) then		(Check remainder)
		value = 26
		if (column != 0) then
		    column--
		endif
	    endif
	    nDigits++
	    save digit
	end
	
	while (nDigits--) do
	    restore digit
	    write (digit + 'A' - 1)
	end

******************************************************************************

Dereferencing Cells:
--------------------
We want to dereference cells as soon as we possibly can. We really want to do
it before we push anything else on the argument stack. The one complication
here is range-separators. If a cell is going to be part of a range-separator
operation then we don't want to dereference that.

Assume that we will choose some mechanism that leaves at most a single
non-dereferenced cell on the stack at a given moment. Assume that this cell
will always be at the top of the stack (if it exists). There are a few
situations that we will want to dereference it:
	(1) When we are about to evaluate an operator
	(2) When we are about to push another argument
	(3) When we reach an arg-end
	(4) When we reach the end of the entire expression

In the case of (1), (2), and (3) if the top operator on the stack is a
range separator then we don't want to dereference the cell. It will be
combined with another cell as part of the range separator operation.

In the case of (4) we have finished the entire calculation and the only thing
left on the stack is a cell reference. It seems reasonable to dereference it.

It turns out that the cases we check to decide what to do in cases 1, 2,
and 3 are also true in the 4th case. This means we can use the same code.

So here are the rules we apply to these cases:
	if top of operator stack is not a range-separator &&
	   the top of the argument stack is a cell-reference then
	    cell = argStack.data
	    Pop1Arg()
	    PushCellData( cell )
	endif

******************************************************************************

Evaluator Error:
----------------

Generating errors in the evaluator is a tricky business. We can't just
generate errors and abort calculation. Because there are these pesky
functions around like IsError() and IsNA() we need to propogate some
errors up the stack.

There are certain errors which we propogate and certain ones we don't.
This doesn't affect the application. If there is any sort of error to
return then it will get that error in al and the carry will be set.

The errors which cause calculation to abort are:
	PSEE_OUT_OF_STACK_SPACE		(Unable to push an argument/operator)
	PSEE_FUNCTION_NO_LONGER_EXISTS	(Use of a function which isn't defined)
	PSEE_NESTING_TOO_DEEP		(> 256 nested names)
	PSEE_TOO_MANY_ARGS_TO_FUNCTION	(> 254 arguments)

The errors which get propogated back up (and so can be detected by
IsError() and IsNA()) are:
	PSEE_ROW_OUT_OF_RANGE
	PSEE_COLUMN_OUT_OF_RANGE
	PSEE_BAD_ARG_COUNT
	PSEE_WRONG_TYPE
	PSEE_DIVIDE_BY_ZERO
	PSEE_UNDEFINED_NAME
