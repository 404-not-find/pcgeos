%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) Berkeley Softworks 1991 -- All Rights Reserved

PROJECT: 	PC/GEOS
MODULE: 	User Interface
FILE: 		MethodConventions -- UI Method Conventions

AUTHOR:		Doug Fults

REVISION HISTORY:
	Date	Name		Description
	----	----		-----------
	3/28/91	Doug		Inital version

DESCRIPTION:

	The purpose of this document is to define register-handling &
	documention conventions for methods in V2.0 of the PC/GEOS
	User Interface.

	$Id: MethodConventions.doc,v 1.2.34.1 97/03/29 03:36:56 canavese Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To Trash or Not to Trash
------------------------
In 1.X, method handlers were allowed to destroy any register they wanted to,
unless specifically documented otherwise.  The result is that message return
registers (ax, cx, dx, & bp) must be presumed to be destroyed, unless
documented otherwise.

After much thought, I've decided to NOT have the UI team embark on a global UI 
effort to have methods preserve all registers not returned.  The rationale:

	* Effort involved to change to preserve everywhere would be large
	  (over 1100 method handlers in the UI :)

	* Documentation accuracy is more important than whether a register
	  is preserved or not.

	* Adding pushes & pops in all method handlers would add 4-8K to the UI,
	  without a clear gain on the application code size;  a quick survey
	  through several apps actually showed few cases of pushing & popping
	  registers which were neither passed nor returned.  Also, Brian Chin
	  notes that it is easy to create near procedures like
	  "ObjMessagePreserveBP" which actually save code size by reducing the
	  number of far calls in a module.

Basically, UI methods will be free to define whether any of ax, cx, dx, or bp
are returned as data, unchanged, or destroyed.  However, trashed registers
will have to be documented as such, in both the method declaration & in method
handlers.

Most UI methods do not currently preserve registers.  Those that are documented
as doing so will be left alone.  If specific cases arise where it would clearly
be useful to programmers to have registers preserved, (& we have the time :),
the method may be re-defined to preserve the register(s), & all handlers of
the method would be corrected to perserve the register(s), & be documented as
such.

Obviously, register preservation is most useful if the developer can remember
the rule without having to look up each method when he goes to use it.  Hence,
if register preservation is used, it should be used consistently throughout
the module/method category area.

Thus, the only change for 2.X will be that each message declaration must have
DOCUMENTED what happens to each return register.

Message Documentation Practices
-------------------------------
UI method documentation practices will be changed to reduce developer confusion
with regards to whether registers are trashed or not.  The current practice
of "presumed destroyed unless documented otherwise" will be tossed in favor
of more explicit documentation, both in method declarations & in method
handlers.

With regards to method declarations, I like John & Tony's style the best, in
which the effect on EVERY register is documented in the "Return" section (i.e.
whether it returns data, is unchanged, or is destroyed).

While we've cleaned up the documentation of return parameters by adding
information on what registers are destroyed, there is a great amount
of other common information which is not finding its way into current
declarations -- basics like "Where does this fit into the rest of the
system?", & "Do I have to call the superclass if I intercept this?"  The
missing info could be categorized into:

       * Context

         Is this a high-level, common function, part of a larger mechanism,
         or a low-level primitive that you should stay away from?  Are
         there alternatives that should be considered?

       * Source

         Who's allowed to send the message, i.e. is this a message a developer
         should send to get something done, or is it something that is
         normally generated by the system itself?
         (e.g. MSG_GEN_SET_USABLE -vs- MSG_VIS_OPEN)

       * Destination

         If not clearly defined by the class that the message belongs to,
         where is it that the message should be/is sent to?  Are there
         restrictions on when the object may legally receive the message?

       * Interception

         If you write a handler for the message, do you have to call the
         superclass?  Before or after various types of operations?  Any
         other restrictions on interception?



The new format would be:

MSG_FOO		method
;
; <General description, details of usage & peculiarities>
;
; Context:	<Context info here>
; Source:	<Source info here>
; Destination:	<Destination info here>
; Interception:	<How, if at all, message can be intercepted.  Should include
;		 instructions on when or if superclass should be called>
; Pass:		<pass parameters, descriptions>
; Return: 	<list of return parameters, descriptions>
;               <list of unchanged registers> - unchanged
;               <list of destroyed registers> - destroyed


Since there are only 4 registers returned in any method invocation, this should
not place an unreasonable burden on the method's author, & certainly provides
clear documentation.

With regards to method handlers, the documention for ax, cx, dx, & bp should
match exactly the method's declaration, except for registers marked as 
"destroyed," which should be labeled "Allowed to destroy".  In the case that a
method handler does not actually destroy a register documented as being
destroyed, EC code should be added to force destruction.  For METHOD_FOO_STUFF,
above, the code would be:

	Destroy	ax, bp

The reason for this is to ensure that applications/other UI code are not 
falsely relying on registers being preserved.  Without such precautions,
applications would crash under later versions of the UI in which the previously
unchanged registers became used.

Some examples:


MSG_GEN_PROCESS_OPEN_APPLICATION		method
;
; This is sent to the process itself from MSG_META_ATTACH, whenever the
; application is being restored to mode APPLICATION, or whenever it is being
; invoked as in APPLICATION mode.  Data passed is the same as that in
; MSG_META_ATTACH.  The default handler sets the application object USABLE.
; This method may be intercepted to open up any data file passed, before
; the UI for the application is actually set USABLE.
; Note that the blocks passed need not be freed, as this is done by the
; caller upon return of this routine.
;
; Context:	This is the primary message to intercept if you want to
;		know when your application is first coming up, after
;		MSG_META_ATTACH itself (Is called from within MSG_META_ATTACH handler)
; Source:	GenProcessClass default handler for MSG_META_ATTACH only.
; Destination:	same object
; Interception:	Frequently intercepted by an application's own process class
;		to find out when an application is first coming alive in 
;		the system.  You MUST pass this message on to the superclass,
;		or the application will never come up.  Be aware that the
;		entire UI tree for the application is the equivalent of
;		NOT_USABLE before the superclass is called, & is USABLE &
;		beginning the process of coming up visually after it is
;		called.  Thus, it is best to do non-UI related things, and
;		changing of generic attributes & hints BEFORE calling the
;		superclass.  You must wait until AFTER calling the superclass
;		do perform any operations which require that objects
;		be full USABLE to function, such as bringing up a dialog box.
; Pass: 	cx	- AppAttachFlags
;		dx	- Handle of AppLaunchBlock, or 0 if none.
;		  	  This block contains the name of any document file
;			  passed into the application on invocation.
;		bp	- Handle of extra state block, or 0 if none.
;		  	  This is the same block as returned from
;		  	  MSG_GEN_PROCESS_CLOSE_APPLICATION or
;		  	  MSG_GEN_PROCESS_CLOSE_ENGINE, in some previous MSG_META_DETACH
; Return: 	nothing
;		ax, cx, dx, bp - destroyed
;
;


;ImportMethod	MetaClass, MetaUIMessages, MSG_META_SEND_CLASSED_EVENT
;
; This method is defined in MetaClass, & augmented by any class that wishes
; to do so, by the addition of new TargetObject types.  MetaClass provides
; TO_NULL & TO_SELF.
;
; GenClass extends TargeObject options to include a way to send a method
; up the generic tree to an object of a certain class, & a way to send
; a method down the focus, view, model, controller hierarchies.  Special
; note:  Passing a ClassedEvent with a class of null results in the event
; being passed all the way to the leaf of the hierarchy specified.
;
; Context:	This is THE way to get a message delivered to an object
;		whose optr is unkown, but it is know to be currently
;		actively within one of the hierarchies listed in the
;		"TargetObject" enumeration.
; Source:	no restrictions
; Destination:	Any object may receive this message, though usefullness will
;		depend to TargetObject type.  See "TargetObject" enumeration
;		declarations for info on where the message may usefully be sent.
; Interception:	Intercepted by Focus, Target, View, Model or Controller nodes,
;		or any object defining a new "TargetObject" level, in order
;		to implement requests for sending to that destination.  If
;		the TargetObject passed does not match the type your handler
;		is redirecting, the request should be passed on to the 
;		superclass.
; Pass:		^hcx	- ClassedEvent
;		dx	- TargetObject
; Return:	nothing
;		ax, cx, dx, bp - destroyed
;

MSG_META_GAINED_FOCUS_EXCL message MetaUIMessages
;
; Sent out to any object gaining the focus exclusive, if all focus nodes
; above it also have the exclusive.  If this is a leaf object, then it will
; also soon get MSG_META_GAINED_KBD_EXCL, & receive any MSG_META_KBD_CHAR's generated.
;
; Context:	Part of the Focus/Target/View/Model/Controller mechanism
; Source:	This message should be sent ONLY by the object which is
;		the focus node above the object receiving the message. 
;		It is normally generated in the MSG_META_GAINED_FOCUS_EXCL or
;		MSG_VIS_VUP_ALTER_FTVWC_EXCL handler for the node itself,
;		eminating from the call to FlowGainedExcl or
;		FlowAlterWithinLevel, respectively
; Destination:	Any MetaClass object which has grabbed and not yet released
;		the focus exclusive
; Interception: Generic UI objects, VisTextClass, and all focus node objects
;		provide default behavior for processing this message.  If
;		you intercept above any of these levels, be sure to call the
;		superclass to let these object know the focus has been gained.
; Pass:		nothing
; Return:	nothing
;		ax, cx, dx, bp - destroyed



Method Documentation Practices
------------------------------

With regards to bx, si, di, ds & es:  These should be documented as "allowed
to destroy" in dynamic method handlers, & as "unchanged for static handling" in
methods which are allowed to be called statically.  An example header might
read:


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FooStuff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Do stuff to the foo object

PASS:		*ds:si	- instance data
		ds:di	- ptr to start of master instance part
		es	- segment of FooClass
		ax 	- METHOD_FOO

		<pass descriptions>

RETURN:		cx - <return description>
                dx - unchanged

ALLOWED TO DESTROY:
		bx, si, di, ds, es

PSEUDO CODE/STRATEGY/KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	me	3/28/91		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

The uigroup will be modifying ALL of the generic & specific UI to adhere to
these register documentation conventions.

						-- Doug

