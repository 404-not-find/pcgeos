COMMENT `-----------------------------------------------------------------------


				GenItemGroupClass

$Id: GenItemGroup.doc,v 1.1.34.1 97/03/29 03:37:50 canavese Exp $

Synopsis
--------
	The GenItemGroupClass and GenItemClass work together in the 
	generic UI to allow an application to set up a list of options for a
	user to choose from.  One or more GenItems will be generic children
	of a GenItemGroup object, and each GenItem represents a particular
	option in the item group. Under a GenItemGroup object, one or more of 
	the options are selected at any particular time, depending on the 
	behavior selected for the item group, and the user can generally select
	or deselect an option by clicking on one of the GenItems.  
	Applications interact solely through the GenItemGroup object, which 
	controls the items and keeps track of which are selected.  The 
	GenItemGroup object also has all the same geometry capabilities as a 
	grouping-type GenInteraction.

	There are certain kinds of option item groups that this object is most
	appropriate for:

		1. Any item group where the items are mutually exclusive (the 
		   user can choose only one item at a time).   

		2. Any scrolling item group, exclusive or non-exclusive, where
		   the items can easily be set up generically.

	There are several types of user selection behavior for a GenItemGroup.
	Items can be set up so that only one is selected at a time, one or 
	none is selected at a time, multiple items can be selected, or 
	or multiple items selected only when dragging or by extending the
	selection.

	In Motif, a GenItemGroup will usually take the form of either 
	a group of settings (checkboxes or diamonds, depending on the behavior
	of the item group) or a scrolling list.  They can also appear in menus 
	(if under a GenInteraction with "visibility = popup").

	When under a GenItemGroup, each GenItem must contain a unique 
	identifier to be associated with the item, often some kind of 
	enumerated value.  The GenItemGroup will keep a word or item group of 
	words which represent the identifiers of the GenItems that are 
	currently selected.  

	For any gadget which changes application or data state, you should 
	always first look at using a GenItemGroup or one of the related objects
	(see Alternatives, below).   For instance, if you plan on having two 
	triggers in a menu that alternate between two application states (for 
	instance, a terse mode and a verbose mode), you probably should instead
	choose to make them two GenItems in a GenItemGroup object.


Alternatives
------------

	There are two objects that are similar to the GenItemGroup which might
	serve your needs better.  The first, GenItemGroup, is optimized for
	managing a small (less than 16) number of items where each item can be
	turned on or off by the user independently of each other.  (These are
	often represented in a specific UI as checkboxes.)    If you want a
	scrolling item group with lots of items, or items where it is 
	convenient to pass pointers to the monikers to use for each when 
	needed rather than have a generic object for each item, you may want 
	to use a GenDynamicList object.

	If the application state you wish to represent is numeric in nature
	(e.g. a game difficulty level), you may wish to use a GenRange object
	rather than take a GenItemGroup/GenItem approach.  (GenRanges are
	generally not available in menus, however.)


Limitations
-----------
	GenItemGroup can only have GenItems as children.  Likewise, GenItems
	must always be a generic children of a GenItemGroup (or GenItemGroup)
	object.  (There are ways to get around the problem of only allowing
	GenItems under a GenItemGroup -- see linked GenItemGroup section, 
	below.)

	There are no capabilities to allow some items under a GenItemGroup
	object to be exclusive, while others be non-exclusive.  This can often
	be accomplished manually by making the item group non-exclusive, and 
	clearing other items manually when necessary to create the exclusive 
	behavior.


Implementation Status
---------------------
	Preliminary specification.  - 1/16/92

See Also
--------
	GenRangeClass, documented in Library/User/Gen/genRange.asm.
	GenItemGroupClass, documented in Library/User/Gen/genItemGroup.asm
	GenDynamicListClass, documented in Library/User/Gen/genDynamicList.asm


;------------------------------------------------------------------------------
;	Description
;------------------------------------------------------------------------------

Terminology
-----------
	apply message --
		A message sent out when a modification in an item group is
		applied, notifying the destination of changed in the state
		of the boolean group.  An item group sends this message
		in response to a MSG_GEN_APPLY, which may be sent out either
		every time the user changes the state of the item group,
		or only when the user presses an "Apply" trigger, depending
		on type of window the item group appears in.  See delayed
		mode section for more info.

	dynamic list --
		A scrolling list where the application is queried for the
		monikers to display for each entry, rather than using generic
		components for the item.  See GenDynamicListClass.

	delayed mode --
		This refers to various property objects that reside
		in Apply/Cancel style dialog boxes.  In these dialog
		boxes, the user can change the state of objects, but the 
		changes aren't sent out in a notification until the user 
		clicks on "Apply" and a MSG_GEN_APPLY reaches the object.  See
		the section on delayed mode below.

	deselect --
		Deselecting a GenItem (usually in a non-exclusive item group)
		usually means to clear its actual and/or user exclusive, i.e.
		to turn it "off."  

	destination --
		Refers to the object or process, if any, that will receive
		apply messages or status message when applicable.  See also:
		apply message, status message.

	exclusives --
		A group of items that has one and only one GenItem
		selected at any given time.  It is possible for an application
		to have no exclusives set, but there is no way for a user to
		put the GenItemGroup in a none-selected state.  This is the
		default behavior for a GenItemGroup, or set via GIGBT_EXCLUSIVE
		in GIGI_behavior type.   See also, non-exclusive, exclusive-
		none, extended-selection.
	
	exclusive-none -- 
		A variant of exclusives, where having no items selected
		is fully supported.  If the user clicks on the selected
		GenItem, it will be turned off, leaving no items selected.
		Otherwise functions like an exclusive item group.  To get this
		behavior in a GenItemGroup, set GIGBT_EXCLUSIVE_NONE in 
		GIGI_behavior type.  See also: exclusive, non-exclusive, 
		extended-selection.

	extended-selection --
		A type of item group (always a scrolling item group) where the 
		default behavior is to deselect other items when the user 
		selects an item.  If the user drags across items, or extends the
		selection (usually done by holding a key down while clicking),
		several items can be selected.  This is sometimes useful for
		selecting a target for an operation, where choosing one item
		is good enough for the novice, but selecting multiple items
		can be useful for the experienced user.  To get this behavior
		in a GenItemGroup, set GIGBT_EXTENDED_SELECTION in GIGI_behavior
		Type.  See section on extended selection behavior, below.
		See also: exclusive, non-exclusive, exclusive-none.

	immediate mode --
		An item group in immediate mode is one that is not delayed, i.e.
		any change in an item by the user will immediately result in an
		apply.   This is used everywhere but in Apply/Cancel
		style dialog boxes.  See delayed mode.
	
	non-exclusives --
		A group of items where the GenItem children can be
		turned on and off independently of each other.  Selecting
		one item will not affect any others.   Multiple items
		can be turned on at a time by the application, and all can
		be turned off as well.   This can be turned on by setting
		GIGBT_NON_EXCLUSIVE in GIGI_behaviorType.  See section on
		non-exclusive item groups below.  See also:  exclusive, 
		exclusive-none, extended-selection-exclusive.

	properties objects --
		These refer to certain generic objects which contain the state
		of some selected data in an application.  GenItemGroup,
		GenItemGroup, GenRange, and GenText all fall into this
		category.

	scrolling list --
		A group of items where not all the entries are visible, and 
		the user can scroll through the entries.  Good for things like
		selecting files, formats, or anything where there are a fair
		number of options, or the number of items varies a lot.
		This mode can be set by adding a ATTR_GEN_ITEM_GROUP_SCROLLABLE.
		to a GenItemGroup or GenItemGroup object.  See the section
		on scrolling lists below.

	status message --
		Can be optionally sent out when any change in the item group
		state occurs, regardless of whether that change is to be 
		applied or not.  Applications can turn on the behavior by
		specifying ATTR_GEN_ITEM_GROUP_STATUS_MESSAGE.  See 
		delayed mode section, below.

	top --
		The "top" of a scrolling list refers to the first item 
		current visible.  Occasionally you may want to position the
		entries in a list by setting the "top."

Relationships/Context
---------------------
	The GenItemGroup can be a generic child any object in the generic 
	world.

	The GenItem cannot be a generic child of any object except a
	GenItemGroup.

	GenItemGroup cannot have non-GenItems as generic children.

	A delayed GenItemGroup object knows how to react appropriately to a 
	MSG_GEN_APPLY and a MSG_GEN_RESET in an apply/reset dialog box.  For 
	more information on delayed mode in the system, see the GenInteraction 
	documentation.


Conceptual Overview
-------------------
	

Setting up your GenItemGroup object
------------------------------------
	
	In the following few sections, we'll discuss how to set up a GenItem-
	Group with mutually exclusive items.  Later we'll discuss what changes
	to make to have non-exclusive, exclusive-none, or extended-selection
	behavior in item groups.

	To use a GenItemGroup, you set up as many GenItem objects as you
	need and assign unique identifiers to each.  The GenItemGroup will keep
	track of the currently selected item (or items).  For instance, to set 
	up three choices for a text color, and set to have light blue 
	initially selected, one might do the following:

		@object GenItemGroupClass ColorGroup = {
			GI_comp = BlueItem, GreenItem, WhiteItem;
			GIGI_selection = C_LIGHT_BLUE;
		}

		@object GenItemClass BlueItem = {	
			GI_visMoniker = "Blue";
			GII_identifier = C_LIGHT_BLUE;
		}
		@object GenItemClass GrrenItem = {	
			GI_visMoniker = "Green";
			GII_identifier = C_LIGHT_GREEN;
		}
		@object GenItemClass WhiteItem = {	
			GI_visMoniker = "White";
			GII_identifier = C_WHITE;
		}

	DEFINE_ITEM is a macro to simplify creating GenItemClass objects,
	which takes a label for the GenItem, a mnemonic, a moniker, and an
	identifier.  The last DEFINE_ITEM above will expand to:

		@object GenItemClass WhiteItem = {
			GI_visMoniker = 'B', "Blue";
			GII_identifier = C_LIGHT_BLUE;
		}

Notification
------------

	While it is sometimes adequate to query the item group for its 
	current state only when you need it (getting the state of the boolean 
	group is described later), often applications will want immediate 
	notification of any changes in the state of the GenItemGroup.

	The destination for GenItemGroup messages can be specified as
	follows:

	    GIGI_destination = Dest;

	where "Dest" is the object to send it to.  To send stuff to the 
	process:

	    GIGI_destination = process;

	The destination can be queried for or changed using MSG_GEN_ITEM_-
	GROUP_GET_DESTINATION and MSG_GEN_ITEM_GROUP_SET_DESTINATION,
	respectively.

	The GenItemGroup will notify the destination of any change in its
	state that needs to be applied by sending an "apply message".  
	This message, defined in GIGI_applyMsg,	will notify the destination
	of the current state of the boolean group.  For example:
		
		@object GenItemGroupClass ColorGroup = {
			GI_comp = BlueItem, GreenItem, WhiteItem;
			GILI_selection = C_LIGHT_BLUE;
			GILI_notifyMsg = MSG_COLOR_CHANGE;
		}

	will cause a MSG_COLOR_CHANGE to be sent out on any applied change.

	The message should be defined as follows:

		@message (GEN_ITEM_GROUP_APPLY_MSG) MSG_COLOR_CHANGE;

	The parameters for the message are "void (word selection, word num-
	Selections, byte stateFlags)" where selection is the new selection.  
	"numSelections" will always be set to 1 in an exclusive item group, and
	can be ignored.  The state flags are as follows:

		GIGSF_INDETERMINATE -- set if the current selection in GenExcl-
			usives is indeterminate.  See the section on indet-
			erminate mode, below.

		GIGSF_MODIFIED -- indicated whether the item group is
			modified.  Can usually be ignored.  See section on
			receiving unmodified applies below.


Oft-used hints for the GenItemGroup
------------------------------------
	All geometry and moniker hints defined in GenClass will work for a 
	GenItemGroup just as they would for a GenInteraction.  Below are notes
	that apply particularly to GenItemGroups:

	    HINT_ALLOW_CHILDREN_TO_WRAP		
		Not available in scrolling or dynamic lists.
	    HINT_BOTTOM_JUSTIFY_CHILDREN		
	    HINT_CENTER_CHILDREN_HORIZONTALLY	
	    HINT_CENTER_CHILDREN_ON_MONIKERS	
	    HINT_CENTER_CHILDREN_VERTICALLY		

	    HINT_CENTER_MONIKER			
		 This can be used on both GenItemGroup and GenItems.

	    HINT_CUSTOM_CHILD_SPACING		
	    HINT_DONT_ALLOW_CHILDREN_TO_WRAP	
	    HINT_DONT_FULL_JUSTIFY_CHILDREN		
	    HINT_DONT_INCLUDE_ENDS_IN_CHILD_SPACING	
	    HINT_DO_NOT_USE_MONIKER			
	    HINT_DRAW_IN_BOX			

	    HINT_EXPAND_HEIGHT_TO_FIT_PARENT	
		 This can be used on both GenItemGroup and GenItems.

	    HINT_EXPAND_WIDTH_TO_FIT_PARENT		
		 This can be used on both GenItemGroup and GenItems.

	    HINT_FIXED_SIZE				
	    HINT_FULL_JUSTIFY_CHILDREN_HORIZONTALLY	
	    HINT_FULL_JUSTIFY_CHILDREN_VERTICALLY	
	    HINT_INCLUDE_ENDS_IN_CHILD_SPACING	

	    HINT_INITIAL_SIZE			
		This can be used on both GenItemGroup and GenItems.

	        In a scrolling list, the child count will be used as the
	        number of items visible, and space will be divided up evenly
		between the items.

	    HINT_LEFT_JUSTIFY_CHILDREN		
	    HINT_LEFT_JUSTIFY_MONIKERS		

	    HINT_MAXIMUM_SIZE			
		This can be used on both GenItemGroup and GenItems.

	        In a scrolling list, the child count will be used as the
	        number of items visible, and space will be divided up evenly
		between the items.

	    HINT_MINIMUM_SIZE			
		 This can be used on both GenItemGroup and GenItems.

	        In a scrolling list, the child count will be used as the
	        number of items visible, and space will be divided up evenly
	        between the items.

	    HINT_NO_TALLER_THAN_CHILDREN_REQUIRE	
	    HINT_NO_WIDER_THAN_CHILDREN_REQUIRE	

	    HINT_ORIENT_CHILDREN_HORIZONTALLY	
	    HINT_ORIENT_CHILDREN_VERTICALLY		
	        In motif, GenBooleanGroups are oriented horizontally in a 
		dialog box by default.  They are always vertical when appearing
		in menus.

	    HINT_PLACE_MONIKER_ABOVE		
	    HINT_PLACE_MONIKER_BELOW		vardata
	    HINT_PLACE_MONIKER_TO_LEFT		vardata
	    HINT_PLACE_MONIKER_TO_RIGHT		vardata
	    HINT_RIGHT_JUSTIFY_CHILDREN		vardata
	    HINT_TOP_JUSTIFY_CHILDREN		vardata
	    HINT_WRAP_AFTER_CHILD_COUNT		vardata		word
		Not available in scrolling or dynamic GenItemGroup.

		
Getting and setting the selection
---------------------------------

	To get the current selection of an exclusive GenItemGroup object, do 
	the following:

		selection = ColorGroup::MSG_GEN_ITEM_GROUP_GET_SELECTION();

	where selection is a word variable to hold the identifier associated 
	with the item that has the exclusive.  

	To set a new selection, you can call the following:

		@call ColorGroup::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION
						(C_LIGHT_BLUE, FALSE);

	where the first argument is a word with the identifier for the item to
	set.   The item will be selected whether usable or not usable, and if
	the identifier refers to an item that is not usable or does not exist,
	no item will be selected in the item group.  The second argument is an
	indeterminate flag, which for simple item groups, can be left false at
	all times.   (See section on indeterminate selections, below.)

	
Exclusive-none items
--------------------

	Exclusive-none item groups are like exclusive item groups, except that 
	you can have no items selected.     The user can achieve a none-selected
	state by clicking on the currently selected item, causing it to be
	toggled off.  To get exclusive-none behavior, add the following:

		GIGI_behaviorType = GIGBT_EXCLUSIVE_NONE;

	When a notification message is sent out for an exclusive-none item 
	group, numSelections will be zero if no items are selected.   To set 
	no items selected, do a:

		@call ColorGroup::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(FALSE);

	The single argument passed is an indeterminate flag, which for most
	item groups can always be false.  See indeterminate selections section
	below for more info.

	When calling MSG_GEN_ITEM_GROUP_GET_SELECTION, no selections will
	be indicated by a return value of GIGS_NONE (-1).  In C,
	if you have an exclusive-none item whose identifier is -1, you 
	can call MSG_GEN_ITEM_GROUP_GET_NUM_SELECTIONS, which returns a word
	which will be zero if no items are selected.  (Assembly language 
	programmers can just check the carry, which is returned set for no
	selections.)


Operations that are done on GenItems
------------------------------------

	Certain messages can be sent directly to GenItems objects.  You may
	want to send messages to items to:

		* Disable or enable an item
		* Set an item usable or not usable
		* Change the moniker of an item
		* Get/set the identifier for an item

	To send a message to an item, you will need its optr.  A convenient
	way to get the optr is from the identifier associated with the item.
	For instance,

	   optr blueItem;
	   blueItem = @call ColorGroup::MSG_GEN_ITEM_GROUP_GET_ITEM(C_LIGHT_BLUE);

	will return the optr of the item whose identifier is C_LIGHT_BLUE.
	Then, to get the identifier for an item, you can do a:
	
	   @call blueItem::MSG_GEN_ITEM_GET_IDENTIFIER();
	   
	which returns a word corresponding to the identifier for the item.  To
	set the item's identifier to C_LIGHT_BLUE, you could do a:

	   @call blueItem::MSG_GEN_ITEM_SET_IDENTIFIER(C_LIGHT_BLUE);


Scrolling list
--------------
	The scrolling list is a special version of the GenItemGroup that is 
	set up so that the user can scroll through a list of items which 
	aren't all visible at one time.   To get this behavior, the user must 
	specify:

		HINT_ITEM_GROUP_SCROLLABLE;

	in the GenItemGroup object.  

	A scrolling list by default will be oriented vertically.
	You can specify an orientation for scrolling lists (the default
	orientation is vertical) via HINT_ORIENT_CHILDREN_HORIZONTALLY and
	HINT_ORIENT_CHILDREN_VERTICALLY.  In motif, a horizontally oriented
	scrolling list will have a scrollbar along the bottom of the scrolling
	list.

	Notification of changes for a scrolling list, as well as setting and 
	getting the selections for a scrolling list, work the same as for 
	non-scrolling GenItemGroup.   When calling MSG_GEN_ITEM_GROUP_SET_-
	SELECTION on an exclusive or exclusive-none list, the list will almost 
	always ensure that the newly selected item is visible.

	To ensure that an item is currently visible, you can do a:

		@call list::MSG_GEN_ITEM_GROUP_MAKE_ITEM_VISIBLE(C_LIGHT_BLUE);

	If your scrolling list is going to have lots of items, or if it will
	be a lot of work for your application to convert data into GenItem
	objects in a GenItemGroup, consider using GenDynamicList instead.

	Geometry hints on a scrolling list
	----------------------------------
	
	If no size hints are specified, the specific UI will choose a default
	height and width for the scrolling list.   In motif, the scrolling list
	will be five items high.  The items will be as wide or high as the 
	items' monikers require.

	To specify a different height for a scrolling list, add a HINT_FIXED_-
	SIZE to your scrolling list.  For example, to make your scrolling list
	10 items high:

		HINT_FIXED_SIZE = {
			0,			  /* No width specified */
			SST_LINES_OF_TEXT | 10,	  /* Height */
			10			  /* Number of children */
		};

	If you specify a height argument in a size hint for a vertical 
	scrolling list, you must also specify the number of children.  The
	scrolling list will calculate the new item height to be the height
	divided by the number of children, regardless of the height of the item
	monikers.

	To specify a width of 40 average width characters:

		HINT_FIXED_SIZE = {
			SST_AVG_CHAR_WIDTHS | 40,	/* Width */
			0,				/* Use default height */
			0
		};

	You can also use HINT_EXPAND_WIDTH_TO_FIT_PARENT or HINT_EXPAND_HEIGHT_-
	TO_FIT_PARENT much as you might in another object, to cause the 
	scrolling list to expand dynamically to fill the space available.
	In a vertical list, expanding the width of the list causes the widths
	of the items to be wider; expanding the height of the list increases
	the number of items that are visible.  HINT_MINIMUM_SIZE, 
	HINT_MAXIMUM_SIZE, and HINT_INITIAL_SIZE can similarly be used along 
	with these hints as desired.

	You can also wrap items in either a horizontal or vertical scrolling
	list using HINT_WRAP_AFTER_CHILD_COUNT.  For instance, if you want
	a vertical scrolling list that is two items wide, add the following
	hints:

		HINT_ORIENT_CHILDREN_HORIZONTALLY;
		HINT_WRAP_AFTER_CHILD_COUNT = 2; 

	The list's items will be laid out horizontally by the geometry manager,
	but will wrap after two items, resulting in vertical scrolling.
	
	On a horizontally scrolling list, which is by default one item high, 
	you may want to specify a certain number of items to stack vertically 
	before wrapping. To set up a horizontally scrolling list that is 10 
	items high, 4 items wide, and the items themselves 20 average 
	characters wide, do the following:

		HINT_FIXED_SIZE {
			SST_AVG_CHAR_WIDTHS | (20*4),	/* Total width */
			0,				/* Default height */
			4				/* Number of children */
		};
		HINT_ORIENT_CHILDREN_VERTICALLY;
		HINT_WRAP_AFTER_CHILD_COUNT = 10;

	Note that if you specify a width on HINT_FIXED_SIZE for a horizontal
	list, the number of visible children needs to be specified along with
	the overall width.  The item width will be the overall width divided by
	the number of children.

Display-only lists
------------------
	GenItemGroups can be display-only, i.e. the user cannot interact with 
	it.  An item can still be selected, or you can have no item selected.
	For a display only item group, clear the generic attribute GA_EDITABLE:

		GI_attrs = @default & ~GA_EDITABLE;

	This would most likely be used with a scrolling or dynamic list to
	display a list of textual information.


Delayed mode
------------
	The GenItemGroup object will send out an apply message whenever
	it is supposed to apply a state that has been modified.  By default,
	any message which sets the state of a GenItemGroup will set a new
	value for the item group and mark its state as unmodified.  Any
	subsequent changes by the user, or by sending a MSG_GEN_ITEM_GROUP_-
	SET_MODIFIED_STATE to the object, will cause the item group to
	be marked modified.     An apply message will then be sent out with
	the modified changes the next time the object receives a MSG_GEN_APPLY.
	No apply message will be sent out if the state of the group is not
	modified (unless ATTR_GEN_SEND_APPLY_MSG_ON_APPLY_EVEN_IF_NOT_MODIFIED	
	is set -- see below).

	The type of window the GenItemGroup appears in will dictate
	when the GenItemGroup receives a MSG_GEN_APPLY, and thus sends out
	its apply message notifying the destination of a modified state.  The 
	item group's parent window will either be:

		1) an immediate mode dialog box, typically with OK/Cancel
		   triggers, or a menu.  In either case, the item group will
		   receive a MSG_GEN_APPLY and send out its apply message
		   every time the user changes its state.

		2) a delayed mode dialog box, typically with Apply/Reset/Cancel
		   triggers.  In this case, the item group will usually only
		   receive a MSG_GEN_APPLY and send its apply message when
		   the user clicks on the "Apply" trigger in the dialog box.
		   Furthermore, if the user clicks on the "Reset" trigger in
		   the dialog box, the GenItemGroup will throw away its
	 	   modified state and revert back the state before it was 
		   modified.

	See GenInteractionClass for more information on how to make your
	dialog box of the delayed variety.

	In general, it should not make much difference from a programming
	point of view which mode the item group is in.  Operations should
	work similarly in either case.

	Setting a modified state for an item group
	------------------------------------------

	Usually an application will only want to set a new unmodified state
	for an item group, then let the user modify the state of the group.
	and wait for an apply message to signal a change in the item state.  
	Occasionally there may be a need for the application to change the 
	modified state of an item group, much as if the user had set it.   To 
	do this, the application should send a MSG_GEN_ITEM_GROUP_SET_MODIFIED_-
	STATE to the group, followed by a MSG_GEN_ITEM_GROUP_SET_SELECTION, or
	some other set message, to actually change the list's state.  For 
	instance, to "modify" the item group to have C_LIGHT_BLUE deselected, you 
	could do a:

	   @call ColorGroup::MSG_GEN_ITEM_GROUP_SET_MODIFIED_STATE(TRUE);

	   @call ColorGroup::MSG_GEN_ITEM_GROUP_SET_SELECTION(C_LIGHT_BLUE
							       FALSE);

	The item group will act exactly as if the user had selected 
	the blue item using the mouse.  If the user then hits reset, the
	item group will be reset to its original state before it was modified.
	Had we not called MSG_GEN_ITEM_GROUP_SET_MODIFIED_STATE first, the list
	would be unmodified and the user pressing reset would have no 
	effect.   MSG_GEN_ITEM_GROUP_SET_MODIFIED_STATE takes a single boolean
	argument for whether to set or clear the modified state of the item
	group.

	To check the modified status of a GenItemGroup object, you can do a:

		@call ColorGroup::MSG_GEN_ITEM_GROUP_IS_MODIFIED();

	which returns a boolean, TRUE if the item group is currently modified.



	Receiving status messages
	-------------------------

	In delayed mode, GenItemGroups will only send out notification if an
	apply occurs.  Sometimes it is useful for the destination to receive
	notification on all any user change to the group, regardless of
	whether it is applied.  This is most often used in dialog boxes, where
	if the user changes the state of one object, the state of another UI
	gadget must also be changed. For example, color of a text field may be
	presented both as a GenBooleanGroup of toggleable red/green/blue
	booleans, and also a GenItemGroup displaying all the possible eight
	combinations of these in a list of exclusive items.  Both objects
	would need to notify the destination any time the user changes one or
	the other, so that the destination can update the other object
	appropriately.  Both GenItemGroups and GenBooleanGroups can optionally
	send out a status message for any change in their state, regardless of
	whether the change is to be applied or not.  To get status messages
	from your GenItemGroup, add an ATTR_GEN_ITEM_GROUP_STATUS_MSG to the
	object.  The attribute takes a single message to send on any user
	change in the object's state.  For example:

		ATTR_GEN_ITEM_GROUP_STATUS_MSG = MSG_COLOR_STATUS_CHANGE;
	
	will cause a MSG_COLOR_STATUS_CHANGE to be sent to the destination
	on a non-applied change.    This message definition should be set up
	as follows:

		@message (GEN_ITEM_GROUP_STATUS_MSG) 
			MSG_COLOR_STATUS_CHANGE;
					
	The message parameters are "void (word selection, word numSelections,
	byte stateFlags)", where:

		selection      -- current selection, or first selection of
				  multiple selections, or GIGS_NONE if no 
				  selection.
		numSelections  -- number of selections
		stateFlags     -- GenItemGroupStateFlags:
				     GIGSF_INDETERMINATE -- set if item
					group state is indeterminate (see
					indeterminate section, below)
				     GIGSF_MODIFIED -- set if user activation
					has just changed the status of the
					group.  (Clear only on redundant user
				 	selection of an item)
	
	You could then use the MSG_COLOR_STATUS_CHANGE handler to change the
	BooleanGroup's state as needed.  Similarly, you'd want to set
	ATTR_GEN_BOOLEAN_GROUP_STATUS_MSG in the boolean group and have its
	status message handler keep the item group up to date.  Since these
	messages are usually invoked by some change by the user, each handler
	will want to mark the other object as modified before changing its
	state, so that reset will return both objects to their original state
	properly.  (See the section above on setting the modified state of an
	item group.)


	Sending unmodified applies
	--------------------------

	By default, apply messages are only sent out if user has modified
	the state of the object since the last apply.  Occasionally
	an application will want its delayed GenItemGroup to send 
	notification of an apply if the object has not been modified by the
	user.

	To receive apply messages, regardless of the modified state of the group,
	set:

		ATTR_GEN_SEND_APPLY_MSG_ON_APPLY_EVEN_IF_NOT_MODIFIED;

	The same message for unmodified applies is sent out as for modified
	applies.  To tell whether anything was actually modified or not, your
	apply message handler can check the GIGSF_MODIFIED bit in "stateFlags."


Indeterminate mode
------------------

	Sometimes applications need to mark the state of a GenItemGroup object
	as indeterminate.  For example, a user in a word processing program
	might be selecting a paragraph of black text with a sentence in a red
	color for emphasis.  Hence no color item would fully represent the
	entire data selection.  To set a GenItemGroup to represent the the
	color of the text, you must pass the color represented at the
	beginning of the selection, C_BLACK, and set the indeterminate flag:

		@call TextColorExcl::MSG_GEN_ITEM_GROUP_SET_SELECTION(C_BLACK, 
						     		      TRUE);

	You can query for the item group's indeterminate state by doing a:

	       @call TextColorExcl::
			MSG_GEN_ITEM_GROUP_IS_INDETERMINATE();

	which returns a Boolean, true if the current selection is indeter-
	minate.


Non-exclusive behavior in item groups
-------------------------------

	The GenItemGroup supports non-exclusive behavior, where items can be
	selected and deselected independently of each other.  Rather than
	keeping a single selection, the item group keeps a list of selections.
	Keep in mind that a related object, GenItemGroup, is optimized for
	handling up to 16 items non-exclusively, keeping a bitmask to repre-
	sent the selected items, and hence often easier to use for most
	non-exclusive situations.  GenItemGroups will usually be turned into
	checkboxes of some form, while non-exclusive GenItemGroups will
	usually be turned into a scrolling list.  To make your GenItemGroup
	object non-exclusive, you set GIGI_behaviorType to GIGBT_NON_EXCLUSIVE 
	in your object definition.  For instance, to create a scrolling
	list of styles, none of which are initially selected:

	        typedef enum /* word */ {
	    	   TS_BOLD, TS_ITALIC, TS_UNDERLINE, ST_STRIKETHRU, TS_OUTLINE;
	        } StyleTypes;

		@object GenItemGroupClass StylesGroup = {
			GI_comp = BoldItem, ItalicItem, UnderlineItem,
				  StrikethruItem, OutlineItem;
			GIGI_selection = GIGS_NONE;
			GIGI_numSelections = 0;
			GIGI_behaviorType = GIGBT_NON_EXCLUSIVE;
		}
		@object GenItemClass BoldItem = {	
			GI_visMoniker = "Bold";
			GII_identifier = TS_BOLD;
		}
		@object GenItemClass ItalicItem = {	
			GI_visMoniker = "Italic";
			GII_identifier = TS_ITALIC;
		}
		@object GenItemClass UnderlineItem = {	
			GI_visMoniker = "Underline";
			GII_identifier = TS_UNDERLINE;
		}
		@object GenItemClass StrikethruItem = {	
			GI_visMoniker = "Strikethru";
			GII_identifier = TS_STRIKETHRU;
		}
		@object GenItemClass OutlineItem = {	
			GI_visMoniker = "Outline";
			GII_identifier = TS_OUTLINE;
		}

	To initially specify more than one selection, you should change GIGI_
	selection to point to a selection chunk that you create:

		@object GenItemGroupClass StylesGroup = {
			GI_comp = BoldItem, ItalicItem, UnderlineItem,
				  StrikethruItem, OutlineItem;
			GIGI_selection = (word) ChunkOf(@InitialStyles);
			GIGI_numSelections = 3;
		}

		@chunk word InitialStyles[3] = {
			TS_BOLD, TS_ITALIC, TS_UNDERLINE
		};
	
	Notification parameters in a non-exclusive item group are the same as
	in an exclusive item group, namely "void (word selection, word
	numSelections, byte stateFlags)".  The handler will want to check
	"numSelections" to see if multiple selections are made.  If there is
	more than one selection, only the first selection in the item group
	will be passed in the "selection" parameter.  The handler must query
	the item group for a complete list of selections.

	To query a non-exclusive item group for multiple selections, you must
	pass a pointer to a buffer large enough to hold the identifiers of the
	selected items, and must also pass the size of the buffer.  The query
	will fill the buffer and tell you how many items are actually
	selected. For instance, if on notification you find there are four
	items selected, you can query for them as follows:

	   word selections[4];  /* Allocate space for selected items */
	   @call StylesGroup::MSG_GEN_ITEM_GROUP_GET_MULTIPLE_SELECTIONS(
					selections, 4);
	
	Selections will get filled in with the four selected items ,
	and the number of selections will be returned (although we ignored the
	return value in this example).   If there are more selections than 
	than space in the buffer, the buffer will not be filled in with the 
	selections.  If you don't know the number of items that are selected, 
	you can first call MSG_GEN_ITEM_GROUP_GET_NUM_SELECTIONS, which returns 
	a word:

	   word selections[], alloc[];
	    
	   numSels = @call StylesGroup::MSG_GEN_ITEM_GROUP_GET_NUM_SELECTIONS();
	    
	   /* Allocate space for the number of word selections */
	   selections = alloc(numSels*2);
	    
	   @call StylesGroup::MSG_GEN_ITEM_GROUP_GET_MULTIPLE_SELECTIONS(
							      selections,
	    						      numSels);
	   {do whatever you want with the selections}
	   free(selections);

	Similarly, you can set a group of selections by passing a pointer to
	list of item identifiers, along with the number of selections:

	    /* Create a list of selections */
	    word selections[3] = { TS_BOLD, TS_ITALIC, TS_UNDERLINE };

	    @call StylesGroup::MSG_GEN_ITEM_GROUP_SET_MULTIPLE_SELECTIONS(
							selections, 3);

	The first argument is a pointer to the list of entries to select, and
	the second argument the number of selected entries.  Any items whose 
	identifiers are in the list will be selected; all other identifiers 
	will be deselected.  Note that indeterminate mode cannot be set via
	this message -- to set the list's indeterminate mode on or off you
	must send a MSG_GEN_ITEM_GROUP_SET_INDETERMINATE_STATE, passing a
	boolean indicating how to set the group's indeterminate state.

	You can also select or deselect a single entry independent of the 
	others.  To select an item (such as TS_OUTLINE above), do the 
	following:
	  
	   @call StylesGroup::MSG_GEN_ITEM_GROUP_SET_ITEM_STATE(TS_OUTLINE, 
								TRUE);

	The second argument should be set to TRUE to set the item, FALSE to
	deselect the item.  Again, the indeterminate state of the item group
	must be set separately.

	You can also query for whether a single item is selected by doing a
	
	    @call MyList::MSG_GEN_ITEM_GROUP_ITEM_IS_ITEM_SELECTED(TS_OUTLINE);
	    
	which will return a Boolean, true if the item is currently selected.
	
	Delayed mode and indeterminate mode work the same for a non-exclusive
	item group as for an exclusive item group.   The modified and 
	indeterminate flags apply to the entire item group as a whole, rather 
	than to each item (in contrast to GenItemGroup, which keeps the 
	indeterminate and modified state for each item).


Extended selection style items
---------------------------------

	Occasionally it is useful to implement a non-exclusive group of 
	items where normal clicks on an item will deselect the previous
	item or items, thus behaving much like an exclusive item group in normal
	operation.  However, extended selections (in motif, by holding down 
	the shift key and selecting, or dragging across several items) allow 
	the selection of more than one item.   The desktop icons are 
	implemented in this fashion (although not with GenItemGroups).

	To get extended-selection behavior from your GenItemGroup object,
	add this line to its instance data:

		GIGI_behaviorType = GIGBT_EXTENDED_SELECTION;

	Messages to the item group function the same for extended-selection-
	exclusive item groups as for non-exclusive item groups.


Generic attributes
------------------

	There are several generic attributes, available for use in the 
	GenItemGroup, which modify its behavior:
	
		* Have the button dismiss its window when clicked on.
		
		* Have user clicks cause the cursor to change to a busy cursor,
		   for long operator.
		   
		* Having clicking on the button hold up input to other UI
		  gadgetry until the handler action finishes (good for when
		  buttons will disable or change UI gadgetry so the user can't
		  subsequently click on an object before its disabled).
		  
		* Having clicking on the button cause input to its application
		  be ignored until the action completes.
		  
	Setting these flags in individual items will have no affect.
	
	These are described in more detail in the GenAttrs section
	of genClass.asm.
		  

Custom double-press behavior
----------------------------

	Usually double-clicking on an exclusive item will activate the interac-
	tion default in a dialog box (usually "Apply" or "OK").  If you want to
	circumvent this, you can add an ATTR_GEN_ITEM_GROUP_CUSTOM_DOUBLE_-
	PRESS with a message to send on a double-press (or null if you don't 
	care at all about double-presses).  The message will be sent to the 
	current destination object.  For example:

	    ATTR_GEN_ITEM_GROUP_CUSTOM_DOUBLE_PRESS = MSG_HANDLE_DOUBLE_PRESS;

	will prevent double-presses from activating the interaction default,
	and will cause a MSG_HANDLE_DOUBLE_PRESS to be sent out instead.
	Arguments passed in MSG_HANDLE_DOUBLE_PRESS are the same as for an
	applied action.  Define your message as follows:

	    @message (GEN_ITEM_GROUP_APPLY_MSG) MSG_HANDLE_DOUBLE_PRESS;

	To cause no message to be sent on a double press, do a:

		ATTR_GEN_CUSTOM_DOUBLE_PRESS = 0;

	Non-exclusive or exclusive-none item groups will not send out a custom
	double press message.


Linked GenItemGroups
-------------------

	There sometimes may arise a need for GenItems to be split up between
	several GenItemGroups.  Usually this would be necessary to accomplish
	a geometry layout that can't work otherwise.  For instance, you might
	choose to lay out a dialog box like the following:

				Add Text To:
		[*] Header
			[*] Left justified [ ] Centered  [ ] Right Justified
			[ ] Add dividing line
			Text to display:_My_Memoirs___________________

		[ ] Body
			[ ] Left justified [ ] Centered  [ ] Right Justified
			Left Margin:_2_in__   Right Margin: 3_in__
			Text to display:______________________________

		[ ] Footer
			[ ] Left justified [ ] Centered  [ ] Right Justified
			[ ] Add dividing line
			Text to display:______________________________
		
			
	You might like to have the Header/Body/Footer items all be exclusive
	items in the same item group.  You are not allowed to have other objects
	as children of a GenItemGroup, however, so you must put each of the
	items in their own GenItemGroup.  Adding an ATTR_GEN_ITEM_GROUP_LINK
	to each object will alert the item groups that they are functioning as 
	one:

		@object GenItemGroupClass HeaderGroup = {
			GI_comp = HeaderItem;
			GIGI_applyMsg = MSG_PAGE_AREA_CHANGE;
			ATTR_GEN_ITEM_GROUP_LINK = BodyGroup;
		}
		@object GenItemClass HeaderItem = {	
			GI_visMoniker = "Header";
			GII_identifier = ATI_HEADER;
		}

		@object GenItemGroupClass BodyGroup = {
			GI_comp = BodyItem;
			GIGI_applyMsg = MSG_PAGE_AREA_CHANGE;
			ATTR_GEN_ITEM_GROUP_LINK = FooterGroup;
		}
		@object GenItemClass BodyItem = {	
			GI_visMoniker = "Body";
			GII_identifier = ATI_BODY;
		}

		@object GenItemGroupClass FooterGroup = {
			GI_comp = FooterItem;
			GIGI_applyMsg = MSG_PAGE_AREA_CHANGE;
			ATTR_GEN_ITEM_GROUP_LINK = HeaderGroup;
		}
		@object GenItemClass FooterItem = {	
			GI_visMoniker = "Footer";
			GII_identifier = ATI_FOOTER;
		}


	Note the circularity of the links.  This allows the specific UI to
	still handle keyboard navigation as if these three items were in a 	
	normal item group (in Motif, this means allowing the cursor keys to 
	move the focus to each item in turn).

	To get exclusive behavior from this item group, you should specify the 
	same action message and destination for the item group and ensure that 
	each of the items has a unique identifier.  When the notification message
	is handled for a new user selection, it should broadcast a SET_SINGLE_-
	SELECTION to all three item groups to make sure they are updated 
	correctly:

		@method MyHandlerClass MSG_PAGE_AREA_CHANGE {
		   @call HeaderGroup::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(
						selection, FALSE);
		   @call BodyGroup::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(
						selection, FALSE);
		   @call FooterGroup::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(
						selection, FALSE);
		}

	Basically, the idea is to always keep all three item groups up to date 
	with the current selection.  While all three will contain the same 
	state, only one of the item groups will show an item selected.


Other miscellanious stuff
------------------------- 
	
	You can change the message that a GenItemGroup object uses for applies
	by sending the following:

		@call ColorsGroup::MSG_GEN_ITEM_GROUP_SET_APPLY_MSG(MSG_FOO);

	Similarly, to retrieve it:

		message = @call ColorsGroup::MSG_GEN_ITEM_GROUP_GET_APPLY_MSG();

	If, for some reason, you need to force an apply for a delayed-mode 
	item group, you can send a 
			
		@call ColorsGroup::MSG_GEN_APPLY;
	
	to the GenItemGroup, which will cause a notification as if the user
	had clicked on the "Apply" button.



------------------------------------------------------------------------------`
