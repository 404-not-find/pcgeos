COMMENT @CLASS DESCRIPTION-----------------------------------------------------

				GenViewClass

$Id: GenView.doc,v 1.1.34.1 97/03/29 03:37:53 canavese Exp $

Synopsis
--------

GenViewClass implements a view (as defined above).

	GenViewClass allows you to display data in a scrollable, clipped
	window.  Methods are provided for arbitrarily scrolling and scaling
	the window.  Scrolling is accomplished via methods to the view, which
	can come from the application, or by scrollers associated  with the
	view.   Optionally, drag scrolling can also be used to scroll a 
	GenView.  Some specific UI's may provide a panning feature to scroll
	the document as well.

	The view's docBounds instance data gives the bounds of the document
	to scroll in.  Typically docBoundsLeft and docBoundsTop will be 0,0
	and docBoundsRight and docBoundsBottom will be the width and height
	of the document respectively, but it is also possible to scroll through
	a subset of the document coordinates, as desired, or through negative
	coordinates.   The docBounds are 32 bit coordinates, to allow scrolling
	in very large documents.

	Typically an application wants to use scrollers to manipulate the
	position of the view.  By default, if a view is scrollable in one
	or more directions, one or more scrollers will be provided so the
	user can easily scroll through the document.  The view can also be
	directed to not display one or more of the scrollers, and only respond
	to methods from the application.
	

	Defining a view in your .ui file
	--------------------------------
	
	To define a view that is scroller in either direction, and scrolls
	from 0 to 1000 in each direction, do the following:

		MyView = GenView {
			docBoundsRight = 1000;
			docBoundsBottom = 1000;
			vertAttrs = scrollable;
			horizAttrs = scrollable;
		}


	Objects should only be put as children of the view if they want to
	appear next to the scrollers.  All other objects will be ignored.
	Scrollers don't have to be defined explicitly by the application; the
	view will add them as children when needed, and throw them away when
	unbuilt.
	
	
	The "content" of the view
	-------------------------
	
	The content, or output of the view is where expose and mouse events 
	for the view window arrive, and who the view interacts with.  The 
	content of the view can be one of several types.  First the output
	can be the process itself.  The process gets raw methods from the
	view and window manager and must process them itself.  The
	advantage of sending stuff straight to a process is that the 
	process can draw or behave any way it wants.  Unlike other parts of
	an application's primary (other than GenGadgets), the area inside
	of the view is the only place where the application has total control.
	
	If you would like to manage a heirarchy of visual objects under the
	view, you will not want to use a process as the content.  In this case, 
	you will want to install the root object in the visual tree as the OD
	of the view.  The VisContent object is designed for just this purpose,
	and handles the view-specific bookkeeping so that the visual tree 
	below it may not have to even be aware that it resides in a view.
	VisContent is subclassed off of VisComp, and has all the default
	capabilities that a visual composite has in terms of setting up 
	MSG_VIS_DRAWS, sending mouse events to the child under the mouse point,
	etc.  

	The VisContent is designed to run under the same thread as the
	view.  For simple tasks, this is fine. Often, however, your objects in 
	the view will be tied to other things going on in your application,
	and you don't want application-related processing to slow down the UI
	queue, so you'll want the content to run under the application thread.
	For this, the VisContent needs to be in an application run block, 
	rather than a UI run block.  
	
	Finally, if you want to run generic objects in the view, you should use
	a GenContent object as the content.  Your other generic objects can
	in a tree under the GenContent.  If you are using generic objects,
	however, you should think about whether the view is appropriate or not,
	as it is unintuitive to the user to have user interface gadgetry that
	is not all visible at once.  The GenContent can run under the same or
	different thread than the view.   You will want to set "viewAttributes 
	= genericContents" so the view knows what it's dealing with.
	
	
	View opening/closing methods
	----------------------------

	These are the methods that are always sent to the OD by the view
	from the time it opens until it is closed (or the view decides to
	change contents):
	
		MSG_META_CONTENT_SET_VIEW -- Tells the content that it now will 
			belong to this view. (The VisContent uses this to set a 
			pointer to the view in its instance data.)
		
		MSG_META_CONTENT_VIEW_ORIGIN_CHANGED -- sent out when the view's
			origin changes, in case the OD cares about such things.
			(First appears here so that content can prepare for 
			being onscreen.)
		
		MSG_META_CONTENT_VIEW_SCALE_FACTOR_CHANGED -- sent out when the 
			view's scale factor changes, in case the OD cares about
			such things.  (First appears here so that content can 
			prepare for being onscreen.)

		MSG_META_CONTENT_VIEW_OPENING -- tells when a view is getting
			a MSG_VIS_OPEN.  (A VisContent object will set an 
			upward visual link to the view, and invalidates itself
			in preparation for its own update.)
		
		MSG_META_CONTENT_VIEW_WIN_OPENED -- tells when a new view window
			has been created.  Process may want to save away the
			window handle and the window's size for later use.
			(A VisContent visually updates its tree at this point,
			setting up geometry and sending MSG_VIS_OPEN's to
			itself and its children.)
			
		MSG_META_CONTENT_VIEW_SIZE_CHANGED -- sent out when the view's
			size changes.  (A VisContent will invalidate its
			geometry and do an update on itself here.)
		
		MSG_META_CONTENT_VIEW_CLOSING -- sent when the view receives
			its MSG_VIS_CLOSE.  (A VisContent will use this to
			send MSG_VIS_CLOSEs to itself and its children.)

		MSG_META_CONTENT_VIEW_WIN_CLOSED - sent when the view has been
			taken down, or is changing to a new content.  A content
			will want to zero its copy of the window handle at this
			point so no further drawing to it is done.
			
		MSG_META_CONTENT_SET_VIEW -- A null value will be passed here 
			after a view is either going away, or no longer using
			that content (the content has been changed).  This
			method immediately follows the MSG_META_CONTENT_VIEW_
			CLOSING business. If the view is now starting to use a 
			different content, that content will now start 
			receiving view methods as if the view just started 
			opening.
		
	Drawing methods
	---------------
	
	If you are running under a process, there is at least one method
	you will definitely want to handle yourself:
	
		MSG_META_EXPOSED -- comes in when the view's window needs
			updating.  The view's window handle is passed. 
			A MSG_META_EXPOSED handler should look something like
			the following:
			
			MyAppExposed method myapp_ProcessClass, MSG_META_EXPOSED
				mov	di, cx		;gstate in di
				call	GrCreateState	;create a gstate
				push	di
				call	GrStartUpdate	;set up inval rect
				.
				.(do drawing)
				.	
				pop	di
				call	GrEndUpdate	;update is complete
				call	GrDestroyState	;get rid of this
				ret
				
			GrStartUpdate and GrEndUpdate sets things in the
			graphics state so any drawing is clipped to those
			areas that are currently invalidated in the window.
			
			Of course, applications can redraw their view at any 
			time by keeping the window handle around, creating
			their own gstate for it, and drawing.
			
			
	Mouse events
	------------
	
	The following methods may be sent to the content, depending on the
	situation:
	
		MSG_META_PTR
		MSG_META_START_SELECT 
		MSG_META_END_SELECT
		MSG_META_DRAG_SELECT
		MSG_META_START_MOVE_COPY
		MSG_META_DRAG_MOVE_COPY
		MSG_META_DRAG_FEATURES
		MSG_META_START_OTHER
		MSG_META_END_OTHER
		MSG_META_DRAG_OTHER
		
	Varying amounts of mouse and keyboard events can be sent from the view
	to the content, depending on what view window flags are set.  grabWhile-
	PressedInView only sends mouse events to the content while the mouse 
	is held down in the view window.  grabWhileOverView sends mouse events 
	when the mouse is over the view, whether pressed or not.  sendPtrEvents 
	allows pointer events to be sent through in addition to press events.  
	Targetable allows the content to receive target gain and lost events, 
	so it can update its window accordingly.  Focusable allows the content
	focus so that keyboard chars will be sent to the content. The 
	application should only set the flags that it needs, in order to keep 
	system performance to a maximum.

	Drag scrolling allows the user to scroll the view by clicking in the
	view window and dragging out of it.  This is useful where it is 
	desirable to have the view scroll automatically to show what the mouse 
	is on top of.   To set this set viewAttrs = dragScrolling, and it 
	will happen automatically.

	
	Keyboard events (MSG_META_KBD_CHAR)
	---------------------------------
	
	The view by default sends all keyboard characters to the content if they
	are not handled by the specific UI, which gets first crack at them.  
	(The exception is ALT, which is always sent to the application, whether 
	handled by the UI or not.)    If this is not acceptable to the app, 
	GVA_SEND_ALL_KBD_CHARS can be set, which gives ALL keyboard characters 
	to the content first, which then is expected to FUP them up so the 
	specific UI can handle them.  Applications shouldn't have to use
	this flag in most cases.  GVA_DONT_SEND_KBD_RELEASES works as before.
	VGA_SEND_ALL_CHARS_TO_CONTENT is gone.

	If you need to handle certain keyboard chars as shortcuts, you may
	wish to process these in the UI thread so that application functions
	stay synchronized with other keyboard characters.   If you have 
	shortcuts that are not handled via the accelerator mechanism, you
	can subclass MSG_META_KBD_CHAR in the GenView and handle them specially:
	
	MyViewKbdChar method GenViewClass, MSG_META_KBD_CHAR
		cmp	cx, SHORTCUT		;special shortcut?
		jnz	callSuper		;no, handle normally
		{do action on shortcut}
	callSuper:
		mov	di, offset GenViewClass	
		call	ObjCallSuperNoLock
		ret
	MyViewKbdChar endm
	
	
	Target/focus events
	-------------------
	
	The content will also receive methods when it gains or loses the
	target or focus.  The content may want to draw itself differently
	depending on whether it has the focus, target, or both.
	
		MSG_META_VIS_ENTER
		MSG_META_VIS_LEAVE
		MSG_META_UNIV_ENTER
		MSG_META_UNIV_LEAVE
		MSG_META_CONTENT_VIEW_LOST_GADGET_EXCL
	
	
	Sizing the view
	---------------

	The view's size, in the default case, generally comes up big enough
	to fit in whatever size the parent primary wants to be.  It then
	responds to any user resizes, getting as small as it needs to
	or as large as the width and height of the scrollable document area.
	The content will receive a MSG_META_CONTENT_VIEW_SIZE_CHANGED any time
	the view's size changes.

	There are several hints and attributes which modify the sizing 
	behavior of the view:
	
		1. HINT_INITIAL_SIZE
			This sets an initial size for when the window opens.
			hint takes arguments of type SpecSizeSpec, which 
			a width or height to be determined by number of pixels,
			the height of the screen, the height of the system
			font, the average width of a number of system font
			characters, etc.  The view window will never get smaller
			than this value. An example is listed under the hints
			section below.

		2. vertAttrs = noMaxSize;
		   horizAttrs = noMaxSize;
			This allows view windows to get larger than the 
			document size.  Expose events still happen
			in the areas outside the scrollable bounds.
			This can be set in one or both directions.

		3. HINT_MINIMUM_SIZE
			This hint sets a minimum size for the view window.  The 
			hint takes arguments of type SpecSizeSpec, which 
			a width or height to be determined by number of pixels,
			the height of the screen, the height of the system
			font, the average width of a number of system font
			characters, etc.  The view window will never get smaller
			than this value.

		4. HINT_MAXIMUM_SIZE
			Sets up a maximum size for the view window.  This
			can used be instead of, or in addition to, the maximum
			size imposed by the document's scrollable bounds.

		5. HINT_FIXED_SIZE
			This can be used instead of the other size hints, and
			defines a permanent size for the view.   It effectively
			sets the initial, minimum, and maximum sizes at once.

		6. vertAttrs = sizeAMultipleOfIncrement;
		   horizAttrs = sizeAMultipleOfIncrement;

			This truncates view width or height to the next lowest
			multiple of the increment for that direction.
			Occasionally useful for controlling the view size.
			Also works for non-scrollable views, when the increment
			is otherwise meaningless.

		7. vertAttrs = keepAspectRatio;
		   horizAttrs = keepAspectRatio;

			This, along width HINT_INITIAL_SIZE, allows the view
			to keep the same ratio between its width and height,
			regardless of what the user tries to resize the view's
			primary to.  If the vertAttrs flag is set, the 
			width is adjustable by the user and the height is
			calculated from the width using the initial ratio.
			If the horizAttrs flag is set, the height is adjustable
			and the width is calculated.  Both flags can't be set.


		If the programmer really needs more precise control of the 
		size of the view window, he can subclass the view's MSG_GEN_
		VIEW_CALC_WIN_SIZE method, adjusting the passed window size as 
		he sees fit.
		
		
	Typical geometry combinations of views and contents
	---------------------------------------------------
	
	Of course, it may not be the case that the view responds to changes
	in the size of the primary, and that size of the content object (and any
	children it has) is independent of the view size.  Here are some of
	the various behaviors that views and contents typically have, and what
	attributes to set to get that behavior:


	1.  View sizes to any size, content has fixed size.
	---------------------------------------------------
		View can have minimum, maximum, or open sizes set to modify
		what sizes the view can be.  No other flags need be set to 
		make this work.  The content's size can be set in the .ui file
		(by setting right and bottom values) or via a MSG_VIS_SET_SIZE
		followed by a MSG_VIS_MARK_INVALID to invalidate the content's
		geometry.  

		An example:
		
			MyView = GenView {
				output = MyContent;
			}
			
			
			MyContent = GenContent {
				right = 1000;
				bottom = 1000;
			}
			
	2.  View sizes to any size, content follows horizontal size, but
	    chooses its own vertical size.
	    ------------------------------------------------------------
		This is what a scrollable GenText object does, what geoPlanner's
		planner window and calendar windows do.  The content should
		have sameWidthAsSubview set in it.  After the view
		is resized and redrawn, the content has its geometry done
		based on this value.  Modify your content's 
		MSG_VIS_DETERMINE_SIZE to return a new height to use.  The 
		VisContent object, after updating its geometry, automatically 
		sends a MSG_GEN_VIEW_SET_DOC_BOUNDS to the view.
		This can be useful even when the content is generic 
		or uses the geometry manager to position and size its 
		children.  
		
		The view must have noMaxSize set in its vertical attributes
		as well, so that it doesn't try to stay smaller than the
		content's width.
		
		The content can also use the view's height, and 
		calculate its own width, by setting sameHeightAsSubview.
		
		Here's an example where the view can be any size, and the
		content sizes itself so that its height = its width.  
		
		
			MyView = GenView {
				output = MyContent;
				horizAttrs = docSizeIsNotMax;
			}
			
			MyContent = VisContent {
				contentAttrs = sameWidthAsSubview;
			}

			ContentDetermineSize method VisContentClass, \
						  MSG_VIS_DETERMINE_SIZE
				mov	cx, ds:[di].VCI_viewWidth  ;get width
				mov	dx, cx			   ;height=width
				ret
			ContentDetermineSize endm
				
				
		A GeoManager folder is a more interesting example, where it 
		takes the width, and figures out how much height it needs
		for all the icons to fit.
		
		This might also be the size behavior you might use to run
		generic objects under a GenContent.  The problem is that the
		children may be unable to size themselves to fit in the width
		provided by the view.  Although there may seem to be no 
		problems under the UI you test your application with, you
		can't be sure that some future UI will not cause some problems.
		To play it safe, you should either set the HINT_CAN_CHOP_WIDTH
		attribute in the GenContent, so it will at least clip things
		horizontally, or use the fourth sizing option below, where
		the view and content interact with each other when geometry
		is being done.
		
				
	3.  View sizes to any size, content completely follows view size 
	----------------------------------------------------------------
		View can have minimum, maximum, or open sizes set to modify what
		sizes the view can be.  Content must have sameHeightAsView
		and sameWidthAsView set.  Everything else happens automatically.
		Presumably the content would draw itself based on this size.
		You may or may not be able to run generic objects under a
		GenContent using these settings, because the children might
		require more space than the view is allowing.
		(The content object would probably have to set
		CAN_CHOP geometry attributes, in case the 
		children got bigger than the available area for the content.)

			MyView = GenView {
				output = MyContent;
			}
			
			MyContent = VisContent {
				contentAttrs = sameWidthAsSubview, 
					       sameHeightAsSubview;
			}

				
		This might be what you would use for a game, where the
		game could resize dynamically to fit whatever space it was
		in, and not scroll.
		
		
	4.  View size follows content size.
	----------------------------------
		To use this function the VisContent must be run in the same
		thread as the view (i.e. be part of a UI-owned block).
		In this case, the content and its children are presumed to have
		their geometry done as part of the view, as if the content were
		a GenInteraction in the parent window.  In this mode, the
		content (Gen or Vis) gets proposed sizes from the view,
		does its own geometry on any children, the returns an
		appropriate size.  The view adjusts its width to that
		of the content, and is scrollable vertically.  This may
		be what you want to do if you have a complicated set of
		generic objects under a GenContent object, and it's necessary
		that the objects determine the width of the view rather than
		the width of the view determining the generic object layout.
		The content must be in the same thread.
		Set "vertAttrs = viewFollowsContentGeometry" in the
		view. If the content just manages generic objects, you're done; 
		otherwise you may need to write a MSG_VIS_DETERMINE_SIZE handler
		to get the content to determine a size based on what is passed.
		In most cases, though, you can probably just use Option 2 and
		just let the view be any size, forcing the generic objects to 
		do the best they can with what they get. 

			MyView = GenView {
				output = MyContent;
				vertAttrs = viewFollowsContentGeometry;
			}
			
			MyContent = GenContent {
				children = MyInteraction, MyText1, MyText2;
				hints = {
					HINT_ORIENT_VERTICALLY
				}
			}

		
	(See the geometry manager section for more information on the geometry
	 manager and writing MSG_VIS_DETERMINE_SIZE handlers.)


	Linked views
	------------
	
	Sometimes it is useful to link two or more views together in one or
	more directions so that scrolls sent to one view (via message or
	user action) are also reflected in the linked views.  Links must always
	be set up in a circular fashion (i.e. MyView1->MyView2->VertRuler->
	MyView1).
	
	One might like to set up extra views to act as horizontal and vertical
	rulers for a document.  A view to the left of the document view would
	act as the vertical ruler, and be linked horizontally (as you would
	typically view it), so that vertical scrolls of the document are 
	reflected in the ruler.  The view above the document view would act as
	the horizontal ruler, and be linked vertically.   Horizontal document
	scrolls would be reflected in this ruler.  A typical setup would look 
	like this:
	
		HorizRulerComp = GenInteraction {
			children = RulerPlaceholder, HorizRuler;
			hints = {
				HINT_ORIENT_CHILDREN_HORIZONTALLY
			}
		}
	
		RulerPlaceholder = GenInteraction {
			hints = {
				HINT_FIXED_SIZE {
					SpecWidth <SST_PIXELS, RULER_WIDTH>
					SpecHeight <SST_PIXELS, RULER_WIDTH>
				}
			}
		}
	
		HorizRuler = GenView {
			vertLink = DocView;
			hints =  {
				HINT_FIXED_SIZE {
					SpecWidth <>
					SpecHeight <SST_PIXELS, RULER_WIDTH>
				}
			}
		}
		
		DocComp = GenInteraction {
			children = VertRuler, DocView;
			hints = {
				HINT_ORIENT_CHILDREN_VERTICALLY
			}
		}
		
		VertRuler = GenView {
			horizLink = DocView;
			hints =  {
				HINT_FIXED_SIZE {
					SpecWidth <SST_PIXELS, RULER_WIDTH>
					SpecHeight <>
				}
			}
		}
		
		DocView = GenView {
			horizLink = VertRuler;
			vertLink = HorizRuler;
		}
		
	The fixed size hints show how to set up geometry for something like
	a ruler.  You will probably want to use the ruler library for this
	specific example.
	
	With scroll messages, the scroll is always broken into a vertical
	component to send through the horizontal links, and a horizontal 
	component to send through the vertical links.  Other messages will
	also be propagated through links if you send them to one view:
	
			MSG_GEN_VIEW_SET_SCALE_FACTOR
			MSG_GEN_VIEW_SET_DOC_BOUNDS
			MSG_GEN_VIEW_SET_CONTENT
			MSG_GEN_VIEW_SET_INCREMENT
			MSG_GEN_VIEW_SET_COLOR

	These will propagate to all the nodes that can be reached through
	the vertical and horizontal links.
	
	If you want to send a message to an object without it automatically
	propagating it to the other links, you can encapsulate the message
	and pass it to the view in a MSG_GEN_VIEW_CALL_WITHOUT_LINKS.  The
	view will dispatch the message to itself without propagating it to the
	links.
	
	Implementation details for linked views
	---------------------------------------
	
	Scroll messages will be converted to MSG_GEN_VIEW_SCROLL_LOW messages,
	encapsulated, and passed in vertical links in MSG_GEN_VIEW_SEND_TO_-
	VLINK, horizontal links in MSG_GEN_VIEW_SEND_TO_HLINK.  You can subclass
	these to break a link for some reason or to send the message along
	but keep the view from receiving the MSG_GEN_VIEW_SCROLL_LOW
	message.    Non-scroll messages are kept as is and passed first 
	horizontally in MSG_GEN_VIEW_SEND_TO_LINKS, then passed vertically
	from each horizontal node in MSG_GEN_VIEW_SEND_TO_VLINK.  All of these
	messages dispatch the passed message to the node before passing it
	on to its link.
	
	A splitting example
	-------------------

	Splitting is not yet implemented.  Documentation to come later.
	
	
	Placing other objects next to the scrollers
	-------------------------------------------
	
	Sometimes applications wish to place objects in the four areas around
	the view that are usually used for scrollers -- the left, top, right,
	and bottom areas around the view window.  These objects can share the 
	space with the scrollers, or it can occupy the space by itself.
	For instance, a word processor may draw the page number to the left of 
	their horizontal scroller, under the view window.  Here's what the .ui 
	file might look like for the example above:

		MyView = GenView {
			children = PageGlyphDisplay;
			docBoundsRight = 1000;
			docBoundsBottom = 1000;
			vertAttrs = scrollable;
			horizAttrs = scrollable;
		}

		PageGlyphDisplay = GenGlyph
			moniker = "Page 3";
			hints = {
				HINT_SEEK_X_SCROLLER_AREA
			}
		}

	Likewise, HINT_SEEK_Y_SCROLLER_AREA will stick the object in with
	the vertical scroller.  HINT_SEEK_LEFT_AREA, HINT_SEEK_TOP_AREA,
	HINT_BOTTOM_AREA, HINT_SEEK_RIGHT_AREA can be used to force an object
	to a given area, regardless of whether a scroller is there or not.
	The object will be put with the horizontal scrollbar if no hint is
	given. More than one object can appear in each of the X or Y scroller 
	areas.  
	
	If the specific UI supports this capability, the objects will be laid
	out left to right or top to bottom according to their positions in the
	generic tree.  If the specific UI doesn't support this, children of the
	view will likely be laid out underneath it visually.


	Unusual placement of scrollers
	-------------------------------

	Most specific UI's have standards for where scrollers should be placed
	around the view.  Usually the vertical scroller is placed on the right
	side and the horizontal scroller is placed on the bottom.  Some UI's
	allow users to choose right-handed vs left handed arrangements as well.
	Hence some specific UI's may not allow scrollbars to be placed
	in a certain position.  To override the UI's positioning, you should
	explicitly specify the scroller in the .ui file, adding the appropriate
	positioning hint to the scroller.  For example, to force a vertical
	scrollbar to be on the left side, you can do the following:
	
		MyView = GenView {
			children = VertScroller;
			docBoundsRight = 1000;
			docBoundsBottom = 1000;
			vertAttrs = scrollable;
		}

		VertScroller = GenRange {
			hints = {	
				HINT_RANGE_Y_SCROLLER,
				HINT_SEEK_LEFT_OF_VIEW
			}
		}

	The scroller can also be farther down in the generic tree (with other 
	objects).  Any child in the tree can have the positioning hint.

		MyView = GenView {
			children = VertInteraction;
			docBoundsRight = 1000;
			docBoundsBottom = 1000;
			vertAttrs = scrollable;
		}

		VertInteraction = GenInteraction {
			children = VertScroller;
			hints = {
				HINT_ORIENT_HORIZONTALLY
			}
		}
			
		VertScroller = GenRange {
			hints = {	
				HINT_RANGE_Y_SCROLLER,
				HINT_SEEK_LEFT_OF_VIEW
			}
		}

	Before creating its own scrollers the view will first look for any 
	scroller with the HINT_RANGE_Y_SCROLLER and HINT_RANGE_X_SCROLLER hints in it.  
	It will use the first one of each it finds.  These scrollbars
	cannot be made not usable or generically removed while the view is
	usable.
	
	
	Tracking the view scrolling
	---------------------------
	
	For extra flexibility while scrolling, we allow applications to track 
	any scrolling that is about to happen in the view, and possibly alter
	the actual scrolling to be done.  To utilize this, set "viewAttributes 
	= trackScrolling" in the view.  If this is set, the view by default
	will send a MSG_META_CONTENT_TRACK_SCROLLING to its content.  The 
	structure passed is as follows:
	
	TrackScrollingParams	struct
	TSP_action		ScrollAction	;action taking place.  Drags
						;don't require the return 
						;method; in fact, return methods
						;will be ignored for drags.
						
	TSP_flags		ScrollFlags     ;scroll flags
						
	TSP_caller		optr		;caller object, to return the
						;  arguments to
	TSP_change		PointDWord	;proposed change 
	TSP_newOrigin		PointDWord	;proposed new origin
	TSP_oldOrigin		PointDWord	;old origin
	TSP_viewWidth		sword		;view width
	TSP_viewHeight		sword		;view height
	TrackScrollingParams	ends
	
	There *must* be a handler for this method, and it must be set up as 
	follows, or the view won't scroll, or it will scroll erratically:
	
	An example of a handler that keeps scroll offsets to a multiple of
	8 (not a very desirable example, as it might cause increments to not
	scroll the view at all in certain situations and increment values.)
	
	MyTrackScrolling method my_ProcessClass, MSG_META_CONTENT_TRACK_SCROLLING
		call	GenSetupTrackingArgs		; fills in extra data
		mov	cx, ss:[bp].TSP_newOrigin.PD_y.low 
						; get suggested new absolute pos
		and	cx, not 7h		; keep as mulitple of 8
		sub	cx, ss:[bp].TSP_oldOrigin.PD_y.low	
						; make relative to old origin
		mov	ss:[bp].TSP_change.PD_y.low, cx	
						; store as the y scroll amount
		mov	cx, ss:[bp].TSP_newOrigin.PD_y.high
		sbb	cx, ss:[bp].TSP_oldOrigin.PD_y.high
		mov	ss:[bp].TSP_change.PD_y.high, cx 
						; store as the y scroll amount
		call	GenReturnTrackingArgs		; send result back.
		ret
	MyTrackScrolling endm
	
	GenSetupTrackingArgs fills in any information missing from the 
	TrackScrollingParams structure so that the information is truly 
	synchronous with the UI thread.  GenReturnTrackingArgs updates the
	values based on TSP_change, and sends a method back to the view, at
	which time the view finally scrolls.
	
	TSP_action tells you what the context of the scroll was, so the 
	application can do different things based on the context, including
	leaving the value alone (you still have to call GenReturnTrackingArgs,
	however.)
	
	Tracking scrolling across threads will likely cause a detectable
	slowdown of the scroll process.  If you are adjusting the scroll in a
	way that doesn't require information from your application, you can
	also just subclass the view's own MSG_META_CONTENT_TRACK_SCROLLING 
	handler, which just sends the method off to the content. Such a handler
	is written in the same way as the multi-thread version.
	
	
	Large Documents (greater than +/- 4096 pixels in size)
	------------------------------------------------------
	
	The standard GenView API supports 32-bit integer quantities in all
	methods involving document coordinates.  This allows applications to
	have document spaces up to 940 miles on a side, at 72 dots per inch.
	As not all aspects of PC/GEOS directly support 32-bit operations,
	however, special efforts must be made to achieve these results.

	If you wish to create a Large Document using visible trees, see
	Management/UserInterface/Documentation/LargeVisTree.

	If your view content is a process, then you will need to do the
	following:

	1) If your document bounds lie outside of the standard PC/GEOS 16-bit
	   graphics space (-4096 to +4096 in each direction), you will need to
	   use GrSetExtTranslation to be able to draw to areas of your document
	   other than the 16 bit space around (0,0).  What GrSetExtTranslation
	   does is allow you to set a 32 bit origin from which subsequent
	   drawing commands are based.  The entire 32-bit space could either be
	   tiled into smaller, graphics space sized chunks, or a new 32-bit
	   offset could be set before each drawing operation.  Either way, 
	   the entire 32-bit space can then be drawn to.  For example:

	   For instance, if you were keeping a PointDWord structure with the
	   left and top offsets to the area to draw, you could do the following:

                                                ;di holds gstate handle
                mov     cx, ds:myAreaOrigin.DP_left.low
                mov     dx, ds:myAreaOrigin.DP_left.high
                mov     ax, ds:myAreaOrigin.DP_top.low
                mov     bx, ds:myAreaOrigin.DP_top.high
                call    GrApplyTranslationDWord   ;set the drawing offset

           All subsequent drawing commands will be with respect to this drawing
           origin, i.e. If PointDWord held (20,000, 30,000), then calling
	   GrDrawRect(0, 0, 10, 10) would draw a rectangle 10 pixels wide at
	   the location (20,000, 30,000) on the document.

           By repeating the process for each area, you can draw a very large
           document.

	
	2) You will need to set the flag GVA_WINDOW_COORDINATE_MOUSE_EVENTS,
	   in the view, in order to get mouse data from which 32-bit document
	   positions can be obtained.  Your process will continue to receive
	   the following mouse methods, though the position data will be the
	   number of screen pixels that the mouse is at from the upper left
	   corner of the view window:

		MSG_META_PTR
		MSG_META_START_SELECT
		MSG_META_START_MOVE_COPY
		MSG_META_START_FEATURES
		MSG_META_START_OTHER
		MSG_META_DRAG_SELECT
		MSG_META_DRAG_MOVE_COPY
		MSG_META_DRAG_FEATURES
		MSG_META_DRAG_OTHER
		MSG_META_END_SELECT
		MSG_META_END_MOVE_COPY
		MSG_META_END_FEATURES
		MSG_META_END_OTHER

	   The following equation will yield the 32-bit location of the mouse:

	   Document location = (View Window Coordinate/Scale Factor)
								+ View Origin

		View Window Coordinate
				- coordinate value passed in 16-bit
				  mouse event when GVA_WINDOW_COORDINATE_MOUSE_
				  EVENTS is set in the GenView.

		Scale Factor	- current view scale factor, as sent to process
				  in MSG_META_CONTENT_VIEW_SCALE_FACTOR_CHANGED

		View Origin	- location in document that currently appears
				  at upper left corner of the view window, as
				  sent to process in MSG_META_CONTENT_VIEW_ORIGIN_
				  CHANGED.


	   Your process will be notified of the current Scale Factor via
	   MSG_META_CONTENT_VIEW_SCALE_FACTOR_CHANGED, and of the current document
	   origin offset by MSG_META_CONTENT_VIEW_ORIGIN_CHANGED.  The data
	   passed should be stored by your process so that it is available
	   for the above calculation when mouse methods come in.  The routine
	   GrSDivWWFixed may be used to perform the division, & yields the
	   added bonus of fractional mouse position in the case of a view
	   which has been scaled up.

	
	Setting the view color
	----------------------

	If the view is managing generic objects, or just displays textual 
	information, it is probably most appropriate for the view window
	to be drawn in the same color as the view's primary.  In this case
	set viewWinAttrs = sameColorAsParentWin.   The color will be selected
	for the view window automatically.

	Otherwise, if you want to set the view to a Color enumerated type
	(16 color EGA set), simply add this line to your view:

		color indexOrRed = C_LIGHT_BLUE;

	Likely you will want the view to show up as white on B/W monitors.
	To do this, set the color flags as follows:

		color flags =
		  "mask CMM_ON_BLACK or CMT_CLOSEST";

	If you want to set a particular RGB background color, do something 
	like the following:

		color flags = rgb;
		color indexOrRed = 360;   	/* Red RGB value   */
		color green = 0;	    	/* Green RGB value */
		color blue = 400;   		/* Blue RGB value  */

	In addition the view window usually has a frame around it.  Setting
	viewWinAttrs = noWinFrame will keep a frame from being included in the
	view.


	Scaling the view
	----------------
		
	You can specify an initial scale factor for the view by putting in
	something like

		scaleX = "0, 2";	/* Scale factor of 2.0 */
		scaleY = "0, 2";

	where the integer part of the WWFixed scale value is the second argument
	and the fractional part of the WWFixed scale value is first.

	You can change the scale factor on the fly by calling 
	MSG_GEN_VIEW_SET_SCALE_FACTOR;  you can choose the point to
	scale around  (i.e. which point stays fixed on the screen 
	as the view scales.  See that method header for more information.
	
	The output will receive normalize information is the view's scrolling
	is being normalized.

	As a result of a scale action, you may have an image in the view that
	you want to keep onscreen, or centered.  This can be done by calling
	MSG_GEN_VIEW_SUSPEND_UPDATE to keep the view from redrawing, scaling
	as desired, then using MSG_GEN_VIEW_MAKE_RECT_VISIBLE to get your
	image back onscreen.  Then a MSG_GEN_VIEW_UNSUSPEND_UPDATE will
	let the screen redraw again.
	

	Suspending screen redraws
	------------------------
	
	Sometimes you may want to do several actions at once on the view,
	such as scale and scroll, or whatever.  To avoid having distracting
	and unecessary intermediate updates of the view window, you can send
	a MSG_GEN_VIEW_SUSPEND_UPDATE before your actions and a MSG_GEN_
	VIEW_UNSUSPEND_UPDATE afterwards to get everything back up to date.
	
	
Hints that the view understands:   

	HINT_INITIAL_SIZE
		;A particular initial size is requested for this view, if
		;possible.   The size is applied to the view window area;
		;the view itself will be somewhat larger, depending on whether
		;there are frames and scrollers around the view or not.  The 
		;hint takes two arguments of type SpecSizeSpec, the desired 
		;width and the desired height.
		;
		;This initial size stuff only affects the size of the
		;view when the parent primary doesn't have an open size 
		;set for it (as the major apps usually do).  Otherwise
		;the view will grow or shrink to fit in the primary
		;area, regardless of any initial size set for it.
		;
		;
		;Example:
		;
		; MyView = GenView {
		;     hints = {
		;	  HINT_INITIAL_SIZE {
		;	   SpecSizeSpec <SST_PCT_OF_SCREEN_WIDTH,PCT__80>
		;	   SpecSizeSpec <SST_PCT_OF_SCREEN_HEIGHT,PCT__80>
		; 	  }
		;     }
		; }


	HINT_MINIMUM_SIZE
		;A particular minimum size is requested for this view, if
		;possible.   The size is applied to the view window area;
		;the view itself will be somewhat larger, depending on whether
		;there are frames and scrollers around the view or not.  The 
		;hint takes two arguments of type SpecSizeSpec, the desired 
		;width and the desired height.
		;
		;Example:
		;
		; MyView = GenView {
		;     hints = {
		;	  HINT_MINIMUM_SIZE {
		;	   SpecSizeSpec <SST_PIXELS, 100>
		;	   SpecSizeSpec <SST_PIXELS, 100>
		; 	  }
		;     }
		; }


	HINT_MAXIMUM_SIZE
		;A particular maximum size is requested for this view, if
		;possible.   The size is applied to the view window area;
		;the view itself will be somewhat larger, depending on whether
		;there are frames and scrollers around the view or not.  The 
		;hint takes two arguments of type SpecSizeSpec, the desired 
		;width and the desired height.  This is in addition to the
		;document size, which the view by default uses as a maximum 
		;size.  
		;
		;Example:
		;
		; MyView = GenView {
		;     hints = {
		;	  HINT_MAXIMUM_SIZE {
		;	   SpecSizeSpec <SST_PCT_OF_SCREEN_WIDTH,PCT__80>
		;	   SpecSizeSpec <SST_PCT_OF_SCREEN_HEIGHT,PCT__80>
		; 	  }
		;     }
		; }
		;

	HINT_FIXED_SIZE
		;A particular fixed size is requested for this view, if
		;possible.   The size is applied to the view window area;
		;the view itself will be somewhat larger, depending on whether
		;there are frames and scrollers around the view or not.  The 
		;hint takes two arguments of type SpecSizeSpec, the desired 
		;width and the desired height.
		;
		;Example:
		;
		; MyView = GenView {
		;     hints = {
		;	  HINT_FIXED_SIZE {
		;	   SpecSizeSpec <SST_PCT_OF_SCREEN_WIDTH,PCT__80>
		;	   SpecSizeSpec <SST_PCT_OF_SCREEN_HEIGHT,PCT__80>
		; 	  }
		;     }
		; }
		;
		;A fixed size if requested for this view window.  This 
		;effectively sets and minimum, maximum, and initial size
		;all at once.  

	HINT_PLACE_MONIKER_ABOVE
		;If a moniker is specified for the view, places the moniker
		;above the view.  (By default the moniker is placed to the
		;left of the view.)

	HINT_CENTER_MONIKER
		;With HINT_PLACE_MONIKER_ABOVE, places a moniker centered
		;above the view.

	HINT_DRAW_IN_BOX
		;Draws a box around the object.  Typically used with a moniker
		;when designing an easy-to-understand dialog box.

Generic hints having to do with the view:
	HINT_SEEK_Y_SCROLLER_AREA
		;Generic object will try to get itself placed next to  the 
		;horizontal scroller of its parent GenView.
	HINT_SEEK_X_SCROLLER_AREA
		;Generic object will try to get itself placed next to  the 
		;vertical scroller of its parent GenView.
	HINT_SEEK_LEFT_OF_VIEW
		;Generic object will try to get itself placed to the left of
		;its parent GenView.  
	HINT_SEEK_RIGHT_OF_VIEW
		;Generic object will try to get itself placed next to the right
		;of its parent GenView.  Note that this does not guarantee 
		;its placement with the vertical scroller, as the scroller
		;may be placed on either side by the specific UI.  To guarantee
		;placement with the vertical scroller, use HINT_SEEK_Y_SCROLLER
		;_AREA.
	HINT_SEEK_TOP_OF_VIEW
		;Generic object will try to get itself placed over its
		;parent GenView.  
	HINT_SEEK_BOTTOM_OF_VIEW
		;Generic object will try to get itself placed at the bottom
		;of its parent GenView.  Note that this does not guarantee 
		;its placement with the horizontal scroller, as the scroller
		;may be placed anywhere by the specific UI.  To guarantee
		;placement with the horizontal scroller, use HINT_SEEK_X_
		;SCROLLER_AREA.



	NOTE: The section between "Declaration" and "Methods declared" is
	      copied into uilib.def by "pmake def"

------------------------------------------------------------------------------@
