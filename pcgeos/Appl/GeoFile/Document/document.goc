/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) GeoWorks 1992 -- All Rights Reserved

PROJECT:        PC/GEOS
MODULE:         GeoFile/Document
FILE:           document.goc

AUTHOR:         John D. Mitchell

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	JDM     92.05.20        Initial version.

DESCRIPTION:
	This file contains UI and code for the GeoFileDocumentClass.

	$Id: document.goc,v 1.1 97/04/04 15:53:50 newdeal Exp $


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Include Files
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@include <stdapp.goh>           /* PC/GEOS Standard Applications.       */
#include <geoworks.h>

#include <Ansi/string.h>        /* Standard C.  */

@include <gcnlist.goh>          /* PC/GEOS Libraries.   */
@include <grobj.goh>
@include <ffile.goh>
@include <math.goh>
@include <Objects/FlatFile/ffDbaseC.goh>
#include <Objects/FlatFile/ffExBld.h>
@include <Objects/FlatFile/ffFldPr.goh>
@include <Objects/FlatFile/ffFldPrC.goh>
#include <graphics.h>
@include <Objects/gDocC.goh>
@include <Objects/gViewCC.goh>
@include <ssheet.goh>

@define __GF_DOCUMENT_GOC       /* Don't over-define.   */
@include <geofile.goh>          /* GeoFile Application. */
@include <gfButton.goh>


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Forward Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

word GetGrObjAMMap (FileHandle docFileHandle);
void SetDesignOptions(LayoutType layoutType);
word GetSpreadsheetMap(word docFileHandle);
VMBlockHandle GetFlatFileVMBlock(word docFileHandle);
void GFResetPrintControllerSizes(optr ffile);


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		GeoFileDocumentClass Declaration
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@classdecl      GeoFileDocumentClass;


/*************************************************************************
	External Message Declarations for FlatFileDatabaseClass
 *************************************************************************/

/*
 * The following are defined in documentPrint.goc
@extern  method GeoFileDocumentClass, MSG_GFD_APPLY_RECORD_SIZE;
 */

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		GeoFileDocControlClass Declaration
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@classdecl GeoFileDocControlClass ;


/***********************************************************************
 *
 * MESSAGE:     MSG_GEN_DOCUMENT_INITIALIZE_DOCUMENT_FILE 
 *
 * DESCRIPTION: Initialize new database document file.
 *              Set up map block for GeoFile, containing map blocks
 *              for both the spreadsheet data and the GrObj body.
 *
 * PARAMETERS:
 *              Boolean (void)
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      anna    1/92            Initial Revision
 *      anna    4/29/92         Added code for GrObj inclusion
 *      AMS     9/8/92          Removed VMA_PRESERVE_HANDLES
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_GEN_DOCUMENT_INITIALIZE_DOCUMENT_FILE
{
    VMBlockHandle       ffSpreadsheetHeaderVMBlock, ffGrObjBodyVMBlock, 
			ffGrObjAMVMBlock, ffFlatFileVMBlock,
			floatControllerVMBlock;
    DBGroupAndItem      ffDBGroupAndItem;
    GeoFileMapBlock     *mapSegmentAndItem;
    MemHandle           grObjBodyBlock, grObjAttrManagerBlock, 
			flatfileBlock, multiRecordGrObjBody;
    FileHandle          documentFileHandle;
    ChunkHandle         ffGrObjAMChunk;
    optr                ffGrObjAMOptr, ffGrObjBodyOptr;
    byte                layoutNum;
    GeodeHandle         processHandle;

    @callsuper();
    pself = ObjDerefGen(oself);
    documentFileHandle = pself->GDI_fileHandle;

    /* here, check ruler options & draw flags */

    /*
     * FlatFileInitFile sets up the necessary things for the flatfile object
     */
    ffSpreadsheetHeaderVMBlock = FlatFileInitFile(documentFileHandle, 0);

    /*
     * Get the chunk offset of the ffGrObjAM in the block we are going to
     * duplicate. This allows us to construct an optr to the ffGrObjAM in
     * the duplicated block
     */

    ffGrObjAMChunk = OptrToChunk(@ffGrObjAM);

    /*
     * Duplicate blocks with GrObjBody and GrObjAttributeManager
     * in it, and have its burden thread be our process thread.
     * Then attach block to the VM file. The handles must be preserved,
     * otherwise the block may get discarded and loaded back in
     * with a different memory handle causing random obscure death
     * when we attempt to send messages to that object.
     */

    grObjBodyBlock = ObjDuplicateResource(OptrToHandle(@ffGrObjBody), 0, 0);
    grObjAttrManagerBlock = ObjDuplicateResource(OptrToHandle(@ffGrObjAM), 
								0, 0);
    /*
     * Duplicate template for flatfile object
     */
    flatfileBlock = ObjDuplicateResource(OptrToHandle(@TemplateFlatFile), 
					    GeodeGetProcessHandle(), 0);        

    /*
     * Read in the various arrays
     */
    @call flatfileBlock, (ChunkHandle) @TemplateFlatFile::    
				MSG_SPREADSHEET_READ_CACHED_DATA(
					documentFileHandle,
					ffSpreadsheetHeaderVMBlock);
    /*
     * Create new VM blocks for Body, Manager, and flatfile
     */

    ffGrObjBodyVMBlock = VMAttach(documentFileHandle, 0, grObjBodyBlock);

    VMPreserveBlocksHandle(documentFileHandle, ffGrObjBodyVMBlock);

    ffGrObjAMVMBlock = VMAttach(documentFileHandle, 0, grObjAttrManagerBlock);

    VMPreserveBlocksHandle(documentFileHandle, ffGrObjAMVMBlock);

    ffFlatFileVMBlock = VMAttach(documentFileHandle, 0, flatfileBlock);

    VMPreserveBlocksHandle(documentFileHandle, ffFlatFileVMBlock);

    /*
     * Attach the GrObjBody to the Attribute Manager's list
     */

    ffGrObjBodyOptr = ConstructOptr(grObjBodyBlock, OptrToChunk(@ffGrObjBody));

    ffGrObjAMOptr = ConstructOptr(grObjAttrManagerBlock, ffGrObjAMChunk);

    @call ffGrObjBodyOptr::MSG_GB_ATTACH_GOAM(ffGrObjAMOptr);

    /*
     * Have attribute manager create all the attribute and style 
     * arrays that it needs to use.
     */
    @call ffGrObjAMOptr::MSG_GOAM_CREATE_ALL_ARRAYS();

    /* set map block */
    /* allocate a map item */
    ffDBGroupAndItem = DBAllocUngrouped(documentFileHandle,
					sizeof(GeoFileMapBlock));
    /* 
     * Make it the map item 
     */
    DBSetMapUngrouped(documentFileHandle, ffDBGroupAndItem); 

    /* lock it */
    mapSegmentAndItem = DBLockMap(documentFileHandle);

    /* set the various maps */
    mapSegmentAndItem->GFMB_spreadsheetMap = ffSpreadsheetHeaderVMBlock;
    mapSegmentAndItem->GFMB_flatfileMap = ffFlatFileVMBlock;
    mapSegmentAndItem->GFMB_grobjAMMap = ffGrObjAMVMBlock;

    DBDirty(mapSegmentAndItem); 

    DBUnlock(mapSegmentAndItem);

    /* Tell the file that it may be storing objects */
    VMSetAttributes(documentFileHandle, 
		    (VMA_OBJECT_RELOC | VMA_SYNC_UPDATE |
		     VMA_NO_DISCARD_IF_IN_USE | VMA_NOTIFY_DIRTY),
		    0);

    pself = ObjDerefGen(oself);
    pself->GFDI_spreadsheet = flatfileBlock;

    /*
     * Create a layout
     */
    processHandle = GeodeGetProcessHandle();

    /*
     * At this point, the document does not have the model exclusive
     * yet, which means a context has not been set for undo stuff.
     * As part of initializing a record layout, we create a GrObject
     * for the record layout boundary. GrObjBodyInstantiateGrObj
     * wants to log this process in the undo chain, but there
     * is no context yet. So... the solution is to ignore actions
     * as far as undo is concerned for now (the user shouldn't
     * be able to "undo" the creation of the record layout boundary
     * anyway). When we're done, we'll start accepting undo
     * actions again
     */

    @call HandleToOptr(processHandle)::
				MSG_GEN_PROCESS_UNDO_IGNORE_ACTIONS(TRUE);

    /*
     * Create a block for the float format controller and keep the
     * block in instance data for later use.
     */
    floatControllerVMBlock = FloatFormatInit(documentFileHandle);

    /*
     * Tell the spreadsheet CellParam structure and flatfile
     * what our document handle is; tell the flatfile what the
     * Attribute Manager optr is
     */
    @call flatfileBlock, (ChunkHandle) @TemplateFlatFile::
		MSG_FFD_INIT_CELL_PARAMS(documentFileHandle,
					 floatControllerVMBlock);

    @call flatfileBlock, (ChunkHandle) @TemplateFlatFile::
		MSG_FFD_SET_DOCUMENT_HANDLE(documentFileHandle);

    @call flatfileBlock, (ChunkHandle) @TemplateFlatFile::
		MSG_FFD_SET_GROBJ_AM(ffGrObjAMOptr);
    /*
     * Initialize the structure needed for single-record layouts
     */
    layoutNum = @call flatfileBlock, (ChunkHandle) @TemplateFlatFile::
	    MSG_FFD_INIT_SINGLE_RECORD_LAYOUT(-1, ffGrObjBodyVMBlock,
					      OptrToChunk(@ffGrObjBody),
					      ffGrObjBodyOptr,
					      LT_SINGLE_RECORD);

    /*
     * Attach the grObjBody as a vis-child of the flatfile object
     */
    @call flatfileBlock, (ChunkHandle) @TemplateFlatFile::
		MSG_VIS_ADD_CHILD(ffGrObjBodyOptr, CCF_MARK_DIRTY);

    /*
     * Initialize the multi-record layout
     */
    multiRecordGrObjBody =
		ObjDuplicateResource(OptrToHandle(@ffGrObjBody), 0, 0);

    @call flatfileBlock, (ChunkHandle) @TemplateFlatFile::
	    MSG_FFD_INIT_MULTI_RECORD_LAYOUT(layoutNum, 
					     multiRecordGrObjBody,
					     OptrToChunk(@ffGrObjBody),
					     GeodeGetOptrNS(@ffGrObjHead));
	
    @call HandleToOptr(processHandle)::
				MSG_GEN_PROCESS_UNDO_ACCEPT_ACTIONS();

    return(FALSE);              /* Return no error */
}


/***********************************************************************
 *
 * FUNCTION:    GFDSetVisAttributes 
 *
 * DESCRIPTION: Set the vis instance data
 *
 * PARAMETERS:
 *              oself - optr to document 
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      anna    1/92            Initial Revision
 *      anna    2/93            Broke out into routine; called from 
 *                              ATTACH_UI now
 *
 ***********************************************************************/
void GFDSetVisAttributes(optr oself)
{
    VisContentInstance *vis;

    /* 
     * To access the vis instance data we need to dereference 
     * the OD of the DGDocument
     */

    vis = ObjDerefVis(oself);

    /* 
     * Set bits for large document model. Clear bits for unmanaged
     * geometry. 
     */

    vis->VCNI_attrs |= (VCNA_LARGE_DOCUMENT_MODEL | 
			VCNA_WINDOW_COORDINATE_MOUSE_EVENTS);

    vis->VI_attrs &= ~VA_MANAGED;

    vis->VI_optFlags &= ~(VOF_GEOMETRY_INVALID | VOF_GEO_UPDATE_PATH);

    vis->VCI_geoAttrs |= VCGA_CUSTOM_MANAGE_CHILDREN;
}

/***********************************************************************
 *
 * MESSAGE:     MSG_GEN_DOCUMENT_CREATE_UI_FOR_DOCUMENT 
 *
 * DESCRIPTION: Create associated UI for new database document  
 *
 * PARAMETERS:
 *              none 
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      anna    1/92            Initial Revision
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_GEN_DOCUMENT_CREATE_UI_FOR_DOCUMENT
{
    @callsuper();

    ObjInitializePart(oself, word_offsetof(VisBase, Vis_offset));
}

/***********************************************************************
 *
 * FUNCTION:    GFDSetUIForDocument 
 *
 * DESCRIPTION: Sets up the UI (menus, field organizer, controllers)         
 *              for the current mode & layout type of the flatfile object
 *
 * PARAMETERS:  optr currentDatabase, 
 *              GeoFileLevelsFeatures   selection,
 *              UIInterfaceLevel    closestLevel)
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      anna    10/16/92        Initial Revision
 *      anna    10/19/92        Added UI for layout type
 *      JDM     92.11.23        Modified to support table driven changes.
 *
 ***********************************************************************/
void GFDSetUIForDocument(optr currentDatabase, 
				GeoFileLevelsFeatures selection,
				UIInterfaceLevel closestLevel)
{
    optr        appObject; 
    ModeType    curMode, oldMode;
    word        currentLayout;
    LayoutType  layoutType, oldLayoutType;

    /* Give the user some feedback.     */
    appObject = GeodeGetAppObject (0);
    @call appObject::MSG_GEN_APPLICATION_MARK_BUSY ();
    @call appObject::MSG_GEN_APPLICATION_HOLD_UP_INPUT ();

    /* Get the current application mode.        */
    oldMode = @call currentDatabase::MSG_FFD_GET_CURRENT_MODE();
    curMode = oldMode;

    currentLayout = @call currentDatabase::MSG_FFD_GET_CURRENT_LAYOUT();
    layoutType = @call currentDatabase::MSG_FFD_GET_LAYOUT_TYPE(
						currentLayout, TRUE);
    oldLayoutType = layoutType;

    /* Set the application's UI to the appropriate state.       */
    @call process::MSG_GF_SET_UI (&curMode,
				  GeodeGetOptrNS (@ModeList),
				  GeodeGetOptrNS (@DesignOptionsList),
				  &layoutType,
				  selection,
				  closestLevel);

    /* Set the database to the current mode. */
    if (curMode == MT_DATA_ENTRY) {
	@call currentDatabase::MSG_FFD_SET_CURRENT_MODE_TO_DATA_ENTRY();
    } else {
	/* It's design mode.    */
	@call currentDatabase::MSG_FFD_SET_CURRENT_MODE_TO_DESIGN();
    }

    /* Switch to the appropriate layout type and reset the UI objects.  */
    (void) @call currentDatabase::MSG_FFD_SWITCH_TO_LAYOUT
	(currentLayout,
	 GeodeGetOptrNS(@ffGrObjHead),
	 layoutType,
	 FALSE);

    /*
     * Update the page size controller sizes.
     */
    GFResetPrintControllerSizes(currentDatabase);

    /*
     * Set up UI for layout type
     */
    @call GeodeGetOptrNS(@DesignOptionsList)::
		MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(layoutType, 
							FALSE);

    /* Finis.   */
    @call appObject::MSG_GEN_APPLICATION_MARK_NOT_BUSY ();
    @call appObject::MSG_GEN_APPLICATION_RESUME_INPUT();
}

/***********************************************************************
 *
 * MESSAGE:     MSG_GEN_DOCUMENT_ATTACH_UI_TO_DOCUMENT 
 *
 * DESCRIPTION: Attach UI for new or existing database document         
 *
 * PARAMETERS:
 *              none 
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      anna    1/92            Initial Revision
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_GEN_DOCUMENT_ATTACH_UI_TO_DOCUMENT
{
    MemHandle   newBlockHandle, memBlock; 
    FileHandle  ourFile;
    optr        docTemplateOptr;
    optr        grObjBody, grObjBody2, grObjAMOptr, databaseOptr;
    VMBlockHandle ffGrObjAMHandle, flatFileVMBlock;
    GeodeHandle processHandle;

    GFDSetVisAttributes(oself);

    @callsuper();
    pself = ObjDerefGen(oself);

    flatFileVMBlock = GetFlatFileVMBlock(pself->GDI_fileHandle);

    pself->GFDI_spreadsheet = VMVMBlockToMemBlock(pself->GDI_fileHandle, 
						  flatFileVMBlock);

    ourFile = pself->GDI_fileHandle;

    /* 
     * Prepare a block with the necessary setup data 
     */
    newBlockHandle = MemAlloc(sizeof(SpreadsheetSetupData), 
			      HF_SWAPABLE,
			      HAF_NO_ERR | HAF_LOCK | HAF_ZERO_INIT);

    /* 
     * Do we need to set up the style stuff here? 
     */
    MemUnlock(newBlockHandle);

    docTemplateOptr = ConstructOptr(pself->GFDI_spreadsheet, @TemplateFlatFile);
    @call docTemplateOptr::MSG_FFD_ATTACH_UI(newBlockHandle, ourFile);

    /* 
     * Add the flat file as the document's child 
     */
    @call oself::MSG_VIS_ADD_NON_DISCARDABLE_VM_CHILD(docTemplateOptr, 0);

    /*
     * Add the document's file handle to the flatfile object's instance data
     * We need it there so it can get the GrObjBody & GrObject optrs later.
     */
    @send docTemplateOptr::MSG_FFD_SET_DOCUMENT_HANDLE(ourFile);

    /*
     * Attach the grobj head to the grobj body
     */
    grObjBody = @call docTemplateOptr::
			MSG_FFD_GET_GROBJ_BODIES_FOR_CURRENT_LAYOUT(
						&grObjBody2);

    @call grObjBody::MSG_GB_ATTACH_UI(GeodeGetOptrNS(@ffGrObjHead));

    if (grObjBody2) {
	@call grObjBody2::MSG_GB_ATTACH_UI(GeodeGetOptrNS(@ffGrObjHead));
    }

    @call grObjBody::MSG_META_GRAB_TARGET_EXCL();

    /*
     * Tell the flatfile object where the GrObjAttributeManager is  
     */
    ffGrObjAMHandle = GetGrObjAMMap(ourFile);

    /* 
     * Convert the VM block to a memory block so that we can
     * access the objects within the block
     */
    memBlock = VMVMBlockToMemBlock(ourFile, ffGrObjAMHandle);

    grObjAMOptr = ConstructOptr(memBlock, OptrToChunk(@ffGrObjAM));

    @call docTemplateOptr::MSG_FFD_SET_GROBJ_AM(grObjAMOptr);
      
    /* sends a message to flat file library */

    pself = ObjDerefGen(oself);
    databaseOptr = ConstructOptr(pself->GFDI_spreadsheet, 
				(ChunkHandle) @TemplateFlatFile);
    @call databaseOptr::MSG_FFD_NOTIFY_MAP_CONTROL(); 

    /*
     * Set the layout name in the Treasure Chest & RCP
     */
    processHandle = GeodeGetProcessHandle();
    @call HandleToOptr(processHandle)::
		MSG_GF_SET_TREASURE_CHEST_VIS_MONIKER(databaseOptr);
    @call HandleToOptr(processHandle)::
			MSG_GF_SET_RECORD_CONTROL_PANEL_VIS_MONIKER(
			databaseOptr);
}

/***********************************************************************
 *
 * MESSAGE:     MSG_META_CONTENT_VIEW_WIN_OPENED for GeoFileDocumentClass
 *
 * DESCRIPTION: This message sets the document size for single record mode.
 *
 * PARAMETERS:
 *      void (word viewWidth, word viewHeight,  WindowHandle viewWindow)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  8/27/92         Initial version
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_META_CONTENT_VIEW_WIN_OPENED
{
    LayoutSize bounds;
    optr view, grobjBody;
    optr ffile;
    PageSizeReport pageBounds;

    view = pself->GCI_genView;
    ffile = ConstructOptr(pself->GFDI_spreadsheet,
			  (ChunkHandle) @TemplateFlatFile);
    @callsuper();

    (void) @call ffile::MSG_FFD_GET_GROBJ_BODIES_FOR_CURRENT_LAYOUT(&grobjBody);
	
    /*
     * Get the bounds for whichever mode we're currently in.
     */
    switch (@call ffile::MSG_FFD_GET_LAYOUT_TYPE(0, TRUE)) {
	case LT_SINGLE_RECORD:
	    @call ffile::MSG_FFD_GET_SINGLE_RECORD_BOUNDS(&bounds);
	    break;

	case LT_MULTI_RECORD:
	    @call ffile::MSG_FFD_GET_PAGE_BOUNDS(&pageBounds);
	    bounds.LS_height = pageBounds.PSR_height;
	    bounds.LS_width = pageBounds.PSR_width;
	    break;
    }

    /*
     * Set the size of the document correctly.
     */
    @call view::MSG_GEN_VIEW_SET_DOC_BOUNDS(bounds.LS_height,
					    bounds.LS_width,
					    0, 0);
    /*
     * Set the size of the GrObj body.
     */
    @call grobjBody::
	MSG_META_CONTENT_VIEW_WIN_OPENED(viewWidth, viewHeight, viewWindow);
}

/***********************************************************************
 *
 * MESSAGE:     MSG_META_GAINED_TARGET_EXCL for GeoFileDocumentClass
 *
 * DESCRIPTION: Received when the document gets the target.  Here, we
 *              set the current page and record size controllers to be
 *              up-to-date.  We also deal with the various controllers
 *              that need to be updated.
 *
 * PARAMETERS:
 *      void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  9/ 3/92         Initial version
 *      jeremy  11/25/92        Added float controller shme
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_META_GAINED_TARGET_EXCL
{
    LayoutSize srBounds;
    PageSizeReport pageSizeReport;
    MemHandle floatFormatDataBlock;
    EventHandle msg;
    optr database;

    @callsuper();

    pself = ObjDerefGen(oself);
    database = ConstructOptr(pself->GFDI_spreadsheet,
			     (ChunkHandle) @TemplateFlatFile);

    /*
     * Call the flat file object for the correct document size, which
     * depends on whether we're in single- or multi-record mode.
     */
    @call database::MSG_FFD_GET_SINGLE_RECORD_BOUNDS(&srBounds);

    @call database::MSG_FFD_GET_PAGE_BOUNDS(&pageSizeReport);

    /*
     * Set the single record size in the record size dialog box.
     */
    @call GeodeGetOptrNS(@GFRecordWidth)::
	MSG_GEN_VALUE_SET_VALUE(MakeWWFixed(srBounds.LS_width), FALSE);
    @call GeodeGetOptrNS(@GFRecordHeight)::
	MSG_GEN_VALUE_SET_VALUE(MakeWWFixed(srBounds.LS_height), FALSE);

    /*
     * Set the PageSizeController with the new page bounds.
     */
    SpoolSetDocSize(TRUE, &pageSizeReport);

    /*
     * Notify the float controller of our existence.
     */
    floatFormatDataBlock =
	MemAlloc(sizeof(NotifyFloatFormatChange),
		 HF_DYNAMIC | HF_SHARABLE, HAF_STANDARD | HAF_ZERO_INIT);
    if (!floatFormatDataBlock) {
	/* No more memory!  Oh nooooo.... */
	return;
    }

    @call database::MSG_FFD_LOAD_FLOAT_FORMAT_BLOCK(floatFormatDataBlock,
						    FORMAT_ID_GENERAL);

    /*
     * The doc file handle and VM block has been filled out.  Send
     * the notification!
     */
    MemInitRefCount(floatFormatDataBlock, (word) 1);
    
    msg = @record (optr) NullClass::MSG_META_NOTIFY_WITH_DATA_BLOCK(
		      MANUFACTURER_ID_GEOWORKS, /* Manufacturer's ID */
		      GWNT_FLOAT_FORMAT_INIT, /* Manufacturer's list type*/
		      floatFormatDataBlock);    /* Handle of data block */

    @call GeodeGetAppObject(0)::MSG_META_GCN_LIST_SEND(
		      (word) GCNLSF_SET_STATUS,
					      /* GCNListSendFlags */
		      (EventHandle) msg,      /* Handle to classed event */
		      (MemHandle) floatFormatDataBlock,
					      /* Handle of extra data block */
		      (word) GAGCNLT_FLOAT_FORMAT_INIT,
					      /* Manufacturer's list type */
		      (word) MANUFACTURER_ID_GEOWORKS);
					      /* Manufacturer's ID */
}

@if 0
/***********************************************************************
 *
 * MESSAGE:     MSG_META_GAINED_MODEL_EXCL for GeoFileDocumentClass
 *
 * DESCRIPTION: We intercept this to tell our fields and gadgetry to
 *              be in the correct mode.
 *
 * PARAMETERS:
 *      void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *              We need to set the menus for the right mode.
 *              Right now we just assume that we're in design mode.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  6/30/92         Initial version
 *      anna    10/16/92        Set menus for the right mode
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_META_GAINED_MODEL_EXCL
{
    ModeType currentMode;
    optr currentDatabase;

    @callsuper();

    pself = ObjDerefGen(oself);

    /*
     * Get the current mode
     */
    currentMode = @call pself->GFDI_spreadsheet, 
		(ChunkHandle) @TemplateFlatFile::MSG_FFD_GET_CURRENT_MODE();

    /* @send pself->GFDI_spreadsheet, (ChunkHandle) @TemplateFlatFile::
	MSG_FFD_SET_CURRENT_MODE_TO_DESIGN();*/
}
@endif

/***********************************************************************
 *
 * MESSAGE:     MSG_GFD_SET_UI_FOR_DOCUMENT for GeoFileDocumentClass
 *
 * DESCRIPTION: We intercept this to tell our fields and gadgetry to
 *              be in the correct mode.
 *
 * PARAMETERS:
 *      void (GeoFileLevelsFeatures   selection,
 *              UIInterfaceLevel    closestLevel)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      anna    12/1/92         Initial version
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_GFD_SET_UI_FOR_DOCUMENT
{
    optr databaseObject;

    databaseObject = ConstructOptr(pself->GFDI_spreadsheet, 
					(ChunkHandle) @TemplateFlatFile);

    GFDSetUIForDocument(databaseObject, selection, closestLevel);
}

/***********************************************************************
 *
 * MESSAGE:     MSG_GEN_DOCUMENT_DETACH_UI_FROM_DOCUMENT 
 *
 * DESCRIPTION: Close document by sending message to body          
 *
 * PARAMETERS:
 *              none 
 *
 * STRATEGY:    Inform the GrObjBody associated with the document
 *              that it should detach from the UI.
 *              Then remove the "spreadsheet" (flatfile) and
 *              GrObjBody from the visual tree.
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      anna    1/92            Initial Revision
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_GEN_DOCUMENT_DETACH_UI_FROM_DOCUMENT
{
    optr grobjBody, grobjBody2, databaseOptr;
    MemHandle spreadsheetBlock;

    spreadsheetBlock = pself->GFDI_spreadsheet;

    databaseOptr = ConstructOptr(spreadsheetBlock, 
				(ChunkHandle) @TemplateFlatFile);
    /*
     * Tell the flat file to commit its current record (if appropriate).
     * If there are bogus data in the fields, they will be thrown away ptui.
     */
    @call databaseOptr::
	MSG_FFD_COMMIT_TEMP_DATA_ROW_TO_DATABASE(FALSE, CRT_SAVE_FILE_COMMIT);
    
    /* sends a message to flat file library */
    /*
     * (What does this message do?  Nobody seems to know...)
     */
    @call databaseOptr::MSG_FFD_FLUSH_MAP_CONTROL(); 

    /*
     * Tell the RCP/Treasure Chest to go away.
     */
    @call GeodeGetOptrNS(@RCPController)::
	MSG_GEN_INTERACTION_ACTIVATE_COMMAND(IC_DISMISS);
    @call GeodeGetOptrNS(@TreasureChest)::
	MSG_GEN_INTERACTION_ACTIVATE_COMMAND(IC_DISMISS);

    /*
     * Get the OD of the current from the map block
     */
    grobjBody = @call spreadsheetBlock, (ChunkHandle) @TemplateFlatFile::
		MSG_FFD_GET_GROBJ_BODIES_FOR_CURRENT_LAYOUT(&grobjBody2);

    /*
     * Notify the GrObjBody that is it about to be removed from
     * the Document/Content and closed.
     */
    @send grobjBody::MSG_GB_DETACH_UI();

    /*
     * If we're in data entry & multi-record mode, we might have 2 grobj
     * bodies attached 
     */
    if (grobjBody2) {
	@send grobjBody2::MSG_GB_DETACH_UI();
    }

    /*
     * Remove the flatfile object from the visual tree
     */
    @send spreadsheetBlock, (ChunkHandle) @TemplateFlatFile::
	MSG_VIS_REMOVE_NON_DISCARDABLE(VUM_MANUAL); 

    @callsuper();
}

/***********************************************************************
*
* FUNCTION:    GetSpreadsheetMap
*
* DESCRIPTION: This procedure finds and returns the handle to the 
*               spreadsheet map block.
*
* CALLED BY:   several message handlers
*
* STRATEGY:
*
* KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
*
* REVISION HISTORY:
*      Name    Date            Description
*      ----    ----            -----------
*      anna    1/92            Initial Revision
*
***********************************************************************/

word GetSpreadsheetMap(word docFileHandle) 
{
    GeoFileMapBlock     *mapSegmentAndItem;
    word                ssMapBlock;

    /* 
     * Lock the map item and get the spreadsheet map handle 
     */
    mapSegmentAndItem = DBLockMap(docFileHandle);

    ssMapBlock = mapSegmentAndItem->GFMB_spreadsheetMap;

    DBUnlock(mapSegmentAndItem);

    return(ssMapBlock);
}

/***********************************************************************
*
* FUNCTION:    GetFlatFileVMBlock
*
* DESCRIPTION: This procedure finds and returns the handle to the 
*               flatfile VM block.
*
* CALLED BY:   several message handlers
*
* STRATEGY:
*
* KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
*
* REVISION HISTORY:
*      Name    Date            Description
*      ----    ----            -----------
*      anna    10/2/92            Initial Revision
*
***********************************************************************/

VMBlockHandle GetFlatFileVMBlock(word docFileHandle) 
{
    GeoFileMapBlock     *mapSegmentAndItem;
    VMBlockHandle       ffVMBlock;

    /* 
     * Lock the map item and get the spreadsheet map handle 
     */
    mapSegmentAndItem = DBLockMap(docFileHandle);

    ffVMBlock = mapSegmentAndItem->GFMB_flatfileMap;

    DBUnlock(mapSegmentAndItem);

    return(ffVMBlock);
}

/***********************************************************************
*
* FUNCTION:    GetGrObjAMMap
*
* DESCRIPTION: Return the handle to the GrObjAM map block. 
*
* CALLED BY:   several message handlers
*
* STRATEGY:
*
* KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
*
* REVISION HISTORY:
*      Name    Date            Description
*      ----    ----            -----------
*      anna    7/1/92         Initial Revision
*
***********************************************************************/
word GetGrObjAMMap(FileHandle docFileHandle) 
{
    GeoFileMapBlock *mapSegmentAndItem;
    VMBlockHandle ffGrObjAMBlock;

    /*
     * Get the map block and lock it 
     */
    mapSegmentAndItem = DBLockMap(docFileHandle); 

    /*
     * Get the VM block handle for the GrObj body
     */
    ffGrObjAMBlock = mapSegmentAndItem->GFMB_grobjAMMap;

    /*
     * Unlock the map block
     */
    DBUnlock(mapSegmentAndItem);
    
    return(ffGrObjAMBlock);
}

/***********************************************************************
 *
 * MESSAGE:     MSG_GEN_DOCUMENT_READ_CACHED_DATA_FROM_FILE 
 *
 * DESCRIPTION: Intercept this here; otherwise it is handled by the
 *              spreadsheet library. The spreadsheet library assumes that
 *              we are not storing the spreadsheet object in the file;
 *              it instead keeps the important instance data in a mapblock.
 *              The spreadsheet library will read that instance data when
 *              it intercepts this message. However, since we store the
 *              object, we don't want to bother with that.
 *              Therefore, just intercept this message and do nothing.
 *
 * PARAMETERS:
 *              none 
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      anna    1/92            Initial Revision
 *      anna    6/15/92         Added flatfile stuff
 *      anna    9/30/92         Spreadsheet object now stored in file;
 *                              have this routine do nothing.
 *      ted     10/29/92        sends a message to flat file library
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_GEN_DOCUMENT_READ_CACHED_DATA_FROM_FILE
{
}

/***********************************************************************
 *
 * MESSAGE:     MSG_GEN_DOCUMENT_WRITE_CACHED_DATA_TO_FILE 
 *
 * DESCRIPTION: Intercept this here; otherwise it is handled by the
 *              spreadsheet library. The spreadsheet library assumes that
 *              we are not storing the spreadsheet object in the file;
 *              it instead keeps the important instance data in a mapblock.
 *              The spreadsheet library will write out that instance data when
 *              it intercepts this message. However, since we store the
 *              object, we don't want to bother with that.
 *              Therefore, just intercept this message and do nothing.
 *
 *              Hah!  Lies!  All lies!  We take this moment to commit
 *              the current record to the database.
 *
 * PARAMETERS:
 *              none 
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      anna    1/92            Initial Revision
 *      anna    9/30/92         Spreadsheet object now stored in file;
 *                              have this routine do nothing.
 *      jeremy  3/3/93          Save off the current record.
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_GEN_DOCUMENT_WRITE_CACHED_DATA_TO_FILE
{
    if (pself->GDI_operation != GDO_AUTO_SAVE) {
	/*
	 * Tell the flat file to commit its current record (if appropriate).
	 * If there are bogus data in the fields, they will be thrown away ptui.
	 */
	@call ConstructOptr(pself->GFDI_spreadsheet,
			    (ChunkHandle) @TemplateFlatFile)::
				MSG_FFD_COMMIT_TEMP_DATA_ROW_TO_DATABASE(FALSE,
							  CRT_SAVE_FILE_COMMIT);
    }
}

/***********************************************************************
 *
 * MESSAGE:     MSG_GEN_DOCUMENT_SAVE_AS_COMPLETED 
 *
 * DESCRIPTION: Handle end of "save as": file handle changes          
 *
 * PARAMETERS:
 *              none 
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      anna    1/92            Initial Revision
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_GEN_DOCUMENT_SAVE_AS_COMPLETED
{
    word        ssMapBlock;
    FileHandle  fileHandle;
    MemHandle   spreadsheetBlock;
    /*
     * The following optr thing is put in here because of a MetaWare
     * bug; without it, trying to compile results in a "System Error 1"
     * with no other information.
     * So even though it looks redundant, leave it in or suffer the
     * consequences... anna 3/20/92
     */
    optr                dorf;

    fileHandle = pself->GDI_fileHandle;
    spreadsheetBlock = pself->GFDI_spreadsheet;

    ssMapBlock = GetSpreadsheetMap(fileHandle);

    dorf = ConstructOptr(spreadsheetBlock, (ChunkHandle) @TemplateFlatFile);

    @call dorf::MSG_FFD_ATTACH_FILE(ssMapBlock, fileHandle);

    /* 
     * We have a new file handle
     */
    @send spreadsheetBlock, (ChunkHandle) @TemplateFlatFile::
		MSG_FFD_SET_DOCUMENT_HANDLE(fileHandle);

}

/***********************************************************************
 *
 * MESSAGE:     MSG_GEN_DOCUMENT_NEW 
 *
 * DESCRIPTION: Put up the Treasure Chest and Field Properties box.           
 *              Mark the application busy, and hold
 *              up input, because it takes a while to put up the
 *              various controllers.
 *
 * PARAMETERS:
 *      Boolean MSG_GEN_DOCUMENT_NEW(
 *                       word *fileOrError = multipleax,
 *                       DocumentCommonParams *params = ss:bp) = carry;
 *
 * STRATEGY:
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      anna    6/8/92          Initial Revision
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_GEN_DOCUMENT_NEW
{
    Boolean newDocumentError;
    optr appObject;

    newDocumentError = @callsuper();

    /*
     * If we failed to create an empty document, exit here
     */
    if (newDocumentError) {
	return(newDocumentError);
    }
    
    appObject = GeodeGetAppObject(0);

    @call appObject::MSG_GEN_APPLICATION_MARK_BUSY();
    @call appObject::MSG_GEN_APPLICATION_IGNORE_INPUT();

    /*
     * Set the field properties' "count of Mark Busy"; the application
     * has been marked busy if this is a new document (then the user
     * has to wait for the various controllers to be displayed)
     */
    @call GeodeGetOptrNS(@CreateNewFieldUIController)::
		MSG_FFFP_INC_MARK_BUSY_COUNT();

    /*
     * Disable, initialize and bring up the Field Properties box. 
     */
    @send GeodeGetOptrNS(@CreateNewFieldUIController)::
			MSG_GEN_SET_NOT_ENABLED(VUM_NOW);

    @send GeodeGetOptrNS(@CreateNewFieldUIController)::
			MSG_FFFP_INITIATE_NEW_FIELD_INTERACTION();

    return(newDocumentError); 
}

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_GEN_DOCUMENT_IMPORT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:    Import transfer file.

PASS:           ImpexTranslationParams *params

RETURN:         ImpexTranslationParams *params

PSEUDO CODE/STRATEGY:

CHECKS:         None.

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:  ???

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	THK     8/24/92         Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@method GeoFileDocumentClass, MSG_GEN_DOCUMENT_IMPORT
{
    optr ffile;

    /* First, get ahold of the database handle. */

    ffile = pself->GFDI_spreadsheet;

    @call ffile, (ChunkHandle) @TemplateFlatFile::
				MSG_FFD_IMPORT_TRANSFER_FILE(params);

    /*
     * Always return a success flag.  Ted, is this right?
     */
    return FALSE;
}

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_GEN_DOCUMENT_CONTROL_INITIATE_EXPORT_DOC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:    Setup export controller before it comes up.

PASS:           nothing

RETURN:         nothing

PSEUDO CODE/STRATEGY:

CHECKS:         None.

KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:  ???

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	THK     10/19/92        Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@method GeoFileDocControlClass, MSG_GEN_DOCUMENT_CONTROL_INITIATE_EXPORT_DOC
{
    EventHandle msg;

    /*
     * Send a request for more information to the current document.
     */
    msg = @record GeoFileDocumentClass::MSG_GFD_INITIATE_EXPORT_DOC();
    @send self::MSG_META_SEND_CLASSED_EVENT(msg, TO_APP_MODEL);

    @callsuper();
}


/***********************************************************************
 *
 * MESSAGE:     MSG_GFD_INITIATE_EXPORT_DOC for GeoFileDocumentClass
 *
 * DESCRIPTION: This message sets up the export controller's extra UI.
 *
 * PARAMETERS:
 *      void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      ted     12/29/92        Initial version
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_GFD_INITIATE_EXPORT_DOC
{
    optr databaseObject;
    word numRecords;

    /* First, get ahold of the database handle. */
    databaseObject = GetTargetDatabaseObject();

    /* check to see if we are in "show only marked" records mode  */
    if (@call databaseObject::MSG_FFD_GET_SHOW_ONLY_MARKED()) {

	/* if so, get the number of marked records in database file */
	numRecords = @call databaseObject::MSG_FFD_GET_NUM_MARKED_RECORDS();
    } else {

	/* else, get the number of records in database file */
	numRecords = @call databaseObject::MSG_FFD_GET_NUM_RECORDS();
    }

    if (numRecords) {

	/* First, enable the objects */
	@call GeodeGetOptrNS(@GeoFileExportGadget)::
	    MSG_GEN_SET_ENABLED(VUM_NOW);

	/* set the selection to "All" */
	@call GeodeGetOptrNS(@ExportChoices)::
	    MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(0, FALSE);

	/* Set the maximum value of 'ExportFrom' object */
	@call GeodeGetOptrNS(@ExportFrom)::
	    MSG_GEN_VALUE_SET_MAXIMUM(MakeWWFixed(numRecords));

	/* Set the maximum value of 'ExportTo' object */
	@call GeodeGetOptrNS(@ExportTo)::
	    MSG_GEN_VALUE_SET_MAXIMUM(MakeWWFixed(numRecords));

	/* Set the current value of 'ExportFrom' object to one */
	@call GeodeGetOptrNS(@ExportFrom)::
	    MSG_GEN_VALUE_SET_VALUE(MakeWWFixed(1.0), FALSE);

	/* Set the current value of 'ExportTo' object */ 
	@call GeodeGetOptrNS(@ExportTo)::
	    MSG_GEN_VALUE_SET_VALUE(MakeWWFixed(numRecords), FALSE);
    } else {

	/* Set the objects not enabled */
	@call GeodeGetOptrNS(@GeoFileExportGadget)::
	    MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    }
    @callsuper();
}

/***********************************************************************
 *
 * MESSAGE:     MSG_GFD_REPORT_RECORD_HEIGHT for GeoFileDocumentClass
 *
 * DESCRIPTION: This message is called when the user modifies the single
 *              record height spin gadget in the page setup dialog box.
 *
 *              We check to see if the new value plus the margin sizes
 *              for the current page are larger than the page size, we
 *              up the page size.
 *
 * PARAMETERS:
 *      void (WWFixedAsDWord height, GenValueStateFlags flags)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  10/18/92        Initial version
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_GFD_REPORT_RECORD_HEIGHT
{
    optr pageSizeControl;
    PageSizeReport psr;
    sdword totalHeight;

    /*
     * Get the size of the current page and margin values.
     */
    pageSizeControl =  GeodeGetOptrNS(@GFPageSizeControl);
    @call pageSizeControl::MSG_PZC_GET_PAGE_SIZE(&psr);

    /*
     * Is the size of the single record now larger than the page size,
     * when you count margins?
     */
    totalHeight = IntegerOf(height) +
		  psr.PSR_margins.PCMP_top +
		  psr.PSR_margins.PCMP_bottom;

    if (totalHeight > psr.PSR_height) {
	/*
	 * Reset the page height to fit the new value.
	 */
	psr.PSR_height = totalHeight;
	@call pageSizeControl::MSG_PZC_SET_PAGE_SIZE(&psr);
    }
}

/***********************************************************************
 *
 * MESSAGE:     MSG_GFD_REPORT_RECORD_WIDTH for GeoFileDocumentClass
 *
 * DESCRIPTION: This message is called when the user modifies the single
 *              record width spin gadget in the page setup dialog box.
 *
 *              We check to see if the new value plus the margin sizes
 *              for the current page are larger than the page size, we
 *              up the page size.
 *
 * PARAMETERS:
 *      void (WWFixedAsDWord width, GenValueStateFlags flags)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  10/18/92        Initial version
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_GFD_REPORT_RECORD_WIDTH
{
    optr pageSizeControl;
    PageSizeReport psr;
    sdword totalWidth;

    /*
     * Get the size of the current page and margin values.
     */
    pageSizeControl =  GeodeGetOptrNS(@GFPageSizeControl);
    @call pageSizeControl::MSG_PZC_GET_PAGE_SIZE(&psr);

    /*
     * Is the size of the single record now larger than the page size,
     * when you count margins?
     */
    totalWidth = IntegerOf(width) +
		 psr.PSR_margins.PCMP_left +
		 psr.PSR_margins.PCMP_right;

    if (totalWidth > psr.PSR_width) {
	/*
	 * Reset the page width to fit the new value.
	 */
	psr.PSR_width = totalWidth;
	@call pageSizeControl::MSG_PZC_SET_PAGE_SIZE(&psr);
    }
}

/***********************************************************************
 *
 * MESSAGE:     MSG_GFD_REPORT_PSZ_CHANGE for GeoFileDocumentClass
 *
 * DESCRIPTION: This message is sent out when one of the page size
 *              controller's UI gadgets change.
 *
 * PARAMETERS:
 *      void (PageSizeReport *psr);
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  10/21/92        Initial version
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_GFD_REPORT_PSZ_CHANGE
{
    optr srHeightGadget, srWidthGadget;
    sdword srHeight, srWidth;
    sdword totalHeight, totalWidth;
    PageSizeReport psr2;            /* <- We can't use the passed psr. */

    /*
     * Reset the size of the current page and margin values.
     */
    @call GeodeGetOptrNS(@GFPageSizeControl)::MSG_PZC_GET_PAGE_SIZE(&psr2);

    /*
     * Get the size of the current single record.
     */
    srHeightGadget = GeodeGetOptrNS(@GFRecordHeight);
    srHeight = IntegerOf(@call srHeightGadget::MSG_GEN_VALUE_GET_VALUE());

    srWidthGadget  = GeodeGetOptrNS(@GFRecordWidth);
    srWidth  = IntegerOf(@call srWidthGadget::MSG_GEN_VALUE_GET_VALUE());

    /*
     * If the page height, width, or margins changed, make sure the
     * single record size is small enough.
     */
    totalHeight = psr2.PSR_height -
		  (psr2.PSR_margins.PCMP_top + psr2.PSR_margins.PCMP_bottom);
    totalWidth  = psr2.PSR_width -
		  (psr2.PSR_margins.PCMP_left + psr2.PSR_margins.PCMP_right);

    if (totalHeight < srHeight) {
	/*
	 * Reset the single record height to fit the new value.
	 */
	@call srHeightGadget::MSG_GEN_VALUE_SET_VALUE(MakeWWFixed(totalHeight),
						      FALSE);
    }

    if (totalWidth < srWidth) {
	/*
	 * Reset the single record width to fit the new value.
	 */
	@call srWidthGadget::MSG_GEN_VALUE_SET_VALUE(MakeWWFixed(totalWidth),
						     FALSE);
    }
}

/***********************************************************************
 *
 * MESSAGE:     MSG_GFD_APPLY_RECORD_SIZE for GeoFileDocumentClass
 *
 * DESCRIPTION: This message is sent when the record size changed.
 *              The current view is changed to reflect the new size,
 *              if the current mode is MT_RECORD.
 *
 * PARAMETERS:
 *      void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  9/ 2/92         Initial version
 *
 ***********************************************************************/
void
GFDApplyRecordSize(optr oself)
{
    LayoutSize srBounds;
    optr view, ffile;
    GeoFileDocumentInstance *pself = ObjDerefGen(oself);

    /*
     * Get some optrs from our instance so we won't have to deref later.
     */
    view = pself->GCI_genView;
    ffile = ConstructOptr(pself->GFDI_spreadsheet,
			  (ChunkHandle)@TemplateFlatFile);
    /*
     * Get the new values, which are in points.
     */
    srBounds.LS_width  = IntegerOf(@call GeodeGetOptrNS(@GFRecordWidth)::
				   MSG_GEN_VALUE_GET_VALUE());
    srBounds.LS_height = IntegerOf(@call GeodeGetOptrNS(@GFRecordHeight)::
				   MSG_GEN_VALUE_GET_VALUE());

    /*
     * Call the flat file object to set the new single record size.
     */
    @call ffile::MSG_FFD_SET_SINGLE_RECORD_BOUNDS(srBounds);

    /*
     * Set the size of the document correctly, or redraw the multi-record
     * layout repeater box.
     */
    if (@call ffile::MSG_FFD_GET_LAYOUT_TYPE(0, TRUE) == LT_SINGLE_RECORD) {
	/*
	 * We're in single-record mode, so reset the view.
	 */
	@send view::MSG_GEN_VIEW_SET_DOC_BOUNDS(srBounds.LS_height,
						srBounds.LS_width,
						0, 0);
    }
}

/***********************************************************************
 *
 * MESSAGE:     MSG_PRINT_REPORT_PAGE_SIZE for GeoFileDatabaseClass
 *
 * DESCRIPTION: This message is sent out when the user changes the page
 *              size via the PageSizeController.
 *
 *              We'll change the size of the current page size, and
 *              if the size of the current single record layout is
 *              larger than the new page size, it'll get set to the
 *              same size.
 *
 * PARAMETERS:
 *      void (PageSizeReport *psr)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  9/ 3/92         Initial version
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_PRINT_REPORT_PAGE_SIZE
{
    LayoutSize mrBounds;
    word availableWidth, availableHeight;
    Boolean mrTooWide, mrTooTall;
    optr view, ffile, grObjBody;
    UIInterfaceLevel userLevel;
    byte currentLayout;
    RectDWord grobjBodyBounds;

    /*
     * Get some optrs from our instance so we won't have to deref later.
     */
    view = pself->GCI_genView;
    ffile = ConstructOptr(pself->GFDI_spreadsheet,
			  (ChunkHandle) @TemplateFlatFile);
    
    /*
     * Call the flat file object to set the new page size.
     */
    @call ffile::MSG_FFD_SET_PAGE_BOUNDS(psr);

    /*
     * Call the flat file object to set the new single record size.
     */
    GFDApplyRecordSize(oself);
	
    /*
     * Set the size of this layout's multi-record grobj body.
     */
    currentLayout = @call ffile::MSG_FFD_GET_CURRENT_LAYOUT();

    grobjBodyBounds.RD_left = grobjBodyBounds.RD_top = 0;
    grobjBodyBounds.RD_right = psr->PSR_width;
    grobjBodyBounds.RD_bottom = psr->PSR_height;
    grObjBody = @call ffile::MSG_FFD_GET_GROBJ_BODY_FOR_LAYOUT(currentLayout,
							       LT_MULTI_RECORD);

    @call grObjBody::MSG_GB_SET_BOUNDS(&grobjBodyBounds);

    /*
     * If the repeater-box is bigger than the page size minus the margins,
     * shrink it down.
     */
    @call ffile::MSG_FFD_GET_MULTI_RECORD_BOUNDS(&mrBounds);

    availableWidth  = psr->PSR_width  - (psr->PSR_margins.PCMP_right +
					 psr->PSR_margins.PCMP_left);
    availableHeight = psr->PSR_height - (psr->PSR_margins.PCMP_top +
					 psr->PSR_margins.PCMP_bottom);

    /*
     * If we're in user level 3 or lower, make the repeater box area always
     * be the size of the page minus the size of the margins.
     */
    userLevel = GET_UI_INTERFACE_LEVEL (@call GeodeGetAppObject(0)::
	MSG_GEN_APPLICATION_GET_APP_FEATURES());
    
    if (userLevel < UIIL_ADVANCED) {
	mrBounds.LS_height = availableHeight;
	mrBounds.LS_width = availableWidth;
	@call ffile::MSG_FFD_SET_MULTI_RECORD_BOUNDS(mrBounds);
	@call ffile::MSG_FFD_SET_MULTI_RECORD_WITHIN_MARGINS(psr);
    } else {
	/*
	 * We're in a high user level, so just make sure the repeater box
	 * isn't too big.
	 */
	mrTooTall = (mrBounds.LS_height > availableHeight);
	mrTooWide = (mrBounds.LS_width > availableWidth);
	if (mrTooTall || mrTooWide) {
	    /*
	     * The multi-record bounds need to be shrunk.
	     */
	    if (mrTooTall) {
		mrBounds.LS_height = availableHeight;
	    }
	    if (mrTooWide) {
		mrBounds.LS_width = availableWidth;
	    }
	    
	    @call ffile::MSG_FFD_SET_MULTI_RECORD_BOUNDS(mrBounds);
	    @call ffile::MSG_FFD_SET_MULTI_RECORD_WITHIN_MARGINS(psr);
	}
    }
    
    /*
     * Set the size of the document.  GFDApplyRecordSize() already redrew
     * the single record stuff.
     */
    if ((@call ffile::MSG_FFD_GET_LAYOUT_TYPE(0, TRUE)) & LT_MULTI_RECORD) {
	/*
	 * We're in multi-record mode, so reset the view and redraw the
	 * repeater-box.
	 */
	@call ffile::MSG_FFD_REDRAW_MULTI_RECORD();
	@call view::MSG_GEN_VIEW_SET_DOC_BOUNDS(psr->PSR_height,
						psr->PSR_width,
						0, 0);
    }
}

/***********************************************************************
 *
 * MESSAGE:     MSG_PRINT_GET_DOC_NAME for GeoFileDocumentClass
 *
 * DESCRIPTION: The print control sends this out when it wants the
 *              current document name.
 *
 * PARAMETERS:
 *      void (optr printCtrlOD)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  9/ 4/92         Initial version
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_PRINT_GET_DOC_NAME
{
    /*
     * Send the document name stored in our instance data.
     */
    @call printCtrlOD::MSG_PRINT_CONTROL_SET_DOC_NAME(pself->GDI_fileName);
}


/***********************************************************************
 *
 * MESSAGE:     MSG_PRINT_NOTIFY_PRINT_DB for GeoFileDocumentClass
 *
 * DESCRIPTION: This message is called when the print controller
 *              is about to come up or go away.  We're interested in
 *              when it's about to come up so we can set the
 *              available number of pages to print.
 *
 * PARAMETERS:
 *      void (optr printCtrlOD, PrintControlStatus pcs)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  10/13/92        Initial version
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_PRINT_NOTIFY_PRINT_DB
{
    word pages;

    if (pcs == PCS_PRINT_BOX_VISIBLE) {
	/*
	 * The box is just coming up.  Set the page range first.
	 */
	pages = @call pself->GFDI_spreadsheet,(ChunkHandle)@TemplateFlatFile::
	    MSG_FFD_GET_NUMBER_OF_PAGES();

	/*
	 * No pages? Just one page is available, then.
	 */
	@call printCtrlOD::
	    MSG_PRINT_CONTROL_SET_TOTAL_PAGE_RANGE(1, pages ? pages : 1);
    }

    @callsuper();
}

/***********************************************************************
 *
 * MESSAGE:     MSG_PRINT_START_PRINTING for GeoFileDocumentClass
 *
 * DESCRIPTION: This message is sent by the print controller when the
 *              user wishes to start printing.  An optr to the print
 *              controller is passed, as well as a gstate handle to
 *              draw to.
 *
 *              We pass this along to the flat file database, which
 *              draws a page at a time.
 *
 * PARAMETERS:
 *      void (optr printCtrlOD, GStateHandle gstate);
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  9/ 4/92         Initial version
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_PRINT_START_PRINTING
{
    PCPageRange pageRange;
    word startPage, endPage, curPage;
    word originalRecord;
    optr databaseObject, grObjHead;
    byte currentLayoutNum;
    LayoutType layoutType;
    ModeType currentMode;

    /*
     * Set the print controller's doc size.
     */
    GFResetPrintControllerSizes(ConstructOptr(pself->GFDI_spreadsheet,
					      (ChunkHandle) @TemplateFlatFile));

    /*
     * Figure out which pages we are to print.
     */
    pageRange = @call printCtrlOD::MSG_PRINT_CONTROL_GET_SELECTED_PAGE_RANGE();
    startPage = pageRange.PCPR_firstPage;
    endPage   = pageRange.PCPR_lastPage;
    
    /*
     * Switch to multi-record mode, if we're not there already.
     */

    /* Get the current layout type. */
    layoutType = @call GeodeGetOptrNS(@DesignOptionsList)::
	MSG_GEN_ITEM_GROUP_GET_SELECTION();

    /* Get hold of the database handle. */
    databaseObject = GetTargetDatabaseObject();

    /*
     * Determine which mode we're in.
     */
    currentMode = @call databaseObject::MSG_FFD_GET_CURRENT_MODE();

    /*
     * Remember what record (row) we're on, so we can jump back.
     */
    originalRecord = @call databaseObject::MSG_FFD_GET_CUR_ROW();

    /*
     * Invalidate the document so the record drawing will not be represented
     * on screen.
     */
    @send oself::MSG_VIS_INVALIDATE();

    /*
     * If we're in single-record mode, change to multi-record mode
     * (which is essentially page preview).
     */
    if (layoutType == LT_SINGLE_RECORD) {
	/* Get the current layout */
	currentLayoutNum = @call databaseObject::MSG_FFD_GET_CURRENT_LAYOUT();
	grObjHead = GeodeGetOptrNS(@ffGrObjHead);

	(void) @call databaseObject::MSG_FFD_SWITCH_TO_LAYOUT(currentLayoutNum,
							      grObjHead,
							      LT_MULTI_RECORD,
							      TRUE);
    }

    /*
     * If we're in design mode, simply draw the current database.
     */
    if (currentMode == MT_DESIGN) {
	/*
	 * Draw, baby.
	 */
	@call databaseObject::MSG_VIS_DRAW(DF_PRINT, gstate);
    } else for (curPage = startPage; curPage <= endPage; curPage++) {
	/*
	 * We're in data entry mode.  Loop, reloading each page and
	 * printing it in turn.
	 */

	/*
	 * Tell the current layout to fill itself with this page's
	 * info, but not to draw yet.
	 */
	@call databaseObject::MSG_FFD_GO_TO_PAGE(curPage, FALSE);

	/*
	 * Indicate the current page.  If, for some reason, the print
	 * controller tells us to abort, break out of here and reset
	 * the database.
	 */
	if (@call printCtrlOD::
	    MSG_PRINT_CONTROL_REPORT_PROGRESS(PCPT_PAGE, curPage) == FALSE) {
	    break;
	}

	/*
	 * Draw, baby.
	 */
	@call databaseObject::MSG_VIS_DRAW(DF_PRINT, gstate);

	/*
	 * Jump to the next page.
	 */
	if (curPage != endPage) {
	    GrNewPage(gstate, PEC_FORM_FEED);
	}
    }

    /*
     * Return to the original record we were on.
     */
    @call databaseObject::MSG_FFD_SET_CUR_ROW(originalRecord);
    
    /*
     * Now return to single-record mode, if that's where we were before.
     */
    if (layoutType == LT_SINGLE_RECORD) {
	(void) @call databaseObject::MSG_FFD_SWITCH_TO_LAYOUT(currentLayoutNum,
							      grObjHead,
							      LT_SINGLE_RECORD,
							      TRUE);
    }

    /*
     * Done printing.
     */
    @send printCtrlOD::MSG_PRINT_CONTROL_PRINTING_COMPLETED();
}


/***********************************************************************
 *
 * MESSAGE:     MSG_VIS_DRAW for GeoFileDocumentClass
 *
 * DESCRIPTION: We intercept this to draw margins, if we're in
 *              multi-record mode and we're not printing.
 *
 * PARAMETERS:
 *      void (DrawFlags drawFlags, GStateHandle gstate)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  10/15/92        Initial version
 *
 ***********************************************************************/
@method GeoFileDocumentClass, MSG_VIS_DRAW
{
    optr databaseObject;

    if (!(drawFlags & DF_PRINT)) {
	/*
	 * We're not printing.  Draw the margins if we're in multi-record
	 * mode.
	 */
	databaseObject = GetTargetDatabaseObject();

	@call databaseObject::MSG_FFD_DRAW_MARGINS(gstate);
    }

    @callsuper();
}


/***********************************************************************
 *
 * FUNCTION:    GFResetPrintControllerSizes
 *
 * DESCRIPTION: This function sets the page and record sizes for the
 *              print/page size controllers.
 *
 * PARAMETERS:  optr ffile - an optr to the current database
 *
 * CALLED BY:   INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  12/ 8/92        Initial version
 *
 ***********************************************************************/
void
GFResetPrintControllerSizes(optr ffile)
{
    PageSizeReport psr;
    LayoutSize recordSize;
    PCDocSizeParams printDocSize;
    PCMarginParams printMarginsSize;
    optr printController;

    /*
     * Get then set the size of the current page bounds.
     */
    @call ffile::MSG_FFD_GET_PAGE_BOUNDS(&psr);

    @call GeodeGetOptrNS(@GFPageSizeControl)::MSG_PZC_SET_PAGE_SIZE(&psr);

    /*
     * Set the PageSizeController with the new page bounds.
     */
    SpoolSetDocSize(TRUE, &psr);

    printDocSize.PCDSP_width  = psr.PSR_width;
    printDocSize.PCDSP_height = psr.PSR_height;

    printController = GeodeGetOptrNS(@GFPrintControl);
    @send printController::
	MSG_PRINT_CONTROL_SET_EXTENDED_DOC_SIZE(&printDocSize);

    memcpy(&printMarginsSize, &(psr.PSR_margins), sizeof(PCMarginParams));
    @send printController::MSG_PRINT_CONTROL_SET_DOC_MARGINS(&printMarginsSize);

    /*
     * Now get the size of the single record layout.
     */
    @call ffile::MSG_FFD_GET_SINGLE_RECORD_BOUNDS(&recordSize);
    
    /*
     * Get the size of the current single record.
     */
    @call GeodeGetOptrNS(@GFRecordHeight)::
	MSG_GEN_VALUE_SET_VALUE(MakeWWFixed(recordSize.LS_height), FALSE);
    @call GeodeGetOptrNS(@GFRecordWidth)::
	MSG_GEN_VALUE_SET_VALUE(MakeWWFixed(recordSize.LS_width), FALSE);
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	MSG_GEN_DOCUMENT_UPDATE_EARLIER_INCOMPATIBLE_DOCUMENT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:    Handle incompatible protocol'ed documents.

PASS:           void

RETURN:         Boolean = TRUE (indicating error).

SIDE EFFECTS:
	Requires:       Nada.

	Asserts:        GeoFile doesn't handle incompatible documents.

CHECKS:                 None.

PSEUDO CODE/STRATEGY:
	Let the system know that we don't handle incompatible document
	protocol changes.

KNOWN DEFECTS/CAVEATS/IDEAS:    ???

REVISION HISTORY:
	Name    Date            Description
	----    ----            -----------
	JDM     92.12.14        Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@method GeoFileDocumentClass,
		MSG_GEN_DOCUMENT_UPDATE_EARLIER_INCOMPATIBLE_DOCUMENT
{
    /* GeoFile don't play with incompatible protocol'ed documents.      */
    return (TRUE);
}


/***********************************************************************
 *
 * MESSAGE:     MSG_GEN_DOCUMENT_UPDATE_EARLIER_COMPATIBLE_DOCUMENT
 *              for GeoFileDocumentClass
 *
 * DESCRIPTION: Handle updating of an earlier protocol file that is
 *              compatible with the protocol of the document control.
 *
 *              We simply return an error flag, since we don't deal with
 *              earlier protocols.
 *              
 * PARAMETERS:
 *              Boolean()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      jeremy  1/25/93         Initial version
 *
 ***********************************************************************/
@method GeoFileDocumentClass,
		    MSG_GEN_DOCUMENT_UPDATE_EARLIER_COMPATIBLE_DOCUMENT
{
    return TRUE;
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		TitledGenItemClass Declaration
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@classdecl      TitledGenItemClass;


/***********************************************************************
 *              MSG_SPEC_BUILD for TitledGenItemClass
 ***********************************************************************
 * SYNOPSIS:        Combine title and picture and use it as the moniker
 * PARAMETERS:      void(SpecBuildFlags flags)
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      Joon    8/25/93         Initial Revision
 *
 ***********************************************************************/
@method TitledGenItemClass, MSG_SPEC_BUILD
{
	TitledGenItemSpecBuild(oself,
			       pself->TGI_title, pself->TGI_pictureNumber,
			       &TitledGenItemClass, flags);
}       /* End of MSG_SPEC_BUILD.       */
