/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) Geoworks 1992 -- All Rights Reserved

PROJECT:	Sample Applications
MODULE:		Vis test application
FILE:		vissamp.goc

AUTHOR:		Tom Manshreck, Oct 22, 1992

ROUTINES:
	Name			Description
	----			-----------

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	TM	10/22/92   	Initial version.

DESCRIPTION:
	This application demonstrates the use of Vis objects within
	the visual world.
	
	It includes examples of:  geometry management in a visible
	tree, a simple MSG_VIS_DRAW handler, basic mouse handling in a
	visible object, setting an object visible/not visible,
	adding/removal of objects, usage of VisMonikers, a simple
	MSG_VIS_RECALC_SIZE handler, custom positioning of objects,
	and marking an object invalid.

	There are several visible classes of objects - VisClass,
	VisCompClass, VisContentClass and VisTextClass in the visible
	world. These visible objects provide much more flexible
	objects than offered in the generic world. Visible objects
	allow for custom drawing, geometry management and input
	handling. 

		*****	VisClass 	*****

	A simple Vis object, an object of VisClass, provides the
	backbone for all visible functionality. All Vis objects are of
	this class or one of its sub-classes. VisClass objects do
	nothing useful by themselves. You must subclass objects off of
	this class and intecept VisClass messages to take advantage of
	its built-in functionality.

	VisClass inherently provides the following features:
		
		Knowledge of visual bounds
	Every visible object has an instance field that defines the
	object's bounds in the GEOS graphic coordinate space. These
	bounds are used for many purposes, including drawing and input
	handling.

		Comprehensive Visual Updating
	When a visible object is included in an object tree displayed
	by a GenView object, the system automatically tells the object
	when it must redraw itself. For example, when the vuiew
	scrolls or when part of the window becomes exposed, the system
	will send a drawing message through the visible tree; the
	objects then draw themselves at the proper location in the
	document space and the view window is updated.

		Geometry Management
	When visible objects are arranged as children of a VisComp or
	a VisContent objects, they can be set up to automatically
	update their size and position appropriate to the current
	window and view context. The VisComp and VisContent classes
	provide extensive and child management functions, though
	custom management is also allowed and is often used.

		Object Tree Manipulation
	VisClass objects cannot have children, but they can be
	children of VisCompClass and VisContentClass objects. All of
	these classes support extensive tree operations including
	passing messages up the tree, passing messages down the tree,
	adding branches, removing branches, and moving branches.

		Mouse Event Handling
	When an input event occurs over the GenView window in which
	the visible tree is displayed, that event is immediately
	passed on to an associated VisContent object. The event then
	travels down the visible object tree (automatically) until it
	is handled by some visible objects. Most often, the event is
	handled by the leaf object with its visible bounds directly
	under the mouse pointer. Individual Vis objects can also grab
	the mouse so that they receive input events that occur outside
	their bounds.

		Keyboard Event Handling
	A visible object can grab the keyboard input stream and
	receive keyboard events as they occur. Typically, certain
	keystrokes will be intercepted by the specific UI even if a
	visible object has the keyboard grab; this ensures the object
	won't usurp functions expected by the user from his specific
	UI. (The object can, however, override keystroke interception,
	though this is strongly discouraged.)

		Interaction witn Input Hierarchies
	VisClass objects have an inherent knowledge of the input
	hierarchies. many visible objects may need to interact with
	the Focus and Target input hierarchies especially, and they
	can also interact with the Model, View, and Controller
	hierarchies as well.

		Use of VisMonikers
	Typically, visible objects will draw themselves in their
	entirety and will not need visual monikers. Monikers are
	labels attached to objects that get displayed either on or
	near the object. Visual monikers are most frequently used
	generic UI objects, but they can be set up and used with
	visible objectws as well.

		Standard MetaClass functions
	Because VisClass is a subclass of MetaClass, it inherits all
	the basic, standard object functions of that class (e.g. state
	saving, instantiation and initialization, detaching and
	destruction, etc.)

		*****	VisCompClass	*****  

	VisCompClass is a sublass of VisClass that allows visible
	objects to have children. VisComp objects, also known as
	composite objects, are the grouping elements within visible
	object trees.

	VisCompClass provides the following features:

		Children
	Normal visible objects can exist only as leaves within a
	visible object tree. VisCompClass objects can have children,
	allowing the tree to be built to any number of levels. A
	composite object can have any number of children.

		Child Management
	A composite's children can be managed arbitrarily by the
	composite, or the compsite can use the geometry manager to
	automatically position and size its children. Since a
	composite can have other composites as its children, this
	sizing can recurse through the visible throughout the visible
	tree, making the entire tree's geometry completely
	self-managed.

		Window Management
	Composite objects can create their own graphics windows.
	Though this is not typically done (except in Specific UI
	libraries), it is possible.

		Other VisClass functionality
	VisCompClass inherits all instance fields and messages of
	VisClass. As such, it can do everything normal VisClass
	objects can do.

		*****	VisContentClass	*****

	VisContentClass provides an object that is used to head a
	visible tree and interact with a GenView object. The
	VisContent is a necessary object within any application that
	plans on displaying visible objects within a view.

	A GenView object contains an instance field (GVI_content)
	specifies the content object to interact with the GenView
	object. In the visible world this content object is a
	VisContent. (There is also a content object in the generic
	world - GenContent.)

	Similarly, the VisContent contains an instance field
	(VCNI_view) that specifies the view object for the VisContent
	to communicate with. This field is set automatically when the
	view is opened.	

	$Id: vissamp.goc,v 1.1 97/04/04 16:37:36 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*
 ***************************************************************************
 *		Include files
 ***************************************************************************
 */

@include <stdapp.goh>

/*
 ***************************************************************************
 *		Class & Message Definitions
 ***************************************************************************
 */

@class	VisSampProcessClass, GenProcessClass ;

/* define methods for this class here. */

@message void MSG_MAKE_ROTARY_PHONE();
@message void MSG_MAKE_BUTTON_PHONE();

@endc   /* end of class definition */

@classdecl	VisSampProcessClass, neverSaved ;

/*
 ***************************************************************************
 *		VisSampNumberClass 
 ***************************************************************************
 */

/*
 * The VisSampNumberClass contains a visual representation of a
 * number. This number has two monikers, one "short" and one "long."
 * (I.e. the short moniker for the number One is "1" and the long
 * moniker is "One.") Depending on how the object is built, it will
 * select the appropriate moniker. 
 */
@class	VisSampNumberClass, VisClass ;

@message void MSG_VIS_SAMP_NUMBER_SET_STATE(
		byte stateToSet, 
		byte stateToClear);
@message byte MSG_VIS_SAMP_NUMBER_GET_STATE();

/* state flags */
#define VSNS_LONG_TEXT	0x80
#define VSNS_MOUSE_DOWN 0x40
#define VSNS_SELECTED   0x20

#define NUMBER_TEXT_HEIGHT 36.0

	@instance @visMoniker VSNI_shortMoniker;
	@instance @visMoniker VSNI_longMoniker;
	@instance word VSNI_xOffset = 0;
	@instance word VSNI_yOffset = 0;
	@instance byte VSNI_state = 0;
@endc
@classdecl	VisSampNumberClass ;

/*
 ***************************************************************************
 *		VisSampCompClass 
 ***************************************************************************
 */

@class VisSampCompClass, VisCompClass ;

@message void MSG_VIS_SAMP_COMP_SET_STATE(
		byte stateToSet = cl, 
		byte stateToClear = ch); 
@message byte MSG_VIS_SAMP_COMP_GET_STATE() = al;

@message void MSG_VIS_SAMP_COMP_INC_DRAW_COLOR();
@message word MSG_VIS_SAMP_COMP_GET_DRAW_COLOR();

/* state flags */
#define VSCS_ROTARY_STYLE	0x80


	@instance byte VSCI_state = 0;
        @instance word VSCI_drawColor = C_LIGHT_CYAN;

@endc
@classdecl	VisSampCompClass ;

/*
 ***************************************************************************
 *		Application object 
 ***************************************************************************
 */

@start	AppResource ;

@object GenApplicationClass VisSampApp = {

    GI_visMoniker = list { @VisSampTextMoniker }
    GI_comp = @VisSampPrimary;
    gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_WINDOWS) = @VisSampPrimary;
}

@visMoniker VisSampTextMoniker = "C VisSamp";

@end	AppResource

/*
 ***************************************************************************
 *		Interface 
 ***************************************************************************
 */

@start	Interface ;

@object GenPrimaryClass VisSampPrimary  = {

    GI_comp = 	@VisSampView, 
		@RotaryTrigger, 
		@ButtonTrigger, 
		@ColorTrigger;		
					
    ATTR_GEN_DISPLAY_NOT_MINIMIZABLE;
    HINT_SIZE_WINDOW_AS_RATIO_OF_PARENT = {
		   SWSS_RATIO | PCT_80, 
		   SWSS_RATIO | PCT_60
    };   
}

/*
 * This trigger builds a classic rotary-style phone out of the Vis
 * objects within the GenView.
 */
@object GenTriggerClass RotaryTrigger = {
    GI_visMoniker = "Rotary";
    GTI_destination = process;
    GTI_actionMsg = MSG_MAKE_ROTARY_PHONE;
}

/*
 * This trigger builds a touch-tone type phone out of the same Vis
 * objects. 
 */
@object GenTriggerClass ButtonTrigger = {
    GI_visMoniker = "Normal";
    GTI_destination = process;
    GTI_actionMsg = MSG_MAKE_BUTTON_PHONE;
}

/*
 * This trigger cycles the color of the number backgrounds in the
 * phone display.
 */
@object GenTriggerClass ColorTrigger = {
    GI_visMoniker = "Color";
    GTI_destination = MySampComp;
    GTI_actionMsg = MSG_VIS_SAMP_COMP_INC_DRAW_COLOR;
}


/*
 *		GenView object
 *
 * This GenView object creates a window where the application can
 * display portions of the document as necessary. As we want this
 * window to be scrollable, the specific UI (Motif) will create scroll
 * bars which the user can interact with. Whenever a portion of the
 * window needs to be redrawn, the GenView object will invalidate a
 * portion of the window, causing a MSG_META_EXPOSED to be sent to the
 * application. The application will draw the document into the window
 * as requested. The window keeps track of a mask, which is used to
 * clip the application's drawing operations, so that only the invalid
 * portion of the window is drawn to. 
 */

@object GenViewClass VisSampView = {
    /*
     * In order to manage Vis objects, we need to have a VisContent
     * object. That object should be linked to the GenView. Set the
     * GVI_content instance field to the View's content object. 
     */
    GVI_content = VisSampContent;

    /* 
     * Choose a pretty color. The other arguments are used for RGB colors.
     * we'll just choose one of the 16 standard EGA colors.
     */
    GVI_color = { C_CYAN, 0, 0, 0 };

    /* 
     * The user won't be typing into the view so no floating keyboard is
     * needed.
     */
    ATTR_GEN_VIEW_DOES_NOT_ACCEPT_TEXT_INPUT;
}

/*
 *		The VisContent object
 * 
 * Just as generic objects are contained within a generic tree, Vis
 * objects appear within the 'visible' tree. If you include any Vis
 * objects in your application, you must include a VisContent object
 * to manage them.
 * 
 * The root object in any visible tree *must* be a VisContent object
 * (or a subclass). The VisContent acts as the interface between the
 * generic and the visible object trees. Usually, a VisContent is
 * linked to a GenView.  The GenView references the VisContent in its
 * GVI_content instance field.
 */

@object VisContentClass VisSampContent = { 

    /* 
     * We'll let the content size itself according to the view.
     * We'll let the view be any size it wants.
     */
    VCNI_attrs = @default | VCNA_SAME_WIDTH_AS_VIEW | 
                            VCNA_SAME_HEIGHT_AS_VIEW; 

    /* 
     * Children of a VisContent are specified in the VisComp instance
     * field VCI_comp. 
     */
    VCI_comp = @MySampComp;  

    /* 
     * Center the children horizontally and vertically. The expand
     * flags allow the content to get larger than the space the
     * children need.  VisComps by default don't get any larger than
     * the children require. 
     */

    VCI_geoDimensionAttrs = @default | WJ_CENTER_CHILDREN_HORIZONTALLY
                                     | HJ_CENTER_CHILDREN_VERTICALLY
				     | VCGDA_EXPAND_HEIGHT_TO_FIT_PARENT
				     | VCGDA_EXPAND_WIDTH_TO_FIT_PARENT;
}

/*
 *		The VisComp object
 *
 * VisCompClass objects contain all the functionality that VisClass
 * objects contain. (It is a subclass of VisClass.) VisComp objects
 * also contain the ability to contain other Vis objects as their
 * children. Simple VisClass objects may not contain any children.
 *
 * VisComp objects allow your visible tree to contain several levels
 * of visible objects, rather than having all your Vis objects hanging
 * off of a single VisContent.  
 */ 

@object VisSampCompClass MySampComp = {
	
    /* 
     * You specify the children of a VisComp object with VCI_comp just
     * as you would use GI_comp to specify a generic object's children.
     */
    VCI_comp =	@MySampNum1,  @MySampNum2, @MySampNum3,
		@MySampNum4,  @MySampNum5, @MySampNum6, 
		@MySampNum7,  @MySampNum8, @MySampNum9, 
		@MySampNumAst,@MySampNum0, @MySampNumHash; 

    /* 
     * Set up some default geometry stuff, in case we manage children 
     * Also, we'll plan on wrapping after 3 items no matter what.
     * We'll make sure to keep a minimum width regardless of the
     * total size of the children or the passed width. The passed
     * width gets set when handling MSG_VIS_SET_MINIMUM_SIZE.
     */
     VCI_geoAttrs = @default | 	VCGA_ALLOW_CHILDREN_TO_WRAP | 
	                        VCGA_WRAP_AFTER_CHILD_COUNT |
	                        VCGA_HAS_MINIMUM_SIZE;
	
}

/* Set up our buttons.  We'll use a macro to make the definitions
 * easier. The X and Y offsets will be used in specifying an objects 
 * position within a rotary phone.
 */

@define defSampNumber(NAME,SHORT,LONG,XOFF,YOFF) \
	@object VisSampNumberClass NAME = { \
	    VSNI_shortMoniker = SHORT; \
	    VSNI_longMoniker = LONG; \
	    VSNI_xOffset = XOFF; \
	    VSNI_yOffset = YOFF; \
	}

@defSampNumber(MySampNum0, "0", "Zero", 10, 10)
@defSampNumber(MySampNum1, "1", "One", 10, 1)
@defSampNumber(MySampNum2, "2", "Two", 7, 0)
@defSampNumber(MySampNum3, "3", "Three", 4, 0)
@defSampNumber(MySampNum4, "4", "Four", 1, 1)
@defSampNumber(MySampNum5, "5", "Five", 0, 4)
@defSampNumber(MySampNum6, "6", "Six", 0, 7)
@defSampNumber(MySampNum7, "7", "Seven", 1, 10)
@defSampNumber(MySampNum8, "8", "Eight", 4, 11)
@defSampNumber(MySampNum9, "9", "Nine", 7, 11)
@defSampNumber(MySampNumAst, "*", "Asterisk", 0, 0)
@defSampNumber(MySampNumHash, "#","Hash mark", 0, 0) 

@end Interface

/***********************************************************************
 *
 * Handlers for VisSampProcessClass
 *
 ***********************************************************************/

/***********************************************************************
 *		MSG_MAKE_ROTARY_PHONE for VisSampProcessClass
 ***********************************************************************
 * SYNOPSIS:	This message builds out the VisSampNumberClass
 *		children visually as a rotary-style phone. 
 * PARAMETERS:	
 *	void()    
 * SIDE EFFECTS:    
 *
 * STRATEGY:	We send a message off to the VisComp subclass telling
 *		it to set the VSCS_ROTARY_STYLE bit.
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/22/92		Initial Revision
 *
 ***********************************************************************/
@method VisSampProcessClass, MSG_MAKE_ROTARY_PHONE 
{
  @send MySampComp::MSG_VIS_SAMP_COMP_SET_STATE(VSCS_ROTARY_STYLE, 0); 
}

/***********************************************************************
 *		MSG_MAKE_BUTTON_PHONE for VisSampProcessClass
 ***********************************************************************
 * SYNOPSIS:	This message builds out the VisSampNumberClass
 *		children visually as a normal touch-tone phone.
 * PARAMETERS:
 *	void()	    
 * SIDE EFFECTS:    
 *
 * STRATEGY:	We send a message off to the VisComp subclass telling
 *		it to clear the VSCS_ROTARY_STYLE bit (and by default
 *		build out a normal phone display.  
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/22/92		Initial Revision
 *
 ***********************************************************************/
@method VisSampProcessClass, MSG_MAKE_BUTTON_PHONE 
{
  @send MySampComp::MSG_VIS_SAMP_COMP_SET_STATE(0, VSCS_ROTARY_STYLE); 
}


/***********************************************************************
 *
 * Handlers for VisSampCompClass
 *
 ***********************************************************************/


/***********************************************************************
 *		MSG_VIS_SAMP_COMP_SET_STATE for VisSampCompClass
 ***********************************************************************
 * SYNOPSIS:	This message sets the state of the VisSampComp object.
 *		Changing this state will update the visual display to
 *		match the new state.      
 * PARAMETERS:	
 *	void(byte stateToSet, byte statetoClear)     
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/22/92		Initial Revision
 *
 ***********************************************************************/
@method VisSampCompClass, MSG_VIS_SAMP_COMP_SET_STATE 
{
    /* 
     * We only want to do something if the flag passed changes the
     * rotary flag. 
     */ 
    if (((pself->VSCI_state ^ stateToSet) & VSCS_ROTARY_STYLE) ||
        (pself->VSCI_state & stateToClear & VSCS_ROTARY_STYLE)) {

	/* 
	 * First we set the VisSampComp state to the passed
	 * 'stateToSet' and clear the state with the passed
	 * 'stateToClear.' 
	 */
	pself->VSCI_state |= stateToSet;
	pself->VSCI_state &= ~stateToClear;

	/* 
	 * If we're doing to a rotary phone, we won't want the
	 * asterisk or the hash mark to be displayed. We'll set the
	 * asterisk not drawable and remove the hash mark from the vis
	 * tree altogether. 
	 */

	if (stateToSet & VSCS_ROTARY_STYLE) {
		
	    /* Set the asterisk not drawable. */
	    @call MySampNumAst::MSG_VIS_SET_ATTRS(
			0, 		/* VisAttrs to set */
			VA_DRAWABLE,	/* VisAttrs to clear */ 
			VUM_DELAYED_VIA_APP_QUEUE);

	    /* 
	     * Close the hash button object, then remove it from the
	     * vis tree. MSG_VIS_CLOSE unrealizes an object (in
	     * this case the hask mark). It is equivalent to
	     * marking a generic object not USABLE before removing
	     * it for the generic tree. 
	     */

	    @call MySampNumHash::MSG_VIS_CLOSE();

	    @call self::MSG_VIS_REMOVE_CHILD(@MySampNumHash, 0);
	}
	
	/*
	 * If we're not building a rotary phone, we're building a
	 * normal touch-tone phone. We need the asterisk and the hash
	 * mark back, so we'll set the asterisk drawable again and add
	 * the hash mark back to the visual tree.
	 */
	else {
	    
	    /* Set the asterisk drawable */
	    @call MySampNumAst::MSG_VIS_SET_ATTRS(
			VA_DRAWABLE,	/* VisAttrs to set */ 
			0,		/* VisAttrs to clear */ 
			VUM_DELAYED_VIA_APP_QUEUE);

	    /* 
	     * Add the hash mark to the tree, then mark it
	     * invalid so that it will be be visually built out.  
	     */
	    @call self::MSG_VIS_ADD_CHILD(@MySampNumHash, CCO_LAST);

	    @call MySampNumHash::MSG_VIS_MARK_INVALID(
			VOF_WINDOW_INVALID, 
			VUM_DELAYED_VIA_APP_QUEUE);
	}

	/* 
	 * Mark our entire geometry invalid, so it gets redone.  Also
	 * mark the image invalid, too, as the size may not change but
	 * we definitely want to redraw.
	 */
	@call self::MSG_VIS_MARK_INVALID(
			 VOF_GEOMETRY_INVALID | VOF_IMAGE_INVALID,
			 VUM_NOW);
      }
}

/***********************************************************************
 *		MSG_VIS_SAMP_COMP_GET_STATE for VisSampCompClass
 ***********************************************************************
 * SYNOPSIS:	This message retreives the contents of the VisSampComp
 *		object's VSCI_state instance field.    
 * PARAMETERS:	
 *	byte()    
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/22/92		Initial Revision
 *
 ***********************************************************************/
@method VisSampCompClass, MSG_VIS_SAMP_COMP_GET_STATE 
{
	return(pself->VSCI_state);
}

/***********************************************************************
 *		MSG_VIS_COMP_GET_WRAP_COUNT for VisSampCompClass
 ***********************************************************************
 * SYNOPSIS:	This message is sent by the geometry manager if
 *		VCGA_WRAP_AFTER_CHILD_COUNT is set. We intercept it
 *		here to set the number of children to count before
 *		wrapping. We set that warp count here to three.
 *
 * PARAMETERS:
 *	void()	    
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/22/92		Initial Revision
 *
 ***********************************************************************/
@method VisSampCompClass, MSG_VIS_COMP_GET_WRAP_COUNT 
{
  return (3);
}


/***********************************************************************
 *		MSG_VIS_COMP_GET_CHILD_SPACING for VisSampCompClass
 ***********************************************************************
 * SYNOPSIS:	This message is sent to the VisComp object when the
 *		geometry manager needs to figure out its child spacing
 *		behavior. By default, this spacing is
 *		VIS_COMP_DEFAULT_SPACING. We intercept this message
 *		here because we do not wish to space our children 
 *		at the default; we set the spacing to 15 units for
 *		both child spacing and wrap spacing.
 *
 * PARAMETERS:
 *	SpacingAsDWord()	    
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/22/92		Initial Revision
 *
 ***********************************************************************/
#define CHILD_SPACING 15
#define WRAP_SPACING  15

@method VisSampCompClass, MSG_VIS_COMP_GET_CHILD_SPACING
{
    /* 
     * The child spacing is the horizontal spacing between children.
     * The wrap spacing is the distance between children if they are
     * wrapped; this is usually vertical.
     */

    return(MAKE_SPACING_DWORD(CHILD_SPACING, WRAP_SPACING));
}

/***********************************************************************
 *		MSG_VIS_COMP_GET_MARGINS for VisSampCompClass
 ***********************************************************************
 * SYNOPSIS:	This message is sent to the VisComp object when the
 *		geometry manager needs to set its margins. These
 *		margins restrict the area of the VisComp to be used to
 *		draw children. We set these margins to 10 units on
 *		each side.
 * 
 * PARAMETERS:
 *	void(rectangle *far retValue)	    
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/22/92		Initial Revision
 *
 ***********************************************************************/
#define SAMP_COMP_MARGIN 10

@method VisSampCompClass, MSG_VIS_COMP_GET_MARGINS 
{
  retValue->R_left = 	SAMP_COMP_MARGIN;
  retValue->R_right = 	SAMP_COMP_MARGIN;
  retValue->R_top = 	SAMP_COMP_MARGIN;
  retValue->R_bottom = 	SAMP_COMP_MARGIN;
}


/***********************************************************************
 *		MSG_VIS_COMP_GET_MINIMUM_SIZE for VisSampCompClass
 ***********************************************************************
 * SYNOPSIS:	This message is sent to the VisComp object when the
 *		geometry manager needs to set its minimum size. These
 *		margins restrict the area of the VisComp to be used to
 *		draw children. We set these margins to 10 units on
 *		each side.
 *  
 * PARAMETERS:
 *	SizeAsDWord()	    
 * SIDE EFFECTS:    
 *
 * STRATEGY:	We intercept this message to keep the VisComp from
 *		getting too small. We need it at least big enough to
 *		allow three children to wrap. 
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/22/92		Initial Revision
 *
 ***********************************************************************/
#define MINIMUM_BUTTON_WIDTH 210
#define MINIMUM_ROTARY_WIDTH 280

@method VisSampCompClass, MSG_VIS_COMP_GET_MINIMUM_SIZE 
{

    /* 
     * We set the width big enough so that the phone will always be
     * displayed. We don't set any minium height, however; the phone
     * may be visually hidden in the vertical direction.
     */

    if (pself->VSCI_state & VSCS_ROTARY_STYLE) {
    	return (MAKE_SIZE_DWORD(MINIMUM_ROTARY_WIDTH, 0));
    } else {
    	return (MAKE_SIZE_DWORD(MINIMUM_BUTTON_WIDTH, 0));
    }
}

/***********************************************************************
 *		MSG_VIS_SAMP_COMP_INC_DRAW_COLOR for VisSampCompClass
 ***********************************************************************
 * SYNOPSIS:	This message increments the color index by a value of
 *		one. When we rubn out of color indices, we reset that
 *		value to zero. After incrementing the color index,
 *		this message marks the object invalid so that it will 
 *		redraw in the new color index.
 * 
 * PARAMETERS:
 *	void()	    
 * SIDE EFFECTS:    
 *
 * STRATEGY:	There are sixteen color indices. If we increment to
 *		the value 15 (the sixteenth), we reset that value to
*		zero. 		
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/22/92		Initial Revision
 *
 ***********************************************************************/
@method VisSampCompClass, MSG_VIS_SAMP_COMP_INC_DRAW_COLOR 
{
    /*
     * Increment the draw color by one; if it's already 15, set it to
     * zero. 
     */
    pself->VSCI_drawColor = (pself->VSCI_drawColor + 1) & 15;

    /* 
     * Invalidate all the children so they redraw.
     */
    @send @visChildren::MSG_VIS_INVALIDATE();  
}


/***********************************************************************
 *		MSG_VIS_SAMP_COMP_GET_DRAW_COLOR for VisSampCompClass
 ***********************************************************************
 * SYNOPSIS:	This message returns the current draw color in use by
 *		the VisSampComp object.    
 * PARAMETERS:
 *	void()	    
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/22/92		Initial Revision
 *
 ***********************************************************************/
@method VisSampCompClass, MSG_VIS_SAMP_COMP_GET_DRAW_COLOR 
{
    return(pself->VSCI_drawColor);
}

/***********************************************************************
 *
 * Handlers for VisSampNumberClass
 *
 ***********************************************************************/


/***********************************************************************
 *		MSG_VIS_DRAW for VisSampNumberClass
 ***********************************************************************
 * SYNOPSIS:	This message draws each VisSampNumber object whenever
 *		that object needs to be redrawn. If the object is part
 *		of a rotary phone, it will draw an elliptical (or
 *		circular) moniker for the number. If the object is not
 *		part of a rotary phone, it will draw a rectangular (or
 *		square) moniker for the number.
 *
 * PARAMETERS:	
 *	void(word drawFlags, GStateHandle gstate)
 *    
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * CAVEATS:	This method does not work in black & white systems.
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/22/92		Initial Revision
 *
 ***********************************************************************/

/*
 *		MSG_VIS_DRAW
 *
 * The visible tree will have to redraw itself whenever a portion of
 * its GenView window becomes newly exposed. When this happens, the
 * GenView will send MSG_META_EXPOSED to the VisContent object. The 
 * VisContent object will create a drawing gstate for its own use,
 * figure out which portion of the content is invalid, and send
 * MSG_VIS_DRAW to itself. The VisContent will then pass MSG_VIS_DRAW
 * to its children with the passed gstate.
 *  
 * All subclasses of VisClass that wish to be drawn must intercept
 * MSG_VIS_DRAW. This message is sent to the visible object tree
 * whenever a portion of that tree may need a visual update.
 * Intercepting this message is one of the most basic ways to
 * define the drawing behavior of objects in the vis tree.
 */
@method VisSampNumberClass, MSG_VIS_DRAW 
{
    ChunkHandle moniker;
    byte parentState;
    word leftTopColor, rightBottomColor, fillColor;

    /*
     * First we find out if the number is within a rotary phone or a
     * normal touch-tone phone.
     */
    parentState = @call @visParent::MSG_VIS_SAMP_COMP_GET_STATE();

    /*
     * Then we set the font and text color for the number's moniker to
     * be drawn in.
     */
    GrSetFont(gstate, FID_DTC_URW_SANS, MakeWWFixed(NUMBER_TEXT_HEIGHT));
    GrSetTextColor(gstate, CF_INDEX, C_BLACK, 0, 0);

    /*
     * Normally, the number will not be selected. In this case, we
     * fill the number region with the current draw color. We also set
     * the left-top edges to white and the right-bottom edges to black
     * to provide shading.
     *   
     * If the number is currently selected (the user has clicked on
     * it) we will use a different color scheme, setting the
     * background color to dark grey. We also set the edges to their
     * 'reverse' values to get that 'reverse video' look.
     */

    if (pself->VSNI_state & VSNS_SELECTED) {
	leftTopColor = C_BLACK;
	rightBottomColor = C_WHITE;
	fillColor = C_DARK_GREY;
    }

    /*
     * Number is not selected. Set background to the current draw
     * color.  
     */
    else {
	leftTopColor = C_WHITE;
	rightBottomColor = C_BLACK;
	fillColor = @call @visParent::MSG_VIS_SAMP_COMP_GET_DRAW_COLOR(); 
    }


    if (parentState & VSCS_ROTARY_STYLE) {

	/* 
	 * For a rotary phone, we'll draw an ellipse to place the
	 * moniker in. If the item is a numerical value (i.e. "1") its
	 * visual bounds will be sufficiently symmetrical to draw the
	 * ellipse as a circle.
	 * 
	 * Our coordinates for the right and bottom should be one
	 * point less from the edge, to guarantee that the thing draws
	 * inside its bounds under the point->pixel mapping of
	 * the graphics system.
	 */

	/* We set the background color to the fillColor value. */
	GrSetAreaColor(gstate, CF_INDEX, fillColor, 0, 0);
	GrFillEllipse(gstate, 	pself->VI_bounds.R_left,
				pself->VI_bounds.R_top,
				pself->VI_bounds.R_right-1,
				pself->VI_bounds.R_bottom-1);

	GrSetLineColor (gstate, CF_INDEX, leftTopColor, 0, 0);
	GrDrawArc(gstate, 
		  pself->VI_bounds.R_left,
		  pself->VI_bounds.R_top,
		  pself->VI_bounds.R_right,
		  pself->VI_bounds.R_bottom,
		  0, 
		  200,
		  ACT_PIE);
	GrSetLineColor (gstate, CF_INDEX, rightBottomColor, 0, 0);
	GrDrawArc(gstate, 
		  pself->VI_bounds.R_left,
		  pself->VI_bounds.R_top,
		  pself->VI_bounds.R_right,
		  pself->VI_bounds.R_bottom,
		  200, 
		  400,
		  ACT_PIE);
    } 
    /*
     * Otherwise, the parentState specifies a touch-tone type display.
     */
    else {
	
	/*
	 * For a touch-tone number, we will represent our numbers as
	 * rectangles. For numerical values (i.e. "9") the number's
	 * visual bounds will be sufficiently symmetrical to draw the
	 * rectangle as a square. 
	 */
	GrSetAreaColor (gstate, CF_INDEX, fillColor, 0, 0);
	GrFillRect (gstate, 	pself->VI_bounds.R_left,
				pself->VI_bounds.R_top,
				pself->VI_bounds.R_right,
				pself->VI_bounds.R_bottom);

	/*
	 * Because of the nature of line drawing in the graphics
	 * system, we have to subtract one from both right and bottom
	 * edges as we draw. Here we draw the outlines of the numbers
	 * with the appropriate top-left and bottom-right colors to
	 * provide shading.
	 */

	/* 
	 * Set the line color for the left and top edges of the
	 * number.  
	 */
	GrSetLineColor (gstate, CF_INDEX, leftTopColor, 0, 0);
	
	/* Draw the top edge line. */
	GrDrawVLine (gstate, 	pself->VI_bounds.R_left,
				pself->VI_bounds.R_top,
				pself->VI_bounds.R_bottom-2);

	/* Draw the left edge line. */
	GrDrawHLine (gstate, 	pself->VI_bounds.R_left,
				pself->VI_bounds.R_top,
				pself->VI_bounds.R_right-2);

	/* 
	 * Set the line color for the right and bottom edges of the
	 * number.
	 */ 
	GrSetLineColor (gstate, CF_INDEX, rightBottomColor, 0, 0);
	
	/* Draw the right edge line. */
	GrDrawVLine (gstate, pself->VI_bounds.R_right-1,
			             pself->VI_bounds.R_top,
			             pself->VI_bounds.R_bottom-2);

	/* Draw the bottom edge line. */
	GrDrawHLine (gstate, pself->VI_bounds.R_left+1,
			             pself->VI_bounds.R_bottom-1,
			             pself->VI_bounds.R_right-2);

	/* 
	 * Draw the right edge line one pixel higher to "double" its
	 * width.
	 */
 	GrDrawVLine (gstate, pself->VI_bounds.R_right-1,
			             pself->VI_bounds.R_top+1,
			             pself->VI_bounds.R_bottom-1);
	
	/*
	 * Draw the bottom edge line one pixel to the left to "double"
	 * its width.
	 */
	GrDrawHLine (gstate, pself->VI_bounds.R_left+1,
			             pself->VI_bounds.R_bottom-1,
			             pself->VI_bounds.R_right-1);
    }

    /*
     * Now we decide what text to draw within the visible bounds
     * by finding out if the VisSampNumberState specifies to use
     * the long text moniker (I.e. "One") or the short moniker
     * (i.e. "1").
     */
    if (pself->VSNI_state & VSNS_LONG_TEXT) {
	moniker = pself->VSNI_longMoniker;
    } else {
	moniker = pself->VSNI_shortMoniker;
    }

    /* 
     * Draw the selected moniker.
     */
    @call self::MSG_VIS_DRAW_MONIKER(
	(J_CENTER << DMF_Y_JUST_OFFSET) | (J_CENTER << DMF_X_JUST_OFFSET),
	moniker, 36, gstate, 0, 0, 0, 0);
}


/***********************************************************************
 *		MSG_VIS_POSITION_BRANCH for VisSampNumberClass
 ***********************************************************************
 * SYNOPSIS:	This message is sent out by the geometry manager when
 *		it needs to positions Vis objects. We intercept it
 *		here so that we can draw our Vis objects at the
 *		correct locations depending on the VisSampComp state
 *		(rotary or touch-tone).
 *  
 * PARAMETERS:
 *	void(word xOffset, word yOffset)
 *	    
 * SIDE EFFECTS:    
 *
 * STRATEGY:	In rotary mode, we ignore the passed offsets and do
 *		our own positioning.
 *		
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/22/92		Initial Revision
 *
 ***********************************************************************/
@method VisSampNumberClass, MSG_VIS_POSITION_BRANCH 
{
    byte parentState;
    word newXOrigin, newYOrigin;
    word phoneIncrement;
    SizeAsDWord availSize;
    Rectangle parentBounds;

    /* 
     * First we retrieve the parent's (VisSampComp) state. If its not
     * a rotary phone, we'll position ourselves as our parent asked,
     * or we'll force our position based on the position hints in the
     * instance data.
     *
     * If its a rotary phone, we'll position the child using custom
     * values.   
     */

    parentState = @call @visParent::MSG_VIS_SAMP_COMP_GET_STATE();
	
    if (parentState & VSCS_ROTARY_STYLE) {
	
	availSize = @call MySampComp::MSG_VIS_GET_SIZE();

	/*
	 * Make the phone increment based on either the height or the
	 * width of the VisComp object (whichever is greater). Divide
	 * this value by 13. 
	 */
	phoneIncrement = 
		  ((DWORD_WIDTH(availSize) > DWORD_HEIGHT(availSize)) ?
		     DWORD_HEIGHT(availSize) : DWORD_WIDTH(availSize));

	phoneIncrement /= 13;

	/*
	 * Get the parent's bounds and use the left and top bounds as
	 * offsets to begin drawing the object. The object offsets are
	 * stored as part of instance data.
	 */
	@call @visParent::MSG_VIS_GET_BOUNDS(&parentBounds);

	newXOrigin = phoneIncrement * pself->VSNI_xOffset
		             + parentBounds.R_left;
	newYOrigin = phoneIncrement * pself->VSNI_yOffset
		             + parentBounds.R_top;
	@call self::MSG_VIS_SET_POSITION(newXOrigin, newYOrigin);
      }

    /*
     * If the phone is not rotary, let the superclass do the
     * default positioning (arranging horizontally and wrapping
     * with a child count of 3).
     */ 
    else {
      @callsuper();
    }
}


/***********************************************************************
 *		MSG_VIS_SAMP_NUMBER_SET_STATE for VisSampNumberClass
 ***********************************************************************
 * SYNOPSIS:	This message sets the state of the VisSampNumber
 *		object, setting and clearing the states using the
 *		passed bitfields.
 *    
 * PARAMETERS:
 *	void (byte stateToSet, byte stateToClear)	    
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/22/92		Initial Revision
 *
 ***********************************************************************/
@method VisSampNumberClass, MSG_VIS_SAMP_NUMBER_SET_STATE 
{
	pself->VSNI_state |= stateToSet;
	pself->VSNI_state &= ~stateToClear;
}

/***********************************************************************
 *		MSG_VIS_SAMP_NUMBER_GET_STATE for VisSampNumberClass
 ***********************************************************************
 * SYNOPSIS:	This message reteives the state of the VisSampNumber
 *		object.
 *     
 * PARAMETERS:
 *	byte()	    
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/22/92		Initial Revision
 *
 ***********************************************************************/
@method VisSampNumberClass, MSG_VIS_SAMP_NUMBER_GET_STATE 
{
	return(pself->VSNI_state);
}


/***********************************************************************
 *		MSG_VIS_RECALC_SIZE for VisSampNumberClass
 ***********************************************************************
 * SYNOPSIS:	This message sets the size of a VisSampNumber object
 *		when the geometry manager needs to calculate that
 *		size. This is used whenever the object changes its
 *		moniker, so that the bounds of the object can be
 *		lengthened or shortened to fit the new moniker.
 *
 * PARAMETERS:
 *	SizeAsDWord (word width, word height)	    
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/22/92		Initial Revision
 *
 ***********************************************************************/
#define	NUMBER_Y_INSET	6
#define NUMBER_X_INSET  6

@method VisSampNumberClass, MSG_VIS_RECALC_SIZE 
{
	word retWidth;
	word retHeight;
	ChunkHandle moniker;
	SizeAsDWord monikerSize;
	GStateHandle gstate;
	VisMoniker *monikerPtr;

	/* 
	 * First, we create a gstate. 
	 */
	gstate = @call self::MSG_VIS_VUP_CREATE_GSTATE();

	/*
	 * We set the font for this gstate, so that when we calculate
	 * the size it will be what we expect.
	 */
        GrSetFont(gstate, FID_DTC_URW_SANS, MakeWWFixed(NUMBER_TEXT_HEIGHT));

	/*
	 * We want the ChunkHandle of the moniker currently in use by
	 * this object. We check in what moniker state it is in and
	 * assign the moniker handle to the appropriate value. 
	 */
	if (pself->VSNI_state & VSNS_LONG_TEXT) {
		moniker = pself->VSNI_longMoniker;
	} else {
		moniker = pself->VSNI_shortMoniker;
	}

	/* 
	 * Unfortunately, since we're using a non-system font, we have to
	 * ignore hinted moniker width values generated by goc.
	 *
	 */
	monikerPtr = LMemDerefHandles(OptrToHandle(oself), moniker);
	if (monikerPtr->VM_width & VMCW_HINTED) {
	    monikerPtr->VM_width = 0;
	}
	

	/* 
	 * Now, we get the size of the moniker, including our margins.
	 * This moniker size is a DWord, returning the width in the
	 * high word and the height in the low word.
	 */
	monikerSize = @call self::MSG_VIS_GET_MONIKER_SIZE(
	   (J_CENTER << DMF_Y_JUST_OFFSET) | (J_CENTER << DMF_X_JUST_OFFSET),
	   moniker, 0, gstate, 0, 0, 0, 0);

	/* 
	 * Extract the information from this DWord and add the proper
	 * insets. 	
	 */
	retWidth = DWORD_WIDTH(monikerSize) + NUMBER_X_INSET*2;
	retHeight = DWORD_HEIGHT(monikerSize) + NUMBER_Y_INSET*2;

	/* 
	 * If the object is using its small text moniker, we take the
	 * larger of the width and height, and return it for both 
	 * the width and the height. This will make the object
	 * circular if building a rotary phone and square if building
	 * a touch-tone phone.
	 */
	if (!(pself->VSNI_state & VSNS_LONG_TEXT)) {
	  if (retWidth < retHeight) {
	    retWidth = retHeight;
	  } else {
	    retHeight = retWidth;
	  }
	}
	
	/* Make sure to destroy our gstate after we're done with it. */ 
	GrDestroyState(gstate);

	/* Return the size as a DWord. */
	return(MAKE_SIZE_DWORD(retWidth, retHeight));
}


/***********************************************************************
 *				EnsureSelectedState
 ***********************************************************************
 * SYNOPSIS:	This routine checks whether a VisSampNumber object is
 *		still currently selected; (the user has clicked and
 *		held on the object).
 *    
 * CALLED BY:	Various message handlers for VisSampNumberClass
 *		(MSG_META_START_SELECT, MSG_META_PTR, and
 *		MSG_VIS_LOST_GADGET_EXCL)
 *    
 * RETURN:	-1		object is not selected 		
 *		 0		object is selected    
 * SIDE EFFECTS:    
 *
 * STRATEGY:	    
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/23/92		Initial Revision
 *
 ***********************************************************************/
byte EnsureSelectedState(byte newState, byte *oldState) {
  if (newState) {
    if (!(*oldState & VSNS_SELECTED)) {
      *oldState = *oldState | VSNS_SELECTED;
      return (-1);
    } else {
      return (0);
    }
  } else {
    if (*oldState & VSNS_SELECTED) {
      *oldState = *oldState & ~VSNS_SELECTED;
      return (-1);
    } else {
      return (0);
    }
  }
}


/***********************************************************************
 *		MSG_META_START_SELECT for VisSampNumberClass
 ***********************************************************************
 * SYNOPSIS:	This message is sent to the VisSampNumber object
 *		whenever the user initiates a select-click within its
 *		visual bounds.     
 * PARAMETERS:	
 *	void (word xPosition, word yPosition, word inputState,
 *					MouseReturnParams *retVal)
 *    
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/23/92		Initial Revision
 *
 ***********************************************************************/
@method VisSampNumberClass, MSG_META_START_SELECT 
{
    /*
     * The user has clicked on the object, so we set our
     * VisSampNumberState to VSNS_MOUSE_DOWN.
     */
    pself->VSNI_state = pself->VSNI_state | VSNS_MOUSE_DOWN;

    /* 
     * Grab the mouse, and make sure we get pointer events. When an
     * object grabs the mouse, it requests that the UI send all future
     * mouse events directly to that object. This object now has the
     * 'active grab' for the mouse (and should intercept MSG_META_PTR
     * events, which will now be sent directly to this object).
     * (Normally, mouse events will travel down the visible tree until
     * they reach the leaf object below the pointer or an object along
     * the way that handles them; these objects have the 'implied
     * grab.' 
     *
     * We also take the gadget exclusive. 
     */
    @call self::MSG_VIS_GRAB_MOUSE();
    @call @visParent::MSG_VIS_TAKE_GADGET_EXCL(oself);

    /* 
     * If the object is still selected, we tell it to redraw itself.
     * (VisSampNumberClass objects that are selected will be drawn
     * differently.)  
     */
    if (EnsureSelectedState(VSNS_SELECTED, &(pself->VSNI_state))) {

	/* This calls MSG_VIS_DRAW if the object is VA_DRAWABLE. */
    	@call self::MSG_VIS_REDRAW_ENTIRE_OBJECT();
    }

    /* 
     * We're done, so we want to return to the default cursor
     * in case someone else set a special cursor previously.
     */
    retVal->flags = (MRF_PROCESSED | MRF_CLEAR_POINTER_IMAGE);
}


/***********************************************************************
 *		MSG_META_END_SELECT for VisSampNumberClass
 ***********************************************************************
 * SYNOPSIS:	This message is sent out when the user releases the
 *		mouse from a previously selected VisSampNumberClass
 *		object.     
 * PARAMETERS:
 *	void (word xPosition, word yPosition, word inputState,
 *				MouseReturnParams *retVal)
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/23/92		Initial Revision
 *
 ***********************************************************************/
@method VisSampNumberClass, MSG_META_END_SELECT 
{
    /* 
     * Release the gadget exclusive, which will cause a
     * MSG_VIS_LOST_GADGET_EXCL to arrive at our object.
     */
    @call @visParent::MSG_VIS_RELEASE_GADGET_EXCL(oself);

    /* 
     * Say user has surrendered the mouse, and let some other object
     * use the message if they want it. (Then MSG_META_END_SELECT
     * will be sent to the object with the implied grab.)
     */
    retVal->flags = MRF_REPLAY;
}


/***********************************************************************
 *		MSG_META_PTR for VisSampNumberClass
 ***********************************************************************
 * SYNOPSIS:	This message handles pointer events once the
 *		VisSampNumber object has the mouse grab. This handler
 *		determines if the mouse is still within the visible
 *		bounds of the object or has roamed outside its bounds.
 *     
 * PARAMETERS:	
 *	void (word xPosition, word yPosition, word inputState,
 *					MouseReturnParams *retVal)
 *    
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/22/92		Initial Revision
 *
 ***********************************************************************/
@method VisSampNumberClass, MSG_META_PTR 
{
    /* 
     * If the user moves off the button, and it's currently selected,
     * we'll deselect it.  If the user moves over the button, and it's
     * currently not selected, we'll reselect it. This "selection"
     * criteria is only related to the object's internal state. It
     * will still have the mouse grab and gadget exclusive until it
     * receives a MSG_META_END_SELECT when the user releases the
     * mouse. 
     *
     * Note that an object would only be reselected when the pointer
     * moves over its image if the object has previously grabbed the
     * mouse without releasing it. (This will only happen if the user
     * clicks on the object, moves the mouse outside the object and
     * moves it back over the object without releasing the button.)
     */

    /*
     * If the mouse is no longer down, send this message on to the
     * object with the implied grab.
     */
    if (!(pself->VSNI_state & VSNS_MOUSE_DOWN)) {
    	retVal->flags = MRF_REPLAY;
    } 
    else {

	/* 
	 * Check if the pointer is currently outside the object
	 * bounds. 
	 */
    	if ((xPosition < pself->VI_bounds.R_left) ||
      		(xPosition > pself->VI_bounds.R_right) ||
     	 	(yPosition < pself->VI_bounds.R_top) ||
      		(yPosition > pself->VI_bounds.R_bottom)) {

      	    /* 
	     * We are outside, so teh user has moved off of the button.
	     * We make sure the object is deselected.
	     */ 
      	    if (EnsureSelectedState(0, &(pself->VSNI_state))) {
            	@call self::MSG_VIS_REDRAW_ENTIRE_OBJECT();
      	    }
    
    	} 
	else {

      	    /* 
	     * Otherwise, the user is over the object, so we make sure
	     * it is still selected.
	     */
	    if (EnsureSelectedState(VSNS_SELECTED, &(pself->VSNI_state))) {
        	@call self::MSG_VIS_REDRAW_ENTIRE_OBJECT();
      	    }
    	}
   	/* 
	 * We've handled this method, and we want to return to the
	 * default cursor in case someone else set a special cursor
	 * previously. 
	 */
    	retVal->flags = MRF_PROCESSED | MRF_CLEAR_POINTER_IMAGE;
    }
}


/***********************************************************************
 *		MSG_VIS_LOST_GADGET_EXCL for VisSampNumberClass
 ***********************************************************************
 * SYNOPSIS:	This message handles the case where the gadget
 *		exclusive is removed from the object before its
 *		release. This may be done by the specific UI in some
 *		circumstances, and you should have a message handler
 *		for those cases.
 * 
 * PARAMETERS:
 *	void()	    
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	TM	10/22/92		Initial Revision
 *
 ***********************************************************************/
@method VisSampNumberClass, MSG_VIS_LOST_GADGET_EXCL {

    /* We only care if the object has been selected. */
    if (pself->VSNI_state & VSNS_MOUSE_DOWN) {

	/* Remove the "mouse down" state from the object. */
      	pself->VSNI_state = pself->VSNI_state & ~VSNS_MOUSE_DOWN;

      	/* Release the mouse grab */
      	@call self::MSG_VIS_RELEASE_MOUSE();

      	if (EnsureSelectedState(0, &(pself->VSNI_state))) {
	    /*
             * Yes, the object was selected.  Let's redraw it and do
	     * whatever our desired action should be.
	     */
            @call self::MSG_VIS_REDRAW_ENTIRE_OBJECT();

	    /* 
	     * Change states to use the other moniker, aand invalidate
	     * the object's geometry and image so it will recalculate
	     * its geometry. (If the object changes size when geometry
	     * is calculated, it will automatically invalidate its
	     * image, but in case the size doesn't change we want to
	     * make sure we redraw it anyway. 
	     */
	    pself->VSNI_state = pself->VSNI_state ^ VSNS_LONG_TEXT;
	    @call self::MSG_VIS_MARK_INVALID(
			VOF_GEOMETRY_INVALID | VOF_IMAGE_INVALID,
                	VUM_NOW);
      	}
    }
}
