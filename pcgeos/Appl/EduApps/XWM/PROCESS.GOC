/***********************************************************************
 *Copyright 1994-2001 Breadbox Computer Company LLC  All Rights Reserved
 *
 * PROJECT:	Breadbox Crossword Maker
 * FILE:		process.goc
 * AUTHOR:	John Howard   11/01
 *
 *
 *
 *
 ***********************************************************************/

@include "xwm.goh"
@include "externs.goh"

/***************************************************************************
 * Globals
 **************************************************************************/

VMFileHandle g_fhDocument = NullHandle;
optr g_oDocument = NullHandle;
VMBlockHandle g_bhDocHeap = NullHandle;
ChunkHandle g_chDocWordList = NullChunk;
ChunkHandle g_chDocWordGrid = NullChunk;
ChunkHandle g_chDocAnswers = NullChunk;
Boolean g_bWSInitialized = FALSE;
Boolean g_onYago = FALSE;
word g_numPlaced = 0;
word g_width = GRID_DEFAULT_SIZE;
word g_height = GRID_DEFAULT_SIZE;
word g_settings = 0;
word g_cellNum = 0;
word g_geosCellNum = 0;
word g_cellNumArray[GRID_MAX_SIZE][GRID_MAX_SIZE];
word g_geosCellNumArray[GRID_MAX_SIZE][GRID_MAX_SIZE];

/***************************************************************************
 * Class declarations
 **************************************************************************/


@classdecl XWMProcessClass, neverSaved;
@classdecl XWMDocumentControlClass;

/* methods in export.goc file */
@extern method XWMProcessClass, MSG_XWM_PROCESS_OPEN_EXPORT_DB;
@extern method XWMProcessClass, MSG_XWM_PROCESS_MAKE_PZL;
@extern method XWMProcessClass, MSG_XWM_PROCESS_MAKE_XWORD;
/* and in import.goc */
@extern method XWMProcessClass, MSG_XWM_IMPORT_WORD_LIST;
@extern method XWMProcessClass, MSG_XWM_IMPORT_SELECTOR_ACTION;

/***************************************************************************
 * XWMProcessClass methods
 **************************************************************************/
 
/***********************************************************************
 *
 * MESSAGE:	MSG_GEN_PROCESS_OPEN_APPLICATION for XWMProcessClass
 *
 * DESCRIPTION:	 check if we're on a yago
 *
 *
 *
 ***********************************************************************/
@method XWMProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
Boolean		initReadErr, makePZL;
char			uiStr[50];
word			size;


	 /* see if we are to show the export to .PZL trigger */
	 initReadErr = InitFileReadBoolean("XWM", "MakePZL", &makePZL);
	 if (!initReadErr && makePZL)
		@send XWMMakePuzzleTrigger::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	 else
	 	@send XWMMakePuzzleTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);

	 /* if we're on a Yago machine set the flag */
    initReadErr = InitFileReadStringBuffer("ui",
								 "specific",
								 &uiStr,
								 50,
								 &size);
    if (!initReadErr)  {
	  if (!strcmp(uiStr, "yago.geo")) {
		/* it is a Bro UI...
		 * now check to see if it is BroWorks on a PC */
		initReadErr = InitFileReadStringBuffer("ui",
								 "productName",
								 &uiStr,
								 50,
								 &size);

		if (strcmp(uiStr, "Yago PC-Demo"))  g_onYago = TRUE;
		}
	  }

    @callsuper();

}

 /***************************************************************************
 * MSG_GEN_PROCESS_INSTALL_TOKEN
 ***************************************************************************
 * SYNOPSIS:    Sent by desktop to get process to install its token and
 *              moniker lists.
 *
 * PARAMETERS:  none
 *
 * STRATEGY:    Call the superclass to install the application icon.
 *              Check and install the document icon.
 *
 **************************************************************************/
@method XWMProcessClass, MSG_GEN_PROCESS_INSTALL_TOKEN
{
	 dword tokenChars;
    TokenFlags tokenFlags;

    /* Install application icon. */
	 @callsuper();
    
	 tokenChars = TOKEN_CHARS('X', 'W', (dword) 'M',(dword) 'd');

    if (!TokenGetTokenInfo(tokenChars, MANUFACTURER_ID_BREADBOX, &tokenFlags))
        TokenDefineToken(tokenChars, MANUFACTURER_ID_BREADBOX,
          @XWMDocIconList, 0);
}

/***************************************************************************
 * MSG_META_DOC_OUTPUT_INITIALIZE_DOCUMENT_FILE
 ***************************************************************************
 * SYNOPSIS:    Called by GenDocumentController to initialize a new file.
 *
 * PARAMETERS:  optr        document,
 *              FileHandle  file
 *
 * STRATEGY:    Allocate and initialize the word list block.
 *              Allocate and initialize the map block.
 *
 **************************************************************************/
@method XWMProcessClass, MSG_META_DOC_OUTPUT_INITIALIZE_DOCUMENT_FILE
{
MemHandle		mh/*, mhMapBlock*/;
VMBlockHandle	bhMapBlock/*, bhHeap = NullHandle*/;
VMBlockHandle	gridVMBHandle, listVMBHandle, answVMBHandle;
MemHandle      gridHeapHandle, listHeapHandle, answHeapHandle;
XWMDocumentMap *pMap;
//XWMHeader		*pxwmh;


	g_fhDocument = file;

	/* Create a VM block for the list ------------------ */
	listVMBHandle = VMAlloc(file, 2048, LIST);
	/* create a mem block to attach to it */
	listHeapHandle = MemAlloc(2048, HF_SWAPABLE, HAF_LOCK);
	LMemInitHeap(listHeapHandle, LMEM_TYPE_GENERAL, 0,
				 sizeof(LMemBlockHeader), STD_INIT_HANDLES, STD_INIT_HEAP);
	/* create the chunk array  */
	g_chDocWordList = ChunkArrayCreate(listHeapHandle, sizeof(XWMListElement), 0, 0);
	MemUnlock(listHeapHandle);
	/* and attach the block to the VM - */
	VMAttach(file, listVMBHandle, listHeapHandle);

	/* Create a VM block for the answers ------------------ */
	answVMBHandle = VMAlloc(file, 2048, ANSW);
	/* create a mem block to attach to it */
	answHeapHandle = MemAlloc(2048, HF_SWAPABLE, HAF_LOCK);
	LMemInitHeap(answHeapHandle, LMEM_TYPE_GENERAL, 0,
				 sizeof(LMemBlockHeader), STD_INIT_HANDLES, STD_INIT_HEAP);
	/* create the chunk array  */
	g_chDocAnswers = ChunkArrayCreate(answHeapHandle, sizeof(XWMAnswerElement), 0, 0);
	MemUnlock(answHeapHandle);
	/* and attach the block to the VM - */
	VMAttach(file, answVMBHandle, answHeapHandle);

	/* Create a VM block for the grid ------------------ */
	gridVMBHandle = VMAlloc(file, 2048, GRID);
	/* create a mem block to attach to it */
	gridHeapHandle = MemAlloc(2048, HF_SWAPABLE, HAF_LOCK);
	LMemInitHeap(gridHeapHandle, LMEM_TYPE_GENERAL, 0,
				 sizeof(LMemBlockHeader), STD_INIT_HANDLES, STD_INIT_HEAP);
	/* create the chunk array -- NOTE: variable sized elements  */
	g_chDocWordGrid = ChunkArrayCreate(gridHeapHandle, 0, 0, 0);
	MemUnlock(gridHeapHandle);
	/* and attach the block to the VM - */
	VMAttach(file, gridVMBHandle, gridHeapHandle);

	/* Allocate, set, and lock the map block. */
	bhMapBlock = VMAlloc(file, sizeof(XWMDocumentMap), 0);
	VMSetMapBlock(file, bhMapBlock);
	pMap = VMLock(file, bhMapBlock, &mh);
	/* Record the handles to the arrays in the map block. */
//	pMap->XWMDM_heapBlock = bhHeap;
	pMap->XWMDM_wordListChunk = g_chDocWordList;
	pMap->XWMDM_wordSearchChunk = g_chDocWordGrid;
	pMap->XWMDM_answersChunk = g_chDocAnswers;
	/* Set the word grid defaults. */
	pMap->XWMDM_width = GRID_DEFAULT_SIZE;
	pMap->XWMDM_height = GRID_DEFAULT_SIZE;
	pMap->XWMDM_settings = XWMS_SQUARE | XWMS_ANSWERS;
	VMDirty(mh);
	VMUnlock(mh);

	/* Initialize the word search. */
	XWMInitializePuzzle();

	return FALSE;

}

/***************************************************************************
 * MSG_META_DOC_OUTPUT_CREATE_UI_FOR_DOCUMENT
 ***************************************************************************
 * SYNOPSIS:    Called by GenDocumentController to create UI for the doc.
 *
 * PARAMETERS:  optr        document,
 *              FileHandle  file
 *
 * STRATEGY:    Enable the document control UI.
 *              Initialize the random number generator.
 *
 **************************************************************************/
@method XWMProcessClass, MSG_META_DOC_OUTPUT_CREATE_UI_FOR_DOCUMENT
{
	@send XWMDocumentUIGroup::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);
	@send XWMSettingsGroup::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);
	MyRandom(0); MyRandom(0); MyRandom(0); MyRandom(0);

}

/***************************************************************************
 * MSG_META_DOC_OUTPUT_ATTACH_UI_TO_DOCUMENT
 ***************************************************************************
 * SYNOPSIS:    Called by GenDocumentController to setup UI for the doc.
 *
 * PARAMETERS:  optr        document,
 *              FileHandle  file
 *
 * STRATEGY:    Setup the document UI.
 *
 **************************************************************************/
@method XWMProcessClass, MSG_META_DOC_OUTPUT_ATTACH_UI_TO_DOCUMENT
{
MemHandle				mh;
VMBlockHandle			bhMapBlock, vmbh;
XWMDocumentMap			*pMap;
RectDWord				docBounds;
VisUpdateModeAsWord	vumaw = { VUM_MANUAL, 0 };
word						numWords;


	g_fhDocument = file;

	/* Load in the map block. */
	bhMapBlock = VMGetMapBlock(g_fhDocument);
	pMap = VMLock(g_fhDocument, bhMapBlock, &mh);
	/* Set global variables so we can quickly reference certain data. */
	g_fhDocument = file;
	g_chDocWordList = pMap->XWMDM_wordListChunk;
	g_chDocWordGrid = pMap->XWMDM_wordSearchChunk;
	g_chDocAnswers = pMap->XWMDM_answersChunk;
	g_width = pMap->XWMDM_width;
	g_height = pMap->XWMDM_height;
	g_settings = pMap->XWMDM_settings;
	VMUnlock(mh);

	/* Retrieve the size of the word list and initialize its UI. */
	vmbh = VMFind(g_fhDocument, 0, LIST);
	VMLock(g_fhDocument, vmbh, &mh);
	numWords = ChunkArrayGetCountHandles(mh, g_chDocWordList);
	VMUnlock(mh);
	@send XWMWordList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(numWords);
	if (numWords) {
		@send XWMWordList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(0, FALSE);
		@send XWMWordListDeleteTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
		@send XWMCluesTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
		@send XWMImportDialog::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
		}
	else {
      @send XWMImportDialog::MSG_GEN_SET_ENABLED(VUM_NOW);
		}
	EnableDisableFileUI(UI_ENABLE);

	/* Retrieve the size of the word search and set the view's
		document bounds. */
	XWMGetDocBounds(&docBounds);
	@send XWMDocumentView::MSG_GEN_VIEW_SET_DOC_BOUNDS(docBounds.RD_bottom,
			 docBounds.RD_right, docBounds.RD_top, docBounds.RD_left);
	/* Retrieve word search settings and initialize the UI. */
	@send XWMSettingsSizeWidth::MSG_GEN_VALUE_SET_INTEGER_VALUE(
			 g_width, FALSE);
	@send XWMSettingsSizeHeight::MSG_GEN_VALUE_SET_INTEGER_VALUE(
			 g_height, FALSE);
	@send XWMSettingsOther::MSG_GEN_BOOLEAN_GROUP_SET_GROUP_STATE(
			 g_settings, 0);

	/* Empty the word list add text object. */
	@send XWMWordListAddText::MSG_VIS_TEXT_DELETE_ALL();

	/* Set scaling attributes for the view now; otherwise, it will
		shrink to nothing with the initial zero bounds. */
	@send XWMDocumentView::MSG_GEN_VIEW_SET_ATTRS(GVA_SCALE_TO_FIT, 0, vumaw);

	/* Force the document view to scale and draw itself. */
	@send XWMDocumentView::MSG_VIS_MARK_INVALID(VOF_GEOMETRY_INVALID, VUM_NOW);
	@send XWMDocumentView::MSG_GEN_VIEW_REDRAW_CONTENT();
    
	/* Assume the word search isn't empty. */
	g_bWSInitialized = FALSE;
    
	/* Cache the document's object descriptor. */
	g_oDocument = document;

}

/***************************************************************************
 * MSG_META_DOC_OUTPUT_DETACH_UI_FROM_DOCUMENT
 ***************************************************************************
 * SYNOPSIS:    Called by GenDocumentController to break down UI for the doc.
 *
 * PARAMETERS:  optr        document,
 *              FileHandle  file
 *
 * STRATEGY:    Break down the document UI.
 *
 **************************************************************************/
@method XWMProcessClass, MSG_META_DOC_OUTPUT_DETACH_UI_FROM_DOCUMENT
{

	/* Empty the word list UI. */
	@send XWMWordList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(0);
	/* Empty the word list add text object. */
	@send XWMWordListAddText::MSG_VIS_TEXT_DELETE_ALL();

	/* Set the state of the settings UI to indeterminate. */
	@send XWMSettingsSizeWidth::MSG_GEN_VALUE_SET_INTEGER_VALUE(0, TRUE);
	@send XWMSettingsSizeHeight::MSG_GEN_VALUE_SET_INTEGER_VALUE(0, TRUE);
	@send XWMSettingsOther::MSG_GEN_BOOLEAN_GROUP_SET_GROUP_STATE(
		0, XWMS_SQUARE | XWMS_ANSWERS);

	/* Destroy global variables. */
	g_chDocWordGrid = NullChunk;
	g_chDocWordList = NullChunk;
	g_bhDocHeap = NullHandle;
	g_fhDocument = NullHandle;
	g_oDocument = NullHandle;

}

/***************************************************************************
 * MSG_META_DOC_OUTPUT_DESTROY_UI_FOR_DOCUMENT
 ***************************************************************************
 * SYNOPSIS:    Called by GenDocumentController to destroy UI for the doc.
 *
 * PARAMETERS:  optr        document,
 *              FileHandle  file
 *
 * STRATEGY:    Disable the document control UI and erase the view.
 *
 **************************************************************************/
@method XWMProcessClass, MSG_META_DOC_OUTPUT_DESTROY_UI_FOR_DOCUMENT
{
	@send XWMDocumentUIGroup::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);
	@send XWMSettingsGroup::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);

	/* Force the document view to empty. */
	@send XWMDocumentView::MSG_GEN_VIEW_REDRAW_CONTENT();

}

/***************************************************************************
 * MSG_META_DOC_OUTPUT_SAVE_AS_COMPLETED
 ***************************************************************************
 * SYNOPSIS:    Called by GenDocumentGroup when a "Save As" operation has
 *              been successfully completed.  Since we cache the file handle
 *              and a "Save As" will cause the document to adopt a new
 *              file handle, we MUST intercept this message and re-cache
 *              the new handle.
 *
 * PARAMETERS:  optr        document,
 *              FileHandle  file
 *
 * STRATEGY:    Store the new file handle.
 *
 **************************************************************************/
@method XWMProcessClass, MSG_META_DOC_OUTPUT_SAVE_AS_COMPLETED
{
	g_fhDocument = file;
}

/***************************************************************************
 * MSG_GEN_DOCUMENT_CONTROL_CONFIGURE_FILE_SELECTOR
 ***************************************************************************
 * SYNOPSIS:    Called to allow special configuration of the file selector
 *              used by the document control.
 *
 * PARAMETERS:  optr fileSelector,
 *              word flags
 *
 * STRATEGY:    See if our default folder is there and go there
 *              If not go to Document
 *              Set the file selector's path to the path.
 *
 **************************************************************************/
@method XWMDocumentControlClass, MSG_GEN_DOCUMENT_CONTROL_CONFIGURE_FILE_SELECTOR
{
Boolean		notThere;
DiskHandle	drive;
char			geoBookPath[50] = "\\GEOWORKS\\DOCUMENT\\";


	@callsuper();

	MemLock (OptrToHandle(@XWMFolderTxt));
	/* see if our default folder is in Document */
	if (!g_onYago)  {  /* for the desktop */
		notThere = @call fileSelector::MSG_GEN_PATH_SET
					 (LMemDeref(@XWMFolderTxt),
					 SP_DOCUMENT);
		}  /* end of desktop if */

	else  {  /* on a yago */
		drive = DiskRegisterDiskSilently(5); /* drive f */
		strcat(geoBookPath, LMemDeref(@XWMFolderTxt));
		notThere = @call fileSelector::MSG_GEN_PATH_SET(geoBookPath, drive);
		}  /* end of yago else */
	MemUnlock (OptrToHandle(@XWMFolderTxt));

	/* if it was there we're all set - if not just go to Document */
	if(notThere)  {
		@call fileSelector::MSG_GEN_PATH_SET(".", SP_DOCUMENT);
		}

}

/***************************************************************************
 * MSG_XWM_PROCESS_QUERY_WORD_LIST
 ***************************************************************************
 * SYNOPSIS:    Called by dynamic XWMWordList to define its items.
 *
 * PARAMETERS:  optr        list,
 *              word        item
 *
 * STRATEGY:    Retrieve the word from the list and call the replace method.
 *
 **************************************************************************/
@method XWMProcessClass, MSG_XWM_PROCESS_QUERY_WORD_LIST
{
MemHandle	mh;
VMBlockHandle	vmbh;
XWMListElement			*pElement;


	/* Lock the word list. */
	vmbh = VMFind(g_fhDocument, 0, LIST);
	VMLock(g_fhDocument, vmbh, &mh);

	/* Locate the requested item and set it in the dynamic list. */
	pElement = ChunkArrayElementToPtrHandles(mh, g_chDocWordList, item, 0);
	@call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_TEXT(item, pElement->XWMLE_word);

	VMUnlock(mh);

}

/***************************************************************************
 * XWMAddWord
 ***************************************************************************
 * SYNOPSIS:    Called by MSG_XWM_PROCESS_ADD_WORD &
 *                        MSG_XWM_IMPORT_WORD_LIST
 *
 * PARAMETERS:  char* wordToAdd
 *					 Returns: position in list if word added successfully,
 *                       error code if not
 *
 * STRATEGY:    Add the provided word to
 *              the word list, update the UI, and clear the text object.
 *              The word list is case-insensitive and is maintained 
 *              alphabetically.  Duplicates are prevented.
 *
 **************************************************************************/
word XWMAddWord(char* wordToAdd)
{
MemHandle	mh;
VMBlockHandle	vmbh;
XWMListElement			*pElement;
word			nStart = 0, nEnd, nMid, nSize;
sword			nResult;
Boolean		bFound = FALSE;
word			retVal;


		LocalUpcaseString(wordToAdd, 0);

		/* Lock the word list. */
		vmbh = VMFind(g_fhDocument, 0, LIST);
		VMLock(g_fhDocument, vmbh, &mh);

		/* Ensure that the list hasn't reached its maximum length. */
		if (ChunkArrayGetCountHandles(mh, g_chDocWordList) < WORD_LIST_MAX_SIZE) {
			/* Use a binary search method to locate the insertion point. */
			nSize = ChunkArrayGetCountHandles(mh, g_chDocWordList);
			nEnd = nSize - 1;
			while (nStart <= nEnd && nEnd != (word)(-1) && !bFound)  {
				/* Compare to the element midway between the endpoints. */
				nMid = nStart + (nEnd - nStart) / 2;
				pElement = ChunkArrayElementToPtrHandles(mh, g_chDocWordList, nMid, 0);
				nResult = LocalCmpStringsNoCase(wordToAdd, pElement->XWMLE_word, 0);
				if (!nResult)
					/* The strings are equal; the word is in the list. */
					bFound = TRUE;
				else if (nResult > 0)
					/* The new word should come after the midpoint. */
					nStart = nMid + 1;
				else if (nResult < 0)
					/* The new word should come before the midpoint. */
					nEnd = nMid - 1;
				}
			/* Ensure that the word was not found to prevent duplicates. */
			if (!bFound)  {
				/* nStart is the proper insertion point. Insert the word
					into the chunk array there. */
				if (nStart < nSize)
					/* Insert a new element within the array. */
					ChunkArrayInsertAtHandle(g_chDocWordList,
								  ChunkArrayElementToPtrHandles(mh, g_chDocWordList, nStart, 0), 0);
				else
					/* Append a new element to the array. */
					ChunkArrayAppendHandles(mh, g_chDocWordList, 0);

				/* Copy the new word into the new element. */
				pElement = ChunkArrayElementToPtrHandles(mh, g_chDocWordList, nStart, 0);
				strcpy(pElement->XWMLE_word, wordToAdd);
				pElement->XWMLE_placed = FALSE;
				pElement->XWMLE_clue[0] = 0;

				/* return the position in the list */
				retVal = nStart;

				VMDirty(mh);
				}  /* end of not dupe if */
			else {
				NotifyDBox(wordToAdd, @DupeWordMsg);
				retVal = ADD_WORD_DUPE;
				}
			} /* end of list not too long if */
		else {
			NotifyDBox(0, @ListTooLongMsg);
			retVal = ADD_WORD_LIST_FULL;
			}

		VMUnlock(mh);

      return(retVal);

}

/***************************************************************************
 * MSG_XWM_PROCESS_ADD_WORD
 ***************************************************************************
 * SYNOPSIS:    Called as apply method of XWMWordListAddText.
 *
 * PARAMETERS:  none
 *
 * STRATEGY:    Add the current text in the XWMWordListAddText object to
 *              the word list, update the UI, and clear the text object.
 *              The word list is case-insensitive and is maintained 
 *              alphabetically.  Duplicates are prevented.
 *
 **************************************************************************/
@method XWMProcessClass, MSG_XWM_PROCESS_ADD_WORD
{
MemHandle	mh;
VMBlockHandle	vmbh;
char			szNewWord[WORD_LIST_ELEMENT_SIZE];
word			wasAdded;


	if (@call XWMWordListAddText::MSG_VIS_TEXT_GET_ALL_PTR(szNewWord)
			 >= WORD_MIN_SIZE)  {

		wasAdded = XWMAddWord(szNewWord);

		if (wasAdded < ADD_WORD_DUPE) {
			/* Update the list UI. */
			@send XWMWordList::MSG_GEN_DYNAMIC_LIST_ADD_ITEMS(wasAdded, 1);
			@send XWMWordList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(wasAdded, FALSE);
			@call self::MSG_XWM_PROCESS_OPEN_CLUES_DB();

			/* Empty the word list add text object. */
			@send XWMWordListAddText::MSG_VIS_TEXT_DELETE_ALL();

			/* Clear the word search, as it no longer reflects the words. */
			XWMClearWordGrid();

			/* Enable UI if this was the first word */
			vmbh = VMFind(g_fhDocument, 0, LIST);
			VMLock(g_fhDocument, vmbh, &mh);
			if (ChunkArrayGetCountHandles(mh, g_chDocWordList) ==  1) {
				@send XWMWordListDeleteTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
				@send XWMCluesTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
				EnableDisableFileUI(UI_ENABLE);
				@send XWMImportDialog::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
				}
			VMUnlock(mh);
			}

		}  /* end of word not too short if */
	else NotifyDBox(szNewWord, @WordTooShortMsg);

}

/***************************************************************************
 * MSG_XWM_PROCESS_DELETE_WORD
 ***************************************************************************
 * SYNOPSIS:    Called as trigger method of XWMWordListDeleteTrigger.
 *
 * PARAMETERS:  none
 *
 * STRATEGY:    Delete the currently selected item in the XWMWordList
 *              object from the word list.
 *
 **************************************************************************/
@method XWMProcessClass, MSG_XWM_PROCESS_DELETE_WORD
{
MemHandle	mh;
VMBlockHandle	vmbh;
word			nSelection, numWords;
XWMListElement			*pElement;


	nSelection = @call XWMWordList::MSG_GEN_ITEM_GROUP_GET_SELECTION();
	if (nSelection != GIGS_NONE)  {
		/* Lock the word list. */
		vmbh = VMFind(g_fhDocument, 0, LIST);
		VMLock(g_fhDocument, vmbh, &mh);

		/* Get the item from the chunk array. */
		pElement = ChunkArrayElementToPtrHandles(mh, g_chDocWordList, nSelection, 0);
		/* and delete it */
		ChunkArrayDeleteHandle(g_chDocWordList, pElement);

		numWords = ChunkArrayGetCountHandles(mh, g_chDocWordList);

		VMDirty(mh);
		VMUnlock(mh);

		/* Update the list UI. */
		@send XWMWordList::MSG_GEN_DYNAMIC_LIST_REMOVE_ITEMS(nSelection, 1);

		/* if we del'd the last word disable the UI */
		if (!numWords) {
			EnableDisableFileUI(UI_DISABLE);
			@send XWMWordListDeleteTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
			@send XWMCluesTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	      @send XWMImportDialog::MSG_GEN_SET_ENABLED(VUM_NOW);
			}
		else
			@send XWMWordList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(0, FALSE);

		/* Clear the word search, as it no longer reflects the words. */
		XWMClearWordGrid();
		}

}

/***************************************************************************
 * MSG_XWM_PROCESS_CALCULATE
 ***************************************************************************
 * SYNOPSIS:    Called as trigger method of XWMCalculateTrigger and sent
 *              by apply methods of the settings UI.
 *
 * PARAMETERS:  none
 *
 * STRATEGY:    Calculate the word search, and display a warning if it
 *              could not be completed.
 *
 **************************************************************************/
@method XWMProcessClass, MSG_XWM_PROCESS_CALCULATE
{
Boolean bSuccess;


	/* Set busy UI states for the application. */
	@call application::MSG_GEN_APPLICATION_MARK_BUSY();
	@call application::MSG_GEN_APPLICATION_HOLD_UP_INPUT();

	/* Perform the word search calculation. */
	bSuccess = XWMCalculatePuzzle();

	/* Reset the application UI states. */
	@call application::MSG_GEN_APPLICATION_RESUME_INPUT();
	@call application::MSG_GEN_APPLICATION_MARK_NOT_BUSY();

	/* Display a warning if the calculation wasn't successful. */
	if (!bSuccess) {
		NotifyDBox(0, @XWNoFitTxt);
		}

}

/***************************************************************************
 * XWMMarkWordsNotPlaced
 ***************************************************************************
 * SYNOPSIS:    mark words in list as not placed
 *
 * STRATEGY:
 *
 *
 *
 *
 **************************************************************************/
void XWMMarkWordsNotPlaced(optr owl)
{
word			numWords, i;
XWMListElement			*pElement;


	/* mark words in list as not placed */
	numWords = ChunkArrayGetCount(owl);
	for (i = 0; i < numWords; i++) {
		pElement = ChunkArrayElementToPtr(owl, i, 0);
		pElement->XWMLE_placed = FALSE;
		}
   g_numPlaced = 0;

	g_bWSInitialized = TRUE;

}


/***************************************************************************
 * XWMInitializePuzzle
 ***************************************************************************
 * SYNOPSIS:    Initialize the word search and answers array.
 *
 * STRATEGY:    Reinitialize the chunk array to the correct size and fill
 *              with spaces.
 *              Zero the answers chunk array.
 *
 *
 **************************************************************************/
void XWMInitializePuzzle(void)
{
word			nRow, nCol;
char			*pRow;
VMBlockHandle	vmbh;
MemHandle		mh;


	vmbh = VMFind(g_fhDocument, 0, GRID);
	VMLock(g_fhDocument, vmbh, &mh);
	ChunkArrayZeroHandles(mh, g_chDocWordGrid);
	/* Append each column-sized row to the word search array. */
	for (nRow = 0; nRow < g_height; nRow ++)  {
		pRow = ChunkArrayAppendHandles(mh, g_chDocWordGrid, g_width);
		/* Initialize the row with spaces. */
		for (nCol = 0; nCol < g_width; nCol ++)
			*(pRow++) = GRID_SPACE;
		}
	VMDirty(mh);
	VMUnlock(mh);

	vmbh = VMFind(g_fhDocument, 0, ANSW);
	VMLock(g_fhDocument, vmbh, &mh);
	ChunkArrayZeroHandles(mh, g_chDocAnswers);
	VMDirty(mh);
	VMUnlock(mh);

	g_bWSInitialized = TRUE;

}

/***************************************************************************
 * XWMClearWordGrid
 ***************************************************************************
 * SYNOPSIS:    Clear the word search and redraw the view.  This should
 *              be done whenever a change is made to the document which
 *              causes the word search to be invalid.
 *
 * STRATEGY:    Initialize the word search.
 *              Redraw the view.
 *
 **************************************************************************/
void XWMClearWordGrid(void)
{

	if (!g_bWSInitialized)  {

		/* Initialize the word search. */
		XWMInitializePuzzle();
    
		/* Redraw the view. */
		@send, forceQueue, checkDuplicate, replace
              XWMDocumentView::MSG_GEN_VIEW_REDRAW_CONTENT();
    
		}

}

/***************************************************************************
 * XWMSetLetter
 ***************************************************************************
 * SYNOPSIS:    Set a letter in the word search.
 *
 * NOTE:        Make sure the word grid is locked
 **************************************************************************/
void XWMSetLetter(optr owg, word x, word y, char c)
{
char				*pRow;


	pRow = ChunkArrayElementToPtr(owg, y, 0);
	pRow[x] = c;

}

/***************************************************************************
 * XWMGetLetter
 ***************************************************************************
 * SYNOPSIS:    Get a letter from the word search.
 *
 * NOTE:        Make sure the word grid is locked
 **************************************************************************/
char XWMGetLetter(optr owg, word x, word y)
{
char *pRow;


	pRow = ChunkArrayElementToPtr(owg, y, 0);
	return pRow[x];

}

/***************************************************************************
 * XWMCalculatePuzzle
 ***************************************************************************
 * SYNOPSIS:    Calculates the word search.
 *
 * RETURNS:     TRUE if successfully placed all words.
 *
 * STRATEGY:    Wipe clean the word search.
 *              Attempt to place each word from the word list at most
 *                GRID_NUM_RANDOM_PLACE_TRIES randomly, then try to fit it
 *                in any valid space.
 *              Attempt to successfully place all words at most
 *                GRID_NUM_CALC_TRIES times before failing.
 *              Fill remaining spaces with .
 *
 **************************************************************************/
Boolean XWMCalculatePuzzle(void)
{
MemHandle		mhList, mhGrid, mhAnsw;
VMBlockHandle	vmbh;
optr				oWordGrid, oWordList, oAnswers;
word				numWords, i, j, k, ii, jj, testLen;
char				testWord[WORD_LIST_ELEMENT_SIZE];
char				perpChar, c;
Boolean			allFit, bPlaced, reverseLoop, justReversed;
word				startX, startY, d;
sword				x, y;
word				numLoops, numTries;
sword				dx, dy;
XWMListElement	*pElement;
XWMAnswerElement		*pAns;

    
	XWMInitializePuzzle();

	/* Lock things. */
	vmbh = VMFind(g_fhDocument, 0, LIST);
	VMLock(g_fhDocument, vmbh, &mhList);
	oWordList = ConstructOptr(mhList, g_chDocWordList);
	vmbh = VMFind(g_fhDocument, 0, GRID);
	VMLock(g_fhDocument, vmbh, &mhGrid);
	oWordGrid = ConstructOptr(mhGrid, g_chDocWordGrid);
	vmbh = VMFind(g_fhDocument, 0, ANSW);
	VMLock(g_fhDocument, vmbh, &mhAnsw);
	oAnswers = ConstructOptr(mhAnsw, g_chDocAnswers);

	numWords = ChunkArrayGetCount(oWordList);
	allFit = FALSE;
	reverseLoop = FALSE;
	justReversed = FALSE;

	XWMMarkWordsNotPlaced(oWordList);

	numLoops = 0;
	numTries = 0;
	/* cycle thru the word list */
	for (i = 0; i < numWords; i ++) {
		if (reverseLoop)  i = numWords - 1 - i;
		pElement = ChunkArrayElementToPtr(oWordList, i, 0);
		/*skip already placed words */
		if (!pElement->XWMLE_placed) {
			strcpy(testWord, pElement->XWMLE_word);
			testLen = strlen(testWord);
			d = MyRandom(2);
			XWMGetDirectionOffsets(d, &dx, &dy);
			bPlaced = FALSE;

			/* skip a lot for the first word */
			if (!g_numPlaced) {
				/* Choose a psuedo-random location where we know the word will fit */
				if (!d) {  /* horizontal */
					x = MyRandom(g_width - testLen);
					y = MyRandom(g_height);
					}
				else { /* vertical */
					x = MyRandom(g_width);
					y = MyRandom(g_height - testLen);
					}
				bPlaced = TRUE;
				} /* end of !g_numPlaced if */

			/* lots of checks for the remaining words */
			else {
				/* we want to try and cross with a word on the board so go thru
					answer list looking for perpendicular words */
				for (j = 0; j < g_numPlaced; j++) {
					pAns = ChunkArrayElementToPtr(oAnswers, j, 0);
					/* check for perp direction */
					if (pAns->XWMAE_direction != d) {
						/* OK, this can cross our test word.  Are there any common
							letters? */
						for (k = 0; k < pAns->XWMAE_length; k++) {
							/* check out the cells for the length of the
								current answer to see if we match */
							/* grab the kth letter of the answer */
							/* we swap dx & dy here since the answer is perpendicular */
							perpChar = XWMGetLetter(oWordGrid,
														 (pAns->XWMAE_column) + (k*dy),
														 (pAns->XWMAE_row) + (k*dx));
							for (ii = 0; ii < testLen; ii++) {
								/* compare kth letter of answer with iith letter of test */
								if (perpChar == testWord[ii]) {
									/* Cool - we found a common letter! get the starting
										point of our test word */
									x = (pAns->XWMAE_column) + (k*dy) - (ii*dx);
									y = (pAns->XWMAE_row) + (k*dx) - (ii*dy);
									/* we'll first need to test to see if this position
										fits in the grid */
									/* first the proposed start point */
									if (x >= 0 && y >= 0) {
										bPlaced = TRUE;
										}
									/* and the end point */
									if ((x + testLen * dx) >= g_width ||
														(y + testLen * dy) >= g_height) {
										/* nope - goes off the end */
										bPlaced = FALSE;
										}
									/* now make sure that the surrounding cells are clear
										and that we're not overwriting anything */

									/* first check the cell before the 1st letter and
										the one after the last letter */
									if (bPlaced && (g_numPlaced > 1)) {
										if (!d) {/* horizontal */
											/* pre 1st letter */
											if ((x - 1) >= 0) {
												c = XWMGetLetter(oWordGrid, x-1, y);
												if (c != ' ') bPlaced = FALSE;
												}
											/* post last letter */
											if ((x + testLen) <= g_width) {
												c = XWMGetLetter(oWordGrid, x+testLen, y);
												if (c != ' ') bPlaced = FALSE;
												}
											}
										else  { /* vertical */
											/* pre 1st letter */
											if ((y - 1) >= 0) {
												c = XWMGetLetter(oWordGrid, x, y-1);
												if (c != ' ') bPlaced = FALSE;
												}
											/* post last letter */
											if ((y + testLen) <= g_height) {
												c = XWMGetLetter(oWordGrid, x, y+testLen);
												if (c != ' ') bPlaced = FALSE;
												}
											}
										}  /* end of pre 1st & post last tests if */

									/* now see if this test placement is overwriting
										any previously placed words/letters */
									if (bPlaced && (g_numPlaced > 1)) {
										for (jj = 0; jj < testLen; jj++) {
											if (jj != ii) {  /* skip crossing cell */
												c = XWMGetLetter(oWordGrid, x+jj*dx, y+jj*dy);
												if (c != ' ') {
													bPlaced = FALSE;
													break;
													}
												}
											}
										}  /* end of overwriting tests if */

									/* ok - now for the last check... adjacent letters */
									if (bPlaced && (g_numPlaced > 1))  {
										for (jj = 0; jj < testLen; jj++) {
											if (jj != ii) {  /* skip crossing cell */
												if (!d) { /* horizontal */
													if (y) {  /* ignore if top row */
														/* above check */
														c = XWMGetLetter(oWordGrid, x+jj, y-1);
														if (c != ' ') {
															bPlaced = FALSE;
															break;
															}
														}
													if (y != g_height - 1) { /* ignore if bot row */
														/* below check */
														c = XWMGetLetter(oWordGrid, x+jj, y+1);
														if (c != ' ') {
															bPlaced = FALSE;
															break;
															}
														}
													}  /* end of horiz */
												else { /* vertical */
													if (x) {  /* ignore if left col */
														/* left check */
														c = XWMGetLetter(oWordGrid, x-1, y+jj);
														if (c != ' ') {
															bPlaced = FALSE;
															break;
															}
														}
													if (x != g_width - 1) { /* ignore if right col */
														/* right check */
														c = XWMGetLetter(oWordGrid, x+1, y+jj);
														if (c != ' ') {
															bPlaced = FALSE;
															break;
															}
														}
													}  /* end of vert */
												}  /* end of skip if */
											} /* end of for (jj) loop */
										} /* end of adjacent letter check */
									} /* end of found common letter if */
								if (bPlaced) break;
								}  /* end of test word (ii) for */
							if (bPlaced) break;
							}  /* end of answer (k) for  */

						}  /* end of perp words if */
					if (bPlaced) break;
					} /* end of find perp words (j) for */

				}  /* end of remaining words else */

			/* If a fit was found, place the word. */
			if (bPlaced) {
				/* Save position/direction temporarily. */
				startX = x;
				startY = y;
				for (j = 0; j < testLen; j++)  {
					XWMSetLetter(oWordGrid, x, y, testWord[j]);
					x += dx;
					y += dy;
					}

				/* and fill the answer array */
				pAns = ChunkArrayAppend(oAnswers, 0);
				pAns->XWMAE_row = startY;
				pAns->XWMAE_column = startX;
				pAns->XWMAE_direction = d;
				pAns->XWMAE_length = testLen;
				pAns->XWMAE_wordNum = i;

				pElement->XWMLE_placed = TRUE;
				g_numPlaced++;
				/* see if we're done */
				if (g_numPlaced == numWords) {
					/* yup - got em all */
					allFit = TRUE;
					}
				}  /* end of place the word if */

			} /* end of not placed if */

		if ((!reverseLoop && (i == (numWords - 1)) && !allFit) ||
				 (reverseLoop && (i == 0) && !allFit)) {
			/* we've gone thru the list and not all words are placed */
			numLoops++;
			if (g_numPlaced < numWords)  {
				/* shall we try again with any remaining words? */
				if (numLoops < 5) {
					/* ok try again */
					if (!reverseLoop) i = 0xffff;
					else i = numWords;
					}
				else if (numTries < 10) {
					/* give it up - wait!  the problem might be the first word
						location... lets reset for a few more rounds */
					if (!reverseLoop) i = 0xffff;
					else i = numWords;
					for (x = 0; x < g_width; x++)
						for (y = 0; y < g_height; y++)
							XWMSetLetter(oWordGrid, x, y, GRID_SPACE);
					XWMMarkWordsNotPlaced(oWordList);
					ChunkArrayZero(oAnswers);
					numLoops = 0;
					numTries++;
					/* let's try reversing the order of placing words for
						a few more tries */
					if (numTries == 5) {
						reverseLoop = TRUE;
						justReversed = TRUE;
						}
					}
				else {
					/* ok - give it up :-( */
					allFit = FALSE;
					}
				} /* end of try again if */
			} /* end of last time thru if */
		if (reverseLoop)  {
			if (justReversed) justReversed = FALSE;
			else i = numWords - 1 - i;
			}
		} /* end of cycle thru list (i) for */

	/* The word search is (most likely) no longer initialized. */
	g_bWSInitialized = FALSE;

	/* Mark our changes. */
	VMDirty(mhList);
	VMUnlock(mhList);
	VMDirty(mhGrid);
	VMUnlock(mhGrid);
	VMDirty(mhAnsw);
	VMUnlock(mhAnsw);

	/* Redraw the document view. */
	@send XWMDocumentView::MSG_GEN_VIEW_REDRAW_CONTENT();

	return (allFit);


}

/***************************************************************************
 * XWMGetDirectionOffsets
 ***************************************************************************
 * SYNOPSIS:    Calculate the x and y offsets for word placement, given
 *              the difficulty level and a direction value.
 *
 **************************************************************************/
void XWMGetDirectionOffsets(word nDir,
									 sword *pndx, sword *pndy)
{
static const sword dx[8] = { 1, 0 };
static const sword dy[8] = { 0, 1 };


	 /* Set the offsets. */
	 *pndx = dx[nDir];
	 *pndy = dy[nDir];

}

/***************************************************************************
 * XWMGetDocBounds
 ***************************************************************************
 * SYNOPSIS:    Determine the document bounds of the word search grid so
 *              that the view properly scales-to-fit the entire grid.
 *
 **************************************************************************/
void XWMGetDocBounds(RectDWord *pr)
{
    pr->RD_left = pr->RD_top = 0;
    pr->RD_right = DRAW_GRID_MARGINS * 2
		+ g_width * DRAW_GRID_SPACE_SIZE;
    pr->RD_bottom = DRAW_GRID_MARGINS * 2
      + g_height * DRAW_GRID_SPACE_SIZE;
}


        
/***************************************************************************
 * XWMDrawHeader
 ***************************************************************************
 * SYNOPSIS:    Called to draw the word search header.
 *
 * STRATEGY:    Calculate the position for drawing the file name centered
 *                horizontally within the header bounds.
 *              Draw the file name.
 *
 **************************************************************************/
void XWMDrawHeader(GStateHandle gstate, Boolean drawNameBlock)
{
 char szFileName[FILE_LONGNAME_BUFFER_SIZE];
 sword x;
    
    if (g_oDocument != NullOptr)
    {
		  GrSetFont(gstate, PRINT_HEADER_TEXT_FONT, PRINT_HEADER_TEXT_SIZE);
		  GrSetTextColor(gstate, CF_INDEX, C_BLACK, 0, 0);
        GrSetDefaultTransform(gstate);

		  @call g_oDocument::MSG_GEN_DOCUMENT_GET_FILE_NAME(szFileName);

        x = (PRINT_HEADER_BOUNDS_LEFT + PRINT_HEADER_BOUNDS_RIGHT -
          GrTextWidth(gstate, szFileName, sizeof(szFileName))) / 2;
		  GrDrawText(gstate, x, PRINT_HEADER_BOUNDS_TOP, szFileName,
			 sizeof(szFileName));

		  if (drawNameBlock) {
				GrSetFont(gstate, PRINT_WORD_TEXT_FONT, MakeWWFixed(12));
				GrSetTextStyle(gstate, TS_BOLD, 0);
				MemLock (OptrToHandle(@PrintNameLine));
				strcpy(szFileName, LMemDeref(@PrintNameLine));
				GrDrawText(gstate,
								.25*72,
								.25*72,
								szFileName,
								sizeof(szFileName) );
				strcpy(szFileName, LMemDeref(@PrintDateLine));
				GrDrawText(gstate,
								.25*72,
								.25*72 + 14,
								szFileName,
								sizeof(szFileName) );
				MemUnlock (OptrToHandle(@PrintNameLine));
				}
	 }
}

/***************************************************************************
 * XWMDrawWordGrid
 ***************************************************************************
 * SYNOPSIS:    Called to draw the puzzle.
 *
 * STRATEGY:    Draw the puzzle.
 *              If the answers are to be drawn, draw them as well.
 *              If printing, scaling must be applied for the passed bounds.
 *
 **************************************************************************/
void XWMDrawWordGrid(GStateHandle gstate, word nLeftBound, word nTopBound, 
                       word nRightBound, word nBottomBound, Boolean bPrinting)
{
MemHandle		mh;
VMBlockHandle	vmbh;
optr				oWordGrid;
word				row, col, x, y, xoff, yoff;
char				c, cellNumStr[13];
    

	if (!g_fhDocument) return;



	/* Setup the gstate. */
	GrSetFont(gstate, DRAW_GRID_TEXT_FONT, MakeWWFixed(DRAW_GRID_TEXT_SIZE));
	GrSetTextColor(gstate, CF_INDEX, C_BLACK, 0, 0);
   GrSetAreaColor(gstate, CF_INDEX, C_LIGHT_GRAY, 0, 0);
	GrSetDefaultTransform(gstate);
	GrApplyTranslation(gstate, MakeWWFixed(nLeftBound), MakeWWFixed(nTopBound));
        
	/* Lock things. */
	vmbh = VMFind(g_fhDocument, 0, GRID);
	VMLock(g_fhDocument, vmbh, &mh);
	oWordGrid = ConstructOptr(mh, g_chDocWordGrid);

	/* Determine the scaling factor to use. */
	if (bPrinting) {
		word nLargestDimension;
		WWFixedAsDWord fScale, fHeight, fWidth, fLeft, fTop;

		if (g_width > g_height)
			nLargestDimension = g_width * DRAW_GRID_SPACE_SIZE;
		else
			nLargestDimension = g_height * DRAW_GRID_SPACE_SIZE;
		fScale = GrUDivWWFixed(MakeWWFixed(nRightBound - nLeftBound),
															  MakeWWFixed(nLargestDimension));
		if (fScale > DRAW_GRID_MAX_SCALE_FACTOR)
			fScale = DRAW_GRID_MAX_SCALE_FACTOR;
		fHeight = GrMulWWFixed(
					MakeWWFixed(g_height * DRAW_GRID_SPACE_SIZE), fScale);
		fWidth = GrMulWWFixed(
					 MakeWWFixed(g_width * DRAW_GRID_SPACE_SIZE), fScale);
		fLeft = (MakeWWFixed(nRightBound - nLeftBound) - fWidth) / 2;
		fTop = (MakeWWFixed(nBottomBound - nTopBound) - fHeight) / 2;
		GrApplyTranslation(gstate, fLeft, fTop);
		GrApplyScale(gstate, fScale, fScale);
		}  /* end of printing if */
            
	/* Draw the letters. */
   g_cellNum = 0;
   g_geosCellNum = 0;
	yoff = (DRAW_GRID_SPACE_SIZE - DRAW_GRID_TEXT_SIZE) + 1;
	y = 0;
	for (row = 0; row < g_height; row++)  {
		x = 0;
		for (col = 0; col < g_width; col++) {
			c = XWMGetLetter(oWordGrid, col, row);
			if (c != ' ') {
				GrDrawRect(gstate, x, y,
										 x+DRAW_GRID_SPACE_SIZE,
										 y+DRAW_GRID_SPACE_SIZE);
				if (g_settings & XWMS_ANSWERS) {
					xoff = (DRAW_GRID_SPACE_SIZE - IntegerOf(GrCharWidth(gstate, c)))/2;
					GrSetFont(gstate, DRAW_GRID_TEXT_FONT,
															 MakeWWFixed(DRAW_GRID_TEXT_SIZE));
					GrDrawChar(gstate, x + xoff, y + yoff, c);
               }
				if (XWMDoesCellGetNumber(oWordGrid, row, col)) {
					UtilHex32ToAscii(cellNumStr, (dword)g_cellNum, UHTAF_NULL_TERMINATE);
					GrSetFont(gstate, DRAW_GRID_NUM_FONT,
															 MakeWWFixed(DRAW_GRID_NUM_SIZE));
					GrDrawText(gstate, x + 2, y, cellNumStr, strlen(cellNumStr));
					}
				}
			else if (!bPrinting) {
				GrFillRect(gstate, x, y,
										 x+DRAW_GRID_SPACE_SIZE,
										 y+DRAW_GRID_SPACE_SIZE);
				}
			x += DRAW_GRID_SPACE_SIZE;
			}
		y += DRAW_GRID_SPACE_SIZE;
		}
        
	/* Unlock things. */
	VMUnlock(mh);

}

/***************************************************************************
 * XWMDoesCellGetNumber
 ***************************************************************************
 * SYNOPSIS:    Sees whether a cell gets a number - if so updates global
 *
 * STRATEGY:    Uses cell numbering system of Geos Crossword app.  All cells
 *              with no letters above OR left get numbers.
 *
 *		OK - change of plans.  We'll fill the cellNumArray with the XWM
 *    simpler cell numbering system - word starts only.  But for export
 *    to geos Xword app we'll still need the full geos array.  We'll
 *    fill them both here since this routine is called for each cell in the
 *    grid when it is drawn.
 *
 *
 *
 **************************************************************************/
Boolean XWMDoesCellGetNumber(optr owg, word row, word col)
{
 Boolean		getsNum = FALSE;
 Boolean		geosGetsNum = FALSE;


/* the geos cell numbers */
	/* left and top edge always get numbers */
	if (!row || !col)  geosGetsNum = TRUE;
	else {  /* check the interior */
		if (XWMGetLetter(owg, col, row-1) == ' ')
			geosGetsNum = TRUE;
		else if (XWMGetLetter(owg, col-1, row) == ' ')
			geosGetsNum = TRUE;
		}

	if (geosGetsNum) {
		/* set the cell number */
		g_geosCellNum++;
		/* and fill in our array (for creation of geos puzzle clue nums) */
		g_geosCellNumArray[row][col] = g_geosCellNum;
		}
	else g_geosCellNumArray[row][col] = 0;

/* now the simpler XWM cell numbers */
	/* check for down words */
	if ((!row || (XWMGetLetter(owg, col, row-1) == ' '))
			&& (XWMGetLetter(owg, col, row+1) != ' ')) getsNum = TRUE;
	/* check for across words */
	else if ((!col || (XWMGetLetter(owg, col-1, row) == ' '))
			&& (XWMGetLetter(owg, col+1, row) != ' ')) getsNum = TRUE;

	if (getsNum) {
		/* set the cell number */
		g_cellNum++;
		/* and fill in our array (for creation of puzzle clue nums) */
		g_cellNumArray[row][col] = g_cellNum;
		}
	else g_cellNumArray[row][col] = 0;

	return (getsNum);
}

/***************************************************************************
 * XWMDrawClueList
 ***************************************************************************
 * SYNOPSIS:    Called to print the clue list.
 *
 * STRATEGY:    Calculate the text size, column width, number of columns,
 *                and number of rows.
 *              Call appropriate drawing functions.
 *
 **************************************************************************/
void XWMDrawClueList(GStateHandle gstate)
{
MemHandle			mhList, mhAnsw;
VMBlockHandle		vmbh;
word					width, numWords, i, j, longestClue, longestClueIdx, colWidth;
word					cellNum, col, row, printRow, clues, tabWidth, tabOffset;
word					acrossXOffset;
sword					x;
WWFixedAsDWord		fFontSize;
char					lineBuffer[255], cellNumStr[13], wrapBuffer[200];
Boolean				bFits = FALSE;
XWMListElement		*pElement;
XWMAnswerElement	*pAns;


	/* lock our data stuff */
	vmbh = VMFind(g_fhDocument, 0, LIST);
	VMLock(g_fhDocument, vmbh, &mhList);
	vmbh = VMFind(g_fhDocument, 0, ANSW);
	VMLock(g_fhDocument, vmbh, &mhAnsw);

	numWords = ChunkArrayGetCountHandles(mhList, g_chDocWordList);
	/* No point in continuing if there are no words. */
	if (!numWords)  {
		VMUnlock(mhAnsw);
		VMUnlock(mhList);
		return;
		}

	/* Find the longest clue.  This will help determine the text size. */
	GrSetFont(gstate, PRINT_WORD_TEXT_FONT, PRINT_WORD_MAX_TEXT_SIZE);
	longestClue = 0;
	longestClueIdx = 0;
	for (i = 0; i < numWords; i++)  {
		pElement = ChunkArrayElementToPtrHandles(mhList, g_chDocWordList, i, 0);
		width = GrTextWidth(gstate, pElement->XWMLE_clue, 0);
		if (width > longestClue) {
			longestClue = width;
			longestClueIdx = i;
			}
		}
	/* Add a small amount for spacing. */
	longestClue += PRINT_WORD_COLUMN_SPACING;
        
	/* Calculate column width for max text length. */
	colWidth = PRINT_WORD_TEXT_BOX_WIDTH / 2 - PRINT_WORD_COLUMN_SPACING;
        
	/* Start with the largest font size. */
	for (fFontSize = PRINT_WORD_MAX_TEXT_SIZE;
          !bFits && fFontSize >= PRINT_WORD_MIN_TEXT_SIZE; 
			 fFontSize -= PRINT_WORD_STEP_TEXT_SIZE)  {
		/* get the width in pixels */
		GrSetFont(gstate, PRINT_WORD_TEXT_FONT, fFontSize);
		pElement = ChunkArrayElementToPtrHandles(
											 mhList, g_chDocWordList, longestClueIdx, 0);
		width = GrTextWidth(gstate, pElement->XWMLE_clue, 0)
																  + PRINT_WORD_COLUMN_SPACING;

		/* If all of the words fit, keep this font size; otherwise,
               shrink the font and try again. */
		if (width <= colWidth)  bFits = TRUE;
		}
        
	/* Enforce the minimum font size even if all the words won't fit. */
	if (!bFits) fFontSize = PRINT_WORD_MIN_TEXT_SIZE;
            
	/* make sure the clues fit vertically too */
	if (numWords > 24) fFontSize = PRINT_WORD_MIN_TEXT_SIZE;

	/* had to add this bit to center the clues under the grid so that it
		would look right when copied to clipboard */
	GrSetFont(gstate, PRINT_WORD_TEXT_FONT, fFontSize);
	pElement = ChunkArrayElementToPtrHandles(
											 mhList, g_chDocWordList, longestClueIdx, 0);
	width = GrTextWidth(gstate, pElement->XWMLE_clue, 0)
																  + PRINT_WORD_COLUMN_SPACING;
	acrossXOffset = 0;
	if (width < colWidth)  acrossXOffset = colWidth - width -
														PRINT_WORD_COLUMN_SPACING;

	/* Setup the remainder of the GState. */
	GrSetTextColor(gstate, CF_INDEX, C_BLACK, 0, 0);
	GrSetDefaultTransform(gstate);

	/* Print across clues column */
	clues = 0;
	x = PRINT_WORD_TEXT_BOX_LEFT + acrossXOffset;
	printRow = 0;
	/* draw the across header */
	GrSetFont(gstate, PRINT_WORD_TEXT_FONT, PRINT_WORD_MAX_TEXT_SIZE);
	GrSetTextStyle(gstate, TS_BOLD | TS_UNDERLINE, 0);
	MemLock (OptrToHandle(@AcrossText));
	GrDrawText(gstate, x, PRINT_WORD_TEXT_BOX_TOP - 16,
						LMemDeref(@AcrossText), 0);
	MemUnlock (OptrToHandle(@AcrossText));
	GrSetFont(gstate, PRINT_WORD_TEXT_FONT, fFontSize);
	GrSetTextStyle(gstate, 0, TS_BOLD | TS_UNDERLINE);
	/* and the clues */
	for (row = 0; row < g_height; row ++) {
		for (col = 0; col < g_width; col ++) {
			for (i = 0; i < numWords; i++) {
				pAns = ChunkArrayElementToPtrHandles(mhAnsw, g_chDocAnswers, i, 0);
				if (pAns->XWMAE_row == row && pAns->XWMAE_column == col
						 && pAns->XWMAE_direction == 0) {
					/* we have an across word start - so grab the cell number */
					tabOffset = 0;
					cellNum = g_cellNumArray[row][col];
					UtilHex32ToAscii(cellNumStr, (dword)cellNum, UHTAF_NULL_TERMINATE);
					if (strlen(cellNumStr) == 1) {
						strcpy(lineBuffer, " ");
						strcat(lineBuffer, cellNumStr);
						}
					else
						strcpy(lineBuffer, cellNumStr);
					strcat(lineBuffer, ". ");
					tabWidth = GrTextWidth(gstate, lineBuffer, 0);
					/* and the clue text */
					pElement = ChunkArrayElementToPtrHandles(
										mhList, g_chDocWordList, pAns->XWMAE_wordNum, 0);
					strcat(lineBuffer, pElement->XWMLE_clue);
					/* see if we need to wrap */
					width = GrTextWidth(gstate, lineBuffer, 0);
					while (width > colWidth) {
						/* we need to wrap */
						for (j = strlen(lineBuffer) - 1; j > 0; j--) {
							if (lineBuffer[j] == ' ') {
								/* test if wrap here */
								lineBuffer[j] = 0;
								width = GrTextWidth(gstate, lineBuffer, 0) + tabOffset;
								if (width < colWidth) {
									/* ok - it's short enuf, wrap here */
									strcpy(wrapBuffer, &lineBuffer[j+1]);
									GrDrawText(gstate, x + tabOffset,
										PRINT_WORD_TEXT_BOX_TOP +
										IntegerOf(GrMulWWFixed(MakeWWFixed(printRow), fFontSize)),
										lineBuffer, 0);
									printRow++;
									strcpy(lineBuffer, wrapBuffer);
									if (!tabOffset) tabOffset = tabWidth;
									width = GrTextWidth(gstate, lineBuffer, 0) + tabOffset;
									break;
									}
								else {
									/* still too long - keep trying */
									lineBuffer[j] = ' ';
									}
								}  /* end of found a space if */
							}  /* end of find spaces for */
						}   /* end of wider than col while */
					/* draw it */
					GrDrawText(gstate, x + tabOffset, PRINT_WORD_TEXT_BOX_TOP +
						IntegerOf(GrMulWWFixed(MakeWWFixed(printRow), fFontSize)),
						lineBuffer, 0);
					printRow++;
					clues++;
					break;
					}  /* end of found across start if */
				}  /* end of numWords (i) for */
			}  /* end of col for */
		}  /* end of row for */

	/* Print down clues column */
	x = PRINT_WORD_TEXT_BOX_LEFT + (PRINT_WORD_TEXT_BOX_WIDTH / 2);
	printRow = 0;
	/* draw the down text */
	GrSetFont(gstate, PRINT_WORD_TEXT_FONT, PRINT_WORD_MAX_TEXT_SIZE);
	GrSetTextStyle(gstate, TS_BOLD | TS_UNDERLINE, 0);
	MemLock (OptrToHandle(@DownText));
	GrDrawText(gstate, x, PRINT_WORD_TEXT_BOX_TOP - 16,
						LMemDeref(@DownText), 0);
	MemUnlock (OptrToHandle(@DownText));
	GrSetFont(gstate, PRINT_WORD_TEXT_FONT, fFontSize);
	GrSetTextStyle(gstate, 0, TS_BOLD | TS_UNDERLINE);
	/* and the clues */
	for (row = 0; row < g_height; row ++) {
		for (col = 0; col < g_width; col ++) {
			for (i = 0; i < numWords; i++) {
				pAns = ChunkArrayElementToPtrHandles(mhAnsw, g_chDocAnswers, i, 0);
				if (pAns->XWMAE_row == row && pAns->XWMAE_column == col
						 && pAns->XWMAE_direction == 1) {
					/* we have a down word start - so grab the cell number */
					tabOffset = 0;
					cellNum = g_cellNumArray[row][col];
					UtilHex32ToAscii(cellNumStr, (dword)cellNum, UHTAF_NULL_TERMINATE);
					if (strlen(cellNumStr) == 1) {
						strcpy(lineBuffer, " ");
						strcat(lineBuffer, cellNumStr);
						}
					else
						strcpy(lineBuffer, cellNumStr);
					strcat(lineBuffer, ". ");
					tabWidth = GrTextWidth(gstate, lineBuffer, 0);
					/* and the clue text */
					pElement = ChunkArrayElementToPtrHandles(
										mhList, g_chDocWordList, pAns->XWMAE_wordNum, 0);
					strcat(lineBuffer, pElement->XWMLE_clue);
					/* see if we need to wrap */
					width = GrTextWidth(gstate, lineBuffer, 0);
					while (width > colWidth) {
						/* we need to wrap */
						for (j = strlen(lineBuffer) - 1; j > 0; j--) {
							if (lineBuffer[j] == ' ') {
								/* test if wrap here */
								lineBuffer[j] = 0;
								width = GrTextWidth(gstate, lineBuffer, 0) + tabOffset;
								if (width < colWidth) {
									/* ok - it's short enuf, wrap here */
									strcpy(wrapBuffer, &lineBuffer[j+1]);
									GrDrawText(gstate, x + tabOffset, PRINT_WORD_TEXT_BOX_TOP +
										IntegerOf(GrMulWWFixed(MakeWWFixed(printRow), fFontSize)),
										lineBuffer, 0);
									printRow++;
									strcpy(lineBuffer, wrapBuffer);
									if (!tabOffset) tabOffset = tabWidth;
									width = GrTextWidth(gstate, lineBuffer, 0) + tabOffset;
									break;
									}
								else {
									/* still too long - keep trying */
									lineBuffer[j] = ' ';
									}
								}  /* end of found a space if */
							}  /* end of find spaces for */
						}   /* end of wider than col while */
					/* draw it */
					GrDrawText(gstate, x + tabOffset, PRINT_WORD_TEXT_BOX_TOP +
						IntegerOf(GrMulWWFixed(MakeWWFixed(printRow), fFontSize)),
						lineBuffer, 0);
					printRow++;
					clues++;
					break;
					}  /* end of found across start if */
				}  /* end of numWords (i) for */
			if (clues == numWords) break;
			}  /* end of col for */
		if (clues == numWords) break;
		}  /* end of row for */

	VMUnlock(mhAnsw);
	VMUnlock(mhList);

}

/***************************************************************************
 * MSG_META_EXPOSED
 ***************************************************************************
 * SYNOPSIS:    Called by XWMDocumentView to redraw the word search display.
 *
 * PARAMETERS:  WindowHandle    win
 *
 * STRATEGY:    Call appropriate drawing functions to render the display.
 *
 **************************************************************************/
@method XWMProcessClass, MSG_META_EXPOSED
{
    GStateHandle gstate;

    gstate = GrCreateState(win);    /* Create a temporary GState. */
    GrBeginUpdate(gstate);          /* Start a window update. */
    XWMDrawWordGrid(gstate, DRAW_GRID_MARGINS, DRAW_GRID_MARGINS, 0, 0, FALSE);
    GrEndUpdate(gstate);            /* We are done with the window update. */
    GrDestroyState(gstate);         /* Destroy the temporary GState. */
}

/***************************************************************************
 * MSG_PRINT_START_PRINTING
 ***************************************************************************
 * SYNOPSIS:    Sent by the print control whenever it wants to print.
 *
 * PARAMETERS:  optr            printCtrlOD,
 *              GStateHandle    gstate
 *
 * STRATEGY:    Call appropriate drawing functions to print the document.
 *
 **************************************************************************/
@method XWMStartPrinting, XWMProcessClass, MSG_PRINT_START_PRINTING
{

	/* Print the header. */
	XWMDrawHeader(gstate, TRUE);
    
	/* Print the puzzle. */
	XWMDrawWordGrid(gstate, PRINT_GRID_BOUNDS_LEFT, PRINT_GRID_BOUNDS_TOP,
					PRINT_GRID_BOUNDS_RIGHT, PRINT_GRID_BOUNDS_BOTTOM, TRUE);

	/* Print the word list. */
	XWMDrawClueList(gstate);

	/* End with a form feed. */
	GrNewPage(gstate, PEC_FORM_FEED);

	@send printCtrlOD::MSG_PRINT_CONTROL_PRINTING_COMPLETED();

}

/***************************************************************************
 * MSG_META_CLIPBOARD_COPY
 ***************************************************************************
 * SYNOPSIS:    Draw the word search display to the clipboard.
 *
 * PARAMETERS:  
 *
 * STRATEGY:    Call appropriate drawing functions to render the display.
 *
 **************************************************************************/
@method XWMProcessClass, MSG_META_CLIPBOARD_COPY
{
 ClipboardItemHeader *headerMem ;
 MemHandle           headerMemHandle ;
 VMFileHandle        transferVMFile ;
 VMBlockHandle       dataVMBlock, headerVMBlock ;
 GStateHandle        gstate;


	 @send XWMApp::MSG_GEN_APPLICATION_MARK_BUSY() ;
    transferVMFile = ClipboardGetClipboardFile() ;

    gstate = GrCreateGString(transferVMFile, GST_VMEM, &dataVMBlock);

	 /* Draw the header. Don't draw the name/date block. */
	 XWMDrawHeader(gstate, FALSE);
	 /* Draw the puzzle. */
	 XWMDrawWordGrid(gstate, PRINT_GRID_BOUNDS_LEFT, PRINT_GRID_BOUNDS_TOP,
					PRINT_GRID_BOUNDS_RIGHT, PRINT_GRID_BOUNDS_BOTTOM, TRUE);
	 /* Draw the word list. */
	 XWMDrawClueList(gstate);

	 GrEndGString(gstate);

    headerVMBlock = VMAlloc(transferVMFile, sizeof(ClipboardItemHeader), 1111) ;
    headerMem = (ClipboardItemHeader *)VMLock(
                 transferVMFile, headerVMBlock, &headerMemHandle) ;
    headerMem->CIH_owner = ConstructOptr(GeodeGetProcessHandle(), 0) ;
    headerMem->CIH_flags = 0 ;
	 headerMem->CIH_name[0] = 'X' ;
	 headerMem->CIH_name[1] = 'W' ;
	 headerMem->CIH_name[2] = 'M' ;
	 headerMem->CIH_name[3] = '\0' ;
	 headerMem->CIH_formatCount = 1;
    headerMem->CIH_sourceID = 0 ;
    headerMem->CIH_formats[0].CIFI_format =
        FormatIDFromManufacturerAndType(
             MANUFACTURER_ID_GEOWORKS,
             CIF_GRAPHICS_STRING) ;
    headerMem->CIH_formats[0].CIFI_vmChain =
        (VMChain)(((dword)(dataVMBlock))<<16L) ;
    headerMem->CIH_formats[0].CIFI_extra1 = 0 ;
    headerMem->CIH_formats[0].CIFI_extra2 = 0 ;
    VMUnlock(headerMemHandle) ;
    ClipboardRegisterItem(BlockIDFromFileAndBlock(transferVMFile,
        headerVMBlock),
        0) ;
	 @send XWMApp::MSG_GEN_APPLICATION_MARK_NOT_BUSY() ;

}

/***************************************************************************
 * MSG_XWM_PROCESS_APPLY_SETTINGS_WIDTH, MSG_XWM_PROCESS_APPLY_SETTINGS_HEIGHT
 ***************************************************************************
 * SYNOPSIS:    Sent when changes to XWMSettingsLevel are applied.
 *
 * PARAMETERS:  WWFixedAsDWord              value,
 *              GenValueStateFlagsAsWord    stateFlags
 *
 * STRATEGY:    Write the setting to the document.
 *              Set the view's document bounds.
 *              Queue a recalculation of the word search.
 *
 **************************************************************************/
@method XWMProcessClass, MSG_XWM_PROCESS_APPLY_SETTINGS_WIDTH,
  MSG_XWM_PROCESS_APPLY_SETTINGS_HEIGHT
{
MemHandle	mh;
VMBlockHandle	vmbh;
XWMDocumentMap			*pMap;
Boolean		bModified = FALSE;
RectDWord	docBounds;


	/* get the settings from the gadgets */
	if (message == MSG_XWM_PROCESS_APPLY_SETTINGS_WIDTH) {
		if (g_width != IntegerOf(value)) {
			g_width = IntegerOf(value);
			bModified = TRUE;
			}
		}
	if (message == MSG_XWM_PROCESS_APPLY_SETTINGS_HEIGHT) {
		if (g_height != IntegerOf(value)) {
			g_height = IntegerOf(value);
			bModified = TRUE;
			}
		}

	if (bModified) {
		/* save in the map block. */
		vmbh = VMGetMapBlock(g_fhDocument);
		pMap = VMLock(g_fhDocument, vmbh, &mh);
		pMap->XWMDM_width = g_width;
		pMap->XWMDM_height = g_height;
		VMDirty(mh);
		VMUnlock(mh);

		/* Clear the grid, as the size has been changed. A redraw now would
			cause a crash. */
		XWMClearWordGrid();

		/* Retrieve the size of the word search and set the view's document
			bounds. */
		XWMGetDocBounds(&docBounds);
		@send XWMDocumentView::MSG_GEN_VIEW_SET_DOC_BOUNDS(
              docBounds.RD_bottom, docBounds.RD_right, 
              docBounds.RD_top, docBounds.RD_left);

		/* Queue a recalculation of the word search. */
		@send, forceQueue, checkDuplicate self::MSG_XWM_PROCESS_CALCULATE();
		}

}

/***************************************************************************
 * MSG_XWM_PROCESS_APPLY_SETTINGS_OTHER
 ***************************************************************************
 * SYNOPSIS:    Sent when changes are made to the XWMSettingsOther object.
 *
 * PARAMETERS:  word selectedBooleans,
 *              word indeterminateBooleans,
 *              word modifiedBooleans
 *
 * STRATEGY:    Write the settings to the document.
 *              Queue a recalculation of the word search if XWMS_INTERSECT
 *                has been changed.
 *              Queue a redraw of the view if XWMS_ANSWERS has been changed.
 *
 **************************************************************************/
@method XWMProcessClass, MSG_XWM_PROCESS_APPLY_SETTINGS_OTHER
{
MemHandle	mh;
VMBlockHandle	vmbh;
XWMDocumentMap			*pMap;
Boolean		bModified = FALSE;


	/* Write the settings to the document. */
	if (g_settings != selectedBooleans) {
		g_settings = selectedBooleans;
		bModified = TRUE;;
		}
        
	if (bModified) {
		/* save in the map block. */
		vmbh = VMGetMapBlock(g_fhDocument);
		pMap = VMLock(g_fhDocument, vmbh, &mh);
		pMap->XWMDM_settings = g_settings;
		VMDirty(mh);
		VMUnlock(mh);
		}

	/* Redraw the grid if XWMS_ANSWERS has been modified. */
	if (modifiedBooleans & XWMS_ANSWERS)
		@send, forceQueue, checkDuplicate
              XWMDocumentView::MSG_GEN_VIEW_REDRAW_CONTENT();

}

/***************************************************************************
 * MSG_XWM_PROCESS_STATUS_WIDTH, MSG_XWM_PROCESS_STATUS_HEIGHT
 ***************************************************************************
 * SYNOPSIS:    Sent when changes are made to either of the size GenValues.
 *
 * PARAMETERS:  WWFixedAsDWord              value,
 *              GenValueStateFlagsAsWord    stateFlags
 *
 * STRATEGY:    Change the GenValue not being modified if the "Keep grid
 *              square" option is set.
 *
 **************************************************************************/
@method XWMProcessClass, MSG_XWM_PROCESS_STATUS_WIDTH, 
  MSG_XWM_PROCESS_STATUS_HEIGHT
{
    word settings = 
      @call XWMSettingsOther::MSG_GEN_BOOLEAN_GROUP_GET_SELECTED_BOOLEANS();
    optr oValue;
      
    if (settings & XWMS_SQUARE)
    {
        if (message == MSG_XWM_PROCESS_STATUS_WIDTH)
            oValue = @XWMSettingsSizeHeight;
        else if (message == MSG_XWM_PROCESS_STATUS_HEIGHT)
            oValue = @XWMSettingsSizeWidth;
        else
            EC_ERROR(-1);
        @send oValue::MSG_GEN_VALUE_SET_VALUE(value, FALSE);
        @send oValue::MSG_GEN_VALUE_SET_MODIFIED_STATE(TRUE);
    }
}

/***************************************************************************
 * MSG_XWM_PROCESS_SETTINGS_OTHER_CHANGED
 ***************************************************************************
 * SYNOPSIS:    Sent when changes are made to the XWMSettingsOther object.
 *
 * PARAMETERS:  word selectedBooleans,
 *              word indeterminateBooleans,
 *              word changedBooleans
 *
 * STRATEGY:    Make sure the two sizes are equal if XWMS_SQUARE is set.
 *
 **************************************************************************/
@method XWMProcessClass, MSG_XWM_PROCESS_SETTINGS_OTHER_CHANGED
{
	 optr oValue = @XWMSettingsSizeHeight;
    optr oOtherValue = @XWMSettingsSizeWidth;
    word size;

    /* Make sure the two sizes are equal if XWMS_SQUARE is set. */
    if ((changedBooleans & XWMS_SQUARE) && (selectedBooleans & XWMS_SQUARE))
    {
        /* Try to guess which one the user wants to set both. */
        if (@call oOtherValue::MSG_GEN_VALUE_IS_MODIFIED() &&
          !(@call oValue::MSG_GEN_VALUE_IS_MODIFIED()))
        {
            oValue = @XWMSettingsSizeWidth;
            oOtherValue = @XWMSettingsSizeHeight;
        }
        size = @call oValue::MSG_GEN_VALUE_GET_INTEGER_VALUE();
        @send oOtherValue::MSG_GEN_VALUE_SET_INTEGER_VALUE(size, FALSE);
        @send oOtherValue::MSG_GEN_VALUE_SET_MODIFIED_STATE(TRUE);
    }
}


word MyRandom(word range)
{
    static word rand1 = 0xf32d ;
    static word rand2 = 0x0103 ;
    static word rand3 = 0x4326 ;
    static word rand4 = 0x4878 ;
    TimerDateAndTime dateAndTime ;
    word old ;
    WWFixed work;

    TimerGetDateAndTime(&dateAndTime) ;
    old = rand1 ;
    rand1 = rand2 ;
    rand2 = rand3 ;
    rand3 = rand4 ;
    rand4 ^= old^rand1^rand2^rand3 ;
    rand3 += rand1+rand2+rand4 ;
    rand4 += TimerGetCount() ;

    work.WWF_frac = old; work.WWF_int = 0;
    return IntegerOf(GrMulWWFixed(*((WWFixedAsDWord*)&work), MakeWWFixed(range)));
}

/***************************************************************************
 * MSG_XWM_PROCESS_OPEN_CLUES_DB
 ***************************************************************************
 * SYNOPSIS:    Initializes things in the Clues dbox before it opens
 *
 * PARAMETERS:
 *
 *
 *
 * STRATEGY:
 *
 **************************************************************************/
@method XWMProcessClass, MSG_XWM_PROCESS_OPEN_CLUES_DB
{
MemHandle	mh;
VMBlockHandle	vmbh;
word			sel;
XWMListElement			*pElement;


	sel = @call XWMWordList::MSG_GEN_ITEM_GROUP_GET_SELECTION();
	if (sel != GIGS_NONE)  {
		/* Lock the word list. */
		vmbh = VMFind(g_fhDocument, 0, LIST);
		VMLock(g_fhDocument, vmbh, &mh);

		/* Get the word from the chunk array. */
		pElement = ChunkArrayElementToPtrHandles(mh, g_chDocWordList, sel, 0);
		/* and show it */
		@call CDBWordText::MSG_VIS_TEXT_REPLACE_ALL_PTR(pElement->XWMLE_word, 0);

		/* is there a clue there already?  if so - show it */
		if (strlen(pElement->XWMLE_clue))
			@call CDBClueText::MSG_VIS_TEXT_REPLACE_ALL_PTR(pElement->XWMLE_clue, 0);
		else
         @call CDBClueText::MSG_VIS_TEXT_DELETE_ALL();
		VMUnlock(mh);

      @send XWMCluesDBox::MSG_GEN_INTERACTION_INITIATE();
		}

}

/***************************************************************************
 * MSG_XWM_PROCESS_ENTER_CLUE
 ***************************************************************************
 * SYNOPSIS:    puts the clue in the word list
 *
 * PARAMETERS:
 *
 *
 *
 * STRATEGY:
 *
 **************************************************************************/
@method XWMProcessClass, MSG_XWM_PROCESS_ENTER_CLUE
{
MemHandle	mh;
VMBlockHandle	vmbh;
word			sel;
XWMListElement			*pElement;


	sel = @call XWMWordList::MSG_GEN_ITEM_GROUP_GET_SELECTION();
	if (sel != GIGS_NONE)  {
		/* Lock the word list. */
		vmbh = VMFind(g_fhDocument, 0, LIST);
		VMLock(g_fhDocument, vmbh, &mh);

		/* Get the item from the chunk array. */
		pElement = ChunkArrayElementToPtrHandles(mh, g_chDocWordList, sel, 0);
		/* if there is a clue on the screen, store it */
		if (@call CDBClueText::MSG_VIS_TEXT_GET_ALL_PTR(pElement->XWMLE_clue));
		else pElement->XWMLE_clue[0] = 0;

		VMDirty(mh);
		VMUnlock(mh);
		}

}

/***********************************************************************
 *
 * FUNCTION:	NotifyDBox  (char* string1, optr notifyMsg)
 *
 * CALLED BY:
 *
 *
 * STRATEGY:    Puts up selected notification box
 *
 *
 ***********************************************************************/
void NotifyDBox (char* string1, optr notifyMsg)
{

    /* put up a notification box */
	 MemLock (OptrToHandle(@XWFolderTxt));
    UserStandardDialog((char*)0,
			  (char*)0,
			  (char*)0,
			  string1,
			  LMemDeref(notifyMsg),
			  ((CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET) |
			  (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET)));
	 MemUnlock (OptrToHandle(@XWFolderTxt));

}

/***********************************************************************
 *
 * FUNCTION:	AckDBox (char* string1, char* string2, optr ackMsg)
 *
 * CALLED BY:
 *
 *
 * STRATEGY:    returns user's Yes or No response
 *
 *
 ***********************************************************************/
word AckDBox (char* string1, char* string2, optr ackMsg)
{

    /* put up an Are you sure box */
	 MemLock (OptrToHandle(@XWFolderTxt));
    if ((UserStandardDialog((char*)0,
			    (char*)0,
			    string2,
			    string1,
			    LMemDeref(ackMsg),
			    ((CDT_WARNING << CDBF_DIALOG_TYPE_OFFSET) |
			    (GIT_AFFIRMATION << CDBF_INTERACTION_TYPE_OFFSET))
			    ) != IC_YES))  {
	  MemUnlock (OptrToHandle(@XWFolderTxt));
	  return(ACK_NO);
	  }
	 else  {
	  MemUnlock (OptrToHandle(@XWFolderTxt));
	  return(ACK_YES);
	  }

}
/***********************************************************************
 *
 * FUNCTION:	EnableDisableFileUI  (word enOrDis)
 *
 * CALLED BY:
 *
 *
 * STRATEGY:    En/Disables UI based on words in list
 *
 *
 ***********************************************************************/
void EnableDisableFileUI(word enOrDis)
{

	if (enOrDis) {
		@send XWMMakePuzzleTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
		@send XWMMakeCrosswordTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
		@send XWMPrintControl::MSG_GEN_SET_ENABLED(VUM_NOW);
		@send XWMCalculateTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
		}
	else {
		@send XWMMakePuzzleTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
		@send XWMMakeCrosswordTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
		@send XWMPrintControl::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
		@send XWMCalculateTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
		}

}

/***************************************************************************
 * MSG_XWM_PROCESS_WORD_LIST_STATUS
 ***************************************************************************
 * SYNOPSIS:    puts the clue in the word list
 *
 * PARAMETERS:  (GEN_ITEM_GROUP_STATUS_MSG)
 *               word selection
 *               word numSelections
 *               byte stateFlags
 *
 * STRATEGY:    turns triggers on/off based on selection
 *
 **************************************************************************/
@method XWMProcessClass, MSG_XWM_PROCESS_WORD_LIST_STATUS
{

	if (numSelections == 1) {
		@send XWMWordListDeleteTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
		@send XWMCluesTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
		}
	else {
		@send XWMWordListDeleteTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
		@send XWMCluesTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
		}

}


