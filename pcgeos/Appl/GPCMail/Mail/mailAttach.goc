/***********************************************************************
 *
 *	Copyright (c) New Deal 1998 -- All Rights Reserved
 *
 * PROJECT:	  Mail
 * MODULE:	  Mail
 * FILE:	  mailAttach.goc
 *
 * AUTHOR:  	  Gene Anderson: 12/22/98
 *
 * REVISION HISTORY:
 *	Date	  Name	    Description
 *	----	  ----	    -----------
 *	12/22/98  gene	    Initial version
 *
 * DESCRIPTION:
 *	AttachListClass for the Mail application
 *
 *      It really ought to be broken into:
 *          AttachListClass (general behavior)
 *          ReadAttachListClass (opening, saving, converting attachments)
 *          ComposeAttachListClass (attaching, unattaching files)
 *
 * 	$Id$
 *
 ***********************************************************************/

@include "mail.goh"
@include "class.goh"
@include "global.goh"
@include <initfile.h>
@include <token.h>

@ifdef MAIL_CONVERSION_SERVER
@include <impex.goh>
@endif

#include "localize.h"

@classdecl AttachListClass;


/**************************************************************
 *      
 * FUNCTION:        CheckFileTypeCB
 * PASS:            stringSection - ptr to current string
 *                  foo - unused arg
 *                  enumData - ptr to CFTStruct
 * RETURN:          TRUE if found file type
 *                  CFTStruct - filled in
 * DESCRIPTION:
 *         callback for InitFileEnumStringSection()
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      1/19/00    Initial Revision
 ***************************************************************/

TCHAR *
GetToken(TCHAR *p, GeodeToken *token)
{
    word i, id;

    while (*p == ' ' || *p == '\t' || *p == ',') {
	p++;
    }
    /*
     * if we've reached the end of the section, exit
     */
    if (!*p || *p == '\r') {
	return(NULL);
    }
    /*
     * skip the leading quote
     */
    EC_ERROR_IF(*p != '"', MAIL_TOKEN_PARSE_ERROR);
    p++;

    for (i = 0; i<4; i++) {
	token->GT_chars[i] = *p;
	p++;
    }
    /*
     * skip the trailing quote and comma
     */
    EC_ERROR_IF(*p != '"', MAIL_TOKEN_PARSE_ERROR);
    p++;
    EC_ERROR_IF(*p != ',', MAIL_TOKEN_PARSE_ERROR);
    p++;
    /*
     * get the manufacturer ID
     */
    id = 0;
    while (*p >= '0' && *p <= '9') {
	id = 10 * id + *p - '0';
	p++;
    }
    token->GT_manufID = id;
    return(p);
}

typedef struct {
    GeodeToken  *CFTS_icon;
    GeodeToken  *CFTS_token;
    TCHAR       *CFTS_ext;
} CFTStruct;

#pragma argsused
Boolean
_pascal CheckFileTypeCB(const char *stringSection, word foo, void *enumData)
{
    TCHAR *p1, *p2;
    word plen = 0;
    CFTStruct *cfts = enumData;

    /*
     * find the extension to check against
     */
    p1 = strchr(stringSection, '.')+1;
    if (p1) {
	p2 = strchr(p1, '=');
	if (p2 && *(p2-1) == ' ') p2--;
	plen = p2-p1;
    }
    if (((strlen(cfts->CFTS_ext) == plen) && !LocalCmpStringsNoCase(p1, cfts->CFTS_ext, plen)) || p1[0] == '*') {
	/*
	 * the extension matches -- get the icon token and the app token
	 */
	p1 = strchr(p1, '=')+1;
	p1 = GetToken(p1, cfts->CFTS_icon);   /* icon token */
	p1 = GetToken(p1, cfts->CFTS_token);  /* app token */
	if (p1) {
	    return(TRUE);
	}
    }

    return(FALSE);
}

const char filemgrCat[] = "fileManager";
const char filenameTokensKey[] = "filenameTokens";

@ifdef DIALOG_ATTACHMENT_LIST
/***********************************************************************
 *         DisableSaveForSpecialExtensions for AttachListClass
 ***********************************************************************
 *
 * SYNOPSIS:	    Disables the Save button on the Open Attachment
 *                  dialog if we've selected one of the attachments listed
 *                  in the dontSaveAttachments key in GEOS.INI.
 * PARAMETERS:	    word selection - the current selection
 *                  MemHandle listArray - AttachFilePath array containing filename
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	dmedeiros	9/07/00   	Initial Revision
 *
 ***********************************************************************/
#pragma argsused
Boolean _pascal DisableSaveIfExtensionMatches(const char* stringSection,
					      word sectionNum,
					      char* enumData)
{
    if(strcmp(stringSection, enumData) == 0) {
	/* return TRUE if match */
	return TRUE;
    }
    else return FALSE;
}

void DisableSaveForSpecialExtensions(word selection, MemHandle listArray)
{
    AttachFilePath *afp;
    MemHandle mh;
    word elSize;
    word len;
    register word x;

    mh = listArray;
    MemLock(mh);
    afp = ChunkArrayElementToPtr(ME_FIRST_CHUNK, selection, &elSize);    
    
    /* read up to the . in the filename */
    len = strlen(afp->AFP_file);
    for(x = 0; x < len && afp->AFP_file[x] != '.'; x++);
    x++; /* move to the extension */
    
    /* read in each extension from GEOS.INI and 
       compare the extension to the file's extension
       to see if we have a match */
    if(InitFileEnumStringSection("mail", "dontSaveAttachments",
				 IFCC_INTACT << IFRF_CHAR_CONVERT_OFFSET,
				 DisableSaveIfExtensionMatches,
				 (afp->AFP_file+x)) == TRUE) {
	/* disable the save trigger */
	@send DialogSaveAttachTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    }
    else {
	/* ensure the save trigger is enabled */
	@send DialogSaveAttachTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
    }
    MemUnlock(mh);

}	/* End of DisableSaveForSpecialExtensions */
@endif /* DIALOG_ATTACHMENT_LIST */


/**************************************************************
 *      
 * FUNCTION:        MSG_ATTACH_LIST_FREE
 * PASS:            none
 * RETURN:          none
 * DESCRIPTION:
 *         we're shutting down
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      10/26/99    Initial Revision
 ***************************************************************/

@method AttachListClass, MSG_ATTACH_LIST_FREE
{
    if (pself->ALI_array) {
	MemFree(pself->ALI_array);
	pself->ALI_array = 0;
    }
}


/**************************************************************
 *      
 * FUNCTION:        MSG_ATTACH_LIST_FILE_SELECTED
 * PASS:            entryNum - entry #
 *                  entryFlags - GenFileSelectorEntryFlags
 * RETURN:          none
 * DESCRIPTION:
 *         a file has been selected in the Attach dialog
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/22/98    Initial Revision
 ***************************************************************/

@method AttachListClass, MSG_ATTACH_LIST_FILE_SELECTED
{
        GenFileSelectorEntryType entryType = GFS_GET_ENTRY_TYPE(entryFlags);

	/*
	 * enable Attach if a file, else disable
	 */
        if (entryType == GFSET_FILE) {
	    @call ComposeAttachAttach::MSG_GEN_SET_ENABLED(VUM_DLYD);
	} else {
	    @call ComposeAttachAttach::MSG_GEN_SET_NOT_ENABLED(VUM_DLYD);
	}
}


/**************************************************************
 *      
 * FUNCTION:        CheckFileAttached
 * PASS:            el - ptr to AttachFilePath in array
 *                  retVal - ptr to new AttachFilePath to check
 * RETURN:          TRUE if file already attached
 * DESCRIPTION:
 *         see if the specified file is already attached
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/22/98    Initial Revision
 ***************************************************************/

Boolean
_pascal CheckFileAttached (void *el, void *retVal)
{
#pragma argsused
    AttachFilePath *p1, *p2;

    p1 = el;
    p2 = retVal;

    return(!strcmp(p1->AFP_full, p2->AFP_full));
}


/**************************************************************
 *      
 * FUNCTION:        UpdateAttachList
 * PASS:            none
 * RETURN:          none
 * DESCRIPTION:
 *         update an AttachListClass object
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/22/98    Initial Revision
 ***************************************************************/

@method AttachListClass, MSG_ATTACH_LIST_UPDATE_LIST
{
        word numFiles;
@ifdef DIALOG_ATTACHMENT_LIST
        optr genParent;
@else
@ifndef GRAPHICAL_ATTACHMENT_LIST
	TCHAR buf[MAX_FOLDER_CONTENTS_STRING+4];
@else
        optr genParent;
@endif
@endif

	/*
	 * update the dynamic list
	 */
	numFiles = @call oself::MSG_ATTACH_LIST_GET_NUM_FILES();
	@call oself::MSG_GEN_DYNAMIC_LIST_INITIALIZE(numFiles);

@ifdef DIALOG_ATTACHMENT_LIST
        genParent = @call oself::MSG_GEN_FIND_PARENT();
        if (numFiles) {
	    @call genParent::MSG_GEN_SET_USABLE(VUM_DLYD);
	    @call oself::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(0, 0);
	    DisableSaveForSpecialExtensions(0, pself->ALI_array);
	} else {
	    @call genParent::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
	}
@else
@ifdef GRAPHICAL_ATTACHMENT_LIST
        genParent = @call oself::MSG_GEN_FIND_PARENT();
        if (numFiles) {
	    @call genParent::MSG_GEN_SET_USABLE(VUM_DLYD);
	    @call oself::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(0, 0);	    
	} else {
	    @call genParent::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
	}
@else
	@call oself::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(FALSE);
	/*
	 * update the moniker
	 */
	LockStrings();
	switch (numFiles) {
	  case 0:
	    sprintf(buf, LMemDeref(@noAttachmentStr));
	    @call oself::MSG_GEN_SET_NOT_ENABLED(VUM_DLYD);
	    break;
	  case 1:
	    sprintf(buf, LMemDeref(@oneAttachmentStr));
	    @call oself::MSG_GEN_SET_ENABLED(VUM_DLYD);
	    break;
	  default:
	    sprintf(buf, LMemDeref(@nAttachmentsStr), numFiles);
	    @call oself::MSG_GEN_SET_ENABLED(VUM_DLYD);
	    break;
	}
	UnlockStrings();
	@call oself::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(buf, VUM_DLYD);
@endif
@endif
        pself->ALI_lastCheckedItem = GIGS_NONE;
}


/**************************************************************
 *      
 * FUNCTION:        MSG_ATTACH_LIST_ATTACH_FILE
 * PASS:            none
 * RETURN:          none
 * DESCRIPTION:
 *         attach the current file to the message
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/22/98    Initial Revision
 ***************************************************************/


@method AttachListClass, MSG_ATTACH_LIST_ATTACH_FILE
{
        MemHandle mh;
	AttachFilePath fullBuf, tempBuf;
	AttachFilePath *afp;
	TCHAR *fbp = &fullBuf.AFP_full;
	DiskHandle afDisk;

	/*
	 * create the attachment array if it doesn't exist
	 */
	@call oself::MSG_ATTACH_LIST_ENSURE_ARRAY();
	mh = pself->ALI_array;
	/*
	 * get the filename
	 */
	@call ComposeAttachFileSelector::MSG_GEN_FILE_SELECTOR_GET_SELECTION(fullBuf.AFP_file);
	/*
	 * get the full path and filename
	 */
	afDisk = GFS_GET_FULL_SELECTION_PATH_DISK_HANDLE(@call ComposeAttachFileSelector::MSG_GEN_FILE_SELECTOR_GET_FULL_SELECTION_PATH(tempBuf.AFP_full));
	FileConstructFullPath(&fbp, sizeof(fullBuf), afDisk, tempBuf.AFP_full, TRUE);
	MemLock(mh);
	/*
	 * See if the file has already been added and see if the user
	 * wants to add it again
	 */
	if (ChunkArrayEnum(ME_FIRST_CHUNK, &fullBuf, CheckFileAttached)) {
	    if (DoYesNo(@attachFileTwiceStr, fullBuf.AFP_file) == IC_NO) {
	        MemUnlock(mh);
		return;
	    }
	}
	/*
	 * add an entry for the file
	 */
	afp = ChunkArrayAppend(ME_FIRST_CHUNK, sizeof(AttachFilePath));
	/*
	 * copy the file and path into the array
	 */
	memcpy(afp, &fullBuf, sizeof(AttachFilePath));
	MemUnlock(mh);
	/*
	 * update the attachment list
	 */
	@call oself::MSG_ATTACH_LIST_UPDATE_LIST();
	/*
	 * enable the save button since we've modified the message
	 */
	@call ComposeSave::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);

	/*
	 * close the dialog
	 */
	@call ComposeAttachDialog::MSG_GEN_INTERACTION_ACTIVATE_COMMAND(IC_DISMISS);
}


/**************************************************************
 *      
 * FUNCTION:        MSG_ATTACH_LIST_ATTACH_FILE_PATH
 * PASS:            fileName - ptr to full path & filename
 * RETURN:          none
 * DESCRIPTION:
 *         Attach a file with full path to the array
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/22/98    Initial Revision
 ***************************************************************/

@method AttachListClass, MSG_ATTACH_LIST_ATTACH_FILE_PATH
{
    MemHandle mh;
    AttachFilePath *afp;
    TCHAR *fnp;

    /*
     * create the attachment array if it doesn't exist
     */
    @call oself::MSG_ATTACH_LIST_ENSURE_ARRAY();
    mh = pself->ALI_array;

    MemLock(mh);
    /*
     * add an entry for the file
     */
    afp = ChunkArrayAppend(ME_FIRST_CHUNK, sizeof(AttachFilePath));
    /*
     * copy the file and path into the array
     */
    strcpy(afp->AFP_full, fileName);
    fnp = strrchr(fileName, C_BACKSLASH)+1;
    strcpy(afp->AFP_file, fnp);
    MemUnlock(mh);
    /*
     * update ourselves
     */
    @call oself::MSG_ATTACH_LIST_UPDATE_LIST();
}



/**************************************************************
 *      
 * FUNCTION:        MSG_ATTACH_LIST_DELETE_FILES
 * PASS:            none
 * RETURN:          none
 * DESCRIPTION:
 *         delete any attached files
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/22/98    Initial Revision
 ***************************************************************/

@method AttachListClass, MSG_ATTACH_LIST_DELETE_FILES
{
    MemHandle mh = pself->ALI_array;
    DMStruct dms;

    if (mh) {
	MemLock(mh);
	ChunkArrayEnum(ME_FIRST_CHUNK, &dms, DeleteAttachmentCB);
	MemFree(mh);
	pself->ALI_array = 0;
    }
}


/**************************************************************
 *      
 * FUNCTION:        MSG_ATTACH_LIST_GET_NUM_FILES
 * PASS:            none
 * RETURN:          # of files
 * DESCRIPTION:
 *         get the number of files currently attached
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/22/98    Initial Revision
 ***************************************************************/

@method AttachListClass, MSG_ATTACH_LIST_GET_NUM_FILES
{
        word numFiles;
	MemHandle mh;

	mh = pself->ALI_array;
	if (mh) {
	    MemLock(mh);
	    numFiles = ChunkArrayGetCount(ME_FIRST_CHUNK);
	    MemUnlock(mh);
	} else {
	    numFiles = 0;
	}
	return(numFiles);
}

@ifdef GEOS_FILE_INSTRUCTIONS


/**************************************************************
 *      
 * FUNCTION:        MSG_ATTACH_LIST_GET_NUM_GEOS_FILES
 * PASS:            none
 * RETURN:          # of GEOS files
 * DESCRIPTION:
 *         get the number of GEOS files currently attached
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      02/24/00    Initial Revision
 ***************************************************************/


Boolean
_pascal CountGEOSFiles (void *el, void *retVal)
{
#pragma argsused
    AttachFilePath *p1;
    word *count;
    GeodeToken token;

    p1 = el;
    count = retVal;

    /*
     * see if a GEOS file
     */
    if (!FileGetPathExtAttributes(p1->AFP_full, FEA_CREATOR, &token, sizeof(GeodeToken))) {
	(*count)++;
    }

    return(FALSE);
}

@method AttachListClass, MSG_ATTACH_LIST_GET_NUM_GEOS_FILES
{
        word numFiles = 0;
	MemHandle mh;

	mh = pself->ALI_array;
	if (mh) {
	    MemLock(mh);
	    ChunkArrayEnum(ME_FIRST_CHUNK, &numFiles, CountGEOSFiles);
	    MemUnlock(mh);
	}
	return(numFiles);
}

@endif // GEOS_FILE_INSTRUCTIONS


@ifdef GRAPHICAL_ATTACHMENT_LIST


/**************************************************************
 *      
 * FUNCTION:        AttachListSetMoniker
 * PASS:            list - list optr to set moniker in
 *                  item - item # to set
 *                  afp - ptr to AttachFilePath
 * RETURN:          TRUE if GEOS file
 * DESCRIPTION:
 *         Make and set a gstring moniker for an attachment
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      1/19/00     Initial Revision
 ***************************************************************/

const char gaiStar[] = "*";

Boolean
GetAttachIcon(AttachFilePath *afp, GeodeToken *gtoken)
{
    word ferror;
    CFTStruct cfts;
    GeodeToken tempTok;
    TCHAR *ext;
    Boolean isGEOS = TRUE;

    ferror = FileGetPathExtAttributes(afp->AFP_full, FEA_CREATOR, gtoken, sizeof(GeodeToken));
    if (ferror == ERROR_ATTR_NOT_FOUND) {
	isGEOS = FALSE;
	/*
	 * no creator; get the extension if any
	 */
	ext = strrchr(afp->AFP_file, '.');
	if (!ext) {
	    ext = gaiStar;
	} else {
	    ext++;
	}
	cfts.CFTS_token = &tempTok;
	cfts.CFTS_icon = gtoken;
	cfts.CFTS_ext = ext;
	InitFileEnumStringSection(filemgrCat,
				  filenameTokensKey,
				  IFRF_READ_ALL,
				  CheckFileTypeCB,
				  &cfts);
    }
    return(isGEOS);
}

void
AttachListSetMoniker(optr list, word item, AttachFilePath *afp)
{
    GStateHandle gs, mgs;
    word   gschunk;
    TokenMonikerInfo tmi;
    byte *moniker;
    VisMoniker *vmp;
    byte *gstr;
    word foo;
    GeodeToken gtoken;
    Boolean foundToken;
    Bitmap *bmap;

    /*
     * create a GString to use
     */
    gs = GrCreateGString(OptrToHandle(list), GST_CHUNK, &gschunk);
    /*
     * figure out which icon to use
     */
    GetAttachIcon(afp, &gtoken);
    /*
     * get and draw the icon
     */
    foundToken = TokenLookupMoniker(TOKEN_CHARS(gtoken.GT_chars[0],
						gtoken.GT_chars[1],
						gtoken.GT_chars[2],
						gtoken.GT_chars[3]),
				    gtoken.GT_manufID,
				    ATTACH_LIST_ICON_DISPLAY_TYPE,
				    ATTACH_LIST_ICON_SEARCH_FLAGS,
				    &tmi);
    if (foundToken) {
	moniker = TokenLockTokenMoniker(tmi);
	vmp = LMemDeref((optr) moniker);

	if (vmp->VM_width <= ATTACH_LIST_ICON_WIDTH) {
	    gstr = (byte *)vmp+(sizeof(VisMonikerWithGString));
	    mgs = GrLoadGString(PtrToSegment(gstr), GST_PTR, PtrToOffset(gstr));
	    GrSaveState(gs);
	    GrDrawGString(gs, mgs, 0, 1, 0, &foo);
	    GrRestoreState(gs);
	    GrDestroyGString(mgs, gs, GSKT_LEAVE_DATA);
	} else {
	    /*
	     * icon is too large; set flag and use default
	     */
	    foundToken = FALSE;
	}
	TokenUnlockTokenMoniker(moniker);
    }
    if (!foundToken) {
	/*
	 * no icon; use our default
	 */
	MemLock(OptrToHandle(@AttachTCMoniker));
	bmap = LMemDeref(@AttachTCMoniker);
	GrDrawBitmap(gs, 0, 1, bmap, NULL);
	MemUnlock(OptrToHandle(@AttachTCMoniker));
    }
    /*
     * draw the filename next to the icon
     */
    GrDrawText(gs, ATTACH_LIST_ICON_WIDTH+2, 1, afp->AFP_file, 0);

    /*
     * Finish up the gstring
     */
    GrEndGString(gs);
    /*
     * Finally, set the moniker
     */
    @call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_MONIKER(
	item,              /* Item number -- Folder number */
	0,                 /* Item not disabled */
	0,                 /* height, 0 = auto detect */
	0,                 /* width, 0 = auto detect */
	0,                 /* size, 0 = auto detect */
	VMDT_GSTRING,
	VMST_OPTR,
	ConstructOptr(OptrToHandle(list), gschunk)
	);

    GrDestroyGString(gs, 0, GSKT_KILL_DATA);
}

@endif // GRAPHICAL_ATTACHMENT_LIST


/**************************************************************
 *      
 * FUNCTION:        MSG_ATTACH_LIST_QUERY_MONIKER
 * PASS:            list - optr of list
 *                  item - item #
 * RETURN:          none
 * DESCRIPTION:
 *         get the moniker for the specified list entry
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/22/98    Initial Revision
 ***************************************************************/

@method AttachListClass, MSG_ATTACH_LIST_QUERY_MONIKER
{
        AttachFilePath *afp;
	MemHandle mh;
	word elSize;

	mh = pself->ALI_array;
	MemLock(mh);
	afp = ChunkArrayElementToPtr(ME_FIRST_CHUNK, item, &elSize);
@ifdef GRAPHICAL_ATTACHMENT_LIST
        AttachListSetMoniker(list, item, afp);
@else

@ifdef SHOW_FULL_ATTACHMENT_PATH
        @call oself::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_TEXT(item, afp->AFP_full);
@else
        @call oself::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_TEXT(item, afp->AFP_file);
@endif // SHOW_FULL_ATTACHMENT_PATH
@endif // GRAPHICAL_ATTACHMENT_LIST
        MemUnlock(mh);
}



/**************************************************************
 *      
 * FUNCTION:        AppendAttachFile
 * PASS:            el - ptr to AttachFilePath in array
 *                  fileHan - ptr to FileHandle
 * RETURN:          FALSE to continue
 * DESCRIPTION:
 *         append one attachment file
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/23/98    Initial Revision
 ***************************************************************/

TCHAR semiStr[] = "; ";

Boolean
_pascal AppendAttachFile (void *el, void *fileHanP)
{
#pragma argsused

        AttachFilePath *p1 = el;
	FileHandle *fp2 = fileHanP;
	FileHandle fh = *fp2;

        AppendMessageFilePtr(fh, p1->AFP_full);
	AppendMessageFilePtr(fh, semiStr);
        return(FALSE);
}


/**************************************************************
 *      
 * FUNCTION:        MSG_ATTACH_LIST_APPEND_ATTACHMENTS
 * PASS:            fileHan - handle of file
 * RETURN:          none
 * DESCRIPTION:
 *         append the attachments to the passed file
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/22/98    Initial Revision
 ***************************************************************/

@method AttachListClass, MSG_ATTACH_LIST_APPEND_ATTACHMENTS
{
        MemHandle mh = pself->ALI_array;
	MemLock(mh);
	ChunkArrayEnum(ME_FIRST_CHUNK, &fileHan, AppendAttachFile);
	MemUnlock(mh);
}


/**************************************************************
 *      
 * FUNCTION:        MSG_ATTACH_LIST_RESET
 * PASS:            none
 * RETURN:          none
 * DESCRIPTION:
 *         reset the list to no attachments
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/22/98    Initial Revision
 ***************************************************************/

@method AttachListClass, MSG_ATTACH_LIST_RESET
{
        MemHandle mh = pself->ALI_array;

	if (mh) {
	    MemFree(mh);
	    pself->ALI_array = 0;
	}
	@call oself::MSG_ATTACH_LIST_UPDATE_LIST();
}


/**************************************************************
 *      
 * FUNCTION:        MSG_ATTACH_LIST_READ_ATTACHMENTS
 * PASS:            fileHan - handle of file
 * RETURN:          none
 * DESCRIPTION:
 *         read attachment files from a message file
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/22/98    Initial Revision
 ***************************************************************/

@method AttachListClass, MSG_ATTACH_LIST_READ_ATTACHMENTS
{
	/*
	 * make sure there's an empty array
	 */
	@call oself::MSG_ATTACH_LIST_ENSURE_ARRAY();
	/*
	 * read the attachments
	 */
	ReadAttachments(pself->ALI_array, fileHan);
	/*
	 * update the list
	 */
	@call oself::MSG_ATTACH_LIST_UPDATE_LIST();
}



/**************************************************************
 *      
 * FUNCTION:        MSG_ATTACH_LIST_ENSURE_ARRAY
 * PASS:            none
 * RETURN:          none
 * DESCRIPTION:
 *         make sure the attachment array exists
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/22/98    Initial Revision
 ***************************************************************/

@method AttachListClass, MSG_ATTACH_LIST_ENSURE_ARRAY
{
        if (!pself->ALI_array) {
	    pself->ALI_array = CreateChunkArrayBlock(sizeof(AttachFilePath));
	    MemUnlock(pself->ALI_array);
	}
}



/**************************************************************
 *      
 * FUNCTION:        CheckDOSFileType
 * PASS:            ext - ptr to extension string
 *                  token - ptr to GeodeToken to return
 * RETURN:          TRUE if file type supported
 *                  token - filled in
 * DESCRIPTION:
 *         see if a file is a DOS file type we support directly
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      2/28/99    Initial Revision
 *	   dhunter   10/12/00    Added Impex auto-detect test
 ***************************************************************/

Boolean
CheckDOSFileType(AttachFilePath *afp, GeodeToken *token)
{
    CFTStruct cfts;
    GeodeToken tempTok;
    TCHAR *ext = strrchr(afp->AFP_file, '.');
    Boolean retval = FALSE;
@ifdef MAIL_CONVERSION_SERVER
    optr fileSel;
    PathName tempPath;
    char *pPath, *pEndPath;
    DiskHandle disk;
@endif

    cfts.CFTS_token = token;
    cfts.CFTS_icon = &tempTok;
    cfts.CFTS_ext = ext + 1;
    if (ext != NULL && ext[1] != '\0' &&
	InitFileEnumStringSection(filemgrCat, filenameTokensKey,
				     IFRF_READ_ALL, CheckFileTypeCB, &cfts))
    {
@ifdef MAIL_CONVERSION_SERVER
	if (toupper(ext[1]) == 'D' && toupper(ext[2]) == 'O'
	    && toupper(ext[3]) == 'C' && ext[4] == '\0')
	{
	    /* Hack for .DOC:
	     *
	     * When file may be an old version we can't import, we'd like to
	     * know now so we can tell the user to go convert it.
	     */
	    @call MailAppObj::MSG_GEN_APPLICATION_MARK_BUSY();
	    /* Bring up the import control dialog (because otherwise it's
	       unhappy) in the background. */
	    @call ImportControl::MSG_GEN_INTERACTION_INITIATE_NO_DISTURB();
	    
	    /* Set the file selector to our file. */
	    fileSel = @call ImportControl::MSG_IMPORT_CONTROL_GET_FILE_SELECTOR();
	    EC_ERROR_IF(fileSel == NullOptr, MAIL_IMPORT_ERROR);
	    /* Copy the absolute file path to a temporary buffer so we can get
	       its disk handle. */
	    pEndPath = strrchr(afp->AFP_full, '\\');
	    EC_ERROR_IF(pEndPath == NULL, MAIL_IMPORT_ERROR);
	    *pEndPath = '\0';
	    pPath = tempPath;
	    disk = FileConstructFullPath(&pPath, sizeof(tempPath), NullHandle, 
					 afp->AFP_full, FALSE);
	    if (!(@call fileSel::MSG_GEN_PATH_SET(tempPath, disk)))
	    {
		@call fileSel::MSG_GEN_FILE_SELECTOR_SET_SELECTION(afp->AFP_file);
		@call ImportControl::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
		
		/* See if any impex translators can auto-detect the file type. */
		if (!(@call ImportControl::
		MSG_IMPORT_CONTROL_AUTO_DETECT_FILE_FORMAT()))
		    retval = TRUE;
	    }
	    *pEndPath = '\\';
	    @call MailAppObj::MSG_GEN_APPLICATION_MARK_NOT_BUSY();
	}
	else
@endif
	    retval = TRUE;
    }
    return retval;
}


/**************************************************************
 *      
 * FUNCTION:        MSG_ATTACH_LIST_ATTACHMENT_SELECTED
 * PASS:            selection - item #
 *                  numSelections - # of selections
 *                  stateFlags - GenItemGroupStateFlags
 * RETURN:          none
 * DESCRIPTION:
 *         an attachment has been selected
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      2/28/99    Initial Revision
 *         dhunter   10/13/00   Cache results of last type check
 ***************************************************************/

@method AttachListClass, MSG_ATTACH_LIST_ATTACHMENT_SELECTED
{
@ifdef MAIL_CONVERSION_SERVER
    GeodeToken token;
    Boolean canOpen = TRUE;
@endif
    word ferror, elSize;
    AttachFilePath *afp;
    MemHandle mh;
    TCHAR buf[UHTA_NULL_TERM_BUFFER_SIZE];
    dword fileSize;
    word fsFrac;
    LocalNumericFormat nf;

    if (!numSelections) {
	return;
    }
    LocalGetNumericFormat(&nf);
    /*
     * see if the attachment is a GEOS file
     */
    mh = pself->ALI_array;
    MemLock(mh);
    afp =  ChunkArrayElementToPtr(ME_FIRST_CHUNK, selection, &elSize);
@ifdef MAIL_CONVERSION_SERVER
    ferror = TRUE;
    ferror = FileGetPathExtAttributes(afp->AFP_full, FEA_CREATOR, &token, sizeof(GeodeToken));
    /*
     * if not a GEOS file, see if it is DOS file we can open
     */
    if (ferror == ERROR_ATTR_NOT_FOUND) {
	if (pself->ALI_lastCheckedItem != selection)
	{
	    pself->ALI_lastCheckedItem = selection;
	    pself->ALI_lastCheckedResult = canOpen = 
		CheckDOSFileType(afp, &pself->ALI_lastCheckedToken);
	}
	else
	    canOpen = pself->ALI_lastCheckedResult;
    }
    if (canOpen) {
	@call OpenAttachTrigger::MSG_GEN_SET_USABLE(VUM_NOW);
	@call ConvertAttachTrigger::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
	@call ConvertAttachText::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
    } else {
	@call OpenAttachTrigger::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
	@call ConvertAttachTrigger::MSG_GEN_SET_USABLE(VUM_NOW);
	@call ConvertAttachText::MSG_GEN_SET_USABLE(VUM_NOW);
    }
@endif
    /*
     * set the name of the attachment in the dialog
     */
    @call SaveAttachName::MSG_VIS_TEXT_REPLACE_ALL_PTR(afp->AFP_file, 0);
    @call AttachNameText::MSG_VIS_TEXT_REPLACE_ALL_PTR(afp->AFP_file, 0);
    ferror = FileGetPathExtAttributes(afp->AFP_full, FEA_SIZE,
				      &fileSize, sizeof(dword));
    if (!ferror) {
	fsFrac = ((fileSize%1024) * 10) / 1024;
	sprintf(buf, " (%ld%c%dK)", fileSize/1024,
		nf.decimalSeparator, fsFrac);
	@call AttachNameText::MSG_VIS_TEXT_APPEND_PTR(buf, 0);
	@call OpenAttachTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
	@call SaveAttachTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
    } else {
	LockStrings();
	@call AttachNameText::MSG_VIS_TEXT_APPEND_OPTR(@attachUnreadable, 0);
	UnlockStrings();
	@call OpenAttachTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	@call SaveAttachTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    }
    MemUnlock(mh);

    /* disable the "Save" button for special file extensions
       listed in the INI file. */
@ifdef DIALOG_ATTACHMENT_LIST
     DisableSaveForSpecialExtensions(selection, pself->ALI_array);
@endif

    /*
     * bring up the dialog letting the user choose what to do
     */
@ifndef DIALOG_ATTACHMENT_LIST  /* only for non-supported when OPENed */
    @call ReadAttachDialog::MSG_GEN_INTERACTION_INITIATE();
@endif
}



/**************************************************************
 *      
 * FUNCTION:        OpenDocFile
 * PASS:            afp - ptr to AttachFilePath
 *                  token - ptr to GeodeToken
 * RETURN:          none
 * DESCRIPTION:
 *         open a document file
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      2/28/99    Initial Revision
 ***************************************************************/
void
OpenDocFile(AttachFilePath *afp, GeodeToken token)
{
    MemHandle launchHan;
    AppLaunchBlock  *launchBlock;
    word i;
    StandardPath spath;
    TCHAR *np;

    /*
     *  create a launch block
     */
    launchHan = MemAlloc(sizeof(AppLaunchBlock),
			 HF_SWAPABLE | HF_SHARABLE,
			 HAF_STANDARD_NO_ERR | HAF_ZERO_INIT);
    launchBlock = (AppLaunchBlock *)MemLock(launchHan);
@if 1
    np = afp->AFP_full;
    spath = FileParseStandardPath(0, &np);
    i = strlen(np);
    i -= strlen(afp->AFP_file);
    strncpy(launchBlock->ALB_path, np, i);
    launchBlock->ALB_path[i-1] = NULL;
    launchBlock->ALB_diskHandle = spath;
    strcpy(launchBlock->ALB_dataFile, afp->AFP_file);
@else
    i = strlen(afp->AFP_full);
    i -= strlen(afp->AFP_file);
    strncpy(launchBlock->ALB_path, 
	    afp->AFP_full,i);
    launchBlock->ALB_path[i-1] = NULL;
    strcpy(launchBlock->ALB_dataFile, 
	   afp->AFP_file);
    launchBlock->ALB_diskHandle = NULL;
@endif
    launchBlock->ALB_launchFlags = ALF_OVERRIDE_MULTIPLE_INSTANCE;
    FilePushDir();
    FileSetCurrentPath(NULL, launchBlock->ALB_path);
    FileSetAttributes(launchBlock->ALB_dataFile, FILE_ATTR_READ_ONLY);
    FilePopDir();
    MemUnlock(launchHan);
    @send, forceQueue MailAppObj::MSG_MAIL_APP_LAUNCH_APPLICATION(token, launchHan, 0, @docLaunchErr);
}


/***********************************************************************
 *		MSG_ATTACH_LIST_OPEN_FILE for AttachListClass
 ***********************************************************************
 *
 * SYNOPSIS:	    If the attachment is a geos file, create a launch 
 *                  block for it, and send a message for it to be launched.
 *                  If it is not a geos file, we will have to go 
 *                  through an as yet to be implemented process of 
 *                  looking for non geos files that we support, and 
 *                  trying to convert the file.
 *                  For now it just does nothing.
 *
 * PARAMETERS:	    
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	        Date		Description
 *	----	        ----		-----------
 *	porteous	2/21/99   	Initial Revision
 *      gene            2/28/99         Added check for DOS file types
 *      dhunter         10/13/00        Cache results of last type check
 *
 ***********************************************************************/

@method AttachListClass, MSG_ATTACH_LIST_OPEN_FILE
{
    word i, elSize;
    AttachFilePath *afp;
    MemHandle mh;
    GeodeToken token;
    FileError ferror;

    @call ReadAttachDialog::MSG_GEN_INTERACTION_ACTIVATE_COMMAND(IC_DISMISS);

    mh = pself->ALI_array;
    MemLock(mh);
    i = @call oself::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    ferror = TRUE;
    if (i != GIGS_NONE) {
	afp =  ChunkArrayElementToPtr(ME_FIRST_CHUNK, i, &elSize);
	ferror = FileGetPathExtAttributes(afp->AFP_full, FEA_CREATOR, &token, sizeof(GeodeToken));
    }

    if (!ferror) {
	OpenDocFile(afp, token);
    } else if (ferror == ERROR_ATTR_NOT_FOUND) {
	/*
	 * if the file is a DOS file, see if it is one we support or not
	 */
	if (pself->ALI_lastCheckedItem != i)
	{
	    pself->ALI_lastCheckedItem = i;
	    pself->ALI_lastCheckedResult = 
		CheckDOSFileType(afp, &pself->ALI_lastCheckedToken);
	}
	if (pself->ALI_lastCheckedResult)
	    OpenDocFile(afp, pself->ALI_lastCheckedToken);
	else {
            /*
	     * the file is not one we support -- complain
	     */
            ReportError(@docLaunchErr, NULL);
	}
    } else {
	ReportError(@docLaunchErr, NULL);
    }
    MemUnlock(mh);
}	/* End of MSG_ATTACH_LIST_OPEN_FILE.	*/


@ifdef DIALOG_ATTACHMENT_LIST

@method AttachListClass, MSG_ATTACH_LIST_CHECK_AND_OPEN_FILE
{
    word i, elSize;
    AttachFilePath *afp;
    MemHandle mh;
    GeodeToken token;
    FileError ferror;

    mh = pself->ALI_array;
    MemLock(mh);
    i = @call oself::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    /* update stuff */
    @call oself::MSG_ATTACH_LIST_ATTACHMENT_SELECTED(i, 1, 0);
    ferror = TRUE;
    if (i != GIGS_NONE) {
	afp =  ChunkArrayElementToPtr(ME_FIRST_CHUNK, i, &elSize);
	ferror = FileGetPathExtAttributes(afp->AFP_full, FEA_CREATOR, &token, sizeof(GeodeToken));
    }

    if (!ferror) {
	OpenDocFile(afp, token);
    } else if (ferror == ERROR_ATTR_NOT_FOUND) {
	/*
	 * if the file is a DOS file, see if it is one we support or not
	 */
	if (pself->ALI_lastCheckedItem != i)
	{
	    pself->ALI_lastCheckedItem = i;
	    pself->ALI_lastCheckedResult = 
		CheckDOSFileType(afp, &pself->ALI_lastCheckedToken);
	}
	if (pself->ALI_lastCheckedResult)
	    OpenDocFile(afp, pself->ALI_lastCheckedToken);
	else {
            /*
	     * the file is not one we support -- open convert dialog
	     */
	    @call ReadAttachDialog::MSG_GEN_INTERACTION_INITIATE();
	}
    } else {
	ReportError(@docLaunchErr, NULL);
    }
    MemUnlock(mh);
}

@endif



/**************************************************************
 *      
 * FUNCTION:        MSG_ATTACH_LIST_CONVERT_FILE
 * PASS:            none
 * RETURN:          none
 * DESCRIPTION:
 *         update an AttachListClass object
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      3/1/99      Initial Revision
 ***************************************************************/

@ifdef MAIL_CONVERSION_SERVER

@method AttachListClass, MSG_ATTACH_LIST_CONVERT_FILE
{
    PathName fileName, buffer;
    MemHandle mh = pself->ALI_array;
    FileHandle fh;
    AttachFilePath *afp;
    word selection, elSize;
    TCHAR *p, *oboxName, *afn;

    /*
     * take the dialog off screen
     */
    @call ReadAttachDialog::MSG_GEN_INTERACTION_ACTIVATE_COMMAND(IC_DISMISS);
    selection = @call oself::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    /*
     * create the message file
     */
    LockStrings();
    FilePushDir();
    GotoMailDirectory(NULL);
    oboxName = MailLockStdString(MSS_OUTBOX_FOLDER);
    strcpy(fileName, oboxName);
    MailUnlockStdString(MSS_OUTBOX_FOLDER);
    fh = FileCreateTempFile(fileName,
			    FCF_NATIVE|FILE_DENY_RW|FILE_ACCESS_RW, 0);
    FilePopDir();
    if (!fh) {
	return;
    }
    /*
     * fill in the To: field
     */
    AppendMessageFileChunk(fh, @toFieldOut);
    AppendMessageFileChunk(fh, @convertAddr);
    AppendMessageFileCR(fh);
    /*
     * fill in the From: field
     */
    AppendMessageFileChunk(fh, @fromFieldOut);
    @call PfReturnAddr::MSG_VIS_TEXT_GET_ALL_PTR(buffer);
    AppendMessageFilePtr(fh, buffer);
    AppendMessageFileCR(fh);
    /*
     * fill in the Subject: field
     */
    MemLock(mh);
    afp =  ChunkArrayElementToPtr(ME_FIRST_CHUNK, selection, &elSize);
    AppendMessageFileChunk(fh, @subjectFieldOut);
    AppendMessageFilePtr(fh, afp->AFP_file);
    AppendMessageFileCR(fh);
    /*
     * fill in the Date: field
     */
    AppendMessageFileDate(fh);
    /*
     * copy the attachment to Outbox/Attachments
     */
    strcpy(buffer, afp->AFP_file);
    MakeOutboxAttachmentPath(buffer);
    FileCopy(afp->AFP_full, buffer, 0, 0);
    /*
     * fill in the X-Mail-Tools-Attachment: field
     */
    afn = MailLockStdString(MSS_ATTACH_FIELD_OUT);
    AppendMessageFilePtr(fh, afn);
    MailUnlockStdString(MSS_ATTACH_FIELD_OUT);

    AppendMessageFilePtr(fh, buffer);
    AppendMessageFilePtr(fh, semiStr);
    MemUnlock(mh);
    AppendMessageFileCR(fh);
    AppendMessageFileCR(fh);
    AppendMessageFileCR(fh);
    AppendMessageFileCR(fh);
    AppendMessageFileCR(fh);

    FileClose(fh, FALSE);
    UnlockStrings();
    p = strrchr(fileName, C_BACKSLASH)+1;
    InsertMessageListArray(MFID_OUTBOX,p);
    /*
     * if 'Send Immediately', do so
     */
@ifndef NO_COMPOSE_OPTIONS
    if (@call ComposeSendOptionsList::MSG_GEN_ITEM_GROUP_GET_SELECTION() == MSO_SEND_IMMEDIATELY) {
@endif

	@call SendReceiveDialog::MSG_MSR_SEND_AND_RECEIVE_MESSAGES();
@ifndef NO_COMPOSE_OPTIONS
    } else {
	RebuildFolderList(MFID_LEAVE_SELECTION, TRUE);
    }
@endif
}

@endif


/**************************************************************
 *      
 * FUNCTION:        MSG_ATTACH_LIST_SAVE_FILE
 * PASS:            none
 * RETURN:          none
 * DESCRIPTION:
 *         update an AttachListClass object
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      3/1/99      Initial Revision
 ***************************************************************/

@method AttachListClass, MSG_ATTACH_LIST_SAVE_FILE
{
@ifdef DIALOG_ATTACHMENT_LIST
    int i;

    /* update stuff */
    i = @call oself::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    @call oself::MSG_ATTACH_LIST_ATTACHMENT_SELECTED(i, 1, 0);
@endif
    @call ReadAttachDialog::MSG_GEN_INTERACTION_ACTIVATE_COMMAND(IC_DISMISS);
    @call SaveAttachDialog::MSG_GEN_INTERACTION_INITIATE();
}



/**************************************************************
 *      
 * FUNCTION:        MSG_ATTACH_LIST_DO_SAVE
 * PASS:            none
 * RETURN:          none
 * DESCRIPTION:
 *         update an AttachListClass object
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      3/1/99      Initial Revision
 ***************************************************************/

TCHAR backSlashStr5[] = "\\";

@method AttachListClass, MSG_ATTACH_LIST_DO_SAVE
{
    FileLongName fileName;
    PathName fullBuf, tempBuf;
    DiskHandle afDisk;
    TCHAR *fbp = &fullBuf;
    AttachFilePath *afp;
    MemHandle mh;
    word selection, err, elSize;
    optr errMsg;
    Boolean closeDialogs = TRUE;

    mh = pself->ALI_array;
    /*
     * get the filename
     */
    @call SaveAttachName::MSG_VIS_TEXT_GET_ALL_PTR(fileName);
    /*
     * get the full path and filename
     */
    afDisk = GFS_GET_FULL_SELECTION_PATH_DISK_HANDLE(@call SaveAttachSelector::MSG_GEN_FILE_SELECTOR_GET_FULL_SELECTION_PATH(&tempBuf));
    @call SaveAttachSelector::MSG_GEN_FILE_SELECTOR_GET_DESTINATION_PATH(&tempBuf, sizeof(tempBuf));
    FileConstructFullPath(&fbp, sizeof(fullBuf), afDisk, tempBuf, TRUE);
    strcat(fullBuf, backSlashStr5);
    strcat(fullBuf, fileName);
    /*
     * try to copy the file
     */
    MemLock(mh);
    selection = @call oself::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    afp =  ChunkArrayElementToPtr(ME_FIRST_CHUNK, selection, &elSize);
    /*
     * if the file exists, see if the user wants to overwrite
     */
    FileGetAttributes(fullBuf);
    if (!ThreadGetError()) {
	if (DoYesNo(@saveAttachOverwriteStr, fileName) == IC_YES) {
	    FileSetAttributes(fullBuf, FILE_ATTR_NORMAL);
	    err = FileDelete(fullBuf);
	    if (!err) {
		err = FileCopy(afp->AFP_full, fullBuf, 0, 0);
	    }
	} else {
	    err = 0;
	    closeDialogs = FALSE;  /* leave dialogs up */
	}
    } else {
	err = FileCopy(afp->AFP_full, fullBuf, 0, 0);
    }
    /*
     * make sure the file is writable now
     */
    FileSetAttributes(fullBuf, FILE_ATTR_NORMAL);
    /*
     * close the dialog else report the error
     */
    if (!err) {
	if (closeDialogs) {
	@call SaveAttachDialog::MSG_GEN_INTERACTION_ACTIVATE_COMMAND(IC_DISMISS);
@ifdef DIALOG_ATTACHMENT_LIST
	/* close main dialog, also */
	@call ReadAttachGroup::MSG_GEN_INTERACTION_ACTIVATE_COMMAND(IC_DISMISS);
@endif
        }
    } else {
	switch (err) {
	case ERROR_INVALID_LONGNAME:
	    errMsg = @saveAttachNameErr;
	    break;
	default:
	    errMsg = @saveAttachErr;
	    break;
	}
	ReportError(errMsg, fileName);
    }
    MemUnlock(mh);
}



/**************************************************************
 *      
 * FUNCTION:        MSG_ATTACH_LIST_COMPOSE_ATTACHMENT_SELECTED
 * PASS:            selected - selection #
 *                  numSelections - # of selections
 * RETURN:          none
 * DESCRIPTION:
 *         a file has bene selected to remove
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      8/25/99      Initial Revision
 ***************************************************************/

@ifndef DIALOG_ATTACHMENT_LIST

@method AttachListClass, MSG_ATTACH_LIST_COMPOSE_ATTACHMENT_SELECTED
{
    MemHandle mh;
    AttachFilePath *afp;
    word elSize;

    /*
     * put the file name in the dialog
     */
    mh = pself->ALI_array;
    MemLock(mh);
    afp = ChunkArrayElementToPtr(ME_FIRST_CHUNK, selection, &elSize);
@ifdef SHOW_FULL_ATTACHMENT_PATH
    @call ComposeAttachRemoveName::MSG_VIS_TEXT_REPLACE_ALL_PTR(afp->AFP_full, 0);
@else
    @call ComposeAttachRemoveName::MSG_VIS_TEXT_REPLACE_ALL_PTR(afp->AFP_file, 0);
@endif
    MemUnlock(mh);
    /*
     * bring the dialog on screen
     */
    @call ComposeAttachRemoveDialog::MSG_GEN_INTERACTION_INITIATE();
}

@endif  /* not DIALOG_ATTACHMENT_LIST */


/**************************************************************
 *      
 * FUNCTION:        MSG_ATTACH_LIST_UNATTACH_FILE
 * PASS:            none
 * RETURN:          none
 * DESCRIPTION:
 *         remove the selected file from the attachment list
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      8/25/99      Initial Revision
 ***************************************************************/

@method AttachListClass, MSG_ATTACH_LIST_UNATTACH_FILE
{
    word sel = @call oself::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    MemHandle mh = pself->ALI_array;

    if (mh && sel != GIGS_NONE) {
	/*
	 * delete the entry
	 * use ChunkArrayDeleteRange() because it works with element #s
	 */
	MemLock(mh);
	ChunkArrayDeleteRange(ME_FIRST_CHUNK, sel, 1);
	MemUnlock(mh);
	/*
	 * update the list
	 */
	@call oself::MSG_ATTACH_LIST_UPDATE_LIST();
    }
    /*
     * take the dialog off screen
     */
    @call ComposeAttachRemoveDialog::MSG_GEN_INTERACTION_ACTIVATE_COMMAND(IC_DISMISS);
}



