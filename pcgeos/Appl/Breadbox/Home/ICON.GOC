@include <stdapp.goh>
@include <Objects/ColorC.goh>
@include "homeapp.goh"
@include "home.goh"
#include <token.h>
#include <gstring.h>
#include <Ansi/string.h>

#define SCRATCH_PAD_BLOCK     0xFEFC
#define ON_ICON_BLOCK         0xFEFD
#define OFF_ICON_BLOCK        0xFEFE                                                                        
#define BLANK_ICON_BLOCK      0xFEFF
#define IS_DRAWING            0x01
#define IS_MODIFIED           0x02

@extern object HomeIconList;
@extern object SaveIconButton;
@extern object SaveAsIconButton;
@extern object UndoButton;
@extern object CopyButton;
@extern object HomeExportImportIconFileList;
@extern object HomeExImFileList;
@extern object HomeExImOKTrigger;
@extern object HomeExImFileNameText;
@extern object HomeExImGlyph;
@extern object HomeExportIconDialog;
@extern object HomeExportIconList;
@extern object HomeExportCancel;
@extern object HomeImportIconDialog;
@extern object HomeImportIconList;
@extern chunk MsgCantConvertIcon;
@extern visMoniker CopyOffButtonMoniker;
@extern visMoniker CopyOnButtonMoniker;
@extern visMoniker SelectImportText;
@extern visMoniker ImportText;
@extern chunk MsgCantOpenIconFile;
@extern chunk MsgNotIconFile;
@extern chunk MsgIconImportDone;
@extern visMoniker SelectExportText;
@extern visMoniker ExportText;
@extern chunk MsgCantCreateIconFile;
@extern chunk MsgIconExportDone;
@extern chunk MsgIconExportNoSelections;
@extern chunk MsgIconImportNoSelections;
@extern chunk MsgConfirmDeleteIcon;

typedef struct {
	word IDMB_numIcons;
} IconDBMapBlock;

typedef struct {
	Bitmap IB_bitmap;
	byte IB_data[450];
} IconBitmap;

typedef struct {
	char IEFMB_signature[21];
	word IEFMB_numIcons;
} IconExportFileMapBlock;

/* saves the export file name so we can delete it incase the user cancels */
char	g_expIconFileName[FILE_LONGNAME_BUFFER_SIZE];


/* This is a replacement for VMDetach.  The lock state of the VM block is
   unaffected; the returned block is unlocked and swapable. */
MemHandle VMDuplicateToMemBlock(VMFileHandle vmFile, VMBlockHandle vmBlock)
{
    MemHandle hSource, hDest;
    void *pSource, *pDest;
    word nSize;
    
    pSource = VMLock(vmFile, vmBlock, &hSource);
    /* The size is rounded to the nearest paragraph. */
    nSize = MemGetInfo(hSource, MGIT_SIZE);
    /* There's no error-handling in the code this will be used, so no point in
       getting concerned here either; HAF_STANDARD_NO_ERR will suffice. */
    hDest = MemAlloc(nSize, HF_SWAPABLE, HAF_STANDARD_NO_ERR);
    pDest = MemLock(hDest);
    memcpy(pDest, pSource, nSize);
    VMUnlock(hSource);
    MemUnlock(hDest);
    return hDest;
}

/*******************************************************************************
* ICON CLASS                                                                   *
*******************************************************************************/
@extern method IconClass, MSG_ICON_VIEW_OPEN_ICON_DB {
	VMBlockHandle mapBlock;
	MemHandle mem;
	IconDBMapBlock *mapPtr;
	IconBitmap *iconPtr;
	char *fileName;

	fileName = "Home Automation Icon Database\0";
	/* Go to the appropriate system path here. */
	FilePushDir();
	FileSetStandardPath(SP_PRIVATE_DATA);
	pself->IC_fileHandle = VMOpen(fileName, VMAF_FORCE_READ_WRITE, VMO_OPEN, 0);
	if (pself->IC_fileHandle != NullHandle &&
		VMGetMapBlock(pself->IC_fileHandle) == NullHandle)
	{
		/* The VM file is corrupt.  Close and overwrite it. */
		VMClose(pself->IC_fileHandle, FALSE);
		pself->IC_fileHandle = NullHandle;
	}
	if (pself->IC_fileHandle == NullHandle)
	{
		/* if we get here, we couldn't find an Icon Database, or it's bad, so
		   we (re)create one with no icons in it. */
		pself->IC_fileHandle = VMOpen(fileName, VMAF_FORCE_READ_WRITE,
		  VMO_CREATE_TRUNCATE, 0);
		mapBlock = VMAlloc(pself->IC_fileHandle, sizeof(IconDBMapBlock), 0);
		VMSetMapBlock(pself->IC_fileHandle, mapBlock);
		mapPtr = VMLock(pself->IC_fileHandle, mapBlock, &mem);
		mapPtr->IDMB_numIcons = 0;
		VMDirty(mem);
		VMUnlock(mem);
		mapBlock = VMAlloc(pself->IC_fileHandle, 0, SCRATCH_PAD_BLOCK);
		mapBlock = VMAlloc(pself->IC_fileHandle, 0, ON_ICON_BLOCK);
		mapBlock = VMAlloc(pself->IC_fileHandle, 0, OFF_ICON_BLOCK);
		mapBlock = VMAlloc(pself->IC_fileHandle, sizeof(IconBitmap), BLANK_ICON_BLOCK);
		iconPtr = VMLock(pself->IC_fileHandle, mapBlock, &mem);
		iconPtr->IB_bitmap.B_width = 30;
		iconPtr->IB_bitmap.B_height = 30;
		iconPtr->IB_bitmap.B_compact = BMC_UNCOMPACTED;
		iconPtr->IB_bitmap.B_type = BMF_4BIT;
		/* Black icon is default document color of white. */
		memset(iconPtr->IB_data, 0xFF, sizeof(iconPtr->IB_data));
		VMDirty(mem);
		VMUnlock(mem);
	}
	FilePopDir();
	mapBlock = VMGetMapBlock(pself->IC_fileHandle);
	mapPtr = VMLock(pself->IC_fileHandle, mapBlock, &mem);
	@send HomeNewUnitIconList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(mapPtr->IDMB_numIcons / 2);
	@send HomeIconList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(mapPtr->IDMB_numIcons / 2);
	VMUnlock(mem);
	@send SmallIcon::MSG_ICON_VIEW_SET_FILE_HANDLE(pself->IC_fileHandle);
}

@extern method IconClass, MSG_ICON_VIEW_SET_FILE_HANDLE {
	pself->IC_fileHandle = file;
}

@extern method IconClass, MSG_ICON_VIEW_GET_FILE_HANDLE {
	return(pself->IC_fileHandle);
}

@extern method IconClass, MSG_ICON_VIEW_CLOSE_ICON_DB {
	VMClose(pself->IC_fileHandle, FALSE);
}

@extern method IconClass, MSG_ICON_VIEW_QUERY_ICON_MONIKER {
	MemHandle hBitmap, monikerBlock;
	VMBlockHandle iconBlock;
	ChunkHandle monikerChunk;
	GStateHandle gstate;
	optr gstring;
	word icon;
	Bitmap *pBitmap;

	icon = (item * 2) + 1;
	monikerBlock = MemAllocLMem(LMEM_TYPE_GENERAL, sizeof(LMemBlockHeader));
	iconBlock = VMFind(pself->IC_fileHandle, NullHandle, icon);
	if (iconBlock == NullHandle) iconBlock = VMFind(pself->IC_fileHandle, NullHandle, BLANK_ICON_BLOCK);
    /* This is the old way: */
/*	hBitmap = VMDetach(pself->IC_fileHandle, iconBlock, 0);
	gstate = GrCreateGString(monikerBlock, GST_CHUNK, &monikerChunk);
	GrSetDefaultTransform(gstate);
	GrDrawBitmapAtCP(gstate, MemLock(hBitmap), NULL);
	GrEndGString(gstate);
	MemUnlock(hBitmap);
	MemFree(hBitmap);*/
    /* This is the new way, without VMDetach/VMAttach: DH 6/4/99 */
	pBitmap = (Bitmap *)VMLock(pself->IC_fileHandle, iconBlock, &hBitmap);
	gstate = GrCreateGString(monikerBlock, GST_CHUNK, &monikerChunk);
	GrSetDefaultTransform(gstate);
	GrDrawBitmapAtCP(gstate, pBitmap, NULL);
	GrEndGString(gstate);
	VMUnlock(hBitmap);
    /* End of changes: DH 6/4/99 */
	gstring = ConstructOptr(monikerBlock, monikerChunk);
	GrDestroyGString(gstate, NULL, GSKT_LEAVE_DATA);
	@call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_MONIKER(item, 0, (word) 30, (word) 30,
											  0, VMDT_GSTRING, VMST_OPTR,   (dword) gstring);
	MemFree(OptrToHandle(gstring));
}

@extern method IconClass, MSG_ICON_VIEW_QUERY_IMPORT_MONIKER {
	MemHandle hBitmap, monikerBlock;
	VMBlockHandle iconBlock;
	ChunkHandle monikerChunk;
	GStateHandle gstate;
	optr gstring;
	word icon;
	Bitmap *pBitmap;

	icon = (item * 2) + 1;
	monikerBlock = MemAllocLMem(LMEM_TYPE_GENERAL, sizeof(LMemBlockHeader));
	iconBlock = VMFind(pself->IC_exportFileHandle, NullHandle, icon);
	if (iconBlock == NullHandle) {
		iconBlock = VMFind(pself->IC_fileHandle, NullHandle, BLANK_ICON_BLOCK);
		pBitmap = (Bitmap *)VMLock(pself->IC_fileHandle, iconBlock, &hBitmap);
	}
	else pBitmap = (Bitmap *)VMLock(pself->IC_exportFileHandle, iconBlock, &hBitmap);
	gstate = GrCreateGString(monikerBlock, GST_CHUNK, &monikerChunk);
	GrSetDefaultTransform(gstate);
	GrDrawBitmapAtCP(gstate, pBitmap, NULL);
	GrEndGString(gstate);
	VMUnlock(hBitmap);
	gstring = ConstructOptr(monikerBlock, monikerChunk);
	GrDestroyGString(gstate, NULL, GSKT_LEAVE_DATA);
	@call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_MONIKER(item, 0, (word) 30, (word) 30,
											  0, VMDT_GSTRING, VMST_OPTR,   (dword) gstring);
	MemFree(OptrToHandle(gstring));
}

@extern method IconClass, MSG_ICON_VIEW_REPLACE_ICON_MONIKER {
	MemHandle hBitmap, monikerBlock;
	VMBlockHandle iconBlock;
	ChunkHandle monikerChunk;
	GStateHandle gstate;
	optr gstring;
	Bitmap *pBitmap;

	if (icon == 0) icon = BLANK_ICON_BLOCK;
	monikerBlock = MemAllocLMem(LMEM_TYPE_GENERAL, sizeof(LMemBlockHeader));
	iconBlock = VMFind(pself->IC_fileHandle, NullHandle, icon);
	if (iconBlock == NullHandle) iconBlock = VMFind(pself->IC_fileHandle, NullHandle, BLANK_ICON_BLOCK);
	pBitmap = (Bitmap *)VMLock(pself->IC_fileHandle, iconBlock, &hBitmap);
	gstate = GrCreateGString(monikerBlock, GST_CHUNK, &monikerChunk);
	GrSetDefaultTransform(gstate);
	GrDrawBitmapAtCP(gstate, pBitmap, NULL);
	GrEndGString(gstate);
	VMUnlock(hBitmap);
	gstring = ConstructOptr(monikerBlock, monikerChunk);
	GrDestroyGString(gstate, NULL, GSKT_LEAVE_DATA);
	@call object::MSG_GEN_REPLACE_VIS_MONIKER(VUM_NOW, (word) 30, (word) 30,
											  sizeof(gstring), VMDT_GSTRING, VMST_OPTR, (dword) gstring);
	MemFree(OptrToHandle(gstring));
}

@extern method IconClass, MSG_ICON_VIEW_NEW_ICON{
	@send self::MSG_ICON_VIEW_SHOW_ICON(0);
	@send HomeIconEditor::MSG_GEN_INTERACTION_INITIATE();
}

@extern method IconClass, MSG_ICON_VIEW_EDIT_ICON {
	word icon = @call HomeIconList::MSG_GEN_ITEM_GROUP_GET_SELECTION();
	if (icon == GIGS_NONE) return;
	icon = (icon * 2) + 1;
	@send self::MSG_ICON_VIEW_SHOW_ICON(icon);
	@send HomeIconEditor::MSG_GEN_INTERACTION_INITIATE();
}

/* IconDownScaleColors is required only temporarily until we can find a
   solution to the problem with displaying high-color (>16) bitmaps in
   the LargeIcon. Meanwhile, */

MemHandle IconDownScaleColors(VMFileHandle vmFile, MemHandle hBitmap)
{
	Bitmap *pOldBitmap;
	
	pOldBitmap = (Bitmap *)MemLock(hBitmap);
	
	if (pOldBitmap->B_type != BMF_4BIT)
	{
		VMBlockHandle vmbHuge, vmbBlank;
		GStateHandle gstate = NullHandle;
		MemHandle hBlankBitmap;
		IconBitmap *pNewBitmap, *pBlankBitmap;
		byte *pData;
		word cols;
		Boolean success = FALSE;
		
		/* Create a new bitmap with an attached gstate. */
		vmbHuge = GrCreateBitmap(BMF_4BIT, 30, 30, vmFile, NullOptr, &gstate);
		if (vmbHuge != NullHandle && gstate != NullHandle)
		{
			/* Draw the old high-color bitmap into our 16-color bitmap. */
			GrDrawBitmap(gstate, 0, 0, pOldBitmap, NULL);

			/* Create a simple bitmap using the blank icon as the template. */
			vmbBlank = VMFind(vmFile, NullHandle, BLANK_ICON_BLOCK);
			pBlankBitmap = (IconBitmap *)VMLock(vmFile, vmbBlank, &hBlankBitmap);
			if (pBlankBitmap->IB_bitmap.B_type == BMF_4BIT
			  && MemGetInfo(hBlankBitmap, MGIT_SIZE) >= sizeof(IconBitmap))
			{
			    /* Resize the old bitmap block and write the bitmap header. */
			    MemReAlloc(hBitmap, sizeof(IconBitmap), 0);
			    pNewBitmap = MemDeref(hBitmap);
			    memcpy(&pNewBitmap->IB_bitmap, &pBlankBitmap->IB_bitmap, 
			      sizeof(pNewBitmap->IB_bitmap));
			    VMUnlock(hBlankBitmap);

				/* Copy the bitmap data from the huge bitmap into the simple bitmap. */
				/* Huge bitmaps are stored with a single scan line per array element.
				   This one is 30x30 and 4-bit color; the array then has 30 elements
				   and 15 bytes per element.  The entire array should be locked by a
				   single call to HugeArrayLock(). */
				if (HAL_COUNT(HugeArrayLock(vmFile, vmbHuge, 0, &pData, &cols)) == 30
				  && cols == 15)
				{
					memcpy(pNewBitmap->IB_data, pData, sizeof(pNewBitmap->IB_data));
					HugeArrayUnlock(pData);

					/* Destroy the huge bitmap. */
					GrDestroyBitmap(gstate, 0);
				
					success = TRUE;
				}
			}
		}
		if (!success) {
			MemLock(OptrToHandle(@MsgCantConvertIcon));
			UserStandardDialog((char *) 0, (char *) 0, (char *) 0, (char *) 0,
			  LMemDeref(@MsgCantConvertIcon),
	  //		  "The icon could not be converted to 16-colors and cannot be edited.",
			  ((CDT_WARNING << CDBF_DIALOG_TYPE_OFFSET) |
			  (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET)));
			MemUnlock(OptrToHandle(@MsgCantConvertIcon));
			}
	}
	MemUnlock(hBitmap);
	return hBitmap;
}

@extern method IconClass, MSG_ICON_VIEW_SHOW_ICON {
	VMBlockHandle iconBlock;
	MemHandle hBitmap;

	pself->IC_bitmapID = icon;
	if (icon == 0) {
		icon = BLANK_ICON_BLOCK;
		@send SaveIconButton::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	}
	else @send SaveIconButton::MSG_GEN_SET_ENABLED(VUM_NOW);
	@send UndoButton::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	pself->IC_status &= ~IS_MODIFIED;
	iconBlock = VMFind(pself->IC_fileHandle, NullHandle, icon);
	if (iconBlock == NullHandle) iconBlock = VMFind(pself->IC_fileHandle, NullHandle, BLANK_ICON_BLOCK);
	hBitmap = VMDuplicateToMemBlock(pself->IC_fileHandle, iconBlock);
	/* Downscale Bitmap to 16 colors here. */
	hBitmap = IconDownScaleColors(pself->IC_fileHandle, hBitmap);
	iconBlock = VMFind(pself->IC_fileHandle, NullHandle, ON_ICON_BLOCK);
	VMAttach(pself->IC_fileHandle, iconBlock, hBitmap);
	hBitmap = VMDuplicateToMemBlock(pself->IC_fileHandle, iconBlock);
	iconBlock = VMFind(pself->IC_fileHandle, NullHandle, SCRATCH_PAD_BLOCK);
	VMAttach(pself->IC_fileHandle, iconBlock, hBitmap);
	if (icon == BLANK_ICON_BLOCK) icon--;
	iconBlock = VMFind(pself->IC_fileHandle, NullHandle, icon + 1);
	if (iconBlock == NullHandle) iconBlock = VMFind(pself->IC_fileHandle, NullHandle, BLANK_ICON_BLOCK);
	hBitmap = VMDuplicateToMemBlock(pself->IC_fileHandle, iconBlock);
	/* Downscale Bitmap to 16 colors here. */
	hBitmap = IconDownScaleColors(pself->IC_fileHandle, hBitmap);
	iconBlock = VMFind(pself->IC_fileHandle, NullHandle, OFF_ICON_BLOCK);
	VMAttach(pself->IC_fileHandle, iconBlock, hBitmap);
	@send IconSelectGroup::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(0, FALSE);
	@send SmallIcon::MSG_VIS_REDRAW_ENTIRE_OBJECT();
	@send self::MSG_VIS_REDRAW_ENTIRE_OBJECT();
 //	@call CopyButton::MSG_GEN_REPLACE_VIS_MONIKER_TEXT("Copy \"Off\" Icon", VUM_NOW);
	@call CopyButton::MSG_GEN_USE_VIS_MONIKER(OptrToChunk(@CopyOffButtonMoniker), VUM_NOW);
}


@extern method IconClass, MSG_ICON_VIEW_CHANGE_DISPLAYED_ICON {
	VMBlockHandle iconBlock, scratchBlock;
	MemHandle newBitmap, oldBitmap;

	scratchBlock = VMFind(pself->IC_fileHandle, NullHandle, SCRATCH_PAD_BLOCK);
	oldBitmap = VMDuplicateToMemBlock(pself->IC_fileHandle, scratchBlock);
	iconBlock = VMFind(pself->IC_fileHandle, NullHandle, ON_ICON_BLOCK + (1 - selection));
	VMAttach(pself->IC_fileHandle, iconBlock, oldBitmap);
	iconBlock = VMFind(pself->IC_fileHandle, NullHandle, ON_ICON_BLOCK + selection);
	newBitmap = VMDuplicateToMemBlock(pself->IC_fileHandle, iconBlock);
	VMAttach(pself->IC_fileHandle, scratchBlock, newBitmap);
	pself->IC_status &= ~IS_MODIFIED;
	@send UndoButton::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	switch (selection) {
		case 0:
			@call CopyButton::MSG_GEN_USE_VIS_MONIKER(OptrToChunk(@CopyOffButtonMoniker), VUM_NOW);
	 //		@call CopyButton::MSG_GEN_REPLACE_VIS_MONIKER_TEXT("Copy \"Off\" Icon",
	 //																			VUM_NOW);
			break;
		case 1:
			@call CopyButton::MSG_GEN_USE_VIS_MONIKER(OptrToChunk(@CopyOffButtonMoniker), VUM_NOW);
	 //		@call CopyButton::MSG_GEN_REPLACE_VIS_MONIKER_TEXT("Copy \"On\" Icon",
	 //																			VUM_NOW);
			break;
	}
	@send SmallIcon::MSG_VIS_REDRAW_ENTIRE_OBJECT();
	@send self::MSG_VIS_REDRAW_ENTIRE_OBJECT();
}

@extern method IconClass, MSG_ICON_VIEW_COPY_OTHER_ICON {
	VMBlockHandle iconBlock, scratchBlock;
	MemHandle bitmap;
	word selection;

	selection = @call IconSelectGroup::MSG_GEN_ITEM_GROUP_GET_SELECTION();
	scratchBlock = VMFind(pself->IC_fileHandle, NullHandle, SCRATCH_PAD_BLOCK);
	iconBlock = VMFind(pself->IC_fileHandle, NullHandle, ON_ICON_BLOCK + (1 - selection));
	bitmap = VMDuplicateToMemBlock(pself->IC_fileHandle, iconBlock);
	VMAttach(pself->IC_fileHandle, scratchBlock, bitmap);
	pself->IC_status |= IS_MODIFIED;
	@send UndoButton::MSG_GEN_SET_ENABLED(VUM_NOW);
	@send SmallIcon::MSG_VIS_REDRAW_ENTIRE_OBJECT();
	@send self::MSG_VIS_REDRAW_ENTIRE_OBJECT();
}
		

@extern method IconClass, MSG_ICON_VIEW_UNDO_CHANGES {
	VMBlockHandle iconBlock;
	MemHandle Bitmap;

	iconBlock = VMFind(pself->IC_fileHandle, NullHandle, ON_ICON_BLOCK + 
					(@call IconSelectGroup::MSG_GEN_ITEM_GROUP_GET_SELECTION()));
	Bitmap = VMDuplicateToMemBlock(pself->IC_fileHandle, iconBlock);
	iconBlock = VMFind(pself->IC_fileHandle, NullHandle, SCRATCH_PAD_BLOCK);
	VMAttach(pself->IC_fileHandle, iconBlock, Bitmap);
	pself->IC_status &= ~IS_MODIFIED;
	@send UndoButton::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	@send SmallIcon::MSG_VIS_REDRAW_ENTIRE_OBJECT();
	@send self::MSG_VIS_REDRAW_ENTIRE_OBJECT();
}

@extern method IconClass, MSG_VIS_DRAW {
	VMBlockHandle iconBlock;
	MemHandle mem;
	Bitmap *bitmap;
	byte flags;

	flags = pself->IC_scaleFactor;
	if (pself->IC_scaleFactor > 0) {
		flags |= IF_BORDER;
	}
	iconBlock = VMFind(pself->IC_fileHandle, NullHandle, SCRATCH_PAD_BLOCK);
	bitmap = VMLock(pself->IC_fileHandle, iconBlock, &mem);
	if (bitmap->B_type & BMT_HUGE)
		GrDrawHugeImage(gstate, 0, 0, flags, pself->IC_fileHandle, iconBlock);
	else
		GrDrawImage(gstate, 0, 0, flags, bitmap);
	VMUnlock(mem);
}

@extern method IconClass, MSG_META_START_SELECT {
	GStateHandle gstate;
	WindowHandle win;
	sword x, y;
	ColorQuad color;

	if ((pself->IC_scaleFactor > 0) && (yPosition < pself->VI_bounds.R_bottom) &&
		 (xPosition < pself->VI_bounds.R_right)) {
		pself->IC_status |= IS_DRAWING;
		if (!(pself->IC_status & IS_MODIFIED)) {
			pself->IC_status |= IS_MODIFIED;
			@send UndoButton::MSG_GEN_SET_ENABLED(VUM_NOW);
		}
		win = @call self::MSG_VIS_QUERY_WINDOW();
		gstate = GrCreateState(win);
		if (@call HomeIconToolGroup::MSG_GEN_ITEM_GROUP_GET_SELECTION()) {
			color.CQ_info = CF_INDEX;
			color.CQ_redOrIndex = C_WHITE;
		}
		else {
			color = pself->IC_lineColor;
		}
		@call SmallIcon::MSG_ICON_VIEW_UPDATE_BITMAP(color, xPosition / 8, yPosition / 8);
		x = ((xPosition / 8) * 8);
		y = ((yPosition / 8) * 8);
		GrSetAreaColor(gstate, color.CQ_info, color.CQ_redOrIndex, color.CQ_green,
							color.CQ_blue);
		GrFillRect(gstate, x, y, x + 7, y + 7);
		GrDestroyState(gstate);
	}
	retVal->flags = MRF_PROCESSED;
}

@extern method IconClass, MSG_META_DRAG_SELECT, MSG_META_PTR {
	GStateHandle gstate;
	WindowHandle win;
	sword x, y;
	ColorQuad color;

	if (pself->IC_status & IS_DRAWING) {
		if ((yPosition >=0 && yPosition < pself->VI_bounds.R_bottom)
		  && (xPosition >= 0 && xPosition < pself->VI_bounds.R_right))
		{
			win = @call self::MSG_VIS_QUERY_WINDOW();
			gstate = GrCreateState(win);
			if (@call HomeIconToolGroup::MSG_GEN_ITEM_GROUP_GET_SELECTION()) {
				color.CQ_info = CF_INDEX;
				color.CQ_redOrIndex = C_WHITE;
			}
			else {
				color = pself->IC_lineColor;
			}
			@call SmallIcon::MSG_ICON_VIEW_UPDATE_BITMAP(color, xPosition / 8, yPosition / 8);
			x = ((xPosition / 8) * 8);
			y = ((yPosition / 8) * 8);
			GrSetAreaColor(gstate, color.CQ_info, color.CQ_redOrIndex, color.CQ_green,
								color.CQ_blue);
			GrFillRect(gstate, x, y, x + 7, y + 7);
			GrDestroyState(gstate);
		}
		retVal->flags = MRF_PROCESSED;
	}
	retVal->flags |= MRF_SET_POINTER_IMAGE;
	retVal->ptrImage = @IconPointer;
}

@extern method IconClass, MSG_META_END_SELECT {
	pself->IC_status &= ~IS_DRAWING;
	retVal->flags = MRF_PROCESSED;
}

@extern method IconClass, MSG_ICON_VIEW_UPDATE_BITMAP {
/* This is the old way, and a bad way, to update the bitmap. */
/*	VMBlockHandle iconBlock;
	MemHandle Bitmap;
	GStateHandle gstate;
	WindowHandle win;

	win = @call self::MSG_VIS_QUERY_WINDOW();
	gstate = GrCreateState(win);
	GrSetAreaColor(gstate, color.CQ_info, color.CQ_redOrIndex, color.CQ_green,
						color.CQ_blue);
	GrDrawPoint(gstate, xPos, yPos);
	Bitmap = GrGetBitmap(gstate, 0, 0, (word) 30, (word) 30, (XYSize *) 0);
	MemModifyFlags(Bitmap, HF_SWAPABLE, 0);
	iconBlock = VMFind(pself->IC_fileHandle, NullHandle, SCRATCH_PAD_BLOCK);
	VMAttach(pself->IC_fileHandle, iconBlock, Bitmap);
	GrDestroyState(gstate);
*/

/* This the new way, and a hack way, to update the bitmap. If the SmallIcon
   were to keep its own off-screen bitmap and associated gstate, it would
   be easier to update it. Until that's changed, we have to modify the
   SCRATCH_PAD_BLOCK bitmap. And until the GrDrawImage routine is fixed to
   draw the LargeIcon with more than 16 colors, we must restrict the bitmap
   to 16 colors. And since this is the ONLY point where a bitmap is actually
   changed, we only have to adjust things here. DH 3/16/99 */

	VMBlockHandle iconBlock;
	MemHandle Bitmap;
	IconBitmap *pBitmap;
	byte *pByte;
	
	if (color.CQ_info == CF_INDEX)
	{
		/* Lock the bitmap block. */
		iconBlock = VMFind(pself->IC_fileHandle, NullHandle, SCRATCH_PAD_BLOCK);
		pBitmap = (IconBitmap *)VMLock(pself->IC_fileHandle, iconBlock, &Bitmap);

		if (pBitmap->IB_bitmap.B_type == BMF_4BIT)
		{
			/* Locate the byte in the bitmap for pixel (xPos,yPos) */
			pByte = &(pBitmap->IB_data[yPos * 15 + xPos / 2]);

			/* Make the change. Since bitmap is 16-color, pixels are 4-bits 
			   long and most-significant nibble first. */
			if (xPos & 1)				/* even/odd test */
			{
				/* xPos is odd, modify lower nibble of byte */
				*pByte &= 0xF0;
				*pByte |= color.CQ_redOrIndex;
			}
			else
			{
				/* xPos is even, modify upper nibble of byte */
				*pByte &= 0x0F;
				*pByte |= (color.CQ_redOrIndex << 4);
			}
		
			/* Dirty the bitmap block. */
			VMDirty(Bitmap);
		}
		VMUnlock(Bitmap);				/* Unlock the bitmap block. */
		
		/* Force the icon to redraw itself onscreen. */
		@call self::MSG_VIS_REDRAW_ENTIRE_OBJECT();
	}
}

@extern method IconClass, MSG_META_COLORED_OBJECT_SET_COLOR {
	pself->IC_lineColor = colorQuad;
}

@extern method IconClass, MSG_ICON_VIEW_SAVE_AS_NEW_ICON {
	pself->IC_bitmapID = 0;
	@call self::MSG_ICON_VIEW_SAVE_ICON();
}

@extern method IconClass, MSG_ICON_VIEW_SAVE_ICON {
	VMBlockHandle mapBlock, iconBlock;
	MemHandle mem;
	IconDBMapBlock *mapPtr;
	word newIconID;

	/* first, we have to save any changes the user has made to the current icon... */
	iconBlock = VMFind(pself->IC_fileHandle, NullHandle, SCRATCH_PAD_BLOCK);
	mem = VMDuplicateToMemBlock(pself->IC_fileHandle, iconBlock);
	iconBlock = VMFind(pself->IC_fileHandle, NullHandle, ON_ICON_BLOCK +
							(@call IconSelectGroup::MSG_GEN_ITEM_GROUP_GET_SELECTION()));
	VMAttach(pself->IC_fileHandle, iconBlock, mem);
	if (pself->IC_bitmapID == 0) {
		/* this would mean we're creating a new icon set. */
		mapBlock = VMGetMapBlock(pself->IC_fileHandle);
		mapPtr = VMLock(pself->IC_fileHandle, mapBlock, &mem);
		mapPtr->IDMB_numIcons = mapPtr->IDMB_numIcons + 2;
		newIconID = mapPtr->IDMB_numIcons - 1;
		VMDirty(mem);
		VMUnlock(mem);
		iconBlock = VMFind(pself->IC_fileHandle, NullHandle, ON_ICON_BLOCK);
		iconBlock = VMCopyVMBlock(pself->IC_fileHandle, iconBlock, pself->IC_fileHandle);
		VMModifyUserID(pself->IC_fileHandle, iconBlock, newIconID);
		iconBlock = VMFind(pself->IC_fileHandle, NullHandle, OFF_ICON_BLOCK);
		iconBlock = VMCopyVMBlock(pself->IC_fileHandle, iconBlock, pself->IC_fileHandle);
		VMModifyUserID(pself->IC_fileHandle, iconBlock, newIconID + 1);
		@send HomeNewUnitIconList::MSG_GEN_DYNAMIC_LIST_INITIALIZE((newIconID + 1) / 2);
		@send HomeIconList::MSG_GEN_DYNAMIC_LIST_INITIALIZE((newIconID + 1) / 2);
	}
	else {
		EventHandle eventToDo;

		/* otherwise, we're modifying an existing icon */
		iconBlock = VMFind(pself->IC_fileHandle, NullHandle, ON_ICON_BLOCK);
		mem = VMDuplicateToMemBlock(pself->IC_fileHandle, iconBlock);
		iconBlock = VMFind(pself->IC_fileHandle, NullHandle, pself->IC_bitmapID);
		VMAttach(pself->IC_fileHandle, iconBlock, mem);
		iconBlock = VMFind(pself->IC_fileHandle, NullHandle, OFF_ICON_BLOCK);
		mem = VMDuplicateToMemBlock(pself->IC_fileHandle, iconBlock);
		iconBlock = VMFind(pself->IC_fileHandle, NullHandle, pself->IC_bitmapID + 1);
		VMAttach(pself->IC_fileHandle, iconBlock, mem);
		eventToDo = @record null::MSG_ITEM_ICON_CHANGED(pself->IC_bitmapID);
		GCNListSend(MANUFACTURER_ID_BREADBOX, BGCNLT_ALL_ITEMS, eventToDo, NullHandle, GCNLSF_FORCE_QUEUE);
		@send HomeNewUnitIconList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(GDLI_NO_CHANGE);
		@send HomeIconList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(GDLI_NO_CHANGE);
		/* get the moniker dynamic list to redraw itself... */
	}
	pself->IC_status &= ~IS_MODIFIED;
	@send UndoButton::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	@send HomeIconEditor::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
}

@extern method IconClass, MSG_ICON_VIEW_DELETE_ICON {
	VMBlockHandle iconBlock;
	EventHandle eventToDo;
	word icon, loop, oldNumIcons;
	MemHandle mem;
	IconDBMapBlock *mapPtr;

	MemLock(OptrToHandle(@MsgConfirmDeleteIcon));
	if (UserStandardDialog(0, 0, 0, 0,
								  LMemDeref(@MsgConfirmDeleteIcon),
							 //	  "Are you sure you want to delete this icon?",
								  ((CDT_QUESTION << CDBF_DIALOG_TYPE_OFFSET) |
								  (GIT_AFFIRMATION << CDBF_INTERACTION_TYPE_OFFSET))) != IC_YES) {
		MemUnlock(OptrToHandle(@MsgConfirmDeleteIcon));
		return;
		}
	MemUnlock(OptrToHandle(@MsgConfirmDeleteIcon));
	icon = @call HomeIconList::MSG_GEN_ITEM_GROUP_GET_SELECTION();
	if (icon == GIGS_NONE) return;
	else icon = (icon * 2) + 1;
	iconBlock = VMFind(pself->IC_fileHandle, NullHandle, icon);
	VMFree(pself->IC_fileHandle, iconBlock);
	iconBlock = VMFind(pself->IC_fileHandle, NullHandle, icon + 1);
	VMFree(pself->IC_fileHandle, iconBlock);
	iconBlock = VMGetMapBlock(pself->IC_fileHandle);
	mapPtr = VMLock(pself->IC_fileHandle, iconBlock, &mem);
	oldNumIcons = mapPtr->IDMB_numIcons;
	mapPtr->IDMB_numIcons -= 2;
	VMDirty(mem);
	VMUnlock(mem);
	for (loop = icon + 2; loop <= oldNumIcons; loop++) {
		iconBlock = VMFind(pself->IC_fileHandle, NullHandle, loop);
		if (iconBlock != NullHandle) VMModifyUserID(pself->IC_fileHandle, iconBlock, loop - 2);
	}
	/* now, we notify any items who need to know that an icon has been deleted...
		and we hope like heck that nobody has tried to redraw before we finish modifying
		the icon ID's... */
	eventToDo = @record null::MSG_ITEM_ICON_DELETED(icon);
	GCNListSend(MANUFACTURER_ID_BREADBOX, BGCNLT_ALL_ITEMS, eventToDo, NullHandle, GCNLSF_FORCE_QUEUE);
	@send HomeNewUnitIconList::MSG_GEN_DYNAMIC_LIST_REMOVE_ITEMS(((icon - 1) / 2), 1);
	@send HomeIconList::MSG_GEN_DYNAMIC_LIST_REMOVE_ITEMS(((icon - 1) / 2), 1);
	/* get the moniker dynamic list to redraw itself... */
}

/************************************************************
	Sets up the ImpEx file selector dbox to do importing and
	brings it on the screen.
************************************************************/
@extern method IconClass, MSG_ICON_VIEW_IMPORT_ICONS {
	FileSelectorAttrs atts;

	atts = @call HomeExImFileList::MSG_GEN_FILE_SELECTOR_GET_ATTRS();
	atts &= ~FSA_SHOW_FILES_DISABLED;
	@call HomeExImFileList::MSG_GEN_FILE_SELECTOR_SET_ATTRS(atts);
	@call HomeExImFileList::MSG_GEN_FILE_SELECTOR_SET_ACTION(@LargeIcon,
																				MSG_ICON_VIEW_ENTRY_SELECTED);
	@call HomeExImFileList::MSG_GEN_FILE_SELECTOR_SET_FILE_CRITERIA(FSFC_DIRS |
																						 FSFC_GEOS_NON_EXECUTABLES);
	/* look at our icon files only - yes this looks goofy
	 * but it gives the desired result of the chars "HAI0"  - jfh*/
	@call HomeExImFileList::MSG_GEN_FILE_SELECTOR_SET_CREATOR(
									TOKEN_CHARS('I', '0', (dword)'H', (dword)'A'),
									MANUFACTURER_ID_BREADBOX);

	@call HomeExImFileNameText::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
	@call HomeExImOKTrigger::MSG_GEN_TRIGGER_SET_ACTION_MSG(MSG_ICON_VIEW_OPEN_FILE_FOR_IMPORT);
	@call HomeExImOKTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	@call HomeExImGlyph::MSG_GEN_USE_VIS_MONIKER
								(OptrToChunk(@SelectImportText), VUM_NOW);
//	@call HomeExImGlyph::MSG_GEN_REPLACE_VIS_MONIKER_TEXT
//								("Select the file containing the icons to import.", VUM_NOW);
	@call HomeExportImportIconFileList::MSG_GEN_USE_VIS_MONIKER
													(OptrToChunk(@ImportText), VUM_NOW);
//	@call HomeExportImportIconFileList::MSG_GEN_REPLACE_VIS_MONIKER_TEXT
//													("Import Icons", VUM_NOW);
	@call HomeExportImportIconFileList::MSG_GEN_INTERACTION_INITIATE();
}

@extern method IconClass, MSG_ICON_VIEW_ENTRY_SELECTED {
	if (GFS_GET_ENTRY_TYPE(entryFlags) == GFSET_FILE) {
		@call HomeExImOKTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
		if (entryFlags & GFSEF_OPEN) {
			@call HomeExImOKTrigger::MSG_GEN_ACTIVATE();
		}
	}
	else @call HomeExImOKTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
}

/************************************************************
	User pressed the import 'Ok' button
	Opens the import file and opens the icon selector dbox to await
		the user's selections of which icons to import
	Leaves the import file open!

************************************************************/
@extern method IconClass, MSG_ICON_VIEW_OPEN_FILE_FOR_IMPORT {
	IconExportFileMapBlock *mapBlock;
	VMBlockHandle mapHandle;
	FileLongName iconExportFilename;
	PathName iconExportPathname;
	FileHandle iconExportFile;
	MemHandle mem;
	word numIcons;

	@call HomeExportImportIconFileList::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
	@call HomeExImFileList::MSG_GEN_PATH_GET(iconExportPathname, PATH_BUFFER_SIZE);
	@call HomeExImFileList::MSG_GEN_FILE_SELECTOR_GET_SELECTION(iconExportFilename);
	FileSetCurrentPath(@call HomeExImFileList::MSG_GEN_PATH_GET_DISK_HANDLE(),
							 iconExportPathname);
	iconExportFile = VMOpen(iconExportFilename, VMAF_FORCE_READ_WRITE, VMO_OPEN, 0);
	if (iconExportFile == NullHandle) {
		MemLock(OptrToHandle(@MsgCantOpenIconFile));
		UserStandardDialog(0, 0, 0, 0,
								  LMemDeref(@MsgCantOpenIconFile),
						 //		  "The selected file could not be opened.",
								  ((CDT_WARNING << CDBF_DIALOG_TYPE_OFFSET) |
								  (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET)));
		MemUnlock(OptrToHandle(@MsgCantOpenIconFile));
		return;
	}
	mapHandle = VMGetMapBlock(iconExportFile);
	mapBlock = VMLock(iconExportFile, mapHandle, &mem);
	if (strncmp(mapBlock->IEFMB_signature, "Home Automation Icons", 21)) {
		VMUnlock(mem);
		VMClose(iconExportFile, FALSE);
		MemLock(OptrToHandle(@MsgNotIconFile));
		UserStandardDialog(0, 0, 0, 0,
								  LMemDeref(@MsgNotIconFile),
					//			  "The selected file is not an icon export file.",
								  ((CDT_WARNING << CDBF_DIALOG_TYPE_OFFSET) |
								  (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET)));
		MemUnlock(OptrToHandle(@MsgNotIconFile));
		return;
	}
	/* now we know it's an OK file, so we store the file handle. */
	numIcons = (mapBlock->IEFMB_numIcons / 2);
	VMUnlock(mem);
	@call HomeImportIconList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(numIcons);
	pself->IC_exportFileHandle = iconExportFile;
	@call HomeImportIconDialog::MSG_GEN_INTERACTION_INITIATE();
}

/*************************************************************************
	User pressed the import button

*************************************************************************/
@extern method IconClass, MSG_ICON_VIEW_IMPORT_SELECTED_ICONS {
	word numIcons, curIcon, *icons, newIconID;
	MemHandle iconSelections;

	numIcons = @call HomeImportIconList::MSG_GEN_ITEM_GROUP_GET_NUM_SELECTIONS();
	/* if no selections alert the user and go back */
	if (!numIcons)  {
		MemLock(OptrToHandle(@MsgIconImportNoSelections));
		UserStandardDialog(0, 0, 0, 0,
							  LMemDeref(@MsgIconImportNoSelections),
							  ((CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET) |
							  (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET)));
		MemUnlock(OptrToHandle(@MsgIconImportNoSelections));
		return;
		}

	@call HomeImportIconDialog::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
	iconSelections = MemAlloc((sizeof(word) * numIcons), HF_FIXED, HAF_LOCK);
	icons = MemDeref(iconSelections);
	@call HomeImportIconList::MSG_GEN_ITEM_GROUP_GET_MULTIPLE_SELECTIONS(
												icons, numIcons);
	for (curIcon = 0; curIcon < numIcons; curIcon++) {
		VMBlockHandle mapBlock, iconBlock;
		MemHandle mem;
		IconDBMapBlock *mapPtr;

		/* we're creating a new icon set. */
		mapBlock = VMGetMapBlock(pself->IC_fileHandle);
		mapPtr = VMLock(pself->IC_fileHandle, mapBlock, &mem);
		mapPtr->IDMB_numIcons = mapPtr->IDMB_numIcons + 2;
		newIconID = mapPtr->IDMB_numIcons - 1;
		VMDirty(mem);
		VMUnlock(mem);
		iconBlock = VMFind(pself->IC_exportFileHandle, NullHandle, (icons[curIcon] * 2 + 1));
		iconBlock = VMCopyVMBlock(pself->IC_exportFileHandle, iconBlock, pself->IC_fileHandle);
		VMModifyUserID(pself->IC_fileHandle, iconBlock, newIconID);
		iconBlock = VMFind(pself->IC_exportFileHandle, NullHandle, (icons[curIcon] * 2 + 2));
		iconBlock = VMCopyVMBlock(pself->IC_exportFileHandle, iconBlock, pself->IC_fileHandle);
		VMModifyUserID(pself->IC_fileHandle, iconBlock, newIconID + 1);
	}
	MemFree(iconSelections);
	VMClose(pself->IC_exportFileHandle, FALSE);
	@send HomeNewUnitIconList::MSG_GEN_DYNAMIC_LIST_INITIALIZE((newIconID + 1) / 2);
	@send HomeIconList::MSG_GEN_DYNAMIC_LIST_INITIALIZE((newIconID + 1) / 2);
	MemLock(OptrToHandle(@MsgIconImportDone));
	UserStandardDialog(0, 0, 0, 0,
							  LMemDeref(@MsgIconImportDone),
						//	  "Icon import is complete.",
							  ((CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET) |
							  (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET)));
	MemUnlock(OptrToHandle(@MsgIconImportDone));
}

/*************************************************************************
	User pressed the import cancel button
*************************************************************************/
@extern method IconClass, MSG_ICON_VIEW_CANCEL_IMPORT_ICONS {
word error;

	/* close the file */
	VMClose(pself->IC_exportFileHandle, FALSE);
	

}

/************************************************************
	Sets up the ImpEx file selector dbox to do exporting and
	brings it on the screen.
************************************************************/
@extern method IconClass, MSG_ICON_VIEW_EXPORT_ICONS {
	FileSelectorAttrs atts;

	atts = @call HomeExImFileList::MSG_GEN_FILE_SELECTOR_GET_ATTRS();
	atts |= FSA_SHOW_FILES_DISABLED;
	/* We don't care about the selections, because we're looking for the user to
		enter a file name, anyway... so we clear out the notification message. */
	@call HomeExImFileList::MSG_GEN_FILE_SELECTOR_SET_ACTION(NullOptr, 0);
	@call HomeExImFileList::MSG_GEN_FILE_SELECTOR_SET_ATTRS(atts);
	@call HomeExImFileNameText::MSG_GEN_SET_USABLE(VUM_NOW);
	@call HomeExImOKTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
	@call HomeExImGlyph::MSG_GEN_USE_VIS_MONIKER
								(OptrToChunk(@SelectExportText), VUM_NOW);
//	@call HomeExImGlyph::MSG_GEN_REPLACE_VIS_MONIKER_TEXT
//								("Select the path and file name to use for export.", VUM_NOW);
	@call HomeExportImportIconFileList::MSG_GEN_USE_VIS_MONIKER
													(OptrToChunk(@ExportText), VUM_NOW);
//	@call HomeExportImportIconFileList::MSG_GEN_REPLACE_VIS_MONIKER_TEXT
//													("Export Icons", VUM_NOW);
	@call HomeExImOKTrigger::MSG_GEN_TRIGGER_SET_ACTION_MSG(MSG_ICON_VIEW_SELECT_ICONS_FOR_EXPORT);
	@call HomeExportImportIconFileList::MSG_GEN_INTERACTION_INITIATE();
}

/*************************************************************************
	User pressed the export 'Ok' button
	Creates an export file and opens the icon selector dbox to await
		the user's selections of which icons to export
	Leaves the export file open!

*************************************************************************/
@extern method IconClass, MSG_ICON_VIEW_SELECT_ICONS_FOR_EXPORT {
	IconExportFileMapBlock *mapPtr;
	IconDBMapBlock *ourMap;
	VMBlockHandle mapBlock;
//	FileLongName iconExportFilename;
	PathName iconExportPathname;
	FileHandle iconExportFile;
	MemHandle mem;
//	word numIcons;

	if (!@call HomeExImFileNameText::MSG_VIS_TEXT_GET_ALL_PTR(g_expIconFileName))
		return;  /* no file name entered */
	@call HomeExportImportIconFileList::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
	@call HomeExImFileList::MSG_GEN_PATH_GET(iconExportPathname, PATH_BUFFER_SIZE);
	FileSetCurrentPath(@call HomeExImFileList::MSG_GEN_PATH_GET_DISK_HANDLE(),
							 iconExportPathname);
	iconExportFile = VMOpen(g_expIconFileName, VMAF_FORCE_READ_WRITE, VMO_CREATE_TRUNCATE, 0);
	if (iconExportFile == NullHandle) {
		MemLock(OptrToHandle(@MsgCantCreateIconFile));
		UserStandardDialog(0, 0, 0, 0,
								  LMemDeref(@MsgCantCreateIconFile),
							//	  "The icon file could not be created.",
								  ((CDT_WARNING << CDBF_DIALOG_TYPE_OFFSET) |
								  (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET)));
		MemUnlock(OptrToHandle(@MsgCantCreateIconFile));
		return;
	}
	pself->IC_exportFileHandle = iconExportFile;
	mapBlock = VMAlloc(pself->IC_exportFileHandle, sizeof(IconExportFileMapBlock), 0);
	VMSetMapBlock(pself->IC_exportFileHandle, mapBlock);
	mapPtr = VMLock(pself->IC_exportFileHandle, mapBlock, &mem);
	mapPtr->IEFMB_numIcons = 0;
	strncpy(mapPtr->IEFMB_signature, "Home Automation Icons", 21);
	VMDirty(mem);
	VMUnlock(mem);
	mapBlock = VMGetMapBlock(pself->IC_fileHandle);
	ourMap = VMLock(pself->IC_fileHandle, mapBlock, &mem);
	@call HomeExportIconList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(ourMap->IDMB_numIcons / 2);
	VMUnlock(mem);
	@send HomeExportIconDialog::MSG_GEN_INTERACTION_INITIATE();
}

/*************************************************************************
	User pressed the export button

*************************************************************************/
@extern method IconClass, MSG_ICON_VIEW_EXPORT_SELECTED_ICONS {
	word numIcons, curIcon, *icons;
	MemHandle iconBlock;
	GeodeToken iconsToken;

	numIcons = @call HomeExportIconList::MSG_GEN_ITEM_GROUP_GET_NUM_SELECTIONS();
	/* if no selections alert the user and go back */
	if (!numIcons)  {
		MemLock(OptrToHandle(@MsgIconExportNoSelections));
		UserStandardDialog(0, 0, 0, 0,
							  LMemDeref(@MsgIconExportNoSelections),
							  ((CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET) |
							  (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET)));
		MemUnlock(OptrToHandle(@MsgIconExportNoSelections));
		return;
		}

	@call HomeExportIconDialog::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
	/* do the export */
	iconBlock = MemAlloc((sizeof(word) * numIcons), HF_FIXED, 0);
	icons = MemDeref(iconBlock);
	@call HomeExportIconList::MSG_GEN_ITEM_GROUP_GET_MULTIPLE_SELECTIONS(
												icons, numIcons);
	for (curIcon = 0; curIcon < numIcons; curIcon++) {
		VMBlockHandle mapBlock, iconBlock;
		MemHandle mem;
		IconExportFileMapBlock *mapPtr;
		word newIconID;

		/* we're creating a new icon set. */
		mapBlock = VMGetMapBlock(pself->IC_exportFileHandle);
		mapPtr = VMLock(pself->IC_exportFileHandle, mapBlock, &mem);
		mapPtr->IEFMB_numIcons = mapPtr->IEFMB_numIcons + 2;
		newIconID = mapPtr->IEFMB_numIcons - 1;
		VMDirty(mem);
		VMUnlock(mem);
		iconBlock = VMFind(pself->IC_fileHandle, NullHandle, (icons[curIcon] * 2 + 1));
		iconBlock = VMCopyVMBlock(pself->IC_fileHandle, iconBlock, pself->IC_exportFileHandle);
		VMModifyUserID(pself->IC_exportFileHandle, iconBlock, newIconID);
		iconBlock = VMFind(pself->IC_fileHandle, NullHandle, (icons[curIcon] * 2 + 2));
		iconBlock = VMCopyVMBlock(pself->IC_fileHandle, iconBlock, pself->IC_exportFileHandle);
		VMModifyUserID(pself->IC_exportFileHandle, iconBlock, newIconID + 1);
	}
	MemFree(iconBlock);

	/* set the file's creator so we can see only these on import
	 * it's unique to our icon files */
	strcpy(iconsToken.GT_chars, "HAI0");
	iconsToken.GT_manufID = MANUFACTURER_ID_BREADBOX;
	FileSetHandleExtAttributes(pself->IC_exportFileHandle,
											FEA_CREATOR, &iconsToken, sizeof(GeodeToken));

	VMClose(pself->IC_exportFileHandle, FALSE);
	MemLock(OptrToHandle(@MsgIconExportDone));
	UserStandardDialog(0, 0, 0, 0,
							  LMemDeref(@MsgIconExportDone),
						//	  "Icon export is complete.",
							  ((CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET) |
							  (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET)));
	MemUnlock(OptrToHandle(@MsgIconExportDone));
}

/*************************************************************************
	User pressed the export cancel button
*************************************************************************/
@extern method IconClass, MSG_ICON_VIEW_CANCEL_EXPORT_ICONS {

	/* close the file and delete it */
	VMClose(pself->IC_exportFileHandle, FALSE);
	FileDelete(g_expIconFileName);

}


