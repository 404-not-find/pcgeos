/* sebrowse.c
 *
 * This file is only a framework, not a finished product. Nombas does not
 * produce a browser, so this file has never been tested by us. It is
 * provided to pull togethor most of the issues you will need to address
 * to get a browser library written, but there will of course be problems
 * you will have to fix. Customer feedback is useful. Suggestions by
 * customers have been and will be in the future incorporated into new releases
 * of this file, so please do tell us what you had to change to make it work.
 */

/* (c) COPYRIGHT 1993-98           NOMBAS, INC.
 *                                 64 SALEM ST.
 *                                 MEDFORD, MA 02155  USA
 * 
 * ALL RIGHTS RESERVED
 * 
 * This software is the property of Nombas, Inc. and is furnished under
 * license by Nombas, Inc.; this software may be used only in accordance
 * with the terms of said license.  This copyright notice may not be removed,
 * modified or obliterated without the prior written permission of Nombas, Inc.
 * 
 * This software is a Trade Secret of Nombas, Inc.
 * 
 * This software may not be copied, transmitted, provided to or otherwise made
 * available to any other person, company, corporation or other entity except
 * as specified in the terms of said license.
 * 
 * No right, title, ownership or other interest in the software is hereby
 * granted or transferred.
 * 
 * The information contained herein is subject to change without notice and
 * should not be construed as a commitment by Nombas, Inc.
 */

/*
 * Written 12/02/97 - 12/08/97  Richard Robinson
 *         12/19/98             Richard Robinson, updated to C
 *         10/23/98 - 11/05/98  Richard Robinson, rewrite
 *                                 (with interruption for vacation)
 *         05/10/00             Richard Robinson
 *                                 updated documentation
 *                                 use Ex(...,jseCreateVar) to avoid
 *                                   so many temp vars
 *
 * Netscape-compatible object stuff. Routines are provided
 * allow a browser to expose objects in its Javascript like
 * Netscape does.
 *
 *
 * This version assumes a single-threaded browser (as all browsers
 * our customers have to date are.) This assumption, along with
 * the experience of solving customer problems, will make this
 * version much faster, though it can use more memory. I think
 * the new, non-dynamic design is also far clearer and easier for
 * you (the customer) to understand. The old version was implemented
 * the way it was to be more generic than it had to be.
 *
 * 
 * Adding it to your browser
 *
 *        -make sure to read all of these comments as well as those
 *         in sebrowse.h - they are the documentation.
 *
 *        -You must be including the ECMA objects in your project.
 *         See the API manual for information on this.
 *
 *        -define JSE_BROWSEROBJECTS in your jseopt.h.
 *
 *        -define JSE_MULTIPLE_GLOBAL in your jseopt.h
 *
 *        -your MayIContinue() function can pop up a dialog
 *         each 1,000,000 calls indicating the program is eating
 *         a lot of processor time and asking if it should be terminated?
 *         This is Internet Explorer's behavior, though Netscape
 *         appears not to do this. It is up to you.
 *
 *        -Initialize a new jseContext to hold your browser window
 *         hierarchy (including loading and initialization of all
 *         ECMA libraries). Use no global variable name, i.e. "".
 *
 *
 *        -after creating the context, call browserGeneralInfo() on it.
 *        -call browserAddMimeType() to add the mime types the browser
 *         knows how to handle
 *        -call browserAddPlugin() to add the plugins
 *
 *        -Call 'browserInitWindow()' whenever your browser pops
 *         up a new window. Do this for all windows and frames.
 *         The order doesn't matter as a placeholder for any window
 *         referred to is filled in when you call this routine for this
 *         window. Remember to initialize your first window!
 *
 *        -do Javascript using browserInterpret() and jseCallFunction().
 *         Although some extra work for generic interprets needs to be done,
 *         thus a new function, JSE_MULTIPLE_GLOBAL handles all the special
 *         work needed for functions. browserEventHandler() is included
 *         for one way to define event handlers.
 *
 *
 *        -do calls to browserUpdate() as needed when browser information
 *         changes outside control of the script.
 *
 *        -During runtime as each window closes, you should call
 *         'browserTermWindow()' on it. This applies to your browserCloseWindow()
 *         routine as well (you must explicitly close the window in this
 *         function.) If you don't close the window, the data structures
 *         associated with it remain in memory until browserCleanup() frees
 *         them up.
 *
 *
 *        -destroy the context when you are done. Right before destroying the
 *         context, call browserCleanup().
 *
 *
 *
 *        -after you have modified your program as above, make sure you
 *         compile and link this file with your program.
 *
 *        -you need to add all of the functions that this program calls.
 *         They represent the communication between the Javascript objects
 *         and your browser. In the companion file, 'sebrowse.h', you should
 *         search and find this text:
 *
 *  * The following functions you must provide! Each should be pretty
 *
 *
 *         all following text is a series of function prototypes
 *         along with a short description of what the function does. You
 *         must write this function and link it with your program. For
 *         example, the first prototype reads:
 *
 *
 *  struct BrowserWindow *browserGetTopWindow(jseContext jsecontext,
 *                                            struct BrowserWindow *current_window);
 *
 *        you must therefore write a function which returns a magic
 *        BrowserWindow cookie representing the top window your browser
 *        is displaying. It might look like this:
 *
 *
 *  struct BrowserWindow *browserGetTopWindow(jseContext jsecontext,
 *                                            struct BrowserWindow *current_window)
 *  {
 *    return (struct BrowserWindow *)(my_global_window_list.top_window);
 *    * alternately it might be:
 *    * return (struct BrowserWindow *)((struct Mywindow *)current_window)->top;
 *  }
 *
 *        Some functions may take more code to write than others. All functions
 *        are passed the current context they are executing in, for you may
 *        have many uses for it (such as to store/retrieve data.)
 *
 *        Please read the comments in the accompanying header file "sebrowse.h"
 *        for information on the magic cookies, data structures, and
 *        functions involved. Also, make sure you have a Javascript
 *        reference (I've been using Javascript: The Definitive Guide 2nd edition)
 *        as I have not duplicated information that can be found there in
 *        many cases (For example, the 'struct BrowserImage' represents the fields
 *        found in the Image object. You should look up Image in a
 *        Javascript book for an extensive description of each one.)
 *
 *
 * What is here?
 *
 *        This file implements the Netscape browser objects as defined
 *        for Netscape 3.0 with the exception of anything taint-related
 *        and anything Java-related. In addition, there are no security
 *        blocks - if you decide you think some data should not be
 *        allowed, then don't give it when asked for (for example, you
 *        might want to only let 'window.document.location' be read
 *        if the Javascript is executing in that window.)
 *
 *
 *        As of this writing, this code is never been tested by Nombas,
 *        since we do not make a browser. It has been compiled.
 *        This makes the code more a framework or sample for you to use.
 *
 *
 *        Search on "NOTE:" for areas that may need your attention.
 */


/* Browser notes
 *
 *
 *    OVERVIEW:
 *
* The routines in this file will construct a standard browser
 * tree. This tree is basically one or more Window objects
 * representing the windows your browser is currently
 * displaying. These windows of course also contain many
 * children as per the standard Netscape browser model, such as
 * 'document', 'history', 'location' and so forth.
 *
 * You create these window objects by calling the provided
 * 'browserInitWindow()' routine for each of your windows. This
 * will construct the window object. In doing so, it calls back
 * to your code to get the information about the window. See
 * the file sebrowse.h for the routines you need to provide,
 * and what they are expected to do.
 *
 * Note that you can use these routines to partially build the
 * window, execute some code, then build more of it. When the
 * 'browserInitWindow()' routine is building the tree, you get
 * to tell it what your window looks like. If you have not
 * completely built it yet, that is fine. The routines should
 * return what they do know about. Later, you can use the
 * 'browserUpdate()' routines to update the pieces of the
 * browser tree you have additional information on.
 *
 * Once the window(s) are constructed, you can execute code
 * using them. There are basically two kinds of code you'll
 * need to execute, standalone scripts and event handlers.
 *
 * Standalone scripts are the the kinds of things you will see
 * in '<SCRIPT>' tag blocks. You use the provided
 * 'browserInterpret()' routine to execute this code. You tell
 * it the window the script belongs to, and the code will be
 * executed 'in' that window. In other words, when the code
 * refers to 'window', it will get that window you specify.
 *
 * The second kind of code you often want to execute are event
 * handlers. Normally, you set them up when you encounter an
 * event definition. Later, you call the event handler when the
 * event actually occurs. Use the provided
 * 'browserEventHandler()' to set up the event. It returns a
 * jseVariable which is the function that you will call when
 * the event happens. The returned jseVariable can be invoked
 * by using the ScriptEase API 'jseCallFunction()' with it as
 * the function to call.
 *
 * Alternately, if you like, you can skip setting up the event
 * handler and just use 'browserInterpret()' to call the
 * function when you need to call it. That requires
 * reparsing the source text of the code each time it is
 * called, which is slow.
 *
 *
 *   BROWSER-TO-BROWSER-LIBRARY COMMUNICATION:
 *
 * Now that you have an understanding of the overview of the
 * browser library, let's talk about how it communicates with
 * your browser. You will need to fill out a number of routines
 * defined in the accompanying 'sebrowse.h' file which will be
 * called as needed. Each of these routines uses a number of
 * 'magic cookie' pointers. For instance, when you call
 * 'browserInitWindow()', you give it a 'struct BrowserWindow *'
 * magic cookie. You will notice that this structure is not
 * actually defined, nor is it ever dereferenced. The browser
 * uses it solely to pass back to your code. For instance,
 * while it is building the window object, it will need to know
 * the parent window. It will call 'browserGetParentWindow()'
 * passing back the same magic cookie. You then provide the
 * magic cookie for the parent window. The idea is that the
 * cookie is some internal pointer to your private data
 * structure. Given the pointer, you should know how to get all
 * the relevent information.
 *
 * The entire communication between your code and the browser
 * library is handled in this fashion. For instance, while
 * building the window object, the browser will need to know
 * what the document in that window is. It will call the
 * 'browserGetDocument()' routine (one of the routines you must
 * write) which must return a magic cookie for the document.
 * That will be passed back to you as the browser library needs
 * information about the document and calls the various
 * document information-fetching routines.
 *
 * Once the objects are built up in memory, they are also made
 * such that certain changes to them are relayed back to you. For
 * instance, let's say you call 'browserInterpret()' on the
 * short script, 'window.location = "http://localhost/";'. In
 * running this code, the routine (again, one of the ones you
 * must provide) 'browserGotoURL()' will be called telling you
 * the user is trying to go to the URL "http://localhost/". A
 * number of the routines you must provide will be called when
 * the script changes part of the browser tree that your code
 * needs to know about. Again, see 'sebrowse.h' for all of the
 * routines that you need to provide.
 *
 *
 *   IMPLEMENTATION THOUGHTS:
 *
 * Currently, the entire tree for a particular window is
 * built first. This means the script can immediately
 * access all of the information about the tree quickly. An
 * alternative is to use ScriptEase's dynamic functionality to
 * look up the information each time it is used. This method
 * was not choosen because it is significantly slower than the
 * current method, as well as harder to understand. If you
 * choose this method, the code in this file will need to
 * be heavily modified. However, the idea is relatively
 * straightforward and can be explained simply. Take the window
 * object as an example (the same idea must be applied to every
 * one of the object types this file builds; windows,
 * documents, locations, elements, etc.) Currently, the window
 * is built by getting the current values for each element of
 * it and converting them to ScriptEase values which are stored
 * in the browser tree. For instance, the member 'name' is
 * created as a jseVariable of type 'jseTypeString', and the
 * current value is put into the member using 'jsePutString()'.
 * In the dynamic scheme, rather than setting up all the
 * members initially, the window would have no members
 * except a dynamic '_get' (see the ScriptEase manual for much
 * more information on dynamic objects.) This '_get' would look
 * at the member being accessed and generate it on demand. For
 * instance, if the member 'name' is being accessed, we create
 * the variable as described abovee and return it, except we
 * don't create it until it is actually used. Basically, the
 * setup routine in the current version is exactly mirrored in
 * the dynamic scheme, except we create the particular member
 * being accessed and return it. The tree is never permanently
 * built in memory, each piece is built as it is accessed and
 * discarded when no longer referenced. The tradeoff is that
 * accessing the tree becomes significantly slower (I do mean
 * _significantly_, not measured in percentage performance
 * decrease, rather in number of times slower.)
 *
 * It is possible to develop a hybrid method, such that the
 * information is constructed on first use but then retained.
 * The first thing the dynamic get would do is check if the
 * member currently exists. If it does, it is returned. Else,
 * the dynamic creation of the member described above is done.
 * However, not only is the member created and returned, it is
 * also added to the object. This way, the next time it is
 * accessed, it has already been created and can be returned
 * more quickly. The tree is created on demand. This is a
 * middleground between the two methods. As the tree is
 * accessed, it is permanently retained in memory, so it will
 * use more memory than the dynamic method (which builds and
 * discards each piece as necessary), but it will be faster.
 * Still, it is much faster to not have to call a dynamic
 * routine at all, so this method may well be the worst of both
 * worlds rather than the best.
 *
 *
 * ---
 *
 * I've talked about the accessing of the properties of the
 * browser object tree and how they are set up. Now I want to
 * talk about how they are updated. When the user accesses
 * information in his script, regardless of how he gets it, the
 * browser doesn't need to know about it. For instance, if the
 * user gets the name of the window, he is just getting a text
 * string. However, if the user's script changes the value,
 * that information must propogate back to the browser. I gave
 * an example earlier about the script changing the
 * 'window.location' to change the page being viewed. The
 * browser library makes sure to call the appropriate routine
 * when this sort of thing happens. How does it do that?
 *
 * Each of the objects has a dynamic put routine (again, see
 * the ScriptEase manual for full information on dynamic
 * objects.) This routine checks the member being updated and
 * if it is one that the browser should know about, it calls
 * the corresponding callback routine to transfer that
 * information. Then it goes along and does the 'usual' thing
 * to update the ScriptEase data structure.
 *
 * Unfortunately, this has the drawback that every member being
 * updated must go through the dynamic put when being updated
 * even if most won't require any special code. Operator
 * overloading offers a solution to this problem, which you may
 * choose to implement. Instead of adding a dynamic put to each
 * object whose members are important, we shift the focus to
 * the members itself. Rather than the member being the actual
 * value (such as a string for window.name), it is an object.
 * This object has a _defaultValue routine that provides the
 * data. This routine is called when the object is put in a
 * place where an integral value is expected. With this in
 * place, the object acts much like it was the integral value
 * in most cases. However, it also now can use operator
 * overloading to overload the '=' operator. Whenver the object
 * is assigned to, the '=' operator will be used. If it is
 * overloaded, the object can call the browser update routine
 * in it, then store the new value to return from
 * _defaultValue.
 *
 */


/* we need this for the callbacks... */
#pragma option -WDE

@include <stdapp.goh>

#include <ansi/stdlib.h>
#include <ansi/ctype.h>
#include <ansi/assert.h>

@include "htmlview.goh"
#include "javascr.h"


#if JAVASCRIPT_SUPPORT

#ifdef DO_DBCS
extern char *G2D(TCHAR *s);
/* only need match/no-match */
sword LocalCmpStringsNoCaseSBCS(const char *s1, const char *s2, word len)
{
    int i;

    /* we only care about ASCII cases */
    for (i = 0; i < len; i++) {
	if (toupper(s1[i]) != toupper(s2[i])) return -1;  /* no-match */
    }
    return 0;  /* match */
}
#else
#define G2D(s) s
#define LocalCmpStringsNoCaseSBCS(s,t,n) LocalCmpStringsNoCase(s,t,n)
#endif

/* ---------------------------------------------------------------------- */

#if 0==JSE_OPERATOR_OVERLOADING
#  error "Browser objects require operator overloading"
#endif

#pragma option -dc-

static CONST_STRING(BROWSER_WINDOW_NAME,"__browserWindow%lx");

static CONST_STRING(BROWSER_UPDATE_ROUTINE,"browserUpdate");


#pragma option -dc

/* List of properties to create variables holding their jseString values: */
#define PROPERTY_STRING(text) \
  static jseString text##_STRING; \
  static CONST_STRING(text##_PROPERTY,#text)

PROPERTY_STRING(action);
PROPERTY_STRING(alinkColor);
PROPERTY_STRING(anchors);
PROPERTY_STRING(appCodeName);
PROPERTY_STRING(applets);
PROPERTY_STRING(appName);
PROPERTY_STRING(appVersion);
PROPERTY_STRING(availHeight);
PROPERTY_STRING(availWidth);
PROPERTY_STRING(platform);
PROPERTY_STRING(language);
PROPERTY_STRING(bgColor);
PROPERTY_STRING(border);
PROPERTY_STRING(checked);
PROPERTY_STRING(closed);
PROPERTY_STRING(complete);
PROPERTY_STRING(cookie);
PROPERTY_STRING(defaultChecked);
PROPERTY_STRING(defaultSelected);
PROPERTY_STRING(defaultStatus);
PROPERTY_STRING(defaultValue);
PROPERTY_STRING(description);
PROPERTY_STRING(document);
PROPERTY_STRING(__document);
PROPERTY_STRING(domain);
PROPERTY_STRING(elements);
PROPERTY_STRING(__elements);
PROPERTY_STRING(element);
PROPERTY_STRING(embeds);
PROPERTY_STRING(enabledPlugin);
PROPERTY_STRING(encoding);
PROPERTY_STRING(fgColor);
PROPERTY_STRING(filename);
PROPERTY_STRING(forms);
PROPERTY_STRING(__forms);
PROPERTY_STRING(form);
PROPERTY_STRING(frames);
PROPERTY_STRING(hash);
PROPERTY_STRING(height);
PROPERTY_STRING(history);
PROPERTY_STRING(hostname);
PROPERTY_STRING(host);
PROPERTY_STRING(href);
PROPERTY_STRING(hspace);
PROPERTY_STRING(images);
PROPERTY_STRING(__images);
PROPERTY_STRING(index);
PROPERTY_STRING(innerHeight);
PROPERTY_STRING(innerWidth);
PROPERTY_STRING(lastModified);
PROPERTY_STRING(length);
PROPERTY_STRING(linkColor);
PROPERTY_STRING(links);
PROPERTY_STRING(__links);
PROPERTY_STRING(location);
PROPERTY_STRING(lowsrc);
PROPERTY_STRING(method);
PROPERTY_STRING(mimeTypes);
PROPERTY_STRING(name);
PROPERTY_STRING(navigator);
PROPERTY_STRING(opener);
PROPERTY_STRING(options);
PROPERTY_STRING(parent);
PROPERTY_STRING(__parent__);
PROPERTY_STRING(pathname);
PROPERTY_STRING(plugins);
PROPERTY_STRING(port);
PROPERTY_STRING(protocol);
PROPERTY_STRING(referrer);
PROPERTY_STRING(screen);
PROPERTY_STRING(search);
PROPERTY_STRING(selectedIndex);
PROPERTY_STRING(selected);
PROPERTY_STRING(self);
PROPERTY_STRING(src);
PROPERTY_STRING(status);
PROPERTY_STRING(suffixes);
PROPERTY_STRING(target);
PROPERTY_STRING(text);
PROPERTY_STRING(title);
PROPERTY_STRING(top);
PROPERTY_STRING(type);
PROPERTY_STRING(URL);
PROPERTY_STRING(userAgent);
PROPERTY_STRING(value);
PROPERTY_STRING(vlinkColor);
PROPERTY_STRING(vspace);
PROPERTY_STRING(width);
PROPERTY_STRING(window);
static jseString equalOp_STRING;

/* List of strings to internalize */
#define INTERNALIZE_STRING(text) {&text##_PROPERTY, &text##_STRING}

static struct { char *prop; jseString *str; } propList[] = {
  INTERNALIZE_STRING(action),
  INTERNALIZE_STRING(alinkColor),
  INTERNALIZE_STRING(anchors),
  INTERNALIZE_STRING(appCodeName),
  INTERNALIZE_STRING(applets),
  INTERNALIZE_STRING(appName),
  INTERNALIZE_STRING(appVersion),
  INTERNALIZE_STRING(platform),
  INTERNALIZE_STRING(language),
  INTERNALIZE_STRING(bgColor),
  INTERNALIZE_STRING(border),
  INTERNALIZE_STRING(checked),
  INTERNALIZE_STRING(closed),
  INTERNALIZE_STRING(complete),
  INTERNALIZE_STRING(cookie),
  INTERNALIZE_STRING(defaultChecked),
  INTERNALIZE_STRING(defaultSelected),
  INTERNALIZE_STRING(defaultStatus),
  INTERNALIZE_STRING(defaultValue),
  INTERNALIZE_STRING(description),
  INTERNALIZE_STRING(document),
  INTERNALIZE_STRING(__document),
  INTERNALIZE_STRING(domain),
  INTERNALIZE_STRING(elements),
  INTERNALIZE_STRING(__elements),
  INTERNALIZE_STRING(element),
  INTERNALIZE_STRING(embeds),
  INTERNALIZE_STRING(enabledPlugin),
  INTERNALIZE_STRING(encoding),
  INTERNALIZE_STRING(fgColor),
  INTERNALIZE_STRING(filename),
  INTERNALIZE_STRING(forms),
  INTERNALIZE_STRING(__forms),
  INTERNALIZE_STRING(form),
  INTERNALIZE_STRING(frames),
  INTERNALIZE_STRING(hash),
  INTERNALIZE_STRING(height),
  INTERNALIZE_STRING(history),
  INTERNALIZE_STRING(hostname),
  INTERNALIZE_STRING(host),
  INTERNALIZE_STRING(href),
  INTERNALIZE_STRING(hspace),
  INTERNALIZE_STRING(images),
  INTERNALIZE_STRING(__images),
  INTERNALIZE_STRING(index),
  INTERNALIZE_STRING(innerHeight),
  INTERNALIZE_STRING(innerWidth),
  INTERNALIZE_STRING(lastModified),
  INTERNALIZE_STRING(length),
  INTERNALIZE_STRING(linkColor),
  INTERNALIZE_STRING(links),
  INTERNALIZE_STRING(__links),
  INTERNALIZE_STRING(location),
  INTERNALIZE_STRING(lowsrc),
  INTERNALIZE_STRING(method),
  INTERNALIZE_STRING(mimeTypes),
  INTERNALIZE_STRING(name),
  INTERNALIZE_STRING(navigator),
  INTERNALIZE_STRING(opener),
  INTERNALIZE_STRING(options),
  INTERNALIZE_STRING(parent),
  INTERNALIZE_STRING(__parent__),
  INTERNALIZE_STRING(pathname),
  INTERNALIZE_STRING(plugins),
  INTERNALIZE_STRING(port),
  INTERNALIZE_STRING(protocol),
  INTERNALIZE_STRING(referrer),
  INTERNALIZE_STRING(search),
  INTERNALIZE_STRING(selectedIndex),
  INTERNALIZE_STRING(selected),
  INTERNALIZE_STRING(self),
  INTERNALIZE_STRING(src),
  INTERNALIZE_STRING(status),
  INTERNALIZE_STRING(suffixes),
  INTERNALIZE_STRING(target),
  INTERNALIZE_STRING(text),
  INTERNALIZE_STRING(title),
  INTERNALIZE_STRING(top),
  INTERNALIZE_STRING(type),
  INTERNALIZE_STRING(URL),
  INTERNALIZE_STRING(userAgent),
  INTERNALIZE_STRING(value),
  INTERNALIZE_STRING(vlinkColor),
  INTERNALIZE_STRING(vspace),
  INTERNALIZE_STRING(width),
  INTERNALIZE_STRING(window),
  {"=", &equalOp_STRING},
};

#pragma option -dc-

/* forward references */
extern struct jseObjectCallbacks FramesArrayCallbacks;
extern struct jseObjectCallbacks ImagesArrayCallbacks;
extern struct jseObjectCallbacks FormsArrayCallbacks;
extern struct jseObjectCallbacks ElementsArrayCallbacks;
extern struct jseObjectCallbacks OptionsArrayCallbacks;

/* storage of dynamically created image objects with "new Image()" */
optr imageHeap = NullOptr;

/* storage of dynamically created option objects with "new Option()"
   held here until attached to SELECT list */
optr optionHeap = NullOptr;

/* locate some global objects */
jseVariable globalObject;
optr browserFrameObj = NullOptr;  /* most recently initialized frame, used
				     only for preloading images */

/* flag to indicate execution during parsing, we suppress dialogs, etc.
   during this pass */
Boolean parsingPass = FALSE;


/* Return/set the magic cookie for this object */
#define get_my_object(t) \
  ((struct t *)jseGetObjectData(jsecontext, jseGetCurrentThisVariable(jsecontext)))
#define get_its_object(obj,t) \
  ((struct t *)jseGetObjectData(jsecontext, obj))
#define set_its_object(obj,data) \
  jseSetObjectData(jsecontext,obj,(void *)(data));

   static void NEAR_CALL
AssignVarToProperty(jseContext jsecontext,jseVariable obj,const jsecharptr propertyName,
                    jseVariable src,jseVarAttributes attr)
{
   jseVariable tmp = jseMemberEx(jsecontext,obj,propertyName,jseTypeUndefined,jseCreateVar);
   jseSetAttributes(jsecontext,tmp,0);
   jseAssign(jsecontext,tmp,src);
   jseSetAttributes(jsecontext,tmp,attr);
   jseDestroyVariable(jsecontext,tmp);
}

   static void NEAR_CALL
AssignStringToProperty(jseContext jsecontext,jseVariable obj,const jsecharptr propertyName,
                       const jsecharptr src,jseVarAttributes attr)
{
   jseVariable v = jseCreateVariable(jsecontext,jseTypeString);
   jsePutString(jsecontext,v,src);
   AssignVarToProperty(jsecontext,obj,propertyName,v,attr);
   jseDestroyVariable(jsecontext,v);
}

   static void NEAR_CALL
AssignLongToProperty(jseContext jsecontext,jseVariable obj,const jsecharptr propertyName,
                     slong src,jseVarAttributes attr)
{
   jseVariable v = jseCreateVariable(jsecontext,jseTypeNumber);
   jsePutLong(jsecontext,v,src);
   AssignVarToProperty(jsecontext,obj,propertyName,v,attr);
   jseDestroyVariable(jsecontext,v);
}

   static void NEAR_CALL
AssignBooleanToProperty(jseContext jsecontext,jseVariable obj,const jsecharptr propertyName,
                        jsebool src,jseVarAttributes attr)
{
   jseVariable v = jseCreateVariable(jsecontext,jseTypeBoolean);
   jsePutBoolean(jsecontext,v,src);
   AssignVarToProperty(jsecontext,obj,propertyName,v,attr);
   jseDestroyVariable(jsecontext,v);
}

/* Get the given member, but make sure it is writeable. Also if it
 * is not of the correct type, trash existing contents and make it
 * the correct type.
 *
 * The returned variable must be destroyed.
 */
   static jseVariable NEAR_CALL
jseMakeMember(jseContext jsecontext,jseVariable obj,const jsecharptr name,jseDataType t)
{
   jseVariable var = jseMemberEx(jsecontext,obj,name,t,jseCreateVar);

   assert( var!=NULL );

   jseSetAttributes(jsecontext,var,(jseVarAttributes)
                    (jseGetAttributes(jsecontext,var)&~jseReadOnly)); /* make sure not readonly */
   if( t!=jseGetType(jsecontext,var)) jseConvert(jsecontext,var,t);

   return var;
}

/* ---------------------------------------------------------------------- */


static void NEAR_CALL browserSetUpWindowObject(jseContext jsecontext,jseVariable where,
                                       struct BrowserWindow *window);
static void NEAR_CALL browserSetUpLocationObject(jseContext jsecontext,jseVariable where,
                                       struct BrowserLocation *loc);
static void NEAR_CALL browserSetUpDocumentObject(jseContext jsecontext,
                                       jseVariable where,
                                       struct BrowserDocument *doc);
static void NEAR_CALL browserSetUpElementOption(jseContext jsecontext,
                                       jseVariable where,
                                       struct BrowserElement *elem,
                                       struct BrowserOptionContents *opt);
static void NEAR_CALL browserSetUpImageObject(jseContext jsecontext,
                                       jseVariable where,
                                       struct BrowserImage *image);
static void NEAR_CALL browserSetUpElementObject(jseContext jsecontext,
                                       jseVariable where,
                                       struct BrowserElement *elem);
static void NEAR_CALL browserSetUpHistoryObject(jseContext jsecontext,
                                       jseVariable where,
                                       struct BrowserWindow *win);
static void NEAR_CALL browserSetUpFormObject(jseContext jsecontext,
                                       jseVariable where,
                                       struct BrowserForm *form);

static jseVariable NEAR_CALL browserCreateWindowObject(jseContext jsecontext,
                                        struct BrowserWindow *window);

static jseVariable NEAR_CALL browserCreateLocationObject(jseContext jsecontext,
                                        struct BrowserLocation *loc);

static jseVariable NEAR_CALL browserCreateHistoryObject(jseContext jsecontext,
                                       struct BrowserWindow *win);

static jseVariable NEAR_CALL browserCreateDocumentObject(jseContext jsecontext,
                                        struct BrowserDocument *doc);

static jseVariable NEAR_CALL browserCreateMimeObject(jseContext jsecontext,struct BrowserMimeType *type,
                                    jseVariable referer);

static jseVariable NEAR_CALL browserCreateImageObject(jseContext jsecontext,
						      struct BrowserImage *image);

static jseVariable NEAR_CALL browserCreateFormObject(jseContext jsecontext,
						     struct BrowserForm *form);

static jseVariable NEAR_CALL browserCreateElementObject(jseContext jsecontext,
							struct BrowserElement *element);

static jseVariable NEAR_CALL browserCreateElementObjectByName(jseContext jsecontext,
                            struct BrowserElement *element);

static jseVariable NEAR_CALL browserCreateElementOption(jseContext jsecontext,
                                              struct BrowserElement *element,
                                              struct BrowserOptionContents *opt);


/* ----------------------------------------------------------------------
 * Utility functions for GPCBrow compatibility
 * ---------------------------------------------------------------------- */

/* The following routine does the same thing as jsePutString, but accepts
   the string in the form of a name token. For convenience, the reference
   to this name token is released by the call. */
void putTokenString(jseContext jsecontext, jseVariable variable,
                    NameToken data)
{
    TCHAR buf[HTML_STATIC_BUF], *p;
#ifdef DO_DBCS
    word pLen, status, backup;
    DosCodePage cp = G_codePage;
#endif

    if(data != NAME_POOL_NONE)
    {
      NamePoolCopy(namePool, buf, sizeof(buf), data, &p);
#ifdef DO_DBCS
      pLen = strlen(p)+1;
      LocalGeosToDos(p, p, &pLen, DEFCHAR, &cp, 0, &status, &backup);
#endif
      jsePutString(jsecontext, variable, p);
      NamePoolDestroyIfDynamic(p);
      NamePoolReleaseToken(namePool, data);
    }
    else
      jsePutString(jsecontext, variable, "");
}

NameToken getTokenString(jseContext jsecontext, jseVariable variable,
                         JSE_POINTER_UINDEX *filled)
{
    const jsecharptr str;

    str = jseGetString(jsecontext, variable, filled);
    return NamePoolTokenizeDOS(namePool, str, FALSE);
}

static jseVariable NEAR_CALL getProp(jseContext jsecontext, jseVarAttributes attrs, Boolean tokenProp, NameToken t, Boolean longProp, ulong l, Boolean boolProp, Boolean b)
{
    jseVariable retVar;

    if (tokenProp) {
	retVar = jseCreateVariable(jsecontext, jseTypeString);
	jseSetAttributes(jsecontext, retVar, 0);
	NamePoolUseToken(namePool, t);  /* so we can release all later */
	putTokenString(jsecontext, retVar, t);
	jseSetAttributes(jsecontext, retVar, attrs);
    } else if (longProp) {
	retVar = jseCreateVariable(jsecontext, jseTypeNumber);
	jseSetAttributes(jsecontext, retVar, 0);
	jsePutLong(jsecontext, retVar, l);
	jseSetAttributes(jsecontext, retVar, attrs);
    } else if (boolProp) {
	retVar = jseCreateVariable(jsecontext, jseTypeBoolean);
	jseSetAttributes(jsecontext, retVar, 0);
	jsePutBoolean(jsecontext, retVar, b);
	jseSetAttributes(jsecontext, retVar, attrs);
    } else {
	retVar = NULL;
    }

    return retVar;
}

/* Get the window object associated with a particular frame. This routine returns
 * a variable reference that has to be explicitly destroyed.
 */
jseVariable JSWindowObject(jseContext jsecontext,optr frame)
{
   jsechar buffer[64];
   
   /* Recurse up across dummy frames */
   frame = @call frame::MSG_URL_FRAME_FIND_REAL_FRAME();

   sprintf_jsechar(buffer,BROWSER_WINDOW_NAME,frame);
   /* this is because it could already exist as a placeholder previously created.
    * We want to update the object so that all the old links to it are still
    * valid.
    */
   return jseMemberEx(jsecontext,globalObject,buffer,jseTypeObject, jseLockRead|jseCreateVar);
}

static jseVariable NEAR_CALL checkImageFormNames(jseContext jsecontext, jseString prop, struct BrowserDocument *doc, jseVariable container)
{
    jseVariable tmp, retVar = NULL;
    struct BrowserImage *bi;
    struct BrowserForm *bf;
    jsecharptr propStr;

    /* no named items if parsing pass */
    if (parsingPass) return NULL;

    propStr = jseGetInternalString(jsecontext, prop, 0);

    /* check for image names */
    bi = browserGetImageItemFromName(jsecontext,
				     browserGetImagesArray(jsecontext, doc),
				     propStr);
    if (bi)
	retVar = browserCreateImageObject(jsecontext, bi);

    /* if not image name, check for form names */
    if (retVar == NULL) {
	bf = browserGetFormItemFromName(jsecontext,
					browserGetFormsArray(jsecontext, doc),
					propStr);
	if (bf)
	    retVar = browserCreateFormObject(jsecontext, bf);
    }

    /* hybrid mirror tree: if something found, attach */
    if (retVar) {
	jseAssign(jsecontext,
		  tmp = jseMemberEx(jsecontext, container, propStr, jseTypeUndefined, jseCreateVar),
		  retVar);
	jseDestroyVariable(jsecontext, tmp);
    }

    return retVar;
}

static jseVariable NEAR_CALL checkElementNames(jseContext jsecontext, jseString prop, struct BrowserForm *form, jseVariable container)
{
    jseVariable tmp, retVar = NULL;
    struct BrowserElement *be;
    jsecharptr propStr;
    word len, i;
    Boolean isIndex = TRUE;

    /* no named items if parsing pass */
    if (parsingPass) return NULL;

    propStr = jseGetInternalString(jsecontext, prop, &len);
    for (i = 0; i < len; i++) {
	if (!isdigit_jsechar(propStr[i])) {
	    isIndex = FALSE;
	    break;
	}
    }
    /* check for element index */
    if (isIndex) {
	ulong index = atoi_jsechar(propStr);
	be = browserGetElementItem(jsecontext, form, index);
	if (be) {
	    retVar = browserCreateElementObject(jsecontext, be);
	    /* hybrid mirror tree: attach indexed item */
	    jseAssign(jsecontext,
		      tmp = jseIndexMemberEx(jsecontext, container, index, jseTypeUndefined, jseCreateVar),
		      retVar);
	    jseDestroyVariable(jsecontext, tmp);
	    return retVar;
	}
    }

    /* check for element names */
    be = browserGetElementItemFromName(jsecontext,
				       form,
				       propStr);
    if (be)
	retVar = browserCreateElementObjectByName(jsecontext, be);

    /* hybrid mirror tree: if something found, attach */
    if (retVar) {
	jseAssign(jsecontext,
		  tmp = jseMemberEx(jsecontext, container, propStr, jseTypeUndefined, jseCreateVar),
		  retVar);
	jseDestroyVariable(jsecontext, tmp);
    }

    return retVar;
}

static jseVariable NEAR_CALL checkGetItemParent(jseContext jsecontext, jseString prop, jsecharptr arrayStr, optr win)
{
    jseVariable v, retVar = NULL;

    if (prop == __parent___STRING) {
	v = jseMemberEx(jsecontext, browserWindowObject(jsecontext, (struct BrowserWindow *)win), "__document", jseTypeUndefined, jseCreateVar);
	retVar = jseMemberEx(jsecontext, v, arrayStr, jseTypeUndefined, jseCreateVar);
	jseDestroyVariable(jsecontext, v);
    }
    return retVar;
}

static jseVariable NEAR_CALL checkGetElementParent(jseContext jsecontext, struct BrowserElement *element, jseString prop, optr win)
{
    jseVariable v, v1, retVar = NULL;

    if (prop == form_STRING || prop == __parent___STRING) {
	v = jseMemberEx(jsecontext, browserWindowObject(jsecontext, (struct BrowserWindow *)win), "__document", jseTypeUndefined, jseCreateVar);
	v1 = jseMemberEx(jsecontext, v, "__forms", jseTypeUndefined, jseCreateVar);
	jseDestroyVariable(jsecontext, v);
	retVar = jseIndexMemberEx(jsecontext, v1, browserGetElementForm(jsecontext, element), jseTypeUndefined, jseCreateVar);
	jseDestroyVariable(jsecontext, v1);
    }
    return retVar;
}

/* ---------------------------------------------------------------------- */


/* Call the 'browserUpdate()' function of the given object if it has one.
 */
   void
browserUpdate(jseContext jsecontext,jseVariable var_to_update)
{
   jseVariable func;
   jseStack stack;
   
   ProfStart("browserUpdate") ;
   func = jseGetMemberEx(jsecontext,var_to_update,BROWSER_UPDATE_ROUTINE,jseCreateVar);
   if( func!=NULL )
   {
      jseVariable ret;
      stack = jseCreateStack(jsecontext);
      jseCallFunction(jsecontext,func,stack,&ret,var_to_update);
      jseDestroyStack(jsecontext,stack);
      jseDestroyVariable(jsecontext, func);
   }
   ProfEnd() ;
}


/* ----------------------------------------------------------------------
 * Some simple utility functions for doing the string encasing
 * ---------------------------------------------------------------------- */

#pragma codeseg SEBROWSE_STRING
#pragma option -dc-

/* Encases the string thisvar in a special string that is passed */
   static void NEAR_CALL
encase_formatted(jseContext jsecontext,jsecharptr format)
{
  jseVariable thisvar = jseGetCurrentThisVariable(jsecontext);

   jseVariable ret,tmp;
   jseVariable val =
      jseCreateConvertedVariable(jsecontext,jseFuncVar(jsecontext,0),jseToString);

   ulong size;
   const jsecharptr str =
      jseGetString(jsecontext,
                   tmp = jseMemberEx(jsecontext,thisvar,VALUE_PROPERTY,jseTypeString,jseCreateVar),
                                    &size);
   jsecharptr buffer = jseMustMalloc(jsecharptrdatum,
      sizeof(jsechar)*(1+strlen_jsechar(format)+size+jseGetArrayLength(jsecontext,val,NULL)));

   jseDestroyVariable(jsecontext,tmp);

   sprintf_jsechar(buffer,format,jseGetString(jsecontext,val,NULL),str);
   ret = jseCreateVariable(jsecontext,jseTypeString);
   jsePutString(jsecontext,ret,buffer);
   jseReturnVar(jsecontext,ret,jseRetTempVar);

   jseMustFree(buffer);

   jseDestroyVariable(jsecontext,val);
}


   static void NEAR_CALL
encase_generic(jseContext jsecontext,jsecharptr tag)
{
  jseVariable thisvar = jseGetCurrentThisVariable(jsecontext);
   jseVariable tmp;


   ulong size;
   const jsecharptr str =
      jseGetString(jsecontext,
                   tmp = jseMemberEx(jsecontext,thisvar,VALUE_PROPERTY,jseTypeString,jseCreateVar),
                                    &size);
   jsecharptr buffer = jseMustMalloc(jsecharptrdatum,sizeof(jsechar)*(100+size));
   jseVariable ret;
   sprintf_jsechar(buffer,UNISTR("<%s>%s</%s>"),tag,str,tag);
   ret = jseCreateVariable(jsecontext,jseTypeString);
   jsePutString(jsecontext,ret,buffer);
   jseReturnVar(jsecontext,ret,jseRetTempVar);

   jseMustFree(buffer);

   jseDestroyVariable(jsecontext,tmp);
}


/* the string extensions */

static jseLibFunc(Stringanchor)
{
  encase_formatted(jsecontext,UNISTR("<A NAME=\"%s\">%s</A>"));
}

static jseLibFunc(Stringbig)
{
  encase_generic(jsecontext,UNISTR("BIG"));
}

static jseLibFunc(Stringblink)
{
  encase_generic(jsecontext,UNISTR("BLINK"));
}

static jseLibFunc(Stringbold)
{
  encase_generic(jsecontext,UNISTR("B"));
}

static jseLibFunc(Stringfixed)
{
  encase_generic(jsecontext,UNISTR("TT"));
}

static jseLibFunc(Stringfontcolor)
{
  encase_formatted(jsecontext,UNISTR("<FONT COLOR=\"%s\">%s</FONT>"));
}

static jseLibFunc(Stringfontsize)
{
  encase_formatted(jsecontext,UNISTR("<FONT SIZE=\"%s\">%s</FONT>"));
}

static jseLibFunc(Stringitalics)
{
  encase_generic(jsecontext,UNISTR("I"));
}

static jseLibFunc(Stringlink)
{
  encase_formatted(jsecontext,UNISTR("<A HREF=\"%s\">%s</A>"));
}

static jseLibFunc(Stringsmall)
{
  encase_generic(jsecontext,UNISTR("SMALL"));
}

static jseLibFunc(Stringstrike)
{
  encase_generic(jsecontext,UNISTR("STRIKE"));
}

static jseLibFunc(Stringsub)
{
  encase_generic(jsecontext,UNISTR("sub"));
}

static jseLibFunc(Stringsup)
{
  encase_generic(jsecontext,UNISTR("sup"));
}


/* ---------------------------------------------------------------------- */
/* Marcos for defining access routines for "active properties"            */
/* ---------------------------------------------------------------------- */

#define DEFAULT_VALUE_PROC(_class, _cookie, _get) \
  jseVariable JSE_CFUNC FAR_CALL _export _class##_defaultValue( \
    jseContext jsecontext,jseVariable obj,jseVariable hint) \
  { \
      struct _cookie *cookie; \
      jseVariable retVar; \
    \
      cookie = get_its_object(obj,_cookie); \
      retVar = jseCreateVariable(jsecontext, jseTypeString); \
      jseSetAttributes(jsecontext, retVar, 0); \
      putTokenString(jsecontext, retVar, _get); \
      jseSetAttributes(jsecontext, retVar, jseDontDelete); \
      return retVar; \
  }

#define ASSIGN_OPERATOR_PROC(_class, _cookie, _set) \
  jseVariable JSE_CFUNC FAR_CALL _export _class##_operator( \
    jseContext jsecontext,jseVariable obj,jseString op,jseVariable operand) \
  { \
      struct _cookie *cookie; \
      const jsecharptr value; \
      jseVariable retVar; \
    \
      if(op==equalOp_STRING) \
      { \
        cookie = get_its_object(obj,_cookie); \
        value = jseGetString(jsecontext,operand,NULL); \
        _set; \
        retVar = jseCreateVariable(jsecontext, jseTypeString); \
        jseSetAttributes(jsecontext,retVar,0); \
        jseAssign(jsecontext,retVar,operand); \
        jseSetAttributes(jsecontext,retVar,jseDontDelete); \
        return retVar; \
      } \
      return NULL; \
  }

/* ---------------------------------------------------------------------- *
 * window object and its dynamic put routine
 *
 * We keep a list of them in the global object (DontEnum/ReadOnly/DontDelete)
 * so when any function is run, we know its BrowserWindow and can find its
 * appropriate window_obj
 * ---------------------------------------------------------------------- */

#pragma codeseg SEBROWSE_WINDOW
#pragma option -dc-

/* Get the window object associated with your magic cookie.
 */
   jseVariable
browserWindowObject(jseContext jsecontext,struct BrowserWindow *window)
{
   jsechar buffer[64];
   
   sprintf_jsechar((jsecharptr)buffer,BROWSER_WINDOW_NAME,window);
   /* this is because it could already exist as a placeholder previously created.
    * We want to update the object so that all the old links to it are still
    * valid.
    */
   return jseMemberEx(jsecontext,globalObject,buffer,jseTypeObject, jseLockRead);
}


/* browserEventHandler()
 *
 * Create a function that can be called to handle an event. This
 * routine sets up the handler so browser variable resolution
 * is handled.
 *
 *
 * Here are the parameters:
 *
 *   window - the window this event is associated with.
 *   eventname - a name for the event. This is up to you, but
 *            you can just use something like "onmouseover"
 *   event_source_txt - the text of the event, just simple
 *            script code.
 *   container - an optional place to store the variable. This
 *            function will return a jseVariable but you'll
 *            likely want to permanently store it. This is
 *            a convenient way to do so. You can choose a
 *            single place to store all events, or store each
 *            as a child of the containing element that the
 *            event is for. The variable must be an object and
 *            the event is stored as a member of it (with the
 *            member name determined by eventname).
 *
 *
 * The routine will generate a new function, just as if
 * you used the ECMAScript 'Function()' call. This function
 * when invoked will do the script code specified in the
 * event's source text. The returned function also has
 * the jseImplicitParents and jseImplicitThis attributes
 * turned on it. These are important, because they make
 * the 'this' variable and its parent's members visible
 * directly. For instance, if you make the event associated
 * with an 'element', you can refer to other members of the
 * element and members of the element's containing document,
 * form, window, and so forth directly.
 *
 * You call the returned function by using jseCallFunction.
 * This is done when the event actually happens. Of course,
 * that is determined by your browser, it knows things like
 * when the mouse moves over an element or clicks on it,
 * that kind of thing. You pass the returned jseVariable
 * to jseCallFunction() as the function to call. You pass
 * the containing element, form, document, or whatever the
 * event is associated with as the 'this' variable, another
 * one of the parameters to jseCallFunction. You usually
 * pass a blank stack (i.e. no parameters) to an event handler.
 */
   jseVariable
browserEventHandler(jseContext jsecontext,
                    struct BrowserWindow *window,
                    const jsecharptr eventname,
                    const jsecharptr event_source_txt,
                    jseVariable container)
{
   jseVariable oldglob = jseGlobalObject(jsecontext);  /* no destroy */
   jseVariable newglob = browserWindowObject(jsecontext,window);  /* no destroy */
   jseVariable ret,param,func;
   jseStack stack;
   
   
   /* Setup so we can call 'Function()', passing the
    * event_source_txt as the text of the function.
    */
   stack = jseCreateStack(jsecontext);
   param = jseCreateVariable(jsecontext,jseTypeString);
   jsePutString(jsecontext,param,event_source_txt);
   jsePush(jsecontext,stack,param,True); /* delete when popped */

   /* Find the 'Function' constructor
    */
   func = jseGetMemberEx(jsecontext,newglob,FUNCTION_PROPERTY,jseCreateVar);
   if( func==NULL )
   {
      /* ECMA objects not there, a browser needs the ECMA objects */
      return NULL;
   }

   /* swap in the new window as the global object effectively running
    * the script in that window. All window's prototypes point back to
    * the real global object so functions and objects will be found as
    * normal.
    */
   jseSetGlobalObject(jsecontext,newglob);

   /* it shouldn't fail, perhaps it is not the real ECMA function? */
   if( !jseCallFunction(jsecontext,func,stack,&ret,NULL) )
      ret = NULL;
   
   jseDestroyVariable(jsecontext,func);

   /* Put back the old global and give the user the result */
   jseSetGlobalObject(jsecontext,oldglob);

   if( ret!=NULL )
   {
      /* lock it because destroying the stack will destroy it, yet we
       * need to return it.
       */
      ret = jseCreateSiblingVariable(jsecontext,ret,0);
      jseSetAttributes(jsecontext,ret,jseImplicitParents|jseImplicitThis);

      if( container!=NULL )
      {
         AssignVarToProperty(jsecontext,container,eventname,ret,
                             jseImplicitParents|jseImplicitThis);
      }
   }
   
   jseDestroyStack(jsecontext,stack);
   
   return ret;
}

extern dword startInterpret;
extern word runawayCount;

void
browserCallFunction(jseContext jsecontext,jseVariable jsefunction,jseStack jsestack,jseVariable *returnVar,jseVariable thisVar,struct BrowserWindow *window)
{
   jseVariable oldglob = jseGlobalObjectEx(jsecontext, jseCreateVar);
   jseVariable newglob = JSWindowObject(jsecontext,(optr)window);
   
   /* swap in the new window as the global object effectively running
    * the script in that window. All window's prototypes point back to
    * the real global object so functions and objects will be found as
    * normal.
    */
   jseSetGlobalObject(jsecontext,newglob);
   jseDestroyVariable(jsecontext,newglob);

   /* it shouldn't fail, perhaps it is not the real ECMA function? */
   startInterpret = TimerGetCount();  /* can we use JSE_INTERPRET_INFREQUENT_CONT here?  No, we want a real-time, not a secode count */
   runawayCount = 0;
   jseCallFunction(jsecontext,jsefunction,jsestack,returnVar,thisVar);

   /* Put back the old global and give the user the result */
   jseSetGlobalObject(jsecontext,oldglob);
   jseDestroyVariable(jsecontext,oldglob);
}

/*** Profiling ***/
#include <timer.h>
dword lastInt;
/*****************/

   jseVariable
browserInterpret(jseContext jsecontext,struct BrowserWindow *window,const jsecharptr source)
{
   jseVariable oldglob = jseGlobalObjectEx(jsecontext, jseCreateVar);
   jseVariable newglob = JSWindowObject(jsecontext,(optr)window);
   jseVariable ret = NULL;
   extern dword startInterpret;

   /*** Profiling ***/
   dword start = TimerGetCount();
   /*****************/
   
   /* swap in the new window as the global object effectively running
    * the script in that window. All window's prototypes point back to
    * the real global object so functions and objects will be found as
    * normal.
    */
   jseSetGlobalObject(jsecontext,newglob);
   jseDestroyVariable(jsecontext,newglob);

   /* we don't call main() as that is not traditional browser behavior */
   startInterpret = TimerGetCount();
   runawayCount = 0;
   if( !jseInterpret(jsecontext,source,NULL,NULL,jseNewNone,JSE_INTERPRET_DEFAULT|JSE_INTERPRET_INFREQUENT_CONT,
                     NULL,&ret) )
      assert( ret==NULL );

   /* Put back the old global and give the user the result */
   jseSetGlobalObject(jsecontext,oldglob);
   jseDestroyVariable(jsecontext,oldglob);

   /*** Profiling ***/
   lastInt = TimerGetCount() - start;
   /*****************/

   return ret;
}


   void
browserTermWindow(jseContext jsecontext,struct BrowserWindow *window)
{
   jsechar buffer[64];
   
   /* Get rid of the given window member. In old versions, pre-se420,
    * we got rid of the self-referencing members of the window because
    * they could confuse our cyclic loop checking. Since we've moved
    * to garbage collection, that is no longer necessary.
    */
   sprintf_jsechar((jsecharptr)buffer,BROWSER_WINDOW_NAME,window);
   jseDeleteMember(jsecontext,globalObject,buffer);

   /* clear this, too */
   browserFrameObj = 0;
}


   void
browserInitWindow(jseContext jsecontext,struct BrowserWindow *window)
{
   jseVariable place;
   jseLibFunc(windowUpdate);
@ifdef COMPILE_OPTION_AUTO_BROWSE
extern void ClearUnsupportedFeatures(void);
@endif


   ProfStart("browserInitWindow") ;
   assert( window !=NULL );

@ifdef COMPILE_OPTION_AUTO_BROWSE
   ClearUnsupportedFeatures();
@endif

   /* not good, but we need to have some anchor for preloading images */
   browserFrameObj = (optr)window;

   place = JSWindowObject(jsecontext,(optr)window);
   assert( place!=NULL );
   jseSetAttributes(jsecontext,place,jseDontEnum|jseDontDelete);

   /*
    * Only initialize the bare minimum we need for surviving up to
    * the first browserUpdate() call for this object. This allows us
    * to perform all initialization under a temporary call, making sure
    * that temporary variables get properly discarded.
    */
   
   /* store the magic cookie */
   set_its_object(place,window);

   /* add in the browserUpdate() routine. */
   jseMemberWrapperFunction(jsecontext,place,BROWSER_UPDATE_ROUTINE,
                            windowUpdate,0,0,jseDontEnum | jseDontDelete,
                            jseFunc_Secure,NULL);

   /* now set up the object in the browser */
   browserUpdate(jsecontext, place);

   jseDestroyVariable(jsecontext,place);
}


   void NEAR_CALL
browserAddFrameNames(jseContext jsecontext, struct BrowserWindow *win)
{
   jseVariable parent, frame, pl;
   TCHAR buf[HTML_STATIC_BUF], *p;
   NameToken tok;
   MemHandle listBlock;
   optr list;
   word i, n, size;
   struct BrowserWindow **fP;

   /* find this window or create a blank template object for it */
   parent = browserWindowObject(jsecontext,win);
   listBlock = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
   if (listBlock) {
       MemLock(listBlock);
       list = ConstructOptr(listBlock, ChunkArrayCreate(listBlock, sizeof(optr), 0, 0));
       browserGetFrameList(jsecontext, win, &list);
       n = ChunkArrayGetCount(list);
       for (i = 0; i < n; i++) {
	   /* add frame name element to window */
	   fP = ChunkArrayElementToPtr(list, i, &size);
	   frame = browserWindowObject(jsecontext, *fP);
	   tok = browserGetNameOfWindow(jsecontext,*fP);
	   if(tok != NAME_POOL_NONE)
	   {
	       NamePoolCopy(namePool, buf, sizeof(buf), tok, &p);
	       pl = jseMemberEx(jsecontext, parent, G2D(p), jseTypeUndefined, jseCreateVar);
	       NamePoolDestroyIfDynamic(p);
	       NamePoolReleaseToken(namePool, tok);
	       jseAssign(jsecontext, pl, frame);
	       jseDestroyVariable(jsecontext, pl);
	   }
       }
       MemFree(listBlock);
   }
}


static jseLibFunc(windowUpdate)
{
   struct BrowserWindow *bw;
   jseVariable thisvar = jseGetCurrentThisVariable(jsecontext);

   
   bw = get_my_object(BrowserWindow);
   browserSetUpWindowObject(jsecontext,thisvar,bw);
}

#pragma argsused
jseVariable JSE_CFUNC FAR_CALL _export Window_get(
  jseContext jsecontext,jseVariable obj,jseString prop,jsebool callHint)
{
    jseVariable retVar = NULL;
    NameToken t = NAME_POOL_NONE;
    struct BrowserWindow *win;
    Boolean handledProp = TRUE;
    jseVarAttributes attrs;

    attrs = jseDontDelete;  /* all of these are first */    
    if (prop==defaultStatus_STRING) {
        win = get_its_object(obj,BrowserWindow);
	t = browserGetDefaultStatus(jsecontext, win);
    } else if (prop==status_STRING) {
        win = get_its_object(obj,BrowserWindow);
	t = browserGetStatus(jsecontext, win);
    } else {
	attrs = jseDontDelete|jseReadOnly;  /* then the read-only ones */
	if (prop==name_STRING) {
            win = get_its_object(obj,BrowserWindow);
	    t = browserGetNameOfWindow(jsecontext, win);
	} else {
	    handledProp = FALSE;
	}
    }
    if (handledProp) {
	retVar = jseCreateVariable(jsecontext, jseTypeString);
	jseSetAttributes(jsecontext, retVar, 0);
	putTokenString(jsecontext, retVar, t);
	jseSetAttributes(jsecontext, retVar, attrs);
    } else if (prop==self_STRING || prop==window_STRING) {
	/* set up some read-only self-referencing properties */
	retVar = jseCreateVariable(jsecontext, jseTypeObject);
	jseSetAttributes(jsecontext, retVar, jseReadOnly | jseDontDelete);
	jseAssign(jsecontext, retVar, obj);
    } else if (prop==top_STRING) {
	/* assign top to the 'top' window. Even if it isn't defined yet, we'll make
	 * a placeholder object for it to point to. The browser writer will make sure
	 * to do a browserInitWindow() on it before too long.
	 */
	retVar = jseCreateVariable(jsecontext, jseTypeObject);
	jseSetAttributes(jsecontext, retVar, jseReadOnly | jseDontDelete);
	jseAssign(jsecontext, retVar, browserWindowObject(jsecontext, browserGetTopWindow(jsecontext, get_its_object(obj, BrowserWindow))));
    } else if (prop==parent_STRING || prop==__parent___STRING) {
	/* ditto for parent */
	retVar = jseCreateVariable(jsecontext, jseTypeObject);
	jseSetAttributes(jsecontext, retVar, jseReadOnly | jseDontDelete);
	jseAssign(jsecontext, retVar, browserWindowObject(jsecontext, browserGetParentWindow(jsecontext, get_its_object(obj, BrowserWindow))));
    } else if (prop==opener_STRING) {
	struct BrowserWindow *opener;
	/* opener is the similar, except it can be NULL (i.e. this window) */
	opener = browserGetOpenerWindow(jsecontext, get_its_object(obj, BrowserWindow));
	if (opener) {
	    retVar = jseCreateVariable(jsecontext, jseTypeObject);
	    jseSetAttributes(jsecontext, retVar, jseReadOnly | jseDontDelete);
	    jseAssign(jsecontext, retVar, browserWindowObject(jsecontext, opener));
	} else {
	    retVar = jseCreateVariable(jsecontext, jseTypeNull);
	    jseSetAttributes(jsecontext, retVar, jseReadOnly | jseDontDelete);
	}
    } else {
	retVar = checkImageFormNames(jsecontext, prop, browserGetDocument(jsecontext, (get_its_object(obj, BrowserWindow))), obj);
    }

    return retVar;
}

jsebool JSE_CFUNC FAR_CALL _export Window_put(
  jseContext jsecontext,jseVariable obj,jseString prop,jseVariable to_put)
{
   const jsecharptr text;
   struct BrowserWindow *bw;
   jsebool handled = False;
      
   if(prop==defaultStatus_STRING)
   {
      bw = get_its_object(obj,BrowserWindow);
      text = jseGetString(jsecontext,to_put,NULL);
      browserSetDefaultStatus(jsecontext,bw,text);
      handled = True;
   }
   else if(prop==status_STRING)
   {
      bw = get_its_object(obj,BrowserWindow);
      text = jseGetString(jsecontext,to_put,NULL);
      browserSetStatus(jsecontext,bw,text);
      handled = True;
   } 
   else if(prop==name_STRING)
   {
      handled = True;
   }

   return handled;
}

struct jseObjectCallbacks WindowCallbacks = {
  Window_get,
  Window_put,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
};

   static jseVariable NEAR_CALL
browserCreateWindowObject(jseContext jsecontext, struct BrowserWindow *window)
{
   jsechar buffer[64];
   optr frame;
   jseVariable retVar;

   frame = @call (optr)window::MSG_URL_FRAME_FIND_REAL_FRAME();
   sprintf_jsechar(buffer, BROWSER_WINDOW_NAME, (optr)frame);
   retVar = jseGetMemberEx(jsecontext, globalObject, buffer, jseCreateVar);
   if (!retVar) {
       retVar = JSWindowObject(jsecontext, (optr)window);
       jseSetAttributes(jsecontext, retVar, jseDontEnum|jseDontDelete);
       browserSetUpWindowObject(jsecontext, retVar, window);
   }
   return retVar;
}

   static void NEAR_CALL
browserSetUpWindowObject(jseContext jsecontext,jseVariable where,
                                     struct BrowserWindow *window)
{
   jseVariable vvv;
   jseVariable tmp,tmp2;
   

   /* make sure if we are updating, we turn off the dynamic put so we
    * can just directly store members without wasting the time to tell
    * the browser to change to the state its already in for everything.
    */
   jseSetObjectCallbacks(jsecontext,where,NULL);

   /* store the magic cookie */
   set_its_object(where,window);

   /* add in the frames. Add also each frame under its name as well as
    * the number of frames as 'length'.
    */
   tmp2 = CreateNewObject(jsecontext, ARRAY_PROPERTY);
   set_its_object(tmp2, window);  /* magic cookie: containing window */
   AssignVarToProperty(jsecontext, where, frames_PROPERTY, tmp2, jseDontDelete | jseReadOnly);
   jseSetObjectCallbacks(jsecontext, tmp2, &FramesArrayCallbacks);
   /* don't use dynamic properties if member already exists */
   jseSetAttributes(jsecontext, tmp2, jseDynamicOnUndefined);
   jseDestroyVariable(jsecontext, tmp2);

   /* even though we have dynamic frame array, add frame names to window */
   browserAddFrameNames(jsecontext, window);

   /* add in the history, documents, and location */
   vvv = jseMemberEx(jsecontext,where,history_PROPERTY,jseTypeUndefined,jseCreateVar);
   jseSetAttributes(jsecontext,vvv,0);
   jseAssign(jsecontext,vvv,
             tmp = browserCreateHistoryObject(jsecontext,window));
   jseDestroyVariable(jsecontext,tmp);
   jseAssign(jsecontext,
             tmp = jseMemberEx(jsecontext,vvv,PARENT_PROPERTY,jseTypeUndefined,jseCreateVar),
             where);
   jseDestroyVariable(jsecontext,tmp);
   jseSetAttributes(jsecontext,vvv,jseReadOnly | jseDontDelete);
   jseDestroyVariable(jsecontext,vvv);

   vvv = jseMemberEx(jsecontext,where,document_PROPERTY,jseTypeUndefined,jseCreateVar);
   jseSetAttributes(jsecontext,vvv,0);
   jseAssign(jsecontext,vvv,
             tmp = browserCreateDocumentObject(jsecontext,browserGetDocument(jsecontext,window)));
   jseAssign(jsecontext,
             tmp2 = jseMemberEx(jsecontext,vvv,PARENT_PROPERTY,jseTypeUndefined,jseCreateVar),where);
   jseSetAttributes(jsecontext,vvv,jseReadOnly | jseDontDelete);
   /* create internal version for our searching */
   AssignVarToProperty(jsecontext,where,__document_PROPERTY,tmp,jseDontDelete | jseReadOnly);
   jseDestroyVariable(jsecontext,tmp);
   jseDestroyVariable(jsecontext,tmp2);

   jseDestroyVariable(jsecontext,vvv);
   
   /* Add in the location object */
   jseAssign(jsecontext,
             vvv = jseMemberEx(jsecontext,where,location_PROPERTY,jseTypeUndefined,jseCreateVar),
             tmp = browserCreateLocationObject(jsecontext,browserGetLocation(jsecontext,window)));
   AssignVarToProperty(jsecontext,vvv,PARENT_PROPERTY,where,0);
   jseSetAttributes(jsecontext,vvv,jseDontDelete);
   jseDestroyVariable(jsecontext,vvv);
   jseDestroyVariable(jsecontext,tmp);

   /* is it closed */
   AssignBooleanToProperty(jsecontext,where,closed_PROPERTY,
                           browserIsWindowClosed(jsecontext,window),jseReadOnly | jseDontDelete);

   
   AssignLongToProperty(jsecontext, where, innerHeight_PROPERTY, 400, jseDontDelete) ;
   AssignLongToProperty(jsecontext, where, innerWidth_PROPERTY, 620, jseDontDelete) ;

   /* define window.screen object with some static properties */
   vvv = jseMemberEx(jsecontext,where,screen_PROPERTY,jseTypeObject,jseCreateVar);
   AssignLongToProperty(jsecontext, vvv, availHeight_PROPERTY, 400, jseDontDelete) ;
   AssignLongToProperty(jsecontext, vvv, availWidth_PROPERTY, 620, jseDontDelete) ;
   AssignLongToProperty(jsecontext, vvv, height_PROPERTY, 480, jseDontDelete) ;
   AssignLongToProperty(jsecontext, vvv, width_PROPERTY, 640, jseDontDelete) ;
   jseSetAttributes(jsecontext,vvv,jseDontDelete);
   jseDestroyVariable(jsecontext,vvv);
   
   /* use fast callback system for dynamic properties */
   jseSetObjectCallbacks(jsecontext,where,&WindowCallbacks);
   /* don't use dynamic properties if member already exists */
   jseSetAttributes(jsecontext,where,jseDynamicOnUndefined);

   /* set the prototype to point back to the global so all of its members
    * end up in the scope chain.
    */
   AssignVarToProperty(jsecontext,where,PROTOTYPE_PROPERTY,
                       jseGlobalObject(jsecontext),jseDontDelete|jseDontEnum|jseReadOnly);
}


/* window routines */


static jseLibFunc(Windowopen)
{
   jseVariable v;
   struct BrowserWindow *bw, *win = 0, *topw;
   const jsecharptr url;
   const jsecharptr name;
   const jsecharptr features;
   jsebool replace = False, force = False;
   uint args;

   
   bw = get_my_object(BrowserWindow);

   url = UNISTR("");  name = NULL;  features = NULL;
   replace = False;

   args = jseFuncVarCount(jsecontext);
   if( 0 < args )
   {
      url = jseGetString(jsecontext,jseFuncVar(jsecontext,0),NULL);
      if ( 1 < args )
      {
         name = jseGetString(jsecontext,jseFuncVar(jsecontext,1),NULL);
         if ( 2 < args )
         {
            features = jseGetString(jsecontext,jseFuncVar(jsecontext,2),NULL);
            if ( 3 < args )
            {
               replace = jseGetLong(jsecontext,jseFuncVar(jsecontext,3));
            }
         }
      }
   }

   if (bw) {
       topw = browserGetTopWindow(jsecontext, bw);
       /* if name exists, open there instead */
       if (name) {
       if (LocalCmpStringsNoCaseSBCS(name, "_top", 0)==0) {
	   bw = topw;
	   force = True;
       } else {
	   /* search frame array */
	   jseVariable topV = JSWindowObject(jsecontext, (optr)topw), frameV;
	   frameV = jseGetMemberEx(jsecontext, topV, name, jseCreateVar);
	   if (frameV) {
	       bw = get_its_object(frameV, BrowserWindow);
	       jseDestroyVariable(jsecontext, frameV);
	       force = True;
	   }
       }
       }
       if (bw) win = browserOpenWindow(jsecontext,bw,url,name,features,replace,force);
   }
   if( win )
   {
      jseVariable place;


      place = browserWindowObject(jsecontext,win);
      if (place == NULL) {
	  place = browserCreateWindowObject(jsecontext, win);
      }
      assert( place!=NULL );

      v = jseCreateSiblingVariable(jsecontext,place,0);
   }
   else
   {
      jseVariable tmp1, tmp2;
      /* create dummy window object */
      v = jseCreateVariable(jsecontext,jseTypeObject);
      jseSetAttributes(jsecontext,v,jseDontEnum|jseDontDelete);
      set_its_object(v,0);  /* NULL magic cookie */
      /* attach methods */
      AssignVarToProperty(jsecontext,v,PROTOTYPE_PROPERTY,
			  jseGlobalObject(jsecontext),jseDontDelete|jseDontEnum|jseReadOnly);
      /* add dummy location object */
      jseAssign(jsecontext,
		tmp1 = jseMemberEx(jsecontext,v,location_PROPERTY,jseTypeUndefined,jseCreateVar),
		tmp2 = browserCreateLocationObject(jsecontext,0));
      jseDestroyVariable(jsecontext, tmp1);
      jseDestroyVariable(jsecontext, tmp2);
   }
   jseReturnVar(jsecontext,v,jseRetTempVar);
}


static jseLibFunc(Windowscroll)
{
   jseVariable x, y;
   struct BrowserWindow *bw;

   JSE_FUNC_VAR_NEED(x,jsecontext,0,JSE_VN_NUMBER);
   JSE_FUNC_VAR_NEED(y,jsecontext,1,JSE_VN_NUMBER);
   bw = get_my_object(BrowserWindow);

   if (bw) browserScrollWindow(jsecontext,bw,jseGetLong(jsecontext,x),
                       jseGetLong(jsecontext,y));
}


static jseLibFunc(Windowmoveto)
{
   jseVariable x, y;
   struct BrowserWindow *bw;

   JSE_FUNC_VAR_NEED(x,jsecontext,0,JSE_VN_NUMBER);
   JSE_FUNC_VAR_NEED(y,jsecontext,1,JSE_VN_NUMBER);
   bw = get_my_object(BrowserWindow);

   if (bw) browserMoveWindowAbs(jsecontext,bw,jseGetLong(jsecontext,x),
                       jseGetLong(jsecontext,y));
}


static jseLibFunc(Windowmoveby)
{
   jseVariable x, y;
   struct BrowserWindow *bw;

   JSE_FUNC_VAR_NEED(x,jsecontext,0,JSE_VN_NUMBER);
   JSE_FUNC_VAR_NEED(y,jsecontext,1,JSE_VN_NUMBER);
   bw = get_my_object(BrowserWindow);

   if (bw) browserMoveWindowRel(jsecontext,bw,jseGetLong(jsecontext,x),
                       jseGetLong(jsecontext,y));
}


static jseLibFunc(Windowalert)
{
   jseVariable msg;
   const jsecharptr txt;
   struct BrowserWindow *bw;

   JSE_FUNC_VAR_NEED(msg,jsecontext,0,JSE_VN_CONVERT(JSE_VN_ANY,JSE_VN_STRING));
   txt = jseGetString(jsecontext,msg,NULL);
   bw = get_my_object(BrowserWindow);

   if (bw && !parsingPass) browserDisplayAlertDialog(jsecontext,bw,txt);
}


static jseLibFunc(Windowconfirm)
{
   jseVariable msg, ret;
   const jsecharptr txt;
   struct BrowserWindow *bw;
   jsebool retval = FALSE;

   JSE_FUNC_VAR_NEED(msg,jsecontext,0,JSE_VN_STRING);
   txt = jseGetString(jsecontext,msg,NULL);
   bw = get_my_object(BrowserWindow);

   if (bw && !parsingPass) retval = browserDisplayQuestionDialog(jsecontext,bw,txt);
   ret = jseCreateVariable(jsecontext,jseTypeBoolean);
   jsePutBoolean(jsecontext,ret,retval);
   jseReturnVar(jsecontext,ret,jseRetTempVar);
}


static jseLibFunc(Windowblur)
{
  struct BrowserWindow *bw;

  bw = get_my_object(BrowserWindow);

  if (bw) browserBlurWindow(jsecontext,bw);
}


static jseLibFunc(Windowfocus)
{
  struct BrowserWindow *bw;

  bw = get_my_object(BrowserWindow);

  if (bw) browserGiveFocusToWindow(jsecontext,bw);
}


static jseLibFunc(Windowsettimeout)
{
   jseVariable code, tm;
   struct BrowserWindow *bw;
   struct BrowserTimeout * tout = 0;
   const jsecharptr txt;

   JSE_FUNC_VAR_NEED(code,jsecontext,0,JSE_VN_STRING);
   JSE_FUNC_VAR_NEED(tm,jsecontext,1,JSE_VN_CONVERT(JSE_VN_ANY, JSE_VN_NUMBER));
   txt = jseGetString(jsecontext,code,NULL);

   bw = get_my_object(BrowserWindow);

   if (bw) tout = browserSetTimeout(jsecontext,bw,txt,jseGetLong(jsecontext,tm));
   jseReturnLong(jsecontext,(ulong)tout);
}


static jseLibFunc(Windowcleartimeout)
{
   jseVariable tm;
   struct BrowserWindow *bw;

   /* there's a _very_ slim chance this could incorrectly return a valid tm */
   JSE_FUNC_VAR_NEED(tm,jsecontext,0,JSE_VN_CONVERT(JSE_VN_ANY, JSE_VN_NUMBER));
   bw = get_my_object(BrowserWindow);

   if (bw) browserClearTimeout(jsecontext,bw,(struct BrowserTimeout *)jseGetLong(jsecontext,tm));
}

static jseLibFunc(Windowsetinterval)
{
   jseVariable code, tm;
   struct BrowserWindow *bw;
   struct BrowserTimeout * tout = 0;
   const jsecharptr txt;

   JSE_FUNC_VAR_NEED(code,jsecontext,0,JSE_VN_STRING);
   JSE_FUNC_VAR_NEED(tm,jsecontext,1,JSE_VN_CONVERT(JSE_VN_ANY, JSE_VN_NUMBER));
   txt = jseGetString(jsecontext,code,NULL);

   bw = get_my_object(BrowserWindow);

   if (bw) tout = browserSetInterval(jsecontext,bw,txt,jseGetLong(jsecontext,tm));
   jseReturnLong(jsecontext,(ulong)tout);
}


static jseLibFunc(Windowclearinterval)
{
   jseVariable tm;
   struct BrowserWindow *bw;

   /* there's a _very_ slim chance this could incorrectly return a valid tm */
   JSE_FUNC_VAR_NEED(tm,jsecontext,0,JSE_VN_CONVERT(JSE_VN_ANY, JSE_VN_NUMBER));
   bw = get_my_object(BrowserWindow);

   if (bw) browserClearInterval(jsecontext,bw,(struct BrowserTimeout *)jseGetLong(jsecontext,tm));
}


static jseLibFunc(Windowclose)
{
   struct BrowserWindow *bw;

   bw = get_my_object(BrowserWindow);

   if (bw) browserCloseWindow(jsecontext,bw);
}

static jseLibFunc(Windowprompt)
{
    struct BrowserWindow *win;
    NameToken token ;
    const jsecharptr msg ;
    const jsecharptr def ;
    Boolean didCancel = TRUE;
    jseVariable v;
    uint args ;

    msg = NULL ;
    def = UNISTR("") ;

    win = get_my_object(BrowserWindow);

    /* Get the message and default data entry */
    args = jseFuncVarCount(jsecontext);
    msg = jseGetString(jsecontext,jseFuncVar(jsecontext,0),NULL);
    if ( 1 < args )      {
        def = jseGetString(jsecontext,jseFuncVar(jsecontext,1),NULL);
    }

    /* Do the real work while we wait here */
    if (win) token = browserWindowPrompt(
                jsecontext,
                win,
                msg,
                def,
                &didCancel) ;

    if (didCancel)  {
       /* If cancel was hit, return a null */
       v = jseCreateVariable(jsecontext,jseTypeNull);
    } else {
       /* If data entered, then return that as a string */
       v = jseCreateVariable(jsecontext, jseTypeString);
       putTokenString(jsecontext, v, token);
    }
    jseReturnVar(jsecontext,v,jseRetTempVar);
}


/* ---------------------------------------------------------------------- */
/* Frames array object
/* ---------------------------------------------------------------------- */

#pragma codeseg SEBROWSE_FRAME
#pragma option -dc-

#pragma argsused
jseVariable JSE_CFUNC FAR_CALL _export FramesArray_get(
  jseContext jsecontext,jseVariable obj,jseString prop,jsebool callHint)
{
    jseVariable retVar = NULL, tmp;
    jsecharptr propStr;
    JSE_POINTER_UINDEX len, i;
    Boolean isIndex = TRUE;
    ulong index;
    struct BrowserWindow *frameArray = get_its_object(obj, BrowserWindow);
    struct BrowserWindow *frameItem;

    if (prop == length_STRING) {
	retVar = jseCreateVariable(jsecontext, jseTypeNumber);
	jseSetAttributes(jsecontext, retVar, 0);
	jsePutLong(jsecontext, retVar, parsingPass ? 0 : browserGetFramesLength(jsecontext, frameArray));
	jseSetAttributes(jsecontext, retVar, jseDontDelete | jseReadOnly);
    } else if (prop == location_STRING) {
	jseVariable winV = browserWindowObject(jsecontext, frameArray);
	retVar = jseCreateVariable(jsecontext, jseTypeObject);
	jseSetAttributes(jsecontext, retVar, 0);
	jseAssign(jsecontext, retVar,
		  tmp = jseMemberEx(jsecontext, winV, location_PROPERTY, jseTypeUndefined, jseCreateVar));
	jseDestroyVariable(jsecontext, tmp);
	jseSetAttributes(jsecontext, retVar, jseDontDelete | jseReadOnly);
    } else if (!parsingPass) {
	propStr = jseGetInternalString(jsecontext, prop, &len);
	for (i = 0; i < len; i++) {
	    if (!isdigit_jsechar(propStr[i])) {
		isIndex = FALSE;
		break;
	    }
	}
	if (isIndex) {
	    /* numeric index */
	    index = atoi_jsechar(propStr);
	    frameItem = browserGetFrameItem(jsecontext, frameArray, index);
	    if (frameItem) {
		retVar = browserCreateWindowObject(jsecontext, frameItem);
		/* hybrid mirror tree: attach indexed item */
		jseAssign(jsecontext,
			  tmp = jseIndexMemberEx(jsecontext, obj, index, jseTypeUndefined, jseCreateVar),
			  retVar);
		jseDestroyVariable(jsecontext, tmp);
	    }
	} else {
	    /* named frame */
	    frameItem = browserGetFrameItemFromName(jsecontext, frameArray, propStr);
	    if (frameItem) {
		retVar = browserCreateWindowObject(jsecontext, frameItem);
		/* hybrid mirror tree: attach named item */
		jseAssign(jsecontext,
			  tmp = jseMemberEx(jsecontext, obj, propStr, jseTypeUndefined, jseCreateVar),
			  retVar);
		jseDestroyVariable(jsecontext, tmp);
	    }
	}
    }
    return retVar;
}

struct jseObjectCallbacks FramesArrayCallbacks = {
    FramesArray_get,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};

#pragma codeseg
#pragma option -dc


/* ---------------------------------------------------------------------- */
/* Location object and its dynamic put routine                            */
/* ---------------------------------------------------------------------- */

#pragma codeseg SEBROWSE_LOC
#pragma option -dc-

#pragma argsused
jseVariable JSE_CFUNC FAR_CALL _export LinksArray_get(
  jseContext jsecontext,jseVariable obj,jseString prop,jsebool callHint)
{
    jseVariable retVar = NULL, tmp;
    jsecharptr propStr;
    JSE_POINTER_UINDEX len, i;
    Boolean isIndex = TRUE;
    ulong index;
    struct BrowserLinksArray *links = get_its_object(obj, BrowserLinksArray);
    struct BrowserLocation *loc;

    if (prop == length_STRING) {
	retVar = jseCreateVariable(jsecontext, jseTypeNumber);
	jseSetAttributes(jsecontext, retVar, 0);
	jsePutLong(jsecontext, retVar, parsingPass ? 0 : browserGetLinksLength(jsecontext, links));
	jseSetAttributes(jsecontext, retVar, jseDontDelete | jseReadOnly);
    } else if (!parsingPass) {
	propStr = jseGetInternalString(jsecontext, prop, &len);
	for (i = 0; i < len; i++) {
	    if (!isdigit_jsechar(propStr[i])) {
		isIndex = FALSE;
		break;
	    }
	}
	if (isIndex) {
	    index = atoi_jsechar(propStr);
	    loc = browserGetLinkItem(jsecontext, links, index);
	    if (loc) {
		/* create location object for index */
		retVar = browserCreateLocationObject(jsecontext, loc);
		/* links array is the parent */
		jseAssign(jsecontext,
			  tmp = jseMemberEx(jsecontext, retVar, PARENT_PROPERTY, jseTypeUndefined, jseCreateVar),
			  obj);
		jseDestroyVariable(jsecontext, tmp);
		/* hybrid mirror tree: attach indexed item */
		jseAssign(jsecontext,
			  tmp = jseIndexMemberEx(jsecontext, obj, index, jseTypeUndefined, jseCreateVar),
			  retVar);
		jseDestroyVariable(jsecontext, tmp);
	    }
	}
    }
    return retVar;
}

struct jseObjectCallbacks LinksArrayCallbacks = {
    LinksArray_get,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};


#pragma argsused
jseVariable JSE_CFUNC FAR_CALL _export Location_get(
  jseContext jsecontext,jseVariable obj,jseString prop,jsebool callHint)
{
    jseVariable retVar;
    NameToken *f = NAME_POOL_NONE;
    struct BrowserLocation *loc;
    struct BrowserURLContents url;
    Boolean handledProp = TRUE;

    if (prop==hash_STRING) {
	f = &url.hash;
    } else if (prop==host_STRING) {
	f = &url.host;
    } else if (prop==hostname_STRING) {
	f = &url.hostname;
    } else if (prop==port_STRING) {
	f = &url.port;
    } else if (prop==pathname_STRING) {
	f = &url.pathname;
    } else if (prop==protocol_STRING) {
	f = &url.protocol;
    } else if (prop==search_STRING) {
	f = &url.search;
    } else if (prop==href_STRING) {
	f = &url.href;
    } else if (prop==target_STRING) {
	f = &url.target;
    } else {
	handledProp = FALSE;
    }
    if (handledProp) {
        loc = get_its_object(obj,BrowserLocation);
	if (!loc) return NULL;  /* default handling */
        browserGetLocationValue(jsecontext, loc, &url);
	
        retVar = jseCreateVariable(jsecontext, jseTypeString);
	jseSetAttributes(jsecontext, retVar, 0);
	NamePoolUseToken(namePool, *f);  /* so we can release all later */
	putTokenString(jsecontext, retVar, *f);
	jseSetAttributes(jsecontext, retVar, jseDontDelete);
        
        /* release returned tokens (putTokenString releases t) */
        if(url.hash) NamePoolReleaseToken(namePool, url.hash);
        if(url.host) NamePoolReleaseToken(namePool, url.host);
        if(url.hostname) NamePoolReleaseToken(namePool, url.hostname);
        if(url.port) NamePoolReleaseToken(namePool, url.port);
        if(url.pathname) NamePoolReleaseToken(namePool, url.pathname);
        if(url.protocol) NamePoolReleaseToken(namePool, url.protocol);
        if(url.search) NamePoolReleaseToken(namePool, url.search);
        if(url.href) NamePoolReleaseToken(namePool, url.href);
        if(url.target) NamePoolReleaseToken(namePool, url.target);
    } else {
        retVar = NULL;	/* Real member will be gotten */
    }
    return retVar;
}

jsebool JSE_CFUNC FAR_CALL _export Location_put(
  jseContext jsecontext,jseVariable obj,jseString prop,jseVariable to_put)
{
   const jsecharptr host;
   const jsecharptr text;
   jsecharptr c;
   struct BrowserLocation *bl;
   struct BrowserURLContents url;
   Boolean handled = FALSE;
   NameToken t,*f = NULL,t2,*f2 = NULL;
   
   bl = get_its_object(obj,BrowserLocation);
   if (!bl) return NULL;  /* default handling */

   if(prop==hash_STRING)
   {
      f = &url.hash;
      t = getTokenString(jsecontext,to_put,NULL);
      handled = TRUE;
   }
   else if(prop==host_STRING)
   {
      f = &url.hostname;
      f2 = &url.port;
      
      host = jseGetString(jsecontext,to_put,NULL);
      c = strchr_jsechar(host,':');
      if( c )
      {
         t2 = NamePoolTokenizeDOS(namePool, c+1, FALSE);
      } else {
         c = host+strlen_jsechar(host);
         t2 = NAME_POOL_NONE;
      }
      t = NamePoolTokenizeLenDOS(namePool, host, (c-host), FALSE);
      handled = TRUE;
   }
   else if(prop==hostname_STRING)
   {
      f = &url.hash;
      t = getTokenString(jsecontext,to_put,NULL);
      handled = TRUE;
   }
   else if(prop==port_STRING)
   {
      f = &url.port;
      t = getTokenString(jsecontext,to_put,NULL);
      handled = TRUE;
   }
   else if(prop==pathname_STRING)
   {
      f = &url.pathname;
      t = getTokenString(jsecontext,to_put,NULL);
      handled = TRUE;
   }
   else if(prop==protocol_STRING)
   {
      f = &url.protocol;
      t = getTokenString(jsecontext,to_put,NULL);
      handled = TRUE;
   }
   else if(prop==search_STRING)
   {
      f = &url.search;
      t = getTokenString(jsecontext,to_put,NULL);
      handled = TRUE;
   }
   else if(prop==href_STRING)
   {
      text = jseGetString(jsecontext,to_put,NULL);
      browserSetLocationURL(jsecontext, bl, text, 0, False);
      handled = TRUE;
   }
   else if(prop==target_STRING)
   {
      f = &url.target;
      t = getTokenString(jsecontext,to_put,NULL);
      handled = TRUE;
   } 

   if(handled && f)
   {
      browserGetLocationValue(jsecontext,bl,&url);

      if(*f) NamePoolReleaseToken(namePool, *f);
      *f = t;
      if(f2)
      {
        if(*f2) NamePoolReleaseToken(namePool, *f2);
        *f2 = t2;
      }
      
      browserSetLocationValue(jsecontext,bl,&url);

      if(url.protocol) NamePoolReleaseToken(namePool, url.protocol);
      if(url.hostname) NamePoolReleaseToken(namePool, url.hostname);
      if(url.port) NamePoolReleaseToken(namePool, url.port);
      if(url.pathname) NamePoolReleaseToken(namePool, url.pathname);
      if(url.search) NamePoolReleaseToken(namePool, url.search);
      if(url.hash) NamePoolReleaseToken(namePool, url.hash);
      if(url.target) NamePoolReleaseToken(namePool, url.target);
      if(url.host) NamePoolReleaseToken(namePool, url.host);
      if(url.href) NamePoolReleaseToken(namePool, url.href);
   }

   return handled;
}

#pragma argsused
DEFAULT_VALUE_PROC(Location, BrowserLocation, 
                   browserGetURL(jsecontext,cookie,NULL))

jseVariable JSE_CFUNC FAR_CALL _export Location_operator(jseContext jsecontext,jseVariable obj,jseString op,jseVariable operand)
{
    struct BrowserLocation *cookie;
    const jsecharptr value;
    jseVariable isVar, tmp, retVar = NULL;

    if(op==equalOp_STRING)
    {
	cookie = get_its_object(obj,BrowserLocation);
	/* only for location, link must use sub-properties */
	if ((OptrToChunk(cookie) & 0x8000) == 0) {
	    isVar = jseGetMemberEx(jsecontext,obj,"__isVar__",jseCreateVar);
	    if (!isVar) {
		value = jseGetString(jsecontext,operand,NULL);
		if (strcmp_jsechar(value, "undefined")==0) {
		    /* set flag so we no longer try to use this as location object */
		    tmp = jseMemberEx(jsecontext,obj,"__isVar__",jseTypeUndefined,jseCreateVar);
		    jseDestroyVariable(jsecontext, tmp);
		} else {
		    /* go ahead and set URL */
		    browserSetLocationURL(jsecontext, cookie, value, 0, False);
		}
		retVar = jseCreateVariable(jsecontext, jseTypeString);
		jseSetAttributes(jsecontext,retVar,0);
		jseAssign(jsecontext,retVar,operand);
		jseSetAttributes(jsecontext,retVar,jseDontDelete);
		jseDestroyVariable(jsecontext,isVar);
	    }
	    return retVar;
	}
    }
    return NULL;
}

struct jseObjectCallbacks LocationCallbacks = {
  Location_get,
  Location_put,
  NULL,
  NULL,
  NULL,
  Location_defaultValue,
  Location_operator
};

   static jseVariable NEAR_CALL
browserCreateLocationObject(jseContext jsecontext,struct BrowserLocation *loc)
{
   jseVariable where;

   
   where = jseCreateVariable(jsecontext,jseTypeObject);
   browserSetUpLocationObject(jsecontext,where,loc);
   return where;
}

   static void NEAR_CALL
browserSetUpLocationObject(jseContext jsecontext,jseVariable where,struct BrowserLocation *loc)
{
   jseVariable tmp, proto;

   
   /* make sure if we are updating, we turn off the dynamic put so we
    * can just directly store members without wasting the time to tell
    * the browser to change to the state its already in for everything.
    */
   jseSetObjectCallbacks(jsecontext,where,NULL);

   /* store the magic cookie */
   set_its_object(where,loc);
  

   /* use fast callback system for dynamic properties */
   jseSetObjectCallbacks(jsecontext,where,&LocationCallbacks);
   /* don't use dynamic properties if member already exists */
   jseSetAttributes(jsecontext,where,jseDynamicOnUndefined);

   tmp = jseMemberEx(jsecontext,globalObject,location_PROPERTY,jseTypeObject,jseCreateVar);
   proto = jseMemberEx(jsecontext,tmp,PROTOTYPE_PROPERTY,jseTypeObject,jseCreateVar);
   AssignVarToProperty(jsecontext,where,PROTOTYPE_PROPERTY,proto,jseDontDelete|jseDontEnum|jseReadOnly);
   jseDestroyVariable(jsecontext,tmp);
   jseDestroyVariable(jsecontext,proto);
}


/* location routines */


static jseLibFunc(Locationreload)
{
   jseVariable thisvar;
   struct BrowserLocation *bl;
   jsebool reload;

   thisvar = jseGetCurrentThisVariable(jsecontext);
   bl = get_my_object(BrowserLocation);

   reload = False;
   if( jseFuncVarCount(jsecontext)==1 )
   {
      reload = jseGetLong(jsecontext,jseFuncVar(jsecontext,0));
   }

   if (bl) browserReloadLocation(jsecontext,bl,reload,thisvar);
}


static jseLibFunc(Locationreplace)
{
   jseVariable url;
   struct BrowserLocation *bl;
   const jsecharptr txt;

   bl = get_my_object(BrowserLocation);

   JSE_FUNC_VAR_NEED(url,jsecontext,0,JSE_VN_STRING);
   txt = jseGetString(jsecontext,url,NULL);

   if (bl) browserSetLocationURL(jsecontext,bl,txt,0,True);
}


/* ---------------------------------------------------------------------- */
/* History object and its dynamic put routine                             */
/* ---------------------------------------------------------------------- */

#pragma codeseg SEBROWSE_DOCUMENT
#pragma option -dc-

   static jseVariable NEAR_CALL
browserCreateHistoryObject(jseContext jsecontext,struct BrowserWindow *win)
{
   jseVariable where;

   
   where = jseCreateVariable(jsecontext,jseTypeObject);
   browserSetUpHistoryObject(jsecontext,where,win);
   return where;
}


   static void NEAR_CALL
browserSetUpHistoryObject(jseContext jsecontext,
                                      jseVariable where,
                                      struct BrowserWindow *win)
{
   jseVariable v, proto, tmp;
   ulong len,x;
   
   /* store the magic cookie */
   set_its_object(where,win);

   tmp = jseMemberEx(jsecontext,globalObject,history_PROPERTY,jseTypeObject,jseCreateVar);
   proto = jseMemberEx(jsecontext,tmp,PROTOTYPE_PROPERTY,jseTypeObject,jseCreateVar);
   AssignVarToProperty(jsecontext,where,PROTOTYPE_PROPERTY,proto,jseDontDelete|jseDontEnum|jseReadOnly);
   jseDestroyVariable(jsecontext,tmp);
   jseDestroyVariable(jsecontext,proto);


   /* add in length */
   len = browserGetHistoryLength(jsecontext,win);
   AssignLongToProperty(jsecontext,where,length_PROPERTY,len,jseDontDelete|jseReadOnly);

   for( x=0;x<len;x++ )
   {
      jseVariable tmp;

      v = jseCreateVariable(jsecontext,jseTypeString);
      putTokenString(jsecontext,v,browserGetHistoryItem(jsecontext,win,x));
      jseAssign(jsecontext,
                tmp = jseIndexMemberEx(jsecontext,where,x,jseTypeUndefined,jseCreateVar),
                v);
      jseSetAttributes(jsecontext,tmp,jseDontDelete|jseReadOnly);
      jseDestroyVariable(jsecontext,tmp);
      jseDestroyVariable(jsecontext,v);
   }

   /* history is completely read-only, so just let the normal put take
    * care of everything.
    */
}


/* history routines */


static jseLibFunc(Historyback)
{
  struct BrowserWindow *bw;

  bw = get_my_object(BrowserWindow);

  browserHistoryGo(jsecontext,bw,-1);
}


static jseLibFunc(Historyforward)
{
   struct BrowserWindow *bw;

   bw = get_my_object(BrowserWindow);

   browserHistoryGo(jsecontext,bw,1);
}


static jseLibFunc(Historygo)
{
   jseVariable offset;
   struct BrowserWindow *bw;

   JSE_FUNC_VAR_NEED(offset,jsecontext,0,JSE_VN_NUMBER);
   bw = get_my_object(BrowserWindow);

   browserHistoryGo(jsecontext,bw,jseGetLong(jsecontext,offset));
}


/* ---------------------------------------------------------------------- */
/* Document object and its dynamic put routine                            */
/* ---------------------------------------------------------------------- */


   static jseVariable NEAR_CALL
browserCreateDocumentObject(jseContext jsecontext,struct BrowserDocument *doc)
{
   jseVariable where;

   
   where = jseCreateVariable(jsecontext,jseTypeObject);
   browserSetUpDocumentObject(jsecontext,where,doc);
   return where;
}

#pragma argsused
jseVariable JSE_CFUNC FAR_CALL _export Document_get(
  jseContext jsecontext,jseVariable obj,jseString prop,jsebool callHint)
{
    jseVariable retVar;
    NameToken t = NAME_POOL_NONE;
    struct BrowserDocument *doc;
    Boolean handledProp = TRUE;
    jseVarAttributes attrs;

    doc = get_its_object(obj,BrowserDocument);
    attrs = jseDontDelete;  /* all of these are first */
    if (prop==alinkColor_STRING) {
	t = browserGetDocumentColor(jsecontext, doc, AlinkColor);
    } else if (prop==linkColor_STRING) {
	t = browserGetDocumentColor(jsecontext, doc, LinkColor);
    } else if (prop==vlinkColor_STRING) {
	t = browserGetDocumentColor(jsecontext, doc, VlinkColor);
    } else if (prop==bgColor_STRING) {
	t = browserGetDocumentColor(jsecontext, doc, BgColor);
    } else if (prop==fgColor_STRING) {
	t = browserGetDocumentColor(jsecontext, doc, FgColor);
    } else if (prop==cookie_STRING) {
	t = browserGetCookie(jsecontext, doc);
    } else if (prop==domain_STRING) {
	struct BrowserURLContents domainURL;
	browserGetLocationValue(jsecontext, browserGetDocumentLocation(jsecontext, doc), &domainURL);
	t = domainURL.host;
        /* release returned tokens (except host) */
        if(domainURL.hash) NamePoolReleaseToken(namePool, domainURL.hash);
        if(domainURL.hostname) NamePoolReleaseToken(namePool, domainURL.hostname);
        if(domainURL.port) NamePoolReleaseToken(namePool, domainURL.port);
        if(domainURL.pathname) NamePoolReleaseToken(namePool, domainURL.pathname);
        if(domainURL.protocol) NamePoolReleaseToken(namePool, domainURL.protocol);
        if(domainURL.search) NamePoolReleaseToken(namePool, domainURL.search);
        if(domainURL.href) NamePoolReleaseToken(namePool, domainURL.href);
        if(domainURL.target) NamePoolReleaseToken(namePool, domainURL.target);
    } else {
	attrs = jseDontDelete|jseReadOnly;  /* then the read-only ones */
	if (prop==URL_STRING) {
            t = browserGetURL(jsecontext, browserGetDocumentLocation(jsecontext, doc), NULL);
	} else if (prop==referrer_STRING) {
	    t = browserGetReferrer(jsecontext, doc);
	} else if (prop==title_STRING) {
	    t = browserGetTitle(jsecontext, doc);
	} else if (prop==lastModified_STRING) {
	    t = browserGetLastModified(jsecontext, doc);
	} else {
	    handledProp = FALSE;
	}
    }
    if (handledProp) {
	retVar = jseCreateVariable(jsecontext, jseTypeString);
	jseSetAttributes(jsecontext, retVar, 0);
	putTokenString(jsecontext, retVar, t);
	jseSetAttributes(jsecontext, retVar, attrs);
    } else {
	retVar = checkImageFormNames(jsecontext, prop, doc, obj);
    }

    return retVar;
}

jsebool JSE_CFUNC FAR_CALL _export Document_put(
  jseContext jsecontext,jseVariable obj,jseString prop,jseVariable to_put)
{
   struct BrowserDocument *bd;
   enum DocumentColors color = -1;
   const jsecharptr text;
   Boolean handled = FALSE;

   if (prop==cookie_STRING)
   {
      bd = get_its_object(obj,BrowserDocument);
      text = jseGetString(jsecontext,to_put,NULL);
      browserSetCookie(jsecontext,bd,text);
      handled = TRUE;
   }
   else if(prop==alinkColor_STRING) color = AlinkColor;
   else if(prop==linkColor_STRING) color = LinkColor;
   else if(prop==vlinkColor_STRING) color = VlinkColor;
   else if(prop==bgColor_STRING) color = BgColor;
   else if(prop==fgColor_STRING) color = FgColor;
   else if(prop==URL_STRING) {
       bd = get_its_object(obj,BrowserDocument);
       text = jseGetString(jsecontext,to_put,NULL);
       browserGotoURL(jsecontext,browserGetDocumentLocation(jsecontext,bd),text,True);
       handled = TRUE;
   }

   if( color!=-1 )
   {
      bd = get_its_object(obj,BrowserDocument);
      text = jseGetString(jsecontext,to_put,NULL);
      browserSetDocumentColor(jsecontext,bd,color,text);
      handled = TRUE;
   }
   
   return handled;
}

struct jseObjectCallbacks DocumentCallbacks = {
  Document_get,
  Document_put,
  NULL,
  NULL,
  NULL,
  NULL,
};

   static void NEAR_CALL
browserSetUpDocumentObject(jseContext jsecontext,
                                       jseVariable where,
                                       struct BrowserDocument *doc)
{
   jseVariable v, vvv, proto, tmp;
   struct BrowserLinksArray *links = browserGetLinksArray(jsecontext, doc);
   struct BrowserImagesArray *images = browserGetImagesArray(jsecontext, doc);
   struct BrowserImagesArray *forms = browserGetFormsArray(jsecontext, doc);

   
   /* make sure if we are updating, we turn off the dynamic put so we
    * can just directly store members without wasting the time to tell
    * the browser to change to the state its already in for everything.
    */
   jseSetObjectCallbacks(jsecontext,where,NULL);


   /* store the magic cookie */
   set_its_object(where,doc);

   /* add in all the properties */ 

   /* anchors: this is NYI in Netscape 3.0/IE 3.0 (I don't know about 4.0),
    *          so for now we do the same.
    *
    * applets: we do not yet support all of the Java connection stuff
    *          which would be needed to implement this. embeds is an
    *          alias for this (or vice versa) as is plugins.
    */
   v = CreateNewObject(jsecontext,ARRAY_PROPERTY);
   AssignVarToProperty(jsecontext,where,anchors_PROPERTY,v,jseDontDelete|jseReadOnly);
   jseDestroyVariable(jsecontext,v);

   /* ---------------------------------------------------------------------- */
   /* Create and assign a blank array to these three items. We have
    * to reset the attributes to 0 first so they are readable.
    */
   v = CreateNewObject(jsecontext,ARRAY_PROPERTY);

   AssignVarToProperty(jsecontext,where,applets_PROPERTY,v,jseDontDelete|jseReadOnly);
   AssignVarToProperty(jsecontext,where,embeds_PROPERTY,v,jseDontDelete|jseReadOnly);
   AssignVarToProperty(jsecontext,where,plugins_PROPERTY,v,jseDontDelete|jseReadOnly);

   jseDestroyVariable(jsecontext,v);
   /* ---------------------------------------------------------------------- */
      
   /* add in the location object */
   jseAssign(jsecontext,
             vvv = jseMemberEx(jsecontext,where,location_PROPERTY,jseTypeUndefined,jseCreateVar),
             tmp = browserCreateLocationObject(jsecontext,browserGetDocumentLocation(jsecontext,doc)));
   AssignVarToProperty(jsecontext,vvv,PARENT_PROPERTY,where,0);
   jseSetAttributes(jsecontext,vvv,jseDontDelete);
   jseDestroyVariable(jsecontext,tmp);
   jseDestroyVariable(jsecontext,vvv);

   /* create and link form array */
   v = CreateNewObject(jsecontext, ARRAY_PROPERTY);
   set_its_object(v, forms);
   AssignVarToProperty(jsecontext,where,forms_PROPERTY,v,jseDontDelete | jseReadOnly);
   /* create internal version for our searching */
   AssignVarToProperty(jsecontext,where,__forms_PROPERTY,v,jseDontDelete | jseReadOnly);   
   jseSetObjectCallbacks(jsecontext, v, &FormsArrayCallbacks);
   /* don't use dynamic properties if member already exists */
   jseSetAttributes(jsecontext,v,jseDynamicOnUndefined);
   jseDestroyVariable(jsecontext,v);

   /* create and link image array */
   v = CreateNewObject(jsecontext, ARRAY_PROPERTY);
   set_its_object(v, images);
   AssignVarToProperty(jsecontext,where,images_PROPERTY,v,jseDontDelete | jseReadOnly);
   /* create internal version for our searching */
   AssignVarToProperty(jsecontext,where,__images_PROPERTY,v,jseDontDelete | jseReadOnly);
   jseSetObjectCallbacks(jsecontext, v, &ImagesArrayCallbacks);
   /* don't use dynamic properties if member already exists */
   jseSetAttributes(jsecontext,v,jseDynamicOnUndefined);
   jseDestroyVariable(jsecontext,v);

   /* create and link links array */
   v = CreateNewObject(jsecontext, ARRAY_PROPERTY);
   set_its_object(v, links);
   AssignVarToProperty(jsecontext,where,links_PROPERTY,v,jseDontDelete | jseReadOnly);
   /* create internal version for our searching */
   AssignVarToProperty(jsecontext,where,__links_PROPERTY,v,jseDontDelete | jseReadOnly);
   jseSetObjectCallbacks(jsecontext, v, &LinksArrayCallbacks);
   /* don't use dynamic properties if member already exists */
   jseSetAttributes(jsecontext,v,jseDynamicOnUndefined);
   jseDestroyVariable(jsecontext,v);


   /* use fast callback system for dynamic properties */
   jseSetObjectCallbacks(jsecontext,where,&DocumentCallbacks);
   /* don't use dynamic properties if member already exists */
   jseSetAttributes(jsecontext,where,jseDynamicOnUndefined);

   /* find and copy the document prototype object to our prototype */
   tmp = jseMemberEx(jsecontext,globalObject,document_PROPERTY,jseTypeObject,jseCreateVar);
   proto = jseMemberEx(jsecontext,tmp,PROTOTYPE_PROPERTY,jseTypeObject,jseCreateVar);
   AssignVarToProperty(jsecontext,where,PROTOTYPE_PROPERTY,proto,jseDontDelete|jseDontEnum|jseReadOnly);
   jseDestroyVariable(jsecontext,tmp);
   jseDestroyVariable(jsecontext,proto);
}


/* document routines */


static jseLibFunc(Documentclose)
{
   struct BrowserDocument *bd;

   bd = get_my_object(BrowserDocument);

   browserCloseDocument(jsecontext,bd);
}


static jseLibFunc(Documentopen)
{
   jseVariable txt;
   struct BrowserDocument *bd;
   const jsecharptr mime;

   if (jseFuncVarCount(jsecontext)>=3) {
       /* document==window==URLFrame, so this is fine */
       Windowopen(jsecontext);
       return;
   }

   bd = get_my_object(BrowserDocument);
   mime = UNISTR("text/html");

   if( jseFuncVarCount(jsecontext)==1 )
   {
      JSE_FUNC_VAR_NEED(txt,jsecontext,0,JSE_VN_STRING);
      mime = jseGetString(jsecontext,txt,NULL);
   }

   browserOpenDocument(jsecontext,bd,mime);
}

   static void NEAR_CALL
DocumentWriter(jseContext jsecontext,jsebool appendNewline)
{
   jseVariable v;
   struct BrowserDocument *bd;
   ulong x;

   bd = get_my_object(BrowserDocument);

   for( x=0; x < jseFuncVarCount(jsecontext); x++ )
   {
      v = jseCreateConvertedVariable(jsecontext,
                                     jseFuncVar(jsecontext,x),
                                     jseToString);
      browserDocumentWrite(jsecontext,bd,jseGetString(jsecontext,v,NULL));
      jseDestroyVariable(jsecontext,v);
   }
   if ( appendNewline )
   {
      browserDocumentWrite(jsecontext,bd,UNISTR("\r\n"));
   }
}

static jseLibFunc(Documentwrite)
{
   DocumentWriter(jsecontext,False);
}


static jseLibFunc(Documentwriteln)
{
   DocumentWriter(jsecontext,True);
}


/* ---------------------------------------------------------------------- */
/* Form object and its dynamic put routine                                */
/* ---------------------------------------------------------------------- */

#pragma codeseg SEBROWSE_FORM
#pragma option -dc-

#pragma argsused
jseVariable JSE_CFUNC FAR_CALL _export FormsArray_get(
  jseContext jsecontext,jseVariable obj,jseString prop,jsebool callHint)
{
    jseVariable tmp, retVar = NULL;
    jsecharptr propStr;
    JSE_POINTER_UINDEX len, i;
    Boolean isIndex = TRUE;
    ulong index;
    struct BrowserFormsArray *forms = get_its_object(obj, BrowserFormsArray);
    struct BrowserForm *bf;

    if (prop == length_STRING) {
	retVar = jseCreateVariable(jsecontext, jseTypeNumber);
	jseSetAttributes(jsecontext, retVar, 0);
	jsePutLong(jsecontext, retVar, parsingPass ? 0 : browserGetFormsLength(jsecontext, forms));
	jseSetAttributes(jsecontext, retVar, jseDontDelete | jseReadOnly);
    } else if (!parsingPass) {
	propStr = jseGetInternalString(jsecontext, prop, &len);
	for (i = 0; i < len; i++) {
	    if (!isdigit_jsechar(propStr[i])) {
		isIndex = FALSE;
		break;
	    }
	}
	if (isIndex) {
	    /* numeric index */
	    index = atoi_jsechar(propStr);
	    bf = browserGetFormItem(jsecontext, forms, index);
	    if (bf) {
		retVar = browserCreateFormObject(jsecontext, bf);
		/* hybrid mirror tree: attach indexed item */
		jseAssign(jsecontext,
			  tmp = jseIndexMemberEx(jsecontext, obj, index, jseTypeUndefined, jseCreateVar),
			  retVar);
		jseDestroyVariable(jsecontext, tmp);
	    }
	} else {
	    /* named form */
	    bf = browserGetFormItemFromName(jsecontext, forms, propStr);
	    if (bf) {
		retVar = browserCreateFormObject(jsecontext, bf);
		/* hybrid mirror tree: attach named item */
		jseAssign(jsecontext,
			  tmp = jseMemberEx(jsecontext, obj, propStr, jseTypeUndefined, jseCreateVar),
			  retVar);
		jseDestroyVariable(jsecontext, tmp);
	    }
	}
    }
    return retVar;
}

struct jseObjectCallbacks FormsArrayCallbacks = {
    FormsArray_get,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};


#pragma argsused
jseVariable JSE_CFUNC FAR_CALL _export Form_get(
  jseContext jsecontext,jseVariable obj,jseString prop,jsebool callHint)
{
    jseVariable retVar;
    NameToken t = NAME_POOL_NONE;
    ulong l;
    struct BrowserForm *form;
    struct BrowserFormContents fo;
    Boolean tokenProp = FALSE, longProp = FALSE, boolProp = FALSE;
    jseVarAttributes attrs;

    form = get_its_object(obj,BrowserForm);
    browserGetForm(jsecontext, form, &fo);
    if (prop==action_STRING) {
	t = fo.action;
	tokenProp = TRUE;
	attrs = jseDontDelete;
    } else if (prop==encoding_STRING) {
	t = fo.encoding;
	tokenProp = TRUE;
	attrs = jseDontDelete;
    } else if (prop==method_STRING) {
	t = fo.method;
	tokenProp = TRUE;
	attrs = jseDontDelete;
    } else if (prop==target_STRING) {
	t = fo.target;
	tokenProp = TRUE;
	attrs = jseDontDelete;
    } else if (prop==name_STRING) {
	t = fo.name;
	tokenProp = TRUE;
	attrs = jseDontDelete|jseReadOnly;
    } else if (prop==length_STRING) {
	l = browserGetElementsLength(jsecontext, form);
	longProp = TRUE;
	attrs = jseDontDelete+jseReadOnly;
    }
    retVar = getProp(jsecontext, attrs, tokenProp, t, longProp, l, boolProp, FALSE);
    if (retVar == NULL) {
	retVar = checkElementNames(jsecontext, prop, form, obj);
    }
    if (retVar == NULL) {
	retVar = checkGetItemParent(jsecontext, prop, "__forms", (optr)(browserGetFormWindow(jsecontext, form)));
    }

    /* release returned tokens */
    if(fo.action) NamePoolReleaseToken(namePool, fo.action);
    if(fo.encoding) NamePoolReleaseToken(namePool, fo.encoding);
    if(fo.method) NamePoolReleaseToken(namePool, fo.method);
    if(fo.target) NamePoolReleaseToken(namePool, fo.target);
    if(fo.name) NamePoolReleaseToken(namePool, fo.name);

    return retVar;
}

jsebool JSE_CFUNC FAR_CALL _export Form_put(
  jseContext jsecontext,jseVariable obj,jseString prop,jseVariable to_put)
{
   struct BrowserForm *bf;
   struct BrowserFormContents fo;
   NameToken *part;
   Boolean handled = FALSE;

   if(prop==action_STRING) part = &(fo.action);
   else if(prop==encoding_STRING) part = &(fo.encoding);
   else if(prop==method_STRING) part = &(fo.method);
   else if(prop==target_STRING) part = &(fo.target);
   else part = NULL;
   if(prop==name_STRING) handled = TRUE;

   if( part )
   {
      bf = get_its_object(obj,BrowserForm);
      browserGetForm(jsecontext,bf,&fo);
      if(*part)                         // Release old value, if any
        NamePoolReleaseToken(namePool, *part);
      *part = getTokenString(jsecontext,to_put,NULL);
      browserSetForm(jsecontext,bf,&fo);
      handled = TRUE;

      if(fo.action) NamePoolReleaseToken(namePool, fo.action);
      if(fo.encoding) NamePoolReleaseToken(namePool, fo.encoding);
      if(fo.method) NamePoolReleaseToken(namePool, fo.method);
      if(fo.target) NamePoolReleaseToken(namePool, fo.target);
      if(fo.name) NamePoolReleaseToken(namePool, fo.name);
   }
   return handled;
}

struct jseObjectCallbacks FormCallbacks = {
  Form_get,
  Form_put,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
};

   static jseVariable NEAR_CALL
browserCreateFormObject(jseContext jsecontext,
                                           struct BrowserForm *form)
{
   jseVariable where;

   
   where = jseCreateVariable(jsecontext,jseTypeObject);
   browserSetUpFormObject(jsecontext,where,form);
   return where;
}


   static void NEAR_CALL
browserSetUpFormObject(jseContext jsecontext,
                                   jseVariable where,
                                   struct BrowserForm *form)
{
   jseVariable v, proto, tmp;

   
   /* make sure if we are updating, we turn off the dynamic put so we
    * can just directly store members without wasting the time to tell
    * the browser to change to the state its already in for everything.
    */
   jseSetObjectCallbacks(jsecontext,where,NULL);

   
   /* store the magic cookie */
   set_its_object(where,form);

   /* add the elements array */
   v = CreateNewObject(jsecontext, ARRAY_PROPERTY);
   set_its_object(v, form);  /* use form as magic cookie here also */
   AssignVarToProperty(jsecontext,where,elements_PROPERTY,v,jseDontDelete | jseReadOnly);
   /* create internal version for our searching */
   AssignVarToProperty(jsecontext,where,__elements_PROPERTY,v,jseDontDelete | jseReadOnly);
   jseSetObjectCallbacks(jsecontext, v, &ElementsArrayCallbacks);
   /* don't use dynamic properties if member already exists */
   jseSetAttributes(jsecontext,v,jseDynamicOnUndefined);
   jseDestroyVariable(jsecontext,v);

   /* use fast callback system for dynamic properties */
   jseSetObjectCallbacks(jsecontext,where,&FormCallbacks);
   /* don't use dynamic properties if member already exists */
   jseSetAttributes(jsecontext,where,jseDynamicOnUndefined);

   /* set up its prototype */
   tmp = jseMemberEx(jsecontext,globalObject,form_PROPERTY,jseTypeObject,jseCreateVar);
   proto = jseMemberEx(jsecontext,tmp,PROTOTYPE_PROPERTY,jseTypeObject,jseCreateVar);
   AssignVarToProperty(jsecontext,where,PROTOTYPE_PROPERTY,proto,jseDontDelete|jseDontEnum|jseReadOnly);
   jseDestroyVariable(jsecontext,tmp);
   jseDestroyVariable(jsecontext,proto);
}


/* form methods */


static jseLibFunc(Formreset)
{
   struct BrowserForm *bf;

   bf = get_my_object(BrowserForm);

   browserFormReset(jsecontext,bf);
}


static jseLibFunc(Formsubmit)
{
   struct BrowserForm *bf;

   bf = get_my_object(BrowserForm);

   browserFormSubmit(jsecontext,bf);
}


/* ---------------------------------------------------------------------- */
/* element object and its dynamic put routine                             */
/* ---------------------------------------------------------------------- */

#pragma codeseg SEBROWSE_ELEMENT
#pragma option -dc-

#pragma argsused
jseVariable JSE_CFUNC FAR_CALL _export ElementsArray_get(
  jseContext jsecontext,jseVariable obj,jseString prop,jsebool callHint)
{
    jseVariable tmp, retVar = NULL;
    jsecharptr propStr;
    JSE_POINTER_UINDEX len, i;
    Boolean isIndex = TRUE;
    ulong index;
    struct BrowserForm *form = get_its_object(obj, BrowserForm);
    struct BrowserElement *be;

    if (prop == length_STRING) {
	retVar = jseCreateVariable(jsecontext, jseTypeNumber);
	jseSetAttributes(jsecontext, retVar, 0);
	jsePutLong(jsecontext, retVar, parsingPass ? 0 : browserGetElementsLength(jsecontext, form));
	jseSetAttributes(jsecontext, retVar, jseDontDelete | jseReadOnly);
    } else if (!parsingPass) {
	propStr = jseGetInternalString(jsecontext, prop, &len);
	for (i = 0; i < len; i++) {
	    if (!isdigit_jsechar(propStr[i])) {
		isIndex = FALSE;
		break;
	    }
	}
	if (isIndex) {
	    /* numeric index */
	    index = atoi_jsechar(propStr);
	    be = browserGetElementItem(jsecontext, form, index);
	    if (be) {
		retVar = browserCreateElementObject(jsecontext, be);
		/* hybrid mirror tree: attach indexed item */
		jseAssign(jsecontext,
			  tmp = jseIndexMemberEx(jsecontext, obj, index, jseTypeUndefined, jseCreateVar),
			  retVar);
		jseDestroyVariable(jsecontext, tmp);
	    }
	} else {
	    /* named element */
	    be = browserGetElementItemFromName(jsecontext, form, propStr);
	    if (be) {
		retVar = browserCreateElementObjectByName(jsecontext, be);
		/* hybrid mirror tree: attach named item */
		jseAssign(jsecontext,
			  tmp = jseMemberEx(jsecontext, obj, propStr, jseTypeUndefined, jseCreateVar),
			  retVar);
		jseDestroyVariable(jsecontext, tmp);
	    }
	}
    }
    return retVar;
}

struct jseObjectCallbacks ElementsArrayCallbacks = {
    ElementsArray_get,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};

   static jseVariable NEAR_CALL
browserCreateElementObject(jseContext jsecontext,
                           struct BrowserElement *element)
{
   jseVariable where;

   where = jseCreateVariable(jsecontext,jseTypeObject);
   browserSetUpElementObject(jsecontext,where,element);
   return where;
}

/* 
   The difference between this routine and the previous one is that
   it will act differently if there is more than one form element
   with the same "name" attribute. In this case, an array of all the
   elements with the same name is created.
   
   Assumption: the passed element must be the first with the given name.
   This is compatible with browserGetElementItemFromName().
 */
   static jseVariable NEAR_CALL
browserCreateElementObjectByName(jseContext jsecontext,
                                    struct BrowserElement *element)
{
   jseVariable where, item;
   struct BrowserElement *next;
   word len;

   where = jseCreateVariable(jsecontext,jseTypeObject);

   /* See if we have at least one more element with the same name */
   if(browserNextArrayElement(jsecontext, element))
   {                                    // yes: make it a control array
     /* Attach all elements with the same name as array members */
     len = 0;
     for(next=element;
         next;
         next=browserNextArrayElement(jsecontext, next))
     {
       item = jseIndexMemberEx(jsecontext,where,len++,jseTypeObject,jseCreateVar);
       browserSetUpElementObject(jsecontext,item,next);
       jseDestroyVariable(jsecontext,item);
     }

     /* Finally, store number of elements in the array */
     AssignLongToProperty(jsecontext,where,length_PROPERTY,len,
                          jseDontDelete|jseReadOnly);    
   }
   else                                 // only one: make it a simple object
     browserSetUpElementObject(jsecontext,where,element);

   return where;
}


#pragma argsused
jseVariable JSE_CFUNC FAR_CALL _export Element_get(
  jseContext jsecontext,jseVariable obj,jseString prop,jsebool callHint)
{
    NameToken t = NAME_POOL_NONE;
    ulong l;
    Boolean b;
    struct BrowserElement *elem;
    struct BrowserElementContents el;
    Boolean tokenProp = FALSE, longProp = FALSE, boolProp = FALSE;
    jseVarAttributes attrs;
    jseVariable retVar;

    elem = get_its_object(obj,BrowserElement);
    browserGetElement(jsecontext, elem, &el);
    if (el.value_used && prop==value_STRING) {
	t = el.value;
	attrs = jseDontDelete;
	tokenProp = TRUE;
    } else if (el.dv_used && prop==defaultValue_STRING) {
	t = el.defaultValue;
	attrs = jseDontDelete|jseReadOnly;
	tokenProp = TRUE;
    } else if (prop==type_STRING) {
	t = el.type;
	attrs = jseDontDelete|jseReadOnly;
	tokenProp = TRUE;
    } else if (prop==name_STRING) {
	t = el.name;
	attrs = jseDontDelete|jseReadOnly;
	tokenProp = TRUE;
    } else if (prop==defaultChecked_STRING) {
	b = el.defaultChecked;
	attrs = jseDontDelete|jseReadOnly;  /* yes, read-only */
	boolProp = TRUE;
    } else if (prop==checked_STRING || prop==status_STRING) {
	b = el.checked;
	attrs = jseDontDelete;
	boolProp = TRUE;
    } else if (prop==selectedIndex_STRING) {
	l = el.selectedIndex;
	attrs = jseDontDelete;
	longProp = TRUE;
    } else if (el.options_used && prop==length_STRING) {
	l = el.num_options;
	attrs = jseDontDelete;
	longProp = TRUE;
    }
    retVar = getProp(jsecontext, attrs, tokenProp, t, longProp, l, boolProp, b);
    if (retVar == NULL) {
	retVar = checkGetElementParent(jsecontext, elem, prop, (optr)(browserGetElementWindow(jsecontext, elem)));
    }

    /* release returned tokens */
    if(el.name) NamePoolReleaseToken(namePool, el.name);
    if(el.type) NamePoolReleaseToken(namePool, el.type);
    if(el.value) NamePoolReleaseToken(namePool, el.value);
    if(el.defaultValue) NamePoolReleaseToken(namePool, el.defaultValue);

    return retVar;
}

jsebool JSE_CFUNC FAR_CALL _export Element_put(
  jseContext jsecontext,jseVariable obj,jseString prop,jseVariable to_put)
{
   struct BrowserElement *be;
   struct BrowserElementContents el;
   Boolean handled = FALSE;

   be = get_its_object(obj,BrowserElement);

   browserGetElement(jsecontext,be,&el);

   if( el.checked_used && (prop==checked_STRING || prop==status_STRING))
   {
       /* get boolean -- brianc 8/15/00 */
      el.checked = jseGetLong(jsecontext,to_put);
      browserSetElement(jsecontext,be,&el);
      handled = TRUE;
   }
   else if( el.si_used && prop==selectedIndex_STRING)
   {
      el.selectedIndex = jseGetLong(jsecontext,to_put);
      browserSetElement(jsecontext,be,&el);
      handled = TRUE;
   }
   else if( el.value_used && prop==value_STRING)
   {
       /* allow conversion -- brianc 8/15/00 */
      if(el.value) NamePoolReleaseToken(namePool, el.value);
      el.value = getTokenString(jsecontext,to_put,NULL);
      browserSetElement(jsecontext,be,&el);
      handled = TRUE;
   }
   if(prop==defaultValue_STRING || 
      prop==type_STRING ||
      prop==name_STRING) {
       handled = TRUE;
   }
   /* handle setting options array length */
   if (el.options_used && prop==length_STRING) {
       ulong newLen = jseGetLong(jsecontext,to_put);
       word o, curLen = browserGetOptionsLength(jsecontext,be);
       for (o = curLen; o > newLen; o--) {  /* must delete backwards */
	   /* get option from select list and index */
	   browserRemoveElementOption(jsecontext,be,o-1);
       }
       handled = TRUE;  /* eats too-long assignments */
   }

   if(el.name) NamePoolReleaseToken(namePool, el.name);
   if(el.type) NamePoolReleaseToken(namePool, el.type);
   if(el.value) NamePoolReleaseToken(namePool, el.value);
   if(el.defaultValue) NamePoolReleaseToken(namePool, el.defaultValue);

   return handled;
}

struct jseObjectCallbacks ElementCallbacks = {
  Element_get,
  Element_put,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
};

/* container_form==NULL = no update (already set) */
   static void NEAR_CALL
browserSetUpElementObject(jseContext jsecontext,
                                      jseVariable where,
                                      struct BrowserElement *elem)
{
   jseVariable v, proto, tmp;
   struct BrowserElementContents el;


   /* make sure if we are updating, we turn off the dynamic put so we
    * can just directly store members without wasting the time to tell
    * the browser to change to the state its already in for everything.
    */
   jseSetObjectCallbacks(jsecontext,where,NULL);
   
   /* store the magic cookie */
   set_its_object(where,elem);

   
   browserGetElement(jsecontext,elem,&el);

   /* dynamic options array handles dynamically created options */
   if( el.options_used )
   {
      v = CreateNewObject(jsecontext, ARRAY_PROPERTY);
      set_its_object(v, elem);
      AssignVarToProperty(jsecontext,where,options_PROPERTY,v,jseDontDelete | jseReadOnly);
      /* Set up dynamic put property for the array itself. */
      jseSetObjectCallbacks(jsecontext, v, &OptionsArrayCallbacks);
      jseDestroyVariable(jsecontext,v);
   }

   if(el.name) NamePoolReleaseToken(namePool, el.name);
   if(el.type) NamePoolReleaseToken(namePool, el.type);
   if(el.value) NamePoolReleaseToken(namePool, el.value);
   if(el.defaultValue) NamePoolReleaseToken(namePool, el.defaultValue);

   /* add in static parent property for proper scoping in event handlers */
   /* the most important use for this is onChange="submit()" */
   v = checkGetElementParent(jsecontext,elem,form_STRING,(optr)(browserGetElementWindow(jsecontext, elem)));
   AssignVarToProperty(jsecontext,where,PARENT_PROPERTY,v,jseDontEnum|jseDontDelete|jseReadOnly);
   jseDestroyVariable(jsecontext,v);

   /* use fast callback system for dynamic properties */
   jseSetObjectCallbacks(jsecontext,where,&ElementCallbacks);
   /* don't use dynamic properties if member already exists */
   jseSetAttributes(jsecontext,where,jseDynamicOnUndefined);

   /* set up prototype */
   tmp = jseMemberEx(jsecontext,globalObject,element_PROPERTY,jseTypeObject,jseCreateVar);
   proto = jseMemberEx(jsecontext,tmp,PROTOTYPE_PROPERTY,jseTypeObject,jseCreateVar);
   AssignVarToProperty(jsecontext,where,PROTOTYPE_PROPERTY,proto,jseDontDelete|jseDontEnum|jseReadOnly);
   jseDestroyVariable(jsecontext,tmp);
   jseDestroyVariable(jsecontext,proto);
}


/* element routines */


static jseLibFunc(Elementblur)
{
   struct BrowserElement *be;

   be = get_my_object(BrowserElement);

   browserElementBlur(jsecontext,be);
}


static jseLibFunc(Elementclick)
{
   struct BrowserElement *be;

   be = get_my_object(BrowserElement);

   browserElementClick(jsecontext,be);
}


static jseLibFunc(Elementfocus)
{
   struct BrowserElement *be;

   be = get_my_object(BrowserElement);

   browserElementFocus(jsecontext,be);
}


static jseLibFunc(Elementselect)
{
   struct BrowserElement *be;

   be = get_my_object(BrowserElement);

   browserElementSelect(jsecontext,be);
}


/* ---------------------------------------------------------------------- */
/* option object                                                          */
/* ---------------------------------------------------------------------- */


#pragma argsused
jseVariable JSE_CFUNC FAR_CALL _export OptionsArray_get(
  jseContext jsecontext,jseVariable obj,jseString prop,jsebool callHint)
{
    jseVariable tmp, retVar = NULL;
    jsecharptr propStr;
    JSE_POINTER_UINDEX len, i;
    Boolean isIndex = TRUE;
    ulong index;
    struct BrowserElement *elem = get_its_object(obj, BrowserElement);
    struct BrowserOptionContents opt;
    struct BrowserElementContents el;

    if (prop == length_STRING) {
	retVar = jseCreateVariable(jsecontext, jseTypeNumber);
	jseSetAttributes(jsecontext, retVar, 0);
	jsePutLong(jsecontext, retVar, parsingPass ? 0 : browserGetOptionsLength(jsecontext, elem));
	jseSetAttributes(jsecontext, retVar, jseDontDelete | jseReadOnly);
    } else if (prop == selectedIndex_STRING) {
	retVar = jseCreateVariable(jsecontext, jseTypeNumber);
	jseSetAttributes(jsecontext, retVar, 0);
        browserGetElement(jsecontext, elem, &el);
        if(el.name) NamePoolReleaseToken(namePool, el.name);
        if(el.type) NamePoolReleaseToken(namePool, el.type);
        if(el.value) NamePoolReleaseToken(namePool, el.value);
        if(el.defaultValue) NamePoolReleaseToken(namePool, el.defaultValue);
	jsePutLong(jsecontext, retVar, el.selectedIndex);
	jseSetAttributes(jsecontext, retVar, jseDontDelete | jseReadOnly);
    } else if (!parsingPass) {
	propStr = jseGetInternalString(jsecontext, prop, &len);
	for (i = 0; i < len; i++) {
	    if (!isdigit_jsechar(propStr[i])) {
		isIndex = FALSE;
		break;
	    }
	}
	if (isIndex) {
	    /* numeric index */
	    index = atoi_jsechar(propStr);
	    if (browserGetOptionItem(jsecontext, elem, index)) {
		browserGetElementOption(jsecontext, elem, index, &opt, FALSE);
		retVar = browserCreateElementOption(jsecontext, elem, &opt);
		/* hybrid mirror tree: attach indexed item */
		jseAssign(jsecontext,
			  tmp = jseIndexMemberEx(jsecontext, obj, index, jseTypeUndefined, jseCreateVar),
			  retVar);
		jseDestroyVariable(jsecontext, tmp);
	    } else {
		/* some things like to see 'null' returned for non-existant
		   option */
		retVar = jseCreateVariable(jsecontext, jseTypeNull);
	    }
	}
    }
    return retVar;
}

/* Add option to select list.  Options array length is a dynamic
 * property, so need to adjust it here.
 *
 * length = 0 -- delete all items
 * length = n -- delete all but n items
 * assign item -- append item
 * item = NULL -- remove specified item
 */
jsebool JSE_CFUNC FAR_CALL _export OptionsArray_put(
    jseContext jsecontext,jseVariable obj,jseString prop,jseVariable to_put)
{
    struct BrowserElement *be_opt_unattached, *be_opt_attached, *be_optArray;
    const jsecharptr propStr;
    struct BrowserOptionContents opt;
    word index;

    be_optArray = get_its_object(obj,BrowserElement);

    /* delete some range via setting new length */
    if (prop == length_STRING) {
	ulong newLen = jseGetLong(jsecontext,to_put);
	word o, curLen = browserGetOptionsLength(jsecontext,be_optArray);
	for (o = curLen; o > newLen; o--) {  /* must delete backwards */
	    /* get option from select list and index */
	    browserRemoveElementOption(jsecontext,be_optArray,o-1);
	}
	return TRUE;  /* eats too-long assignments */
    }

    /* handle indexed item: delete or add */
    propStr = jseGetInternalString(jsecontext, prop, 0);
    if (isdigit_jsechar(JSECHARPTR_GETC(propStr))) {
	index = atoi_jsechar(propStr);

	/* delete specified item */
	if (jseGetType(jsecontext,to_put) == jseTypeNull) {
	    browserRemoveElementOption(jsecontext,be_optArray,index);
	    return TRUE;
	}

	/* add item to end */
	be_opt_unattached = get_its_object(to_put,BrowserElement);

	/* only handle dynamically created option */
	if (!optionHeap ||
	    OptrToHandle((optr)be_opt_unattached) != OptrToHandle(optionHeap))
	    return FALSE;

	if (be_optArray && be_opt_unattached) {
	    /* fetch option from option heap (index not used) */
	    browserGetElementOption(jsecontext,be_opt_unattached,index,&opt,TRUE);
	    /* set new index */
	    opt.index = index;
	    /* create and add (or update) new option in browser text object */
	    be_opt_attached = browserAssignElementOption(jsecontext,be_optArray,&opt);
	    /* update new option (new magic cookie, index) */
	    browserSetUpElementOption(jsecontext,to_put,be_opt_attached,&opt);
	    return TRUE;
	}
    }
    return FALSE;
}

struct jseObjectCallbacks OptionsArrayCallbacks = {
    OptionsArray_get,
    OptionsArray_put,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};


   static void NEAR_CALL
browserFillOptionFields(jseContext jsecontext,
                                    jseVariable where,
				    struct BrowserOptionContents *opt)
{
   jseVariable tmp;

   /* still need for DYNAMIC case since we need to identify which option */
   jsePutLong(jsecontext,tmp = jseMakeMember(jsecontext,where,index_PROPERTY,jseTypeNumber),
             opt->index);
   jseDestroyVariable(jsecontext,tmp);
}


   static jseVariable NEAR_CALL
browserCreateElementOption(jseContext jsecontext,
                                              struct BrowserElement *element,
                                              struct BrowserOptionContents *opt)
{
   jseVariable where;

   
   where = jseCreateVariable(jsecontext,jseTypeObject);
   browserSetUpElementOption(jsecontext,where,element,opt);
   return where;
}


   static void NEAR_CALL
browserUpdateElement(jseContext jsecontext,
                                 jseVariable thisvar,
                                 struct BrowserElement *be)
{
   jseVariable tmp;
   struct BrowserOptionContents opt;

   opt.defaultSelected = jseGetLong(jsecontext,
         tmp = jseMemberEx(jsecontext,thisvar,defaultSelected_PROPERTY,jseTypeBoolean,jseCreateVar));
   jseDestroyVariable(jsecontext,tmp);

   opt.selected = jseGetLong(jsecontext,
         tmp = jseMemberEx(jsecontext,thisvar,selected_PROPERTY,jseTypeBoolean,jseCreateVar));
   jseDestroyVariable(jsecontext,tmp);

   opt.index = jseGetLong(jsecontext,
         tmp = jseMemberEx(jsecontext,thisvar,index_PROPERTY,jseTypeNumber,jseCreateVar));
   jseDestroyVariable(jsecontext,tmp);

   opt.text = getTokenString(jsecontext,
         tmp = jseMemberEx(jsecontext,thisvar,text_PROPERTY,jseTypeString,jseCreateVar),NULL);
   jseDestroyVariable(jsecontext,tmp);

   opt.value = getTokenString(jsecontext,
         tmp = jseMemberEx(jsecontext,thisvar,value_PROPERTY,jseTypeString,jseCreateVar),NULL);
   jseDestroyVariable(jsecontext,tmp);
 
   /* need to pass the element index */
   browserSetElementOption(jsecontext,be,&opt);

   if(opt.text) NamePoolReleaseToken(namePool, opt.text);
   if(opt.value) NamePoolReleaseToken(namePool, opt.value);
}


#pragma argsused
jseVariable JSE_CFUNC FAR_CALL _export Option_get(
  jseContext jsecontext,jseVariable obj,jseString prop,jsebool callHint)
{
    jseVariable tmp, retVar;
    NameToken t = NAME_POOL_NONE;
    ulong l;
    Boolean b;
    struct BrowserElement *be;
    struct BrowserOptionContents opt;
    ulong index;
    Boolean tokenProp = FALSE, longProp = FALSE, boolProp = FALSE;

    be = get_its_object(obj,BrowserElement);
    
    index = jseGetLong(jsecontext,tmp = jseMakeMember(jsecontext,obj,index_PROPERTY,jseTypeNumber));
    jseDestroyVariable(jsecontext,tmp);
    browserGetElementOption(jsecontext, be, index, &opt, FALSE);
    if (prop==text_STRING) {
	t = opt.text;
	tokenProp = TRUE;
    } else if (prop==value_STRING) {
	t = opt.value;
	tokenProp = TRUE;
    } else if (prop==defaultSelected_STRING) {
	b = opt.defaultSelected;
	boolProp = TRUE;
    } else if (prop==selected_STRING) {
	b = opt.selected;
	boolProp = TRUE;
    } else if (prop==index_STRING) {
	l = opt.index;
	longProp = TRUE;
    }
    retVar = getProp(jsecontext, 0, tokenProp, t, longProp, l, boolProp, b);

    /* release returned tokens */
    if(opt.text) NamePoolReleaseToken(namePool, opt.text);
    if(opt.value) NamePoolReleaseToken(namePool, opt.value);

    return retVar;
}

#pragma argsused
jsebool JSE_CFUNC FAR_CALL _export Option_put(
  jseContext jsecontext,jseVariable obj,jseString prop,jseVariable to_put)
{
   struct BrowserElement *be;
   Boolean handled = FALSE;

   be = get_its_object(obj,BrowserElement);

   if(prop==text_STRING ||
      prop==value_STRING) {
       handled = TRUE;
   }

   /* then if we are attached to an element, update it */
   if( be && handled )
   {
      /* TBD: this does no longer work with a dynamic put callback any more
         because the object hasn't yet been updated, so it will still read
         the old state through the dynamic get. */
      browserUpdateElement(jsecontext,obj,be);
   }

   return handled;
}

struct jseObjectCallbacks OptionCallbacks = {
  Option_get,
  Option_put,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
};

#pragma argsused
   static void NEAR_CALL
browserSetUpElementOption(jseContext jsecontext,
                                      jseVariable where,
                                      struct BrowserElement *elem,
                                      struct BrowserOptionContents *opt)
{
   /* make sure if we are updating, we turn off the dynamic put so we
    * can just directly store members without wasting the time to tell
    * the browser to change to the state its already in for everything.
    */
   jseSetObjectCallbacks(jsecontext,where,NULL);

   /* store the magic cookie */
   set_its_object(where,elem);
   
   /* update all the fields */
   browserFillOptionFields(jsecontext,where,opt);

   /* use fast callback system for dynamic properties */
   jseSetObjectCallbacks(jsecontext,where,&OptionCallbacks);
   /* don't use dynamic properties if member already exists */
   jseSetAttributes(jsecontext,where,jseDynamicOnUndefined);
}


/* Create and return (with NULL BrowserElement) a new option - 0 to 4 params */
static jseLibFunc(Optionconstruct)
{
   struct BrowserOptionContents opt, *optP;
   struct BrowserElement *be;
   int count, i, size;
   jseVariable text, val, ret = NULL;

   opt.defaultSelected = False;
   opt.index = 0;
   opt.selected = False;
   opt.text = NAME_POOL_NONE;
   opt.value = NAME_POOL_NONE;

   /* ensure our option heap exists */
   if (!optionHeap) {
       optionHeap = ConstructOptr(MemAllocLMem(LMEM_TYPE_GENERAL, 0), 0);
       MemLock(OptrToHandle(optionHeap));
       optionHeap = ConstructOptr(OptrToHandle(optionHeap),
				  ChunkArrayCreate(OptrToHandle(optionHeap),
						   sizeof(struct BrowserOptionContents),
						   0, 0));
       MemUnlock(OptrToHandle(optionHeap));
   }

   /* process arguments */
   count = jseFuncVarCount(jsecontext);
   if( count>0 )
   {
      JSE_FUNC_VAR_NEED(text,jsecontext,0,JSE_VN_CONVERT(JSE_VN_ANY, JSE_VN_STRING));
      opt.text = getTokenString(jsecontext,text,NULL);
   }
   if( count>1 )
   {
      JSE_FUNC_VAR_NEED(text,jsecontext,1,JSE_VN_CONVERT(JSE_VN_ANY, JSE_VN_STRING));
      opt.value = getTokenString(jsecontext,text,NULL);
   }
   if( count>2 )
   {
      JSE_FUNC_VAR_NEED(val,jsecontext,2,JSE_VN_CONVERT(JSE_VN_ANY, JSE_VN_BOOLEAN));
      opt.defaultSelected = jseGetLong(jsecontext,val);
   }
   if( count>3 )
   {
      JSE_FUNC_VAR_NEED(val,jsecontext,3,JSE_VN_CONVERT(JSE_VN_ANY, JSE_VN_BOOLEAN));
      opt.selected = jseGetLong(jsecontext,val);
   }

   /* create new option in option heap (with special magic cookie) */
   if (optionHeap) {
       MemLock(OptrToHandle(optionHeap));
       count = ChunkArrayGetCount(optionHeap);
       for (i = 0; i < count; i++) {
	   optP = ChunkArrayElementToPtr(optionHeap, i, &size);
	   if (optP->index == 0xffff) break;
       }
       if (i == count) {  /* need to add new one */
	   optP = ChunkArrayAppend(optionHeap, 0);
       }
       memcpy(optP, &opt, sizeof(struct BrowserOptionContents));
       be = (struct BrowserElement *)(ConstructOptr(OptrToHandle(optionHeap),
						    i));
       MemUnlock(OptrToHandle(optionHeap));
       ret = browserCreateElementOption(jsecontext, be, &opt);
   }

   jseReturnVar(jsecontext,ret,jseRetTempVar);
}


/* ---------------------------------------------------------------------- */
/* image object                                                           */
/* ---------------------------------------------------------------------- */

#pragma codeseg SEBROWSE_IMAGE
#pragma option -dc-

#pragma argsused
jseVariable JSE_CFUNC FAR_CALL _export ImagesArray_get(
  jseContext jsecontext,jseVariable obj,jseString prop,jsebool callHint)
{
    jseVariable tmp, retVar = NULL;
    jsecharptr propStr;
    JSE_POINTER_UINDEX len, i;
    Boolean isIndex = TRUE;
    ulong index;
    struct BrowserImagesArray *images = get_its_object(obj, BrowserImagesArray);
    struct BrowserImage *bi;

    if (prop == length_STRING) {
	retVar = jseCreateVariable(jsecontext, jseTypeNumber);
	jseSetAttributes(jsecontext, retVar, 0);
	jsePutLong(jsecontext, retVar, parsingPass ? 0 : browserGetImagesLength(jsecontext, images));
	jseSetAttributes(jsecontext, retVar, jseDontDelete | jseReadOnly);
    } else if (!parsingPass) {
	propStr = jseGetInternalString(jsecontext, prop, &len);
	for (i = 0; i < len; i++) {
	    if (!isdigit_jsechar(propStr[i])) {
		isIndex = FALSE;
		break;
	    }
	}
	if (isIndex) {
	    /* numeric index */
	    index = atoi_jsechar(propStr);
	    bi = browserGetImageItem(jsecontext, images, index);
	    if (bi) {
		retVar = browserCreateImageObject(jsecontext, bi);
		/* hybrid mirror tree: attach indexed item */
		jseAssign(jsecontext,
			  tmp = jseIndexMemberEx(jsecontext, obj, index, jseTypeUndefined, jseCreateVar),
			  retVar);
		jseDestroyVariable(jsecontext, tmp);
	    }
	} else {
	    /* named image */
	    bi = browserGetImageItemFromName(jsecontext, images, propStr);
	    if (bi) {
		retVar = browserCreateImageObject(jsecontext, bi);
		/* hybrid mirror tree: attach named item */
		jseAssign(jsecontext,
			  tmp = jseMemberEx(jsecontext, obj, propStr, jseTypeUndefined, jseCreateVar),
			  retVar);
		jseDestroyVariable(jsecontext, tmp);
	    }
	}
    }
    return retVar;
}

struct jseObjectCallbacks ImagesArrayCallbacks = {
    ImagesArray_get,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};


   static jseVariable NEAR_CALL
browserCreateImageObject(jseContext jsecontext,
                                            struct BrowserImage *image)
{
   jseVariable where;

   
   where = jseCreateVariable(jsecontext,jseTypeObject);
   browserSetUpImageObject(jsecontext,where,image);
   return where;
}


#pragma argsused
jseVariable JSE_CFUNC FAR_CALL _export Image_get(
  jseContext jsecontext,jseVariable obj,jseString prop,jsebool callHint)
{
    NameToken t = NAME_POOL_NONE;
    ulong l;
    Boolean b;
    struct BrowserImage *image;
    struct BrowserImageContents im;
    Boolean tokenProp = FALSE, longProp = FALSE, boolProp = FALSE;
    jseVarAttributes attrs;
    jseVariable retVar;

    image = get_its_object(obj,BrowserImage);
    browserGetImage(jsecontext, image, &im);
    attrs = jseDontDelete;  /* all of these are read-only */
    tokenProp = TRUE;  /* all of these are first */
    if (prop==lowsrc_STRING) {
	t = im.lowsrc;
    } else if (prop==name_STRING) {
	t = im.name;
    } else if (prop==src_STRING) {
	t = im.src;
    } else {
	tokenProp = FALSE;
	longProp = TRUE;  /* try these */
	if (prop==border_STRING) {
	    l = im.border;
	} else if (prop==height_STRING) {
	    l = im.height;
	} else if (prop==hspace_STRING) {
	    l = im.hspace;
	} else if (prop==vspace_STRING) {
	    l = im.vspace;
	} else if (prop==width_STRING) {
	    l = im.width;
	} else {
	    longProp = FALSE;
	    if (prop==complete_STRING) {
		b = im.complete;
		boolProp = TRUE;
	    }
	}
    }
    retVar = getProp(jsecontext, attrs, tokenProp, t, longProp, l, boolProp, b);
    if (retVar == NULL) {
	retVar = checkGetItemParent(jsecontext, prop, "__images", (optr)(browserGetImageWindow(jsecontext, image)));
    }

    /* release returned tokens */
    if(im.lowsrc) NamePoolReleaseToken(namePool, im.lowsrc);
    if(im.name) NamePoolReleaseToken(namePool, im.name);
    if(im.src) NamePoolReleaseToken(namePool, im.src);

    return retVar;
}

jsebool JSE_CFUNC FAR_CALL _export Image_put(
  jseContext jsecontext,jseVariable obj,jseString prop,jseVariable to_put)
{
   struct BrowserImage *bi;
   struct BrowserImageContents im;
   NameToken *part;
   uint *int_part;
   Boolean handled = FALSE;


   bi = get_its_object(obj,BrowserImage);
   browserGetImage(jsecontext,bi,&im);

   if(prop==lowsrc_STRING) part = &(im.lowsrc);
   else if(prop==name_STRING) part = &(im.name);
   else if(prop==src_STRING) part = &(im.src);
   else part = NULL;

   if( part )
   {
      if(*part)                         // Release old value, if any
        NamePoolReleaseToken(namePool, *part);
      *part = getTokenString(jsecontext,to_put,NULL);
      browserSetImage(jsecontext,bi,&im);
      handled = TRUE;
   }
   else
   {
      if(prop==border_STRING) int_part = &(im.border);
      else if(prop==height_STRING) int_part = &(im.height);
      else if(prop==hspace_STRING) int_part = &(im.hspace);
      else if(prop==vspace_STRING) int_part = &(im.vspace);
      else if(prop==width_STRING) int_part = &(im.width);
      else int_part = NULL;

      if( int_part )
      {
         *int_part = jseGetLong(jsecontext,to_put);
         browserSetImage(jsecontext,bi,&im);
	 handled = TRUE;
      }
      else if(prop==complete_STRING)
      {
         im.complete = jseGetLong(jsecontext,to_put);
         browserSetImage(jsecontext,bi,&im);
	 handled = TRUE;
      }
   }

   if(im.lowsrc) NamePoolReleaseToken(namePool, im.lowsrc);
   if(im.name) NamePoolReleaseToken(namePool, im.name);
   if(im.src) NamePoolReleaseToken(namePool, im.src);

   return handled;
}

struct jseObjectCallbacks ImageCallbacks = {
  Image_get,
  Image_put,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
};

/* Create and return a new Image */
static jseLibFunc(Imageconstruct)
{
   jseVariable where = NULL;
   struct BrowserImage *image;
   struct BrowserImageContents *im;
   

   if (!imageHeap) {
       imageHeap = ConstructOptr(MemAllocLMem(LMEM_TYPE_GENERAL, 0), 0);
       MemLock(OptrToHandle(imageHeap));
       imageHeap = ConstructOptr(OptrToHandle(imageHeap),
				 ChunkArrayCreate(OptrToHandle(imageHeap),
						  sizeof(struct BrowserImageContents),
						  0, 0));
       MemUnlock(OptrToHandle(imageHeap));
   }
   if (imageHeap) {
       MemLock(OptrToHandle(imageHeap));
       im = ChunkArrayAppend(imageHeap, 0);  /* zero-init */
       im->border = 0;
       im->lowsrc = NAME_POOL_NONE;
       if (jseFuncVarCount(jsecontext) > 1) {
	   im->height = (uint)jseGetLong(jsecontext,
					 jseFuncVarNeed(jsecontext,
							1, JSE_VN_NUMBER));
       }
       if (jseFuncVarCount(jsecontext)) {
	   im->width = (uint)jseGetLong(jsecontext,
					jseFuncVarNeed(jsecontext,
						       0, JSE_VN_NUMBER));
       }
       im->hspace = 0;
       im->vspace = 0;
       im->complete = TRUE;
       im->src = NAME_POOL_NONE;
       im->name = NAME_POOL_NONE;
       image = (struct BrowserImage *)(ConstructOptr(OptrToHandle(imageHeap),
					      ChunkArrayGetCount(imageHeap)-1));
       MemUnlock(OptrToHandle(imageHeap));

       where = jseCreateVariable(jsecontext,jseTypeObject);
       browserSetUpImageObject(jsecontext,where,image);
   }

   jseReturnVar(jsecontext,where,jseRetTempVar);
}


   static void NEAR_CALL
browserSetUpImageObject(jseContext jsecontext,
                                    jseVariable where,
                                    struct BrowserImage *image)
{
   /* make sure if we are updating, we turn off the dynamic put so we
    * can just directly store members without wasting the time to tell
    * the browser to change to the state its already in for everything.
    */
   jseSetObjectCallbacks(jsecontext,where,NULL);

   /* store the magic cookie */
   set_its_object(where,image);

   /* use fast callback system for dynamic properties */
   jseSetObjectCallbacks(jsecontext,where,&ImageCallbacks);
   /* don't use dynamic properties if member already exists */
   jseSetAttributes(jsecontext,where,jseDynamicOnUndefined);
}


/* ----------------------------------------------------------------------
 * What follows is some routines that the browser should call.
 * ---------------------------------------------------------------------- */

#pragma codeseg SEBROWSE_INITEXIT
#pragma option -dc-

static CONST_STRING(JAVA_ENABLED,"javaEnabledFlag");


/* This routine is here because many shut-down type activities may eventually
 * be needed. Its best to be prepared.
 *
 * I've added back the se410 code to get rid of the self-referencing members.
 * The cyclic checking should find them anyway, but it doesn't hurt anything,
 * and it's always better to do more checking rather than less. An analogous
 * change has been made to 'browserTermWindow()'.
 */
   void
browserCleanup(jseContext jsecontext)
{
   int i;

   /* remove the local imageHeap for dynamically created images */
   /* (this should really be per-window, but we don't need that
      since we reset the engine for each page */
   if (imageHeap) {
       MemFree(OptrToHandle(imageHeap));
       imageHeap = NullOptr;
   }
   if (optionHeap) {
       MemFree(OptrToHandle(optionHeap));
       optionHeap = NullOptr;
   }

   /* release internalized strings */
  for(i=0; i<sizeof(propList)/sizeof(propList[0]); i++)
    jseFreeInternalString(jsecontext,*propList[i].str);
}

/* Sets up some general information about your browser in the 'navigator'
 * object. For compatibility, it is suggested you make your 'appCodeName'
 * be "Mozilla".
 */
   void
browserGeneralInfo(jseContext jsecontext,const jsecharptr appCodeName,const jsecharptr appName,
                   const jsecharptr appVersion,const jsecharptr platform,
		   const jsecharptr language,jsebool javaEnabled)
{
   jseVariable nav, tmp;
   jsecharptr buf;

   nav = jseMakeMember(jsecontext,NULL,navigator_PROPERTY,jseTypeObject);

   AssignStringToProperty(jsecontext,nav,appCodeName_PROPERTY,appCodeName,0);
   AssignStringToProperty(jsecontext,nav,appName_PROPERTY,appName,0);
   AssignStringToProperty(jsecontext,nav,appVersion_PROPERTY,appVersion,0);
   AssignStringToProperty(jsecontext,nav,platform_PROPERTY,platform,0);
   AssignStringToProperty(jsecontext,nav,language_PROPERTY,language,0);
   jsePutBoolean(jsecontext,tmp = jseMakeMember(jsecontext,nav,JAVA_ENABLED,jseTypeBoolean),
              javaEnabled);
   jseDestroyVariable(jsecontext,tmp);

   buf = jseMustMalloc(jsecharptrdatum,sizeof(jsechar)*(strlen_jsechar(appCodeName)+strlen_jsechar(appVersion)+2));
   sprintf_jsechar(buf,UNISTR("%s/%s"),appCodeName,appVersion);
   AssignStringToProperty(jsecontext,nav,userAgent_PROPERTY,buf,0);
   jseMustFree(buf);

   jseDestroyVariable(jsecontext,nav);
}


/* This routine works just like browserAddMimeTypes(); you can call it as many
 * times as needed, and the entire list is added each time, overwriting any old
 * values.
 */
   void
browserAddPlugin(jseContext jsecontext,struct BrowserPlugin *plugin)
{
   jseVariable nav, list, newlist, pl, newpl, mime, value;
   ulong count = 0;
   struct BrowserMimeType *loop;

   nav = jseMakeMember(jsecontext,NULL,navigator_PROPERTY,jseTypeObject);
   list = jseGetMemberEx(jsecontext,nav,plugins_PROPERTY,jseCreateVar);
   if( list==NULL )
   {
      newlist = CreateNewObject(jsecontext,ARRAY_PROPERTY);
      list = jseMemberEx(jsecontext,list,plugins_PROPERTY,jseTypeUndefined,jseCreateVar);
      jseAssign(jsecontext,list,newlist);
      jseDestroyVariable(jsecontext,newlist);
   }

   while( plugin )
   {
      pl = jseGetMemberEx(jsecontext,list,plugin->name,jseCreateVar);
      if( pl==NULL )
      {
         /* add a new plugin both as 'name' and as the next array element. */
         newpl = CreateNewObject(jsecontext,ARRAY_PROPERTY);
         pl = jseMemberEx(jsecontext,list,plugin->name,jseTypeUndefined,jseCreateVar);
         jseAssign(jsecontext,pl,newpl);
         jseDestroyVariable(jsecontext,pl);
         pl = jseIndexMemberEx(jsecontext,list,jseGetArrayLength(jsecontext,list,NULL),
                             jseTypeUndefined,jseCreateVar);
         jseAssign(jsecontext,pl,newpl);
         jseDestroyVariable(jsecontext,newpl);
         jseDestroyVariable(jsecontext,pl);
      }

      jseSetArrayLength(jsecontext,pl,0,0);       /* erase all old mime-type information */

      AssignStringToProperty(jsecontext,pl,description_PROPERTY,plugin->description,jseReadOnly);
      AssignStringToProperty(jsecontext,pl,filename_PROPERTY,plugin->filename,jseReadOnly);
      AssignStringToProperty(jsecontext,pl,name_PROPERTY,plugin->name,jseReadOnly);

      count = 0;
      loop = plugin->types;
      while( loop )
      {
         mime = jseIndexMemberEx(jsecontext,pl,count++,jseTypeUndefined,jseCreateVar);

         value = browserCreateMimeObject(jsecontext,loop,pl);
         jseAssign(jsecontext,mime,value);
         jseDestroyVariable(jsecontext,value);
         jseDestroyVariable(jsecontext,mime);

         loop = loop->next;
      }

      jseDestroyVariable(jsecontext,pl);

      plugin = plugin->next;
   }

   jseDestroyVariable(jsecontext,nav);
   jseDestroyVariable(jsecontext,list);
}


   static jseVariable NEAR_CALL
browserCreateMimeObject(jseContext jsecontext,struct BrowserMimeType *type,jseVariable referer)
{
   jseVariable obj, tmp;

   obj = jseCreateVariable(jsecontext,jseTypeObject);

   AssignStringToProperty(jsecontext,obj,description_PROPERTY,type->description,jseReadOnly);

   AssignStringToProperty(jsecontext,obj,suffixes_PROPERTY,type->suffixes,jseReadOnly);

   AssignStringToProperty(jsecontext,obj,type_PROPERTY,type->type,jseReadOnly);

   tmp = jseMakeMember(jsecontext,obj,enabledPlugin_PROPERTY,jseTypeNull);
   if( referer ) jseAssign(jsecontext,tmp,referer);
   jseDestroyVariable(jsecontext,tmp);

   return obj;
}


/* This routine can be called any number of times. All types in the linked list
 * started by 'type' are added. If you call it again, the new types are added,
 * and any duplicates overwrite the original value.
 */
   void
browserAddMimeType(jseContext jsecontext,struct BrowserMimeType *type)
{
   jseVariable nav = jseMakeMember(jsecontext,NULL,navigator_PROPERTY,jseTypeObject);
   jseVariable list = jseGetMemberEx(jsecontext,nav,mimeTypes_PROPERTY,jseCreateVar);

  if( list==NULL )
    {
      jseVariable newlist = CreateNewObject(jsecontext,ARRAY_PROPERTY);
      list = jseMemberEx(jsecontext,list,mimeTypes_PROPERTY,jseTypeUndefined,jseCreateVar);
      jseAssign(jsecontext,list,newlist);
      jseDestroyVariable(jsecontext,newlist);
    }

  while( type )
    {
      jseVariable pl = jseGetMemberEx(jsecontext,list,type->type,jseCreateVar);
      jseVariable value = browserCreateMimeObject(jsecontext,type,NULL);

      if( pl==NULL )
        {
         pl = jseMemberEx(jsecontext,list,type->type,jseTypeUndefined,jseCreateVar);
          jseAssign(jsecontext,pl,value);
         jseDestroyVariable(jsecontext,pl);
         pl = jseIndexMemberEx(jsecontext,list,jseGetArrayLength(jsecontext,list,NULL),
                               jseTypeUndefined,jseCreateVar);
        }

      jseAssign(jsecontext,pl,value);
      jseDestroyVariable(jsecontext,value);

      jseDestroyVariable(jsecontext,pl);

      type = type->next;
    }

   jseDestroyVariable(jsecontext,list);
   jseDestroyVariable(jsecontext,nav);
}

/* ----------------------------------------------------------------------
 * The one function in 'navigator'
 * ---------------------------------------------------------------------- */


static jseLibFunc(Navigatorjava)
{
  jseVariable thisvar = jseGetCurrentThisVariable(jsecontext);
  jseVariable tmp;


  jseReturnVar(jsecontext,
               tmp = jseMemberEx(jsecontext,thisvar,JAVA_ENABLED,jseTypeBoolean,jseCreateVar),
               jseRetKeepLVar);
  jseDestroyVariable(jsecontext,tmp);
}


/* ---------------------------------------------------------------------- */
/* Set up all the generic prototypes                                      */
/* ---------------------------------------------------------------------- */

#pragma option -dc

static CONST_DATA(struct jseFunctionDescription) BrowserLibFunctionList[] =
{
   /* ----------------------------------------------------------------------
    * Add some browser-specific routines to the string object. Because
    * strings are constructed via new, it is correct to put these particular
    * routines in 'prototype', not '_prototype'
    * ---------------------------------------------------------------------- */

  JSE_LIBMETHOD(UNISTR("String.prototype.anchor"), Stringanchor,   1,    1,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("String.prototype.big"),    Stringbig,      0,    0,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("String.prototype.blink"),  Stringblink,    0,    0,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("String.prototype.bold"),   Stringbold,     0,    0,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("String.prototype.fixed"),  Stringfixed,    0,    0,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("String.prototype.fontcolor"), Stringfontcolor,1, 1,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("String.prototype.fontsize"), Stringfontsize,1,   1,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("String.prototype.italics"),Stringitalics,  0,    0,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("String.prototype.link"),   Stringlink,     1,    1,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("String.prototype.small"),  Stringsmall,    0,    0,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("String.prototype.strike"), Stringstrike,   0,    0,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("String.prototype.sub"),    Stringsub,      0,    0,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("String.prototype.sup"),    Stringsup,      0,    0,      jseDontEnum,    jseFunc_Secure ),


  /* ----------------------------------------------------------------------
   * The single method in navigator
   * ---------------------------------------------------------------------- */

  JSE_LIBMETHOD(UNISTR("navigator.javaEnabled"),   Navigatorjava,  0,    0,      jseDontEnum,    jseFunc_Secure ),


  /* ----------------------------------------------------------------------
   * Set up the window prototype object
   * ---------------------------------------------------------------------- */

  JSE_LIBMETHOD(UNISTR("_prototype.alert"),  Windowalert,    1,    1,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("_prototype.blur"),   Windowblur,     0,    0,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("_prototype.clearInterval"),Windowclearinterval,1,1,jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("_prototype.clearTimeout"),Windowcleartimeout,1,1,  jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("_prototype.close"),  Windowclose,    0,    0,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("_prototype.confirm"),Windowconfirm,  1,    1,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("_prototype.focus"),  Windowfocus,    0,    0,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("_prototype.open"),   Windowopen,     0,    4,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("_prototype.prompt"), Windowprompt,   1,    2,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("_prototype.scroll"), Windowscroll,   2,    2,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("_prototype.moveTo"),  Windowmoveto,    2,    2,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("_prototype.moveBy"),  Windowmoveby,    2,    2,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("_prototype.setInterval"),Windowsetinterval,2,2,    jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("_prototype.setTimeout"),Windowsettimeout,2,2,      jseDontEnum,    jseFunc_Secure ),


  /* ----------------------------------------------------------------------
   * The location object has a couple of methods we store in
   * 'location.prototype' for convenience
   * ---------------------------------------------------------------------- */

  JSE_LIBMETHOD(UNISTR("location._prototype.reload"), Locationreload,0,    1,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("location._prototype.replace"),  Locationreplace,    1,    1,      jseDontEnum,    jseFunc_Secure ),

  /* ----------------------------------------------------------------------
   * We do the same for the 'history' object
   * ---------------------------------------------------------------------- */

  JSE_LIBMETHOD(UNISTR("history._prototype.back"),  Historyback,    0,    0,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("history._prototype.forward"),Historyforward,0,    0,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("history._prototype.go"),    Historygo,      1,    1,      jseDontEnum,    jseFunc_Secure ),


  /* ----------------------------------------------------------------------
   * document properties
   * ---------------------------------------------------------------------- */

  JSE_LIBMETHOD(UNISTR("document._prototype.close"),Documentclose,  0,    0,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("document._prototype.open"), Documentopen,   0,    1,      jseDontEnum,    jseFunc_Secure ),
  /* clear() is deprecated, and we map it to open() just like IE does */
  JSE_LIBMETHOD(UNISTR("document._prototype.clear"),Documentopen,   0,    1,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("document._prototype.write"),Documentwrite,  0,   -1,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("document._prototype.writeln"),Documentwriteln,0, -1,      jseDontEnum,    jseFunc_Secure ),

  /* ----------------------------------------------------------------------
   * form properties
   * ---------------------------------------------------------------------- */

  JSE_LIBMETHOD(UNISTR("form._prototype.reset"), Formreset,      0,      0,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("form._prototype.submit"),Formsubmit,     0,      0,      jseDontEnum,    jseFunc_Secure ),

  /* ----------------------------------------------------------------------
   * Element properties
   * ---------------------------------------------------------------------- */

  JSE_LIBMETHOD(UNISTR("element._prototype.blur"),Elementblur,   0,      0,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("element._prototype.click"),Elementclick, 0,      0,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("element._prototype.focus"),Elementfocus, 0,      0,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("element._prototype.select"),Elementselect,0,     0,      jseDontEnum,    jseFunc_Secure ),

  /* ----------------------------------------------------------------------
   * Constructors
   * ---------------------------------------------------------------------- */
  JSE_LIBMETHOD(UNISTR("Option"),               Optionconstruct,0,      4,      jseDontEnum,    jseFunc_Secure ),
  JSE_LIBMETHOD(UNISTR("Image"),                Imageconstruct, 0,      2,      jseDontEnum,    jseFunc_Secure ),

  JSE_FUNC_END
};

   void
InitializeInternalLib_BrowserLib(jseContext jsecontext)
{
  word i;
  char *p;

  /* this now takes string vfptr in table -- brianc 8/22/00 */
  jseAddLibrary(jsecontext,NULL,BrowserLibFunctionList,NULL,NULL,NULL);

  /* internalize strings we need */
  for(i=0; i<sizeof(propList)/sizeof(propList[0]); i++)
  {
    p = MemLockFixedOrMovable(propList[i].prop);
#ifdef DO_DBCS
    (*propList[i].str) = jseInternalizeString(jsecontext,p,strlensbcs(p));
#else
    (*propList[i].str) = jseInternalizeString(jsecontext,p,strlen(p));
#endif
    MemUnlockFixedOrMovable(propList[i].prop);
  }
}

#pragma option -dc-

#endif
