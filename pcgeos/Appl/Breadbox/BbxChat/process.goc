
/**************************************************************
 *  ==CONFIDENTIAL INFORMATION==
 *  COPYRIGHT 1994-2000 BREADBOX COMPUTER COMPANY --
 *  ALL RIGHTS RESERVED  --
 *  THE FOLLOWING CONFIDENTIAL INFORMATION IS BEING DISCLOSED TO YOU UNDER A
 *  NON-DISCLOSURE AGREEMENT AND MAY NOT BE DISCLOSED OR FORWARDED BY THE
 *  RECIPIENT TO ANY OTHER PERSON OR ENTITY NOT COVERED BY THE SAME
 *  NON-DISCLOSURE AGREEMENT COVERING THE RECIPIENT. USE OF THE FOLLOWING
 *  CONFIDENTIAL INFORMATION IS RESTRICTED TO THE TERMS OF THE NON-DISCLOSURE
 *  AGREEMENT.
 **************************************************************/

/*-------------------------------------------------------------------------
 | Project:  Lysle's IRC Chat program
 | Module:   Main Process Class handling routines
 |           Copyright (c) 1998 Breadbox Computer Company
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/01/98  Created.
 |                   (LES = Lysle Shields)
 *-----------------------------------------------------------------------*/

@include "gpcchat.goh"
@include "externs.goh"
#include <iapp.h>
#include <sysstats.h>
#include <product.h>


/*********************************************************************
 *  All the globals declared as extern in .goh
 ********************************************************************
*/
word G_ircError = 0;
Socket G_sock = NullHandle ;
TimerHandle G_timer = NullHandle ;
word G_timerID = 0;

char G_currentChannel[80] = "" ;
char G_currentNick[NICK_LEN] = "" ;
char G_firstChannel[80] = "";
char G_prevChannel[80] = "";

Boolean logging = FALSE;
FileHandle LogFileHandle = NullHandle;
@ifdef DUMP_TO_FILE
FileHandle DumpFileHandle;
@endif

word G_numPrivMsgs = 0;
optr G_privMsgArray = NullHandle;
optr G_chanOpenArray = NullHandle;
word G_numChansOpen;
optr G_curDisplay = NullHandle;
optr G_curList = NullHandle;


Boolean G_ImAnOper = FALSE;
Boolean g_canSlash = FALSE;
word	g_personSelected = GIGS_NONE;
//Boolean g_onTV = FALSE;
word g_sysPointSize = 12;

Boolean G_startupPassword = FALSE;
Boolean g_pastMOTD = FALSE;
//Boolean g_isCUI = FALSE;

Boolean g_isOpenSystem = FALSE;

/*=========================================================================*
 *  METHODS FOR CLASS:  IRCProcessClass
 *=========================================================================*/

@classdecl IRCProcessClass, neverSaved ;

/* methods in miscpro file */
@extern method IRCProcessClass, MSG_IRC_CHANGE_NICKNAME;
@extern method IRCProcessClass, MSG_IRC_START_LOGGING;
@extern method IRCProcessClass, MSG_IRC_APPEND_LOGGING;
@extern method IRCProcessClass, MSG_IRC_STOP_LOGGING;
@extern method IRCProcessClass, MSG_APPEND_LOG_SELECTOR_ACTION;
@extern method IRCProcessClass, MSG_IRC_SEND_PRIV;
@extern method IRCProcessClass, MSG_IRC_CLOSE_PRIV;
@extern method IRCProcessClass, MSG_IRC_RECEIVE_PRIV;
@extern method IRCProcessClass, MSG_PROCESS_CREATE_UI_THREAD;

/*-------------------------------------------------------------------------
 | Routine:  IsValidNick
 *-------------------------------------------------------------------------
 |
 | Description:
 |    makes sure user's nick is valid
 |
 |
 | Inputs:
 |    char nick[10]
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    jfh  03/06/99  Created.
 |
 *-----------------------------------------------------------------------*/
Boolean IsValidNick(char nick[GPC_NICK_LEN + 1])
{

    /* the first character has to be alpha */
    if (LocalIsAlpha((word) nick[0])) return(TRUE);
    else {
	  UserStandardDialogOptr(
				 0, 0, 0, 0,
				 @BadNickErrMsg,
				 ((GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET) |
				 (CDT_ERROR<<CDBF_DIALOG_TYPE_OFFSET)));
	  return(FALSE);
	  }
}

/*-------------------------------------------------------------------------
 | Routine:  CheckClosePrivMsgOnExit
 *-------------------------------------------------------------------------
 |
 | Description:
 |    closes a priv msg window if "nick" PARTs or QUITs
 |
 |
 | Inputs:
 |    char nick[50]
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    jfh  03/07/99  Created.
 |
 *-----------------------------------------------------------------------*/
 void CheckClosePrivMsgOnExit(char nick[51])
{
 word		i;
 char		*p_element;
 optr		myDbox;


    /* Check if we have a privmsg dbox for this person */
    MemLock(OptrToHandle(G_privMsgArray));
    for (i = 0; i < G_numPrivMsgs; i++)  {
	  p_element = ChunkArrayElementToPtr(G_privMsgArray, i, 0);
	  if (!strcmp(nick, p_element)) {
		/* it matches */
		break;
		}
	  }
    MemUnlock(OptrToHandle(G_privMsgArray));

    if (i == G_numPrivMsgs)  {
	  /* nope - no priv messages with them */
	  return;
	  }

    else {
	  /* there is a dbox for this person */
	  myDbox = @call IRCDialogs::
				  MSG_GEN_FIND_CHILD_AT_POSITION(i + PRIV_DBOX_START);

	  /* delete its entry from the array */
	  MemLock(OptrToHandle(G_privMsgArray));
	  p_element = ChunkArrayElementToPtr(G_privMsgArray, i, 0);
	  ChunkArrayDelete(G_privMsgArray, p_element);
	  MemUnlock(OptrToHandle(G_privMsgArray));

	  /* and remove & free the dbox */
	  @call myDbox::MSG_GEN_REMOVE(VUM_NOW, CCF_MARK_DIRTY);
	  @send myDbox::MSG_META_BLOCK_FREE();

	  G_numPrivMsgs--;
	  } /* end of existing dbox else */



}

/*-------------------------------------------------------------------------
 | function:  GetValueOfKey
 *-------------------------------------------------------------------------
 |
 | Description: Parses out the launchB->ALB_extraData string into its
 |              elements -> site, port, nick, channel
 |
 |
 | Inputs:
 |    char *key
 |    char *value
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    GPC            Created.
 |
 *-----------------------------------------------------------------------*/
word GetValueOfKey(char *key, char *value)
{
 char *ptr = key;
 word cnt = 0;
    
    while (*ptr && *ptr != '&') {
	if (ptr[0] == '+')
	    value[cnt++] = ' ';
	else if (ptr[0] == '%' && ptr[1] == '2' && ptr[2] == '3') {
	  /*  value[cnt++] = '#'; */
	    value[cnt++] = '\043';
	    ptr += 2;
	}
	else
	    value[cnt++] = *ptr;
	ptr++;
    }
    value[cnt] = '\0';
    
    return cnt;
}

/*-------------------------------------------------------------------------
 | function:  IRCLaunchData
 *-------------------------------------------------------------------------
 |
 | Description: To start the app when it has been launched by another
 |              app - Browser.  Called from MSG...OPEN_APP...
 |
 |
 | Inputs:
 |    AppLaunchBlock *launchB
 | Returns:
 |         TRUE if good data, FALSE if not
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    GPC            Created.
 |    jfh  7/13/00   added return value
 *-----------------------------------------------------------------------*/
Boolean IRCLaunchData(AppLaunchBlock *launchB)
{
char		*buffer, value[125], *key;
word		cnt = 0;


    buffer = MemLock(launchB->ALB_extraData);
    if (!buffer)
	return(FALSE);
/*
    char buffer[] = "site=irc.breadbox.com&port=6667&nickname=My+Name&channel=%23TheBreadboxChannel";
 */
    if (*((word *)buffer) != IADT_MAIL_TO) {
	return(FALSE);
    }
    buffer += sizeof(InternetAppDataType);  /* skip the first word */

    key = strstr(buffer, "site=");
    if (key) {
	if (GetValueOfKey(key+5, value)) {
	    @call ConnectSiteName::
		MSG_VIS_TEXT_REPLACE_ALL_PTR(value, 0);
	    cnt++;
	}
    }
    key = strstr(buffer, "channel=");
    if (key) {
	if (GetValueOfKey(key+8, value)) {
	    @call ConnectSiteChannel::
		MSG_VIS_TEXT_REPLACE_ALL_PTR(value, 0);
	    cnt++;
	}
    }
    key = strstr(buffer, "port=");
    if (key) {
	if (GetValueOfKey(key+5, value)) {
	    @call ConnectSitePort::
		MSG_VIS_TEXT_REPLACE_ALL_PTR(value, 0);
	    cnt++;
	}
    }
    key = strstr(buffer, "nickname=");
    if (key) {
	if (GetValueOfKey(key+9, value)) {
	    @call ConnectSiteNick::
		MSG_VIS_TEXT_REPLACE_ALL_PTR(value, 0);
	    cnt++;
	}
    }

    if (cnt == 4) {
	   @call process::MSG_IRC_DO_CONNECT() ;
	   return(TRUE);
    }
    else return(FALSE);
}

/*-------------------------------------------------------------------------
 | Method:  IRCProcessClass::MSG_GEN_PROCESS_OPEN_APPLICATION
 *-------------------------------------------------------------------------
 |
 | Description:
 |    On started up, call our startup code
 |
 | Inputs:
 |    AppAttachFlags attachFlags
 |    MemHandle launchBlock
 |    MemHandle extraState
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/01/98  Created.
 |
 *-----------------------------------------------------------------------*/
@method IRCProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
 MemHandle	mem;
 ChunkHandle	chunk;
 AppLaunchBlock *launchB;
 Boolean		initError, /*showTip,*/ bailOut=FALSE;
/* DisplayScheme		displayScheme;
 byte			aspectRatio; */
 AccessFlags		pcAccess;


	 /* see if we're on an open system */
 /*	 initError = InitFileReadBoolean("system", "openSystem", &g_isOpenSystem);
	 if (initError) g_isOpenSystem = FALSE;
 */
	 /* ok - after some discussion we decided to write it as always open */
	 g_isOpenSystem = TRUE;

	 /* CUI vs AUI settings */
/*    if (UserGetDefaultUILevel() == UIIL_INTRODUCTORY) {
	  @call IRCPrimary::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
	  @call IRCPrimary::MSG_META_ADD_VAR_DATA(
			  (HINT_PRIMARY_FULL_SCREEN | VDF_SAVE_TO_STATE),
			  0, NULL);
	  @call IRCPrimary::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);

   /*	  @call IRCDisplayGroup::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
	  @call IRCDisplayGroup::MSG_META_DELETE_VAR_DATA(
			  HINT_DISPLAY_GROUP_OVERLAPPING_ON_STARTUP);
	  @call IRCDisplayGroup::MSG_META_ADD_VAR_DATA(
			  (HINT_DISPLAY_GROUP_FULL_SIZED_ON_STARTUP | VDF_SAVE_TO_STATE),
			  0, NULL);
	  @call IRCDisplayGroup::MSG_GEN_SET_USABLE(VUM_NOW);
   */
/*	  @call IRCLogMenu::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	  @call WindowMenu::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	  @call IRCCommandQuitChannel::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	  g_isCUI = TRUE;
	  }

    /* see if we're running on a TV */
/*    @call IRCApp::MSG_GEN_APPLICATION_GET_DISPLAY_SCHEME(&displayScheme);
    aspectRatio = (displayScheme.DS_displayType & DT_DISP_ASPECT_RATIO)
			    >> DT_DISP_ASPECT_RATIO_OFFSET;
	 if (aspectRatio == DAR_TV)  g_onTV = TRUE;
*/
    if (launchBlock) {
	  launchB = MemLock(launchBlock);
	  if (launchB->ALB_extraData) { /* we have the chan from the portal */
		/* set connect menu item not usable if launched from Browser */
		@send IRCConnectDialog::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		bailOut = FALSE;
		}
#if !_NDO2000 
	  else if (g_isOpenSystem) {
		  /* we're allowing acces to any server... */
		  bailOut = FALSE;
		  /* allow changing rooms */
		  @send IRCCommandChangeChannel::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		  /* allow changing nicks */
		  @send IRCChangeNickItem::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		  }
	  else {  /* go right to browser to get a channel */
		@send self::MSG_IRC_GO_TO_CHAT_PORTAL();
		/* don't build out the app */
		bailOut = TRUE;
		}
#else
	  /* Always Boot to the main screen in NewDeal Office. */
	  bailOut = FALSE;
#endif
	  MemUnlock(launchBlock);
    }

    @callsuper() ;

    if (bailOut) {
	  @send IRCApp::MSG_META_QUIT();
	  return;
	  }

    /* if we were launched from Browser get port, chan & nick info. */
    if (launchBlock) {
	  launchB = MemLock(launchBlock);
	  if (launchB->ALB_extraData) {
		if(!IRCLaunchData(launchB))  {
		   /* couldn't figger out the extraData so bail out */
		   MemFree(launchB->ALB_extraData);
		   MemUnlock(launchBlock);
		   @send IRCApp::MSG_META_QUIT();
	        return;
		   }
		MemFree(launchB->ALB_extraData);
		}
	  MemUnlock(launchBlock);
	  }

    /* see if we can use / commands */
    initError = InitFileReadBoolean("chat", "canSlash", &g_canSlash);
    if (initError) g_canSlash = FALSE;

    /* get the system font size (for people dlist)*/
    initError = InitFileReadInteger("ui", "fontsize", &g_sysPointSize);
    if (initError) g_sysPointSize = 12;

    /* check for parental control */
    pcAccess = ParentalControlGetAccessInfo();
    /* if no access, ask for password */
    if (pcAccess & AF_CHATROOM)  {
	  G_startupPassword = TRUE;
	  if (@call PCRoot::MSG_PC_CHECK_PASSWORD_DB(PC_CHAT) == IC_OK) {
		/* allow access */
		}
	  else {
		@send, forceQueue IRCApp::MSG_META_QUIT();
		}
	  G_startupPassword = FALSE;
	  }


@ifdef DUMP_TO_FILE
    FileSetStandardPath(SP_DOCUMENT);
    DumpFileHandle = FileCreate("IRCDUMP.TXT",
				  ((FCF_NATIVE)
				  | (FILE_ACCESS_RW | FILE_DENY_RW)),
				  0);
@endif

    /* create the priv msg array */
    mem = MemAllocLMem(LMEM_TYPE_GENERAL, 0) ;
    MemLock(mem) ;
    chunk = ChunkArrayCreate(mem, 51, 0, 0) ;
    G_privMsgArray = ConstructOptr(mem, chunk) ;
    MemUnlock(mem) ;

    /* create the channels open array */
    mem = MemAllocLMem(LMEM_TYPE_GENERAL, 0) ;
    MemLock(mem) ;
    chunk = ChunkArrayCreate(mem, 81, 0, 0) ;
    G_chanOpenArray = ConstructOptr(mem, chunk) ;
    MemUnlock(mem) ;

    /* needed to install tiny icon for NDO 3.0 */
    @call IRCApp::MSG_GEN_APPLICATION_INSTALL_TOKEN();

    /* open a window */
    strcpy(G_currentChannel, "Signing on...");
    @call IRCApp::MSG_IRC_NEW_CHANNEL();

	 /* see if we should show tip */
/*	 initError = InitFileReadBoolean("chat", "showTip", &showTip);
	 if (initError) showTip = TRUE;
	 if (showTip)
	  @send IRCTipDialog::MSG_GEN_INTERACTION_INITIATE();

	 /* open up the connect dbox... */
	 if (g_isOpenSystem)
		 @send IRCConnectDialog::MSG_GEN_INTERACTION_INITIATE();

}

/*-------------------------------------------------------------------------
 | Method:  IRCProcessClass::MSG_GEN_PROCESS_CLOSE_APPLICATION
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Be sure to close the connection before exiting.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/01/98  Created.
 |
 *-----------------------------------------------------------------------*/
@method IRCProcessClass, MSG_GEN_PROCESS_CLOSE_APPLICATION
{
    @call oself::MSG_IRC_CONNECTION_SEVERED() ;
    IRCClose() ;

    if (logging) FileClose(LogFileHandle, FALSE);

@ifdef DUMP_TO_FILE
    FileClose(DumpFileHandle, FALSE);
@endif

    return @callsuper() ;
}

/*-------------------------------------------------------------------------
 | Method:  IRCProcessClass::MSG_IRC_START_CONNECT
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Do all the startup code as follows:
 |        * Bring up the startup dialog.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/01/98  Created.
 |
 *-----------------------------------------------------------------------*/
@method IRCProcessClass, MSG_IRC_START_CONNECT
{
 char	nickStr[GPC_NICK_LEN + 1];
 word	activeAP;
 Boolean	apError = TRUE;
 char	apCat[20];
 word	datasize;


	  /* check for valid nick */
	  @call ConnectSiteNick::MSG_VIS_TEXT_GET_ALL_PTR(nickStr) ;
	  if (!IsValidNick(nickStr)) return;

	  /* ensure access point is available, instead of using AccessPoint
		library, we'll go straight to .ini file (from Browser code) */
	  if (!InitFileReadInteger("accpnt", "active1", &activeAP)) {
		if (activeAP) {
		   sprintf(apCat, "accesspoint%04x", activeAP);
		   if (!InitFileReadStringBuffer(apCat, "phone",
					      apCat, 20, &datasize)) {
			 apError = FALSE;
			 }
		   }
		}
	  if (apError) {
		UserStandardDialogOptr(
				 0, 0, 0, 0,
				 @NoISPErrMsg,
				 ((GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET) |
				 (CDT_ERROR<<CDBF_DIALOG_TYPE_OFFSET)));
		return;
		}

	   /* OK - lets connect */
	   @send IRCConnectDialog::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
	   @call oself::MSG_IRC_DO_CONNECT() ;

}

/*-------------------------------------------------------------------------
 | Method:  IRCProcessClass::MSG_IRC_END_CONNECT
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Do all the end connection code as follows:
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/01/98  Created.
 |
 *-----------------------------------------------------------------------*/
@method IRCProcessClass, MSG_IRC_END_CONNECT
{

    if (G_sock)  {

	   @call oself::MSG_IRC_CONNECTION_SEVERED() ;
        IRCClose() ;

	   }

	   /* we'll exit the app */
	   @send IRCApp::MSG_META_QUIT();

    
}

/*-------------------------------------------------------------------------
 | Method:  IRCProcessClass::MSG_IRC_DO_CONNECT
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Start up the connection and do the appropriate login based on the
 |    connect dialog.
 |    If a connection is made, a polling timer is started.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/01/98  Created.
 |
 *-----------------------------------------------------------------------*/
@method IRCProcessClass, MSG_IRC_DO_CONNECT
{
    MemHandle siteNameBlock ;
    char *p_siteName ;
    MemHandle portBlock ;
    char *p_port ;
    word port ;
    char buffer[100] ;
    char *p_nick;
    MemHandle nickBlock ;
    word accPnt;
    char lowerNick[GPC_NICK_LEN + 1] ;
    word i ;
    word j ;

    /* get the access point */
    accPnt = 1;

    /* Determine the site and site's port and do a connection based on */
    /* that. */
    @call IRCApp::MSG_GEN_APPLICATION_MARK_BUSY() ;
    siteNameBlock = @call ConnectSiteName::MSG_VIS_TEXT_GET_ALL_BLOCK(0);

    if (siteNameBlock)  {
        p_siteName = MemLock(siteNameBlock) ;

	   portBlock = @call ConnectSitePort::MSG_VIS_TEXT_GET_ALL_BLOCK(0) ;
	   if (portBlock)  {
            /* Get the port number */
            p_port = MemLock(portBlock) ;
            port = atoi(p_port) ;
            MemUnlock(portBlock) ;
            MemFree(portBlock) ;

		  if (IRCOpen(p_siteName, port, accPnt))  {
                @call oself::MSG_IRC_START_POLL_TIMER() ;
            } else {
                DisplayError() ;
                G_sock = NullHandle ;
            }
        }

        MemUnlock(siteNameBlock) ;
        MemFree(siteNameBlock) ;
    }



    /* Do we have a connection now? */
    if (G_sock)  {
        /* Do all activation code */
        @call oself::MSG_IRC_CONNECTION_ESTABLISHED() ;

	   @call ConnectSiteChannel::MSG_VIS_TEXT_GET_ALL_PTR(G_firstChannel) ;

	   /* jfh 6-10-99  gotta add the # if it isn't there */
	   if (G_firstChannel[0] != '\043') {
		 strcpy(buffer, "\043");
		 strcat(buffer, G_firstChannel);
		 strcpy(G_firstChannel, buffer);
		 }

        /* Let's now sign in with our nick name */
	   nickBlock = @call ConnectSiteNick::MSG_VIS_TEXT_GET_ALL_BLOCK(0) ;
	   if (nickBlock)
            p_nick = MemLock(nickBlock) ;
        else
            p_nick = "Unknown" ;
	   strncpy(G_currentNick, p_nick, sizeof(G_currentNick)-1) ;

        /* lowerNick was added for Mike's server to recognize nicks */
	   for (i=j=0; p_nick[i]; i++)
            if (isalpha(p_nick[i]))
                lowerNick[j++] = tolower(p_nick[i]) ;
        lowerNick[j] = '\0' ;

        sprintf(
            buffer,
            "USER %s %s %s :%s\r\nNICK %s\r\n",
            lowerNick,
            lowerNick,
            lowerNick,
            lowerNick,
            p_nick) ;
        IRCSendString(buffer) ;
        if (nickBlock)  {
            MemUnlock(nickBlock) ;
            MemFree(nickBlock) ;
        }
    }

    @call IRCApp::MSG_GEN_APPLICATION_MARK_NOT_BUSY() ;
}


/*-------------------------------------------------------------------------
 | Method:  IRCProcessClass::MSG_IRC_SEND_LINE
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Takes the text entered on the line and sends it out.
 |    Determines if it is a message or a command and handles it
 |    correctly.
 |
 |    Changed to a gen trigger message so I could find its parent
 |
 |
 | Inputs:
 |    word stateFlags             -- GenText state (ignored)  <----  NO LONGER
 |    optr trigger
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/01/98  Created.
 |    jfh  09/27/98  added multi chan
 |    jfh  09/03/99  back to single chan  ;-)
 *-----------------------------------------------------------------------*/
@method IRCProcessClass, MSG_IRC_SEND_LINE
{
 MemHandle mem ;
 word len ;
 char *p_mem, *p_temp;
 char talk[600] ;
 char command[20], buffer[80];
 optr		myLine, myRight, myChan, myEntryWin;
 char		*p_element;
 word		childNum;


    /* find out which display this trigger is in */
    myLine = @call trigger::MSG_GEN_FIND_PARENT();
    myRight = @call myLine::MSG_GEN_FIND_PARENT();
    myChan = @call myRight::MSG_GEN_FIND_PARENT();

    /* get my text and entry windows */
    G_curDisplay = @call myRight::MSG_GEN_FIND_CHILD_AT_POSITION(0);
    myEntryWin = @call myLine::MSG_GEN_FIND_CHILD_AT_POSITION(0);

    /* find out which channel we're in */
    childNum = @call IRCDisplayGroup::MSG_GEN_FIND_CHILD(myChan);

    MemLock(OptrToHandle(G_chanOpenArray));
    p_element = ChunkArrayElementToPtr(G_chanOpenArray, childNum, 0);
    strcpy(G_currentChannel, p_element);
    MemUnlock(OptrToHandle(G_chanOpenArray));



    /* Grab the text from the text line */
    mem = @call myEntryWin::MSG_VIS_TEXT_GET_ALL_BLOCK(0) ;
    len = @call myEntryWin::MSG_VIS_TEXT_GET_TEXT_SIZE() ;
    if (mem)  {
	   /* Is user entering a command or what? */
	   p_mem = MemLock(mem) ;
	   if (p_mem[0] == '/')  {
		  /* It's a command.  See if user is allowed to use them */
		  if (!g_canSlash) {
			UserStandardDialogOptr(
				 0, 0, 0, 0,
				 @NoSlashCmdErrMsg,
				 ((GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET) |
				 (CDT_ERROR<<CDBF_DIALOG_TYPE_OFFSET))) ;
			MemUnlock(mem) ;
			MemFree(mem) ;
			return;
			}
		  /* It's a command.  do we need to be an op to use the command? */
		  p_temp = GetSpaceDelimited(p_mem+1, command, sizeof(command)-1) ;
		  LocalUpcaseString(command, strlen(command)) ;
		  if ((((!strcmp(command, "MODE")) && (p_temp[0] == '\043'))||
			 (!strcmp(command, "KICK")) ||
			 (!strcmp(command, "TOPIC"))) && !G_ImAnOper)  {
			UserStandardDialogOptr(
				 0, 0, 0, 0,
				 @OperCmdErrMsg,
				 ((GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET) |
				 (CDT_ERROR<<CDBF_DIALOG_TYPE_OFFSET))) ;
			MemUnlock(mem) ;
			MemFree(mem) ;
			return;
			}
		  /* OK - it is allowed so send it on */
		  IRCSendData(p_mem+1, len-1) ;
		  IRCSendString("\r\n") ;

		  /* Send it to ourselves too (with added null) */
		  if (strcmp(command, "KICK") && strcmp(command, "MODE"))  {
			/* we don't wanna send KICK or MODE to ourselves */
			MemUnlock(mem) ;
			MemReAlloc(mem, len+1, HAF_STANDARD);
			p_mem = MemLock(mem) ;
			p_mem[len] = '\0' ;
			@call oself::MSG_IRC_HANDLE_INCOMING_MESSAGE(p_mem+1, FALSE, FALSE) ;
			}

	   } else {  /* is is just a post */
		  if (G_currentChannel[0] == '\0')  {
			 MemLock(OptrToHandle(@CantTalkMsg));
			 strcpy(buffer, LMemDeref(@CantTalkMsg));
			 MemUnlock(OptrToHandle(@CantTalkMsg));
			 DisplayMsg(buffer, G_curDisplay, FALSE) ;
		  } else {
			 sprintf(talk, "PRIVMSG %s :%s\r\n", G_currentChannel, p_mem) ;
			 IRCSendData(talk, strlen(talk)) ;
			 sprintf(talk, ":%s PRIVMSG %s :%s\r\n", G_currentNick, G_currentChannel, p_mem) ;
			 @call oself::MSG_IRC_HANDLE_INCOMING_MESSAGE(talk, FALSE, FALSE) ;
		  }
	   }
	   MemUnlock(mem) ;
	   MemFree(mem) ;

	   @call myEntryWin::MSG_VIS_TEXT_DELETE_ALL() ;

	   /* tell the curdisp to put ins point at the end to avoid jumping */
	   @send G_curDisplay::MSG_META_GRAB_TARGET_EXCL();
	   @send G_curDisplay::MSG_VIS_TEXT_SELECT_END();

        /* so that the text will scroll horiz while the user types */
	   @send myEntryWin::MSG_META_GRAB_TARGET_EXCL();

    }
}

/*-------------------------------------------------------------------------
 | Method:  IRCProcessClass::MSG_IRC_START_POLL_TIMER
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Starts a timer to poll the socket for incoming data.
 |
 | Inputs:
 |    word stateFlags             -- GenText state (ignored)
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/01/98  Created.
 |
 *-----------------------------------------------------------------------*/
@method IRCProcessClass, MSG_IRC_START_POLL_TIMER
{
    if (G_sock)  {
        G_timer =
            TimerStart(
                TIMER_EVENT_ONE_SHOT,
                oself,
                10,
                MSG_IRC_POLL_SOCKET,
                10,
                &G_timer) ;
    } else {
        G_timer = NullHandle ;
    }
}

/*-------------------------------------------------------------------------
 | Method:  IRCProcessClass::MSG_IRC_POLL_SOCKET
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Message created by a timer and handled to read the IRC socket
 |    connection for incoming data.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/01/98  Created.
 |    jfh  08/05/02  fixed long line bug
 |
 *-----------------------------------------------------------------------*/
#define POLL_TIMEOUT 1  /* 2/60ths of a second ... very short */
@method IRCProcessClass, MSG_IRC_POLL_SOCKET
{
    char line[512] ;
    word num ;
    word len ;
	 char *p_return ;
	 Boolean doLoop, wasTrunc ;


	 /* Read as many lines in the incoming side as possible. */
	 do {
		  doLoop = FALSE ;
		  if (G_sock)  {
				wasTrunc = FALSE;
				/* Peek as much as possible */
				num = SocketRecv(G_sock, line, sizeof(line)-2,
										POLL_TIMEOUT, SRF_PEEK, NULL) ;
				if (num > sizeof(line)-2)  {
					num = sizeof(line)-2 ;
					/* gotta add a CRLF even though we truncated it
					 * so that it will get to our display message - jfh
					 */
					line[num] = '\r';
					num++;
					line[num] = '\n';
					num++;
					wasTrunc = TRUE;
					}
				line[num] = '\0' ;
				if (num)  {

					/* Do we have a carriage return & linefeed character? */
					if ((p_return = strchr(line, '\n')) != NULL)  {
						len = p_return - line ;

						/* For now, show the line with the linefeed stripped */
						if (len)  {
							/* Read in the line now (including \n) */
							SocketRecv(G_sock, line, len+1, POLL_TIMEOUT, 0, NULL) ;
							line[len-1] = '\0' ;
							@call oself::MSG_IRC_HANDLE_INCOMING_MESSAGE(
																		line, TRUE, wasTrunc) ;
							doLoop = TRUE ;
							}
						else {
							/* skip the linefeed character */
							SocketRecv(G_sock, line, 1, POLL_TIMEOUT, 0, NULL) ;
							}
						}
					}
				else {
					/* If num is zero, it might be an error */
					G_ircError = SOCKET_GENERIC_ERROR(ThreadGetError());
					if (G_ircError != SE_NORMAL)  {
						if (G_ircError != SE_TIMED_OUT) DisplayError();
						if ((G_ircError == SE_CONNECTION_FAILED)
										|| (G_ircError == SE_CONNECTION_CLOSED)
										|| (G_ircError == SE_IMPROPER_CONDITION)
										|| (G_ircError == SE_LINK_FAILED)
										|| (G_ircError == SE_INTERNAL_ERROR)
										|| (G_ircError == SE_CONNECTION_RESET))  {

							SocketClose(G_sock) ;
							G_sock = NullHandle ;
							/* we'll
							 * need to shut down Chat. The system tells the user
							 * that the connection was lost */
							@call oself::MSG_IRC_END_CONNECT();
							} /* end of lost conn if */
						}  /* end of != NORMAL if */
					}  /* end of num = 0 else */
				} /* end of good socket if */
		  } while (doLoop) ;

	 /* Trigger the timer again if we have not timed out */
	 if (G_sock)
		@call oself::MSG_IRC_START_POLL_TIMER() ;
}

/*-------------------------------------------------------------------------
 | Routine:  UpdateChanGlobals
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Sets channel globals based on the input channel name string
 |
 |
 | Inputs:
 |    char *p_chan                 -- Null terminated text
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    jfh  10/08/98  Created.
 |
 *-----------------------------------------------------------------------*/
void UpdateChanGlobals(char *p_chan)
{
 optr		myLeft, myChan, myRight;
 char		*p_element;
 word		len, i;


    MemLock(OptrToHandle(G_chanOpenArray));
    for (i = 0; i < G_numChansOpen; i++)  {
	  p_element = ChunkArrayElementToPtr(G_chanOpenArray, i, 0);
	  len = strlen(p_element);
	  if (strlen(p_chan) > len) len = strlen(p_chan);
	  if (!LocalCmpStringsNoCase(p_chan, p_element, len)) {
		/* set chan disp and list */
		strcpy(G_currentChannel, p_chan);
		myChan = @call IRCDisplayGroup::
						 MSG_GEN_FIND_CHILD_AT_POSITION(i);
		myRight = @call myChan::MSG_GEN_FIND_CHILD_AT_POSITION(1);
		G_curDisplay = @call myRight::MSG_GEN_FIND_CHILD_AT_POSITION(0);
		myLeft = @call myChan::MSG_GEN_FIND_CHILD_AT_POSITION(0);
		G_curList = @call myLeft::MSG_GEN_FIND_CHILD_AT_POSITION(0);
		break;
		}
	  }
    MemUnlock(OptrToHandle(G_chanOpenArray));
}

/*-------------------------------------------------------------------------
 | Method:  IRCProcessClass::MSG_IRC_HANDLE_INCOMING_MESSAGE
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Main routine for processing messages received from the server.
 |
 | Inputs:
 |    char *p_msg                 -- Message to interpret and process
 |    Boolean needTrans           -- to suppress translation
 |    Boolean wasTrunc				 -- to add a msg that string was chopped
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/01/98  Created.
 |    jfh  02/11/00  added translation supression
 |    jfh  08/05/02  added truncation msg
 |
 *-----------------------------------------------------------------------*/
@method IRCProcessClass, MSG_IRC_HANDLE_INCOMING_MESSAGE
{
 char serverName[80] ;
 char command[20] ;
 word comNum;
 char ourname[50] ;
 char data[80] ;
 char channel[80] ;
 char buffer[200] ;
 char *p_all ;
 Boolean dumpRemaining = FALSE ;
 char nick[51] ;
 char who[51] ;
 Boolean sayRemaining = FALSE ;
 char *p_end ;
 ColorQuad color = {C_BLACK, CF_INDEX, 0, 0 };
 optr	peopleArray, myRight, myLeft, myChannel, myLine, myEntryWin;
 PeopleHereStruct		*p_element;
 word	numPeople, i, len, childNum;
 char	*p_chanElement;
 char	test[51], testNick[51];
 Boolean	ignore;
 dword	start;


	 p_all = p_msg ;

    /* strip CR and LF */
    p_end = strchr(p_msg, '\r') ;
    if (p_end) *p_end = '\0' ;
    p_end = strchr(p_msg, '\n') ;
    if (p_end) *p_end = '\0' ;

    /* Skip any spaces at the beginning */
    p_msg = SkipSpaces(p_msg) ;

@ifdef DUMP_TO_FILE
	 FileWrite(DumpFileHandle, "IN - ", 5, FALSE);
	 FileWrite(DumpFileHandle, p_msg, strlen(p_msg), FALSE);
	 FileWrite(DumpFileHandle, "\r\n", 2, FALSE);
@endif

    /* Does this message start with a server name? */
    nick[0] = '\0' ;
    if (p_msg[0] == ':')  {
	   p_msg = GetSpaceDelimited(p_msg+1, serverName, sizeof(serverName)-1) ;
	   ParseNicknameFromServerString(serverName, nick, sizeof(nick)-1) ;
    } else {
	   serverName[0] = '\0' ;
    }

    /* Let's get the command or command number */
    p_msg = GetSpaceDelimited(p_msg, command, sizeof(command)-1) ;

    /* Only go on if we have a command */
    if (command[0])  {
		/* Only deal with upper case commands */
		LocalUpcaseString(command, strlen(command)) ;

	   /* Is the command a number or a string? */
	   if (isdigit(command[0]))  {
		  comNum = atoi(command) ;
		  p_msg = GetSpaceDelimited(p_msg, ourname, sizeof(ourname)-1) ;
		  switch (comNum)  {
			 case RPL_NOTOPIC:
			 case RPL_LIST:
			 case RPL_TOPIC:
				p_msg = GetSpaceDelimited(p_msg, buffer, sizeof(buffer)-1) ;
				break ;
		  }
		  switch (comNum)  {
			 case RPL_ENDOFNAMES:
				@call G_curList::MSG_SORT_LIST_UPDATE() ;
				break ;
			 case RPL_NAMREPLY:
				p_msg = strchr(p_msg, ':') ;
				if (p_msg)  {
				    p_msg++ ;
				    /* Keep adding names */
				    while ((p_msg = GetSpaceDelimited(
								    p_msg,
								    buffer,
								    sizeof(buffer)-1)) != NullHandle)  {
					   /* check if we're an op */
					   if (buffer[0] == '@')  {
						 ourname[0] = 0;
						 strcpy(ourname, &buffer[1]);
						 if (!strcmp(G_currentNick, ourname)) {
						    /* yes - set the flag */
						    G_ImAnOper = TRUE;
						    }
						 }
					   /* don't show ChanOps if !g_canSlash */
					   if (((buffer[0] == '@') || (buffer[0]=='+')) && (!g_canSlash))
						  @call G_curList::MSG_SORT_LIST_ADD_ITEM_QUIETLY(buffer+1) ;
					   else @call G_curList::MSG_SORT_LIST_ADD_ITEM_QUIETLY(buffer) ;
					   if (p_msg[0] == '\0')
						  break ;
				    }  /* end of while */
				} /* end of p_msg if */
				break ;
			 case RPL_NOTOPIC:
				break ;
			 case RPL_TOPIC:
				strncpy(G_currentChannel, buffer, sizeof(G_currentChannel)-1) ;
				p_msg = strchr(p_msg, ':') ;
				if ((p_msg) && (*p_msg != '\0'))  {
				    strcat(buffer, " [");
				    strcat(buffer, p_msg+1);
				    strcat(buffer, "]");
				    myChannel = 0;
				    MemLock(OptrToHandle(G_chanOpenArray));
				    for (i = 0; i < G_numChansOpen; i++)  {
					  p_element = ChunkArrayElementToPtr(G_chanOpenArray, i, 0);
					  len = strlen(p_element);
					  if (strlen(G_currentChannel) > len) len = strlen(G_currentChannel);
					  if (!LocalCmpStringsNoCase(G_currentChannel, p_element, len)) {
						/* find channel */
						myChannel = @call IRCDisplayGroup::
								    MSG_GEN_FIND_CHILD_AT_POSITION(i);
						break;
						}
					  }
					 MemUnlock(OptrToHandle(G_chanOpenArray));
				    if (myChannel)
					  @call myChannel::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(buffer, VUM_NOW);
				    }
				break ;
			 case RPL_MOTDSTART:
				g_pastMOTD = TRUE; /* stop supressing server info */
				MemLock(OptrToHandle(@StartMODMsg));
				strcpy(buffer, LMemDeref(@StartMODMsg));
				MemUnlock(OptrToHandle(@StartMODMsg));
				DisplayMsg(buffer, G_curDisplay, needTrans) ;
				break ;
			 case RPL_MOTD:
				DisplayText("\r", G_curDisplay, needTrans) ;
				dumpRemaining = TRUE ;
				break ;
			 case RPL_ENDOFMOTD:
				MemLock(OptrToHandle(@StartMODMsg));
				strcpy(buffer, LMemDeref(@EndMODMsg));
				MemUnlock(OptrToHandle(@StartMODMsg));
				DisplayMsg(buffer, G_curDisplay, needTrans) ;
				/* fix scrolling */
				@send G_curDisplay::MSG_META_GRAB_TARGET_EXCL();
				@send G_curDisplay::MSG_VIS_TEXT_SELECT_END();
				myRight = @call G_curDisplay::MSG_GEN_FIND_PARENT();
				myLine = @call myRight::MSG_GEN_FIND_CHILD_AT_POSITION(1);
				myEntryWin = @call myLine::MSG_GEN_FIND_CHILD_AT_POSITION(0);
				@send myEntryWin::MSG_META_GRAB_TARGET_EXCL();
				if (G_firstChannel[0])  {
				    sprintf(buffer, "JOIN :%s%s\r\n",
					   (G_firstChannel[0]=='\043')?"":"\043",
					   G_firstChannel) ;
				    IRCSendString(buffer) ;
				}
				break ;
			 case RPL_NO_MOTD:  /* no MOTD for GPC irc server */
				if (G_firstChannel[0])  {
				    sprintf(buffer, "JOIN :%s%s\r\n",
					   (G_firstChannel[0]=='\043')?"":"\043",
					   G_firstChannel) ;
				    IRCSendString(buffer) ;
				}
				g_pastMOTD = TRUE; /* stop supressing server info */
				break ;
			 case RPL_NICKNAMEINUSE:
				/* Require a new nickname to be entered */
				UserStandardDialogOptr(
					 0, 0, 0, 0,
					 @MessageNicknameInUse,
					 ((GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET) |
					(CDT_WARNING<<CDBF_DIALOG_TYPE_OFFSET))) ;
				@send ,forceQueue IRCChangeNickname::
							   MSG_GEN_INTERACTION_INITIATE() ;
				DisplayText("\r", G_curDisplay, needTrans) ;
				dumpRemaining = TRUE ;
				break ;
			 case RPL_NO_SUCH_CHAN:
			    /* tell the user there is a problem with that channel */
			    p_msg = GetSpaceDelimited(p_msg, buffer, sizeof(buffer)-1) ;
			    MemLock(OptrToHandle(@MessageNoSuchChan));
			    UserStandardDialog(
				    0, 0, 0, buffer,
				    LMemDeref(@MessageNoSuchChan),
				    ((GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET) |
					(CDT_WARNING<<CDBF_DIALOG_TYPE_OFFSET))) ;
			    MemUnlock(OptrToHandle(@MessageNoSuchChan));
			    /* Since there is nothing for the user to do if this
				* was the first channel they tried or if they are
				* in the CUI, then we close the app. */
			    if (/*(*/G_numChansOpen <= 1) /*|| g_isCUI)*/ {
				  @send, forceQueue IRCApp::MSG_META_QUIT();
                      }

				 break;
			 default:
				/* Not sure what we got */
				/* Just output the data then */
				if ((comNum == 333) || (comNum == 328) || !g_pastMOTD)  {
				    /* I don't know what they are, but ignore them. */
				    /* and don't show stuff before the motd */
				} else {
				    if (comNum >= 200)  sprintf(buffer, "%d:", comNum) ;
				    start = @call G_curDisplay::MSG_VIS_TEXT_GET_TEXT_SIZE();
				    color.CQ_redOrIndex = C_BLUE;
				    @call G_curDisplay::MSG_VIS_TEXT_SET_COLOR
						  (color, TEXT_ADDRESS_PAST_END, start);
				    DisplayText(buffer, G_curDisplay, needTrans) ;
				    dumpRemaining = TRUE ;
				}
				break ;
		  }  /* end of command is a number switch */

	   } else {   /* command is a string */

		  if (strcmp(command, "NOTICE") == 0)  {
			 /* Skip our name */
			 p_msg = GetSpaceDelimited(p_msg, ourname, sizeof(ourname)-1) ;
			 p_msg = strchr(p_msg, ':') ;
			 if (p_msg)  {
			    p_msg++ ;
			    strcpy(buffer, nick);
			    MemLock(OptrToHandle(@WhisperStr));
			    strcat(buffer, LMemDeref(@WhisperStr));
			    MemUnlock(OptrToHandle(@WhisperStr));
			    DisplayText(buffer, G_curDisplay, needTrans) ;
				 DisplayMsg(p_msg, G_curDisplay, needTrans) ;
				/* fix scrolling */
				@send G_curDisplay::MSG_META_GRAB_TARGET_EXCL();
				@send G_curDisplay::MSG_VIS_TEXT_SELECT_END();
				myRight = @call G_curDisplay::MSG_GEN_FIND_PARENT();
				myLine = @call myRight::MSG_GEN_FIND_CHILD_AT_POSITION(1);
				myEntryWin = @call myLine::MSG_GEN_FIND_CHILD_AT_POSITION(0);
				@send myEntryWin::MSG_META_GRAB_TARGET_EXCL();
				 }
		  } else if (strcmp(command, "PING")==0)  {
			 /* Got the ping message.  Need to respond with PONG */
			 GetSpaceDelimited(p_msg, data, sizeof(data)-1) ;
			 sprintf(buffer, "PONG %s\r\n", data) ;
			 IRCSendString(buffer) ;
		  } else if (strcmp(command, "JOIN")==0)  {
			 p_msg = strchr(p_msg, ':');
			 p_msg++;

			 /* if it is someone else joining... */
			 if (nick[0] && (strcmp(nick, G_currentNick))) {
			    UpdateChanGlobals(p_msg);
			    start = @call G_curDisplay::MSG_VIS_TEXT_GET_TEXT_SIZE();
				 color.CQ_redOrIndex = C_BLUE;
			    @call G_curDisplay::MSG_VIS_TEXT_SET_COLOR
						  (color, TEXT_ADDRESS_PAST_END, start);
			    @call G_curList::MSG_SORT_LIST_ADD_ITEM(nick) ;
			    }
			 /* if it is us joining */
			 else {
				 strcpy(G_currentChannel, p_msg) ;
			    if (G_firstChannel[0])  {
				  G_firstChannel[0] = 0;
				  /* the display is up... just show the title */
				  myRight = @call G_curDisplay::MSG_GEN_FIND_PARENT();
				  myChannel = @call myRight::MSG_GEN_FIND_PARENT();
				  @call myChannel::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(G_currentChannel, VUM_NOW);
				  /* and change the name in the array */
				  childNum = @call IRCDisplayGroup::MSG_GEN_FIND_CHILD(myChannel);
				  MemLock(OptrToHandle(G_chanOpenArray));
				  p_chanElement = ChunkArrayElementToPtr(G_chanOpenArray, childNum, 0);
				  strcpy(p_chanElement, G_currentChannel);
				  MemUnlock(OptrToHandle(G_chanOpenArray));
				  }  /* end of first chan open if */
		  /*	    else if (g_isCUI) {
				  /* and show the new room title */
		  /*		  myRight = @call G_curDisplay::MSG_GEN_FIND_PARENT();
				  myChannel = @call myRight::MSG_GEN_FIND_PARENT();
				  @call myChannel::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(G_currentChannel, VUM_NOW);
				  }  */
			    else  {
				  @call IRCApp::MSG_IRC_NEW_CHANNEL();
			 	  }
			    /* show us joining */
			    MemLock(OptrToHandle(@JoiningStr));
			    strcpy(buffer, LMemDeref(@JoiningStr));
			    MemLock(OptrToHandle(@JoiningStr));
			    strcat(buffer, G_currentChannel);
				 DisplayMsg(buffer, G_curDisplay, needTrans) ;
				 }  /* end of us joining else */

			 /* show person entering */
			 strcpy(buffer, nick);
			 MemLock(OptrToHandle(@EntersStr));
			 strcat(buffer, LMemDeref(@EntersStr));
			 MemUnlock(OptrToHandle(@EntersStr));
			 DisplayMsg(buffer, G_curDisplay, needTrans) ;
				/* fix scrolling */
				@send G_curDisplay::MSG_META_GRAB_TARGET_EXCL();
				@send G_curDisplay::MSG_VIS_TEXT_SELECT_END();
				myRight = @call G_curDisplay::MSG_GEN_FIND_PARENT();
				myLine = @call myRight::MSG_GEN_FIND_CHILD_AT_POSITION(1);
				myEntryWin = @call myLine::MSG_GEN_FIND_CHILD_AT_POSITION(0);
				@send myEntryWin::MSG_META_GRAB_TARGET_EXCL();

		  } else if (strcmp(command, "PART")==0)  {
			 if (strcmp(nick, G_currentNick)/* || g_isCUI*/) {
			    /* it's not me so show it */
			    UpdateChanGlobals(p_msg);
			    strcpy(buffer, nick);
			    MemLock(OptrToHandle(@EntersStr));
			    strcat(buffer, LMemDeref(@LeavesStr));
			    MemUnlock(OptrToHandle(@EntersStr));

			    start = @call G_curDisplay::MSG_VIS_TEXT_GET_TEXT_SIZE();
			    color.CQ_redOrIndex = C_BLUE;
			    @call G_curDisplay::MSG_VIS_TEXT_SET_COLOR
				 (color, TEXT_ADDRESS_PAST_END, start);

				 DisplayMsg(buffer, G_curDisplay, needTrans) ;
				/* fix scrolling */
				@send G_curDisplay::MSG_META_GRAB_TARGET_EXCL();
				@send G_curDisplay::MSG_VIS_TEXT_SELECT_END();
				myRight = @call G_curDisplay::MSG_GEN_FIND_PARENT();
				myLine = @call myRight::MSG_GEN_FIND_CHILD_AT_POSITION(1);
				myEntryWin = @call myLine::MSG_GEN_FIND_CHILD_AT_POSITION(0);
				@send myEntryWin::MSG_META_GRAB_TARGET_EXCL();

			    @call G_curList::MSG_SORT_LIST_DELETE_ITEM(nick) ;
			    /* now see if we have a priv msg box open with them...
				* and dump it if we do. */
			  //  CheckClosePrivMsgOnExit(nick);
			    }
		  } else if (strcmp(command, "QUIT")==0)  {
			for (i = 0; i < G_numChansOpen; i++)  {
			   /* set disp and list */
			   myChannel = @call IRCDisplayGroup::MSG_GEN_FIND_CHILD_AT_POSITION(i);
			   myRight = @call myChannel::MSG_GEN_FIND_CHILD_AT_POSITION(1);
			   G_curDisplay = @call myRight::MSG_GEN_FIND_CHILD_AT_POSITION(0);
				myLeft = @call myChannel::MSG_GEN_FIND_CHILD_AT_POSITION(0);
				G_curList = @call myLeft::MSG_GEN_FIND_CHILD_AT_POSITION(0);
			   if (@call G_curList::MSG_SORT_LIST_DELETE_ITEM(nick))  {
				 /* only display a message in the chan if the guy was there */
				 strcpy(buffer, nick);
				 MemLock(OptrToHandle(@EntersStr));
				 strcat(buffer, LMemDeref(@QuitStr));
				 MemUnlock(OptrToHandle(@EntersStr));

				 start = @call G_curDisplay::MSG_VIS_TEXT_GET_TEXT_SIZE();
				 color.CQ_redOrIndex = C_BLUE;
				 @call G_curDisplay::MSG_VIS_TEXT_SET_COLOR
							  (color, TEXT_ADDRESS_PAST_END, start);

				 DisplayText(buffer, G_curDisplay, needTrans) ;
				 if (p_msg) OutputTextPastColon(p_msg);
				 /* now see if we have a priv msg box open with them...
				  * and dump it if we do. */
				 CheckClosePrivMsgOnExit(nick);
				 }  /* end of showing other guy quit */
			   }  /* end of for checking all rooms */
		  } else if ((strcmp(command, "MODE")==0) && g_canSlash)  {
			 /* Ignore mode commands EXCEPT for when someone is
			  * given or taken oper status */
			 /* the channel is first */
			 p_msg = GetSpaceDelimited(p_msg, channel, sizeof(channel)-1) ;
			 /* now the mode being executed */
			 p_msg = GetSpaceDelimited(p_msg, data, sizeof(data)-1) ;
			 /* and finally the nick */
			 p_msg = GetSpaceDelimited(p_msg, nick, sizeof(nick)-1) ;
			 if (/*!(strcmp(nick, G_currentNick)) && */
				  (!(strcmp(data, "+o")) || !(strcmp(data, "-o"))))  {
			    /* this mode is an oper + or - */
			    UpdateChanGlobals(channel);
			    strcpy (who, "@");
			    strcat (who, nick);
			    if (!(strcmp(data, "+o"))) {
				  /* someone's been given oper status */
				  @call G_curList::MSG_SORT_LIST_RENAME_ITEM(
						  nick, who) ;
				  if (!strcmp(nick, G_currentNick)) G_ImAnOper = TRUE;
				  }
			    else if (!(strcmp(data, "-o"))) {
				  /* oper status has been taken */
				  @call G_curList::MSG_SORT_LIST_RENAME_ITEM(
						  who, nick) ;
				  if (!strcmp(nick, G_currentNick)) G_ImAnOper = FALSE;
				  }
			    }
		  } else if (strcmp(command, "KICK")==0)  {
			 p_msg = GetSpaceDelimited(p_msg, channel, sizeof(buffer)-1) ;
			 p_msg = GetSpaceDelimited(p_msg, who, sizeof(who)-1) ;
			 UpdateChanGlobals(channel);
			 if (strcmp(who, G_currentNick)) {
			    /* it was somebody else */
			    MemLock(OptrToHandle(@KickOtherStr));
			    strcpy(buffer, nick);
			    strcat(buffer, LMemDeref(@KickOtherStr));
			    strcat(buffer, who);
			    MemLock(OptrToHandle(@KickOtherStr));
				 DisplayMsg(buffer, G_curDisplay, needTrans) ;
				/* fix scrolling */
				@send G_curDisplay::MSG_META_GRAB_TARGET_EXCL();
				@send G_curDisplay::MSG_VIS_TEXT_SELECT_END();
				myRight = @call G_curDisplay::MSG_GEN_FIND_PARENT();
				myLine = @call myRight::MSG_GEN_FIND_CHILD_AT_POSITION(1);
				myEntryWin = @call myLine::MSG_GEN_FIND_CHILD_AT_POSITION(0);
				@send myEntryWin::MSG_META_GRAB_TARGET_EXCL();
			    @call G_curList::MSG_SORT_LIST_DELETE_ITEM(who) ;
			    }
			 else  { /* it was us :-(  */
			    /* close that channel */
			    @send IRCApp::MSG_IRC_LEAVE_CHANNEL();
			    /* notify user in a dbox */
			    MemLock(OptrToHandle(@KickOtherStr));
			    strcpy(buffer, LMemDeref(@KickMeStr));
			    MemLock(OptrToHandle(@KickOtherStr));
			    UserStandardDialog(
					0, 0, channel, nick,
					buffer,
					((GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET) |
					(CDT_ERROR<<CDBF_DIALOG_TYPE_OFFSET))) ;
				 }

		  } else if (strcmp(command, "NICK")==0)  {
			 p_msg = strchr(p_msg, ':') ;
			 for (i = 0; i < G_numChansOpen; i++)  {
			    /* set disp and list */
			    myChannel = @call IRCDisplayGroup::MSG_GEN_FIND_CHILD_AT_POSITION(i);
			    myRight = @call myChannel::MSG_GEN_FIND_CHILD_AT_POSITION(1);
				 G_curDisplay = @call myRight::MSG_GEN_FIND_CHILD_AT_POSITION(0);
			    myLeft = @call myChannel::MSG_GEN_FIND_CHILD_AT_POSITION(0);
			    G_curList = @call myLeft::MSG_GEN_FIND_CHILD_AT_POSITION(0);

			    /* change the list and show the new nick */
			    if (p_msg)  {
				  p_msg++ ;
				  if (@call G_curList::MSG_SORT_LIST_RENAME_ITEM(nick, p_msg))  {
					/* good rename */

					MemLock(OptrToHandle(@ChangesNickStr));
					strcpy(buffer, nick);
					strcat(buffer, LMemDeref(@ChangesNickStr));
					MemLock(OptrToHandle(@ChangesNickStr));
					start = @call G_curDisplay::MSG_VIS_TEXT_GET_TEXT_SIZE();
					color.CQ_redOrIndex = C_BLUE;
					@call G_curDisplay::MSG_VIS_TEXT_SET_COLOR
							   (color, TEXT_ADDRESS_PAST_END, start);
					DisplayText(buffer, G_curDisplay, needTrans) ;

					/* if it is us... */
					if (LocalCmpStringsNoCase(p_msg, G_currentNick,
									sizeof(G_currentNick))==0)  {
					   strncpy(G_currentNick, p_msg, sizeof(G_currentNick)) ;
					   }
					p_msg-- ;
					if (p_msg) {
					   start = @call G_curDisplay::MSG_VIS_TEXT_GET_TEXT_SIZE();
					   color.CQ_redOrIndex = C_BLUE;
					   @call G_curDisplay::MSG_VIS_TEXT_SET_COLOR
								(color, TEXT_ADDRESS_PAST_END, start);
					   OutputTextPastColon(p_msg);
					   }
					} /* end of good rename if */
				  } /* end of valid string if */
			    }  /* end of cycle thru chans for */
		  } else if (strcmp(command, "PRIVMSG")==0)  {
			 /* Get the receiver of the message (us or a chan we're in
			  * (our name represents a private msg) */
			 p_msg = GetSpaceDelimited(p_msg, ourname, sizeof(ourname)-1) ;
			 /* If starts with # then it is the name of a room */
			 if (ourname[0] == '\043')   {
			    /* update things to check the right ignore list */
			    UpdateChanGlobals(ourname);
			    }

			 /* see if the sender is on the ignore list */
			 peopleArray = @call G_curList::MSG_SORT_LIST_GET_ARRAY_OPTR();
			 /* find the selected nick in the array */
			 if (peopleArray) {
			    MemLock(OptrToHandle(peopleArray));
			    numPeople = ChunkArrayGetCount(peopleArray) ;
			    for (i = 0; i < numPeople; i++)  {
				  p_element = ChunkArrayElementToPtr(peopleArray, i, 0);
				  /* get the test nick */
				  strcpy(test, p_element->PHS_nick);
				  /* clean up the nick */
				  if ((test[0] == '@') || (test[0] == '+'))
								strcpy(testNick, &test[1]);
				  else  strcpy(testNick, test);
				  if (!strcmp(testNick, nick))  {
					/* is he to be ignored? */
					ignore = p_element->PHS_ignore;
					break;
					}
				  }
			    MemUnlock(OptrToHandle(peopleArray));
			    }

			 if (!ignore)  {  /* get the message */
			    /* If starts with # then it is the name of a room */
			    if (ourname[0] == '\043')   {
				  /* show it in the proper window */
				  UpdateChanGlobals(ourname);
				  sayRemaining = TRUE ;
				  }
			    else  {
				  /* it is a priv msg to us - give it its own dbox */
				  @send process::MSG_IRC_RECEIVE_PRIV(&nick[0], p_msg);
				  }
			    }  /* end of don't ignore if */

		  } else if (strcmp(command, "TOPIC")==0)  {
			 p_msg = GetSpaceDelimited(p_msg, buffer, sizeof(buffer)-1) ;
			 if (p_msg)  {
				strncpy(G_currentChannel, buffer, sizeof(G_currentChannel)-1) ;
				p_msg = strchr(p_msg, ':') ;
				if ((p_msg) && (*p_msg != '\0'))  {
				    strcat(buffer, " [");
				    strcat(buffer, p_msg+1);
				    strcat(buffer, "]");
				    /* show it in window title */
				    myChannel = 0;
				    MemLock(OptrToHandle(G_chanOpenArray));
				    for (i = 0; i < G_numChansOpen; i++)  {
					  p_element = ChunkArrayElementToPtr(G_chanOpenArray, i, 0);
					  len = strlen(p_element);
					  if (strlen(G_currentChannel) > len) len = strlen(G_currentChannel);
					  if (!LocalCmpStringsNoCase(G_currentChannel, p_element, len)) {
						/* find channel */
						myChannel = @call IRCDisplayGroup::
								    MSG_GEN_FIND_CHILD_AT_POSITION(i);
						break;
						}
					  }
				    MemUnlock(OptrToHandle(G_chanOpenArray));
				    if (myChannel)
					  @call myChannel::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(buffer, VUM_NOW);
				}
			 }

		  } else {
			 if (g_pastMOTD) {  /* supress it if before MOTD */
			    /* not a supported command - just show it */
			    start = @call G_curDisplay::
										 MSG_VIS_TEXT_GET_TEXT_SIZE();
			    color.CQ_redOrIndex = C_BLUE;
			    @call G_curDisplay::MSG_VIS_TEXT_SET_COLOR
						   (color, TEXT_ADDRESS_PAST_END, start);
				 DisplayMsg("???", G_curDisplay, needTrans) ;
			    DisplayMsg(p_all, G_curDisplay, needTrans) ;
			    dumpRemaining = TRUE ;
			    }
		  }
	   }  /* end of it is a string command else */

	   if (sayRemaining)  {  /*  from PRIVMSG */
		  p_msg = strchr(p_msg, ':') ;
		  if (p_msg)  {
			 p_msg++ ;
			 if (strncmp(p_msg, "\001ACTION", 7) == 0)  {
				sprintf(buffer, "%s", nick) ;
				p_msg += 7 ;
				dumpRemaining = TRUE ;
			 } else {
				sprintf(buffer, "%s: ", nick) ;
			 }

		  if (strcmp(nick, G_currentNick) == 0) {
			/* show our text in red */
			color.CQ_redOrIndex = C_RED;
			}
		  else color.CQ_redOrIndex = C_BLACK;
		  start = @call G_curDisplay::MSG_VIS_TEXT_GET_TEXT_SIZE();
		  @call G_curDisplay::MSG_VIS_TEXT_SET_COLOR
			 (color, TEXT_ADDRESS_PAST_END, start);
		  /* the nicks BOLD */
		  @call G_curDisplay::MSG_VIS_TEXT_SET_TEXT_STYLE
			(0,0,0,TS_BOLD, TEXT_ADDRESS_PAST_END, start);
		  /* and if on TV make them SANS */
   /*		  if (g_onTV)
			 @call G_curDisplay::MSG_VIS_TEXT_SET_FONT_ID(
			 FID_DTC_URW_SANS, TEXT_ADDRESS_PAST_END, TEXT_ADDRESS_PAST_END);
   */
		  DisplayText(buffer, G_curDisplay, needTrans) ;

		  start = @call G_curDisplay::MSG_VIS_TEXT_GET_TEXT_SIZE();
		  @call G_curDisplay::MSG_VIS_TEXT_SET_TEXT_STYLE
			  (0,0,TS_BOLD,0, TEXT_ADDRESS_PAST_END, start);
    /*		  if (g_onTV)
			 @call G_curDisplay::MSG_VIS_TEXT_SET_FONT_ID(
			 FID_BERKELEY, TEXT_ADDRESS_PAST_END, TEXT_ADDRESS_PAST_END);
    */
		  DisplayMsg(p_msg, G_curDisplay, needTrans) ;

		  /* and a message that the prev msg was chopped */
		  if (wasTrunc) {
				MemLock(OptrToHandle(@ChoppedMsg));
				DisplayMsg(LMemDeref(@ChoppedMsg), G_curDisplay, needTrans) ;
				MemLock(OptrToHandle(@ChoppedMsg));
				}
				/* fix scrolling */
				@send G_curDisplay::MSG_META_GRAB_TARGET_EXCL();
				@send G_curDisplay::MSG_VIS_TEXT_SELECT_END();
				myRight = @call G_curDisplay::MSG_GEN_FIND_PARENT();
				myLine = @call myRight::MSG_GEN_FIND_CHILD_AT_POSITION(1);
				myEntryWin = @call myLine::MSG_GEN_FIND_CHILD_AT_POSITION(0);
				@send myEntryWin::MSG_META_GRAB_TARGET_EXCL();
		  }
	   }  /* end of say remaining if */

	   if (dumpRemaining) if (p_msg) OutputTextPastColon(p_msg);

    } /* end of it is a command if */
}

/*-------------------------------------------------------------------------
 | Method:  IRCProcessClass::MSG_IRC_CONNECTION_ESTABLISHED
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Take care of any tasks that occur when we just connect (like enabling
 |    UI features).
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  06/08/98  Created.
 |
 *-----------------------------------------------------------------------*/
@method IRCProcessClass, MSG_IRC_CONNECTION_ESTABLISHED
{

    /* No channel yet. */
    G_currentChannel[0] = '\0' ;

    /* Save the settings since we connected */
    @call IRCPrimary::MSG_META_SAVE_OPTIONS();
    InitFileCommit() ;

    /* Disable UI features */
	 @call IRCConnectDialog::MSG_GEN_SET_NOT_ENABLED(
				  VUM_DELAYED_VIA_UI_QUEUE) ;
	 @call IRCCommandChangeChannel::MSG_GEN_SET_ENABLED(
				  VUM_DELAYED_VIA_UI_QUEUE) ;
	 @call IRCChangeNickItem::MSG_GEN_SET_ENABLED(
				  VUM_DELAYED_VIA_UI_QUEUE) ;
}

/*-------------------------------------------------------------------------
 | Method:  IRCProcessClass::MSG_IRC_CONNECTION_SEVERED
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Take care of any tasks that occur when we just disconnect (like
 |    disabling UI features).
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  06/08/98  Created.
 |
 *-----------------------------------------------------------------------*/
@method IRCProcessClass, MSG_IRC_CONNECTION_SEVERED
{


    /* Enable UI features */
    @call IRCConnectDialog::MSG_GEN_SET_ENABLED(
              VUM_DELAYED_VIA_UI_QUEUE) ;
	 @call IRCCommandChangeChannel::MSG_GEN_SET_NOT_ENABLED(
				  VUM_DELAYED_VIA_UI_QUEUE) ;
	 @call IRCChangeNickItem::MSG_GEN_SET_NOT_ENABLED(
				  VUM_DELAYED_VIA_UI_QUEUE) ;

    /* reset the globals */
    G_currentChannel[0] = '\0';

}

/*-------------------------------------------------------------------------
 | Method:  IRCProcessClass::MSG_IRC_ABSORB_DBLCLICK
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Keep send trigger from screwing up sending double sends
 |
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    jfh  1?/??/99  Created.
 |
 *-----------------------------------------------------------------------*/
@method IRCProcessClass, MSG_IRC_ABSORB_DBLCLICK
{

}

/*-------------------------------------------------------------------------
 | Method:  IRCProcessClass::MSG_IRC_CLOSE_TIP
 *-------------------------------------------------------------------------
 |
 | Description:
 |    make ini entry if user doesn't want to see Tip again
 |
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    jfh  01/19/00  Created.
 |    jfh  03/18/00  changes item to bool
 *-----------------------------------------------------------------------*/
/*@method IRCProcessClass, MSG_IRC_CLOSE_TIP
{
Boolean		sel;


    sel = @call IRCTipShowAgainGroup::
							MSG_GEN_BOOLEAN_GROUP_IS_BOOLEAN_SELECTED(1);
    if (sel)  {
       /* turn off tip dialog box */
/*	  InitFileWriteBoolean("chat", "showTip", FALSE);
	  }

	 @send IRCTipDialog::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
					 
}
*/
/***********************************************************************
 *	MSG_IRC_GO_TO_CHAT_PORTAL for IRCProcessClass
 ***********************************************************************
 * SYNOPSIS:     opens the Browser to the chat page on the portal
 *
 * PARAMETERS:  
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:	    
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jfh	3/22/00	Initial Revision
 *
 ***********************************************************************/
@method IRCProcessClass, MSG_IRC_GO_TO_CHAT_PORTAL
{
IACPConnection   iacpConnectionToken;
GeodeToken       serverGeodeToken = {"GlbI", 16431};
word             serverCount;
MemHandle        hLaunchBlock, mh, mh2;
InternetAppBlock *ptr;
AppLaunchBlock   *alb;
word             len;


    iacpConnectionToken = IACP_NO_CONNECTION;
    /* set up a block to launch the Browser */
    hLaunchBlock = IACPCreateDefaultLaunchBlock(MSG_GEN_PROCESS_OPEN_APPLICATION);

    /* get the URL */
    if(!InitFileReadStringBlock("chat", "chatURL", &mh2, 0, &len) && len) {
	  mh = MemAllocSetOwner((GeodeHandle)SysGetInfo(SGIT_UI_PROCESS),
	                      len+sizeof(InternetAppBlock)+sizeof(TCHAR),
					  HF_SHARABLE, HAF_ZERO_INIT);
	  ptr = (InternetAppBlock*)MemLock(mh);
	  strcpy((char*)(ptr+1), MemLock(mh2));
	  MemFree(mh2);
	  }
    else {
	  mh = MemAlloc(sizeof(InternetAppBlock)+sizeof(TCHAR),
		                 HF_SHARABLE, HAF_ZERO_INIT);
	  ptr = (InternetAppBlock*)MemLock(mh);
	  }
  
    ptr->IAB_type = IADT_URL;

    MemLock(mh);

    alb = (AppLaunchBlock*)MemLock(hLaunchBlock);

    alb->ALB_extraData = mh;

    MemUnlock(hLaunchBlock);

    iacpConnectionToken = IACPConnect( &serverGeodeToken,
				     IACPSM_NOT_USER_INTERACTIBLE,
				     hLaunchBlock, 
				     NullOptr, 
				     &serverCount );
  
    if( IACP_NO_CONNECTION != iacpConnectionToken ) {
	  /* close the IACP connection */
	  IACPShutdown( iacpConnectionToken, NullOptr );

    //	  @send, forceQueue GeodeGetOptrNS(@IRCApp)::MSG_META_QUIT();
	  }

}

/***********************************************************************
 *	MSG_IRC_OPENING_AUI_CHOICE for IRCProcessClass
 ***********************************************************************
 * SYNOPSIS:     goes from the opening AUI to Browser or set connections
 *                   dialog box
 * PARAMETERS:  
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:	    
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jfh	3/23/00	Initial Revision
 *
 ***********************************************************************/
@method IRCProcessClass, MSG_IRC_OPENING_AUI_CHOICE
{
/*word		choice;
AccessFlags		pcAccess;


    choice = @call GeodeGetOptrNS(@IRCChoiceGroup)::
						MSG_GEN_ITEM_GROUP_GET_SELECTION();
    if (choice == 1) {
	  /* go to browser */
/*	  @send self::MSG_IRC_GO_TO_CHAT_PORTAL();
	  /* and shut down */
/*	  @send, forceQueue GeodeGetOptrNS(@IRCApp)::MSG_META_QUIT();
	  }
    else  { /* let user set up IRC */
	  /* swap primaries */
/*	  @send GeodeGetOptrNS(@IRCPrimary)::MSG_GEN_SET_USABLE(VUM_NOW);
	  @send GeodeGetOptrNS(@IRCChoicePrimary)::MSG_GEN_SET_NOT_USABLE(VUM_NOW);

	  /* check for parental control */
/*	  pcAccess = ParentalControlGetAccessInfo();
	  /* if no access, ask for password */
/*	  if (pcAccess & AF_CHATROOM)  {
		G_startupPassword = TRUE;
		if (@call GeodeGetOptrNS(@PCRoot)::MSG_PC_CHECK_PASSWORD_DB(PC_CHAT) == IC_OK) {
		   /* allow access */
/*		   }
		else {
		   @send, forceQueue GeodeGetOptrNS(@IRCApp)::MSG_META_QUIT();
		   }
		G_startupPassword = FALSE;
		}
		
    strcpy(G_currentChannel, "No open Channel yet");
    @call GeodeGetOptrNS(@IRCApp)::MSG_IRC_NEW_CHANNEL();

	  /* and open the connect dbox */
/*	  @send GeodeGetOptrNS(@IRCConnectDialog)::MSG_GEN_INTERACTION_INITIATE();
	  }
*/

}


/***********************************************************************
 *	MSG_IRC_OPEN_PRIVATE_MESSAGE, MSG_IRC_SEND_IGNORE for IRCProcessClass
 ***********************************************************************
 * SYNOPSIS:     send message to active IRCList
 *
 * PARAMETERS:  
 *
 * SIDE EFFECTS:
 *
 * STRATEGY:	    
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	brianc	5/20/00         Initial Revision
 *
 ***********************************************************************/
@method IRCProcessClass, MSG_IRC_OPEN_PRIVATE_MESSAGE, MSG_IRC_SEND_IGNORE
{
    optr channel, list;

    if (@call IRCDisplayGroup::MSG_META_GET_TARGET_EXCL(&channel)) {
	list = ConstructOptr(OptrToHandle(channel), OptrToChunk(@IRCList));
	if (message == MSG_IRC_OPEN_PRIVATE_MESSAGE) {
	    @send list::MSG_OPEN_PRIVATE_MESSAGE();
	} else if (message == MSG_IRC_SEND_IGNORE) {
	    @send list::MSG_SEND_IGNORE();
	}
    }
}

