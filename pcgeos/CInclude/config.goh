/***********************************************************************
 *
 *	Copyright (c) GeoWorks 1993 -- All Rights Reserved
 *
 * PROJECT:	  
 * MODULE:	  
 * FILE:	  config.goh
 *
 * AUTHOR:  	  Adam de Boor: Apr  6, 1993
 *
 * REVISION HISTORY:
 *	Name	  Date	    Description
 *	----	  ----	    -----------
 *	ardeb	  4/ 6/93    Initial version
 *
 * DESCRIPTION:
 *	Definition file for the config library
 *
 * 	$Id: config.goh,v 1.1 97/04/04 15:57:43 newdeal Exp $
 *
 ***********************************************************************/

@include <ui.goh>
#include <dbase.h>

/*=============================================================================
 *
 *		     Module Interface Definition
 *
 *===========================================================================*/

/*
 * Revision level of this interface. These constants must be *outside* of the
 * StartLibrary so they end up in the symbol table of the module, and can thus
 * be used by Glue to set the protocol number of the module.
 */ 
#define PREF_MODULE_PROTO_MAJOR	2
#define PREF_MODULE_PROTO_MINOR	0

@deflib	config
 
/* 
 * Note that unlike normal UI features, the user cannot set these flags
 * directly.  Instead, they are normally set by running a small
 * "launcher" app which passes the flags to PrefMgr in the extra data
 * block.  DO NOT Rearrange these bits without changing the
 * usabilityTable in prefmgrApplication.asm
 */
typedef WordFlags PrefMgrFeatures;
#define	PMF_HARDWARE	0x8000
	/* These settings are for a user who has permissions to
	 * actually change the configuration of the workstation.  In a
	 * network environment where users log in to different machines
	 * at different times, normal users would be prevented from
	 * changing the mouse & video drivers, etc. */

#define	PMF_SYSTEM	0x4000
	/* These changes are more complex & potentially more damaging
	 * than the basic "user" changes, therefore, some users may be
	 * prevented from using these settings. */

#define PMF_NETWORK	0x2000
	/* Network settings -- generally only the system administrator
	 * will see these settings */

#define	PMF_USER	0x1000
	/* These are basic user changes -- normally this flag works the
	 * opposite way of the other flags -- by default all UI is
	 * "on", but if the user flag is off, then some basic UI might
	 * go away.  This would allow a network administrator, for
	 * example, to look at a scaled-down, "network-only" prefmgr. */


/*
 * Entry points for the Preferences Modules.  Each module (library)
 * MUST have the following routines exported in its .gp file, in the
 * following order, as the FIRST routines exported from that library.
 */
typedef enum {
    PMET_FETCH_UI,  	    /* Return the OD of the top-most object in the UI
			     * tree. All UI *must* be in the same segment as
			     * this object. The UI tree will be duplicated by
			     * the application, and added to the app's generic
			     * tree.
			     *
			     * Parameters:  optr _pascal (void)
			     */
    PMET_GET_MODULE_INFO,   /* Return information about this module that will
			     * be used to determine whether to display it
			     * on-screen, what it will look like, etc, etc. 
			     *
			     * Parameters: void _pascal (PrefModuleInfo *)
			     */
} PrefModuleEntryType;

typedef	struct {
	PrefMgrFeatures	    PMI_requiredFeatures;
	PrefMgrFeatures	    PMI_prohibitedFeatures;
	UIInterfaceLevel    PMI_minLevel;
	UIInterfaceLevel    PMI_maxLevel;
	optr	    	    PMI_monikerList;
	GeodeToken	    PMI_monikerToken;
} PrefModuleInfo;

	


/*---------------------------------------------------------------------------
 *	TOC FILE		
 *---------------------------------------------------------------------------*/
#define DT_UNKNOWN	(-1)
 /* When the source disk for a file is unknown */

#define DT_EXTRA_ENTRY	(-2)
 /* item is a temporary entry.  File is on the hard disk. */


/* This structure is the map item of the TOC file.
 * The TOC file consists of two main arrays -- the DISKS array and the
 * CATEGORIES array.   */

typedef	struct {
	DBGroupAndItem	TM_disks;
	DBGroupAndItem	TM_categories;
} TocMap;

typedef	struct {
	VolumeName	TDSS_volumeName;
	MediaType	TDSS_mediaType;
 	TCHAR	    	TDSS_name[1];
} TocDiskStruct;


/*---------------------------------------------------------------------------
 *	UPDATING A CATEGORY		
 *---------------------------------------------------------------------------
 * Certain operations (opening a device list, scanning for modules), cause a
 * category to be updated, which means that the files are scanned, and
 * the list is maintained, etc.  Each category in question is
 * identified by its token chars, which MUST be unique across all
 * categories.  Normally, a category consists of an array of FILES,
 * each element of which is of size TocFileStruct.  However, a custom
 * array may be created, in which elements are of the passed size.  If
 * a custom array is used, the caller must specify a callback routine
 * that gets called when a new element is added to the array.
 */


typedef WordFlags TocUpdateCategoryFlags;
#define	TUCF_EXTENDED_DEVICE_DRIVERS	0x8000
	/* Files being enumerated are assumed to be extended device drivers. */

#define	TUCF_CUSTOM_FILES   	    	0x4000
	/* The TUCP_fileArrayElementSize field will be
	 * used when creating the files array.  Otherwise, each element
	 * of the files array will be of size TocFileStruct.  NOTE:  If
	 * this flag is used, the data structure used for each file
	 * element MUST contain TocFileStruct as its first element. */

#define	TUCF_ADD_CALLBACK   	    	0x2000
	/* TUCP_addCallback contains a fptr to a callback
	 * routine that will be called when a file is added to the
	 * files array. */

#define	TUCF_DIRECTORY_NOT_FOUND    	0x1000
	/* Don't actually scan the directory, because it doesn't exist.
	 * Just create the category, and leave it empty. */
 
typedef word _pascal TocUpdateAddCallback(const char *filename,
				    	  optr chunkArray);
	/* Return 0 if add aborted, else return offset of new element within
	 * block */

typedef struct {
	TocUpdateCategoryFlags	TUCP_flags;
	TokenChars		TUCP_tokenChars;
	byte	    	    	TUCP_fileArrayElementSize;

	TocUpdateAddCallback	*TUCP_addCallback;
	byte	TUCP_pad;   	/* Wants to be word-aligned */
} TocUpdateCategoryParams;


/* This is the element structure for each element in the categories
 * array.  */
typedef	struct {
	TokenChars	TCS_tokenChars;
	DBGroupAndItem	TCS_files;	/* file name array */
	DBGroupAndItem	TCS_devices;	/* device name array -- only if
					 * TCF_EXTENDED_DEVICE_DRIVERS
					 * is set. */
} TocCategoryStruct;

typedef	struct {
	word	    	TFS_sourceDisk;		/* disk token */
	ReleaseNumber	TFS_release;
	TCHAR	    	TFS_name[1];
} TocFileStruct;

typedef struct {
	word	TDS_driver;		/* element in driver array */
	word	TDS_info;		/* extra word of info (depends
					 * on device type)	 */

	TCHAR	TDS_name[1];
} TocDeviceStruct;

#define TOC_NAME_MAX_LENGTH 64
#define TOC_ELEMENT_BUFFER_SIZE	((size TocDeviceStruct) + (TOC_NAME_MAX_LENGTH * sizeof(TCHAR)))


/*---------------------------------------------------------------------------
 *	STRUCTURES		
 *---------------------------------------------------------------------------*/

typedef ByteFlags PrefInitFileFlags;

#define	PIFF_USE_ITEM_STRINGS	    	    0x80
	/* If set, then the item group's children must be of class
	 * PrefStringItemClass, and their strings will be used to
	 * interact with the init file. */

#define	PIFF_USE_ITEM_MONIKERS	    	    0x40
	/* If set, then the monikers of the items are used to interact
	 * with the init file. */

#define	PIFF_APPEND_TO_KEY  	    	    0x20
	/* If set, the strings in this list will be ADDED to strings
	 * that may already exist for this key */

#define	PIFF_ABSENT_KEY_OVERRIDES_DEFAULTS  0x10
	/* If set, an absent key for the item group will cause it to
	 * behave as if an empty key were in the ini file, effectively
	 * overriding any default values stored with the group when it was
	 * compiled. Used primarily by those groups where one subclasses
	 * MSG_PREF_STRING_ITEM_CHECK_IF_IN_INIT_FILE_KEY to determine the
	 * initial setting, rather than looking in the ini file. */


#define	PIFF_SUSPEND_ON_LOAD_OPTIONS	    0x08
	/* Suspend the item group when loading options, to keep it from
	 * sending out status messages, etc. */

#if DBCS_GEOS
#define	PIFF_NUMERIC_MONIKERS		    0x04
	/* Used with PIFF_USE_ITEM_MONIKERS to force item to be stored in
	 * init file as an integer rather than a string.  Only relevant for
	 * DBCS.  For this to work, PIFF_APPEND_TO_KEY and
	 * ATTR_PREF_ITEM_GROUP_EXTRA_STRING_SECTION mustn't be set, and
	 * the item group must be exclusive or exclusive-none, and the
	 * numeric moniker must be in the range 0-65535. */
#endif





typedef ByteFlags PrefEnableFlags;
#define	PEF_DISABLE_IF_SELECTED	    0x80
	/* if set, disable the object if the associated item is selected,
	 * otherwise do the opposite. */

#define	PEF_DISABLE_IF_NONE 	    0x40
	/* If this flag is set, then the PED_item field is ignored.
	 * Instead, the item group will disable the specified object if
	 * no items are selected -- or if there are no items in the list. */

typedef ByteFlags PrefCategoryFlags;
#define	PCF_DELETE_IF_SELECTED	    0x80
	/* If set, delete the category if the item is selected.
	 * Otherwise, the category will be created if the item is
	 * selected, and deleted otherwise. */

typedef	struct {
	word	    	    PCD_item;
	/* Item identifier to control deletion/creation of category */

	PrefCategoryFlags   PCD_flags;
} PrefCategoryData;

	
typedef	struct {
	word	    	PED_item;   /* Identifier of the item that controls
				     * enabling / disabling of object.  If the
				     * identifier is GIGS_NONE, then the action
				     * will be performed if no items are
				     * selected. */
	ChunkHandle 	PED_lptr;   /* Object to be enabled/disabled */
	PrefEnableFlags	PED_flags;
} PrefEnableData;


/*=============================================================================
 *
 *			      PrefClass
 *
 * The root class of the various subclasses of generic objects used to
 * implement new Preferences modules. Each of these subclasses
 * performs various functions beyond the basic save/load options
 * functionality provided by the generic object of which they are a
 * subclass.
 *
 * PrefClass is a variant master class, meaning each subclass of it will be
 * asked at runtime what its generic superclass should be, if it's not
 * already been specified (when you define these objects in a resource, they
 * are already built to the Gen level).
 *
 * PrefClass exists to provide common functionality required by all the various
 * Pref subclasses, define messages implemented by every subclass, and define
 * instance data required to implement the common functionality.
 *===========================================================================*/

#define ObjDerefPref(op)	ObjDeref((op),offsetof(PrefBase,Pref_offset))

@class PrefClass, GenClass, master, variant;

@message void MSG_PREF_SET_INIT_FILE_CATEGORY(const char *category = cx:dx);
/*
 * Change the value of vardata ATTR_GEN_INIT_FILE_CATEGORY
 *
 * Context:	
 * Source:	
 * Destination:  
 * Interception: 
 *
 */

@message Boolean MSG_PREF_HAS_STATE_CHANGED() = carry;
/*
 * Determine whether this object, or any of its children, have changed
 * since the last LOAD_OPTIONS
 *
 * Context:	Part of APPLY/SAVE OPTIONS mechanism
 * Source:	
 * Destination:  
 * Interception: 
 *
 */

@message optr MSG_PREF_GET_REBOOT_INFO() = cx:dx;
/*
 * Sent to any of the "Pref" objects to see if the system needs
 * rebooting as a result of changes.
 *
 * Context:	    APPLY mechanism in PrefMgr
 * Source:
 * Destination:     any "Pref" object
 * Interception:    subclass should determine whether state has changed,
 * 	    	    and, if so, what reboot message to put up on
 * 	    	    screen.  If reboot is * never needed for a class,
 * 	    	    then no need to do anything.
 *
 * Return:	IF NEEDS REBOOT:
 *			OD of string to put up in ConfirmDialog (placed
 *	    	    	in the middle of a sentence)
 *		ELSE
 *			0
 */

@message optr MSG_PREF_GET_REBOOT_STRING() = cx:dx;
/*
 * Return the optr of a string in a sharable lmem resource that will be
 * displayed in the reboot dialog.  If this object doesn't have such a
 * string, it will call its gen parent (if the GenParent is a subclass
 * of PrefClass).
 *
 *
 * Return:	optr of string (cx = 0 if not found)
 */

@message void MSG_PREF_INIT(PrefMgrFeatures features=cx,
			    UIInterfaceLevel level=dx);
/*
 * Initialize this object.   Perform any setup that's required when the
 * object first comes on-screen.  This message is sent from a
 * PrefDialog to all of its children when the dialog is first
 * initiated. 
 *
 * Context:	    Part of initialization mechanism
 * Source:	    generic parent
 * Destination:     any PrefClass object
 * Interception:    default behavior is to determine whether to make the
 * 		    object usable based on UI level and features (or will
 * 		    be, when implemented).  Subclass should call
 * 		    superclass before handling, as subclass behavior may
 * 		    be different if the object is not usable, etc.
 */

@message void MSG_PREF_NOTIFY_DIALOG_CHANGE(PrefDialogChangeType type=cx);
/* Message sent out over PDGCNLT_DIALOG_CHANGE list bound to PrefDialog object,
 * telling interested parties of a change in the box's state.
 *
 * Context:	    Sent when the dialog box is being opened, closed, or
 *	    	    destroyed.
 * Source:	    PrefDialogClass
 * Destination:     Any Pref object registered on PDGCNLT_DIALOG_CHANGE
 * Interception:    Must be intercepted to do anything (no default handler)
 */

typedef enum {
    PDCT_OPEN,
    PDCT_CLOSE,
    PDCT_DESTROY,
    PDCT_RESTART,
    PDCT_SHUTDOWN
} PrefDialogChangeType;

@message void MSG_PREF_SET_ORIGINAL_STATE();
/*
 * Copy this object's current state to the "original" settings, which
 * will be restored on a MSG_GEN_RESET.
 *
 */


/*---------------------------------------------------------------------------
 *	INSTANCE DATA		
 *---------------------------------------------------------------------------*/
typedef ByteFlags PrefAttributes;
#define	PA_REBOOT_IF_CHANGED	0x80
	/* This bit signals that changes in the state of this object
	 * require a system reboot to take effect. */

#define	PA_LOAD_IF_USABLE   	0x40
	/* Load options only if this object is usable (this is ON by
	 * default). */

#define	PA_SAVE_IF_USABLE   	0x20
	/* Save options only if this object is usable (this is ON by
	 * default)  */

#define	PA_SAVE_IF_ENABLED  	0x10
	/* Save options only if this object is enabled */

#define	PA_SAVE_IF_CHANGED  	0x08
	/* Save options only if this object has changed. */


	@instance PrefAttributes PI_attrs = (PA_LOAD_IF_USABLE|PA_SAVE_IF_USABLE);

/*---------------------------------------------------------------------------
 *	VARIABLE DATA		
 *---------------------------------------------------------------------------*/

@vardata optr ATTR_PREF_REBOOT_STRING;
/* This is the string passed to MSG_PREF_MGR_DO_REBOOT_DIALOG -- the
 * string must be in a SHARABLE LMEM resource and is incorporated into the
 * middle of another sentence. In English, the sentence is "The system software
 * will shut down and restart to change the <reboot_string>. Do you wish
 * to proceed?"
 *
 * If an object has its PA_REBOOT_IF_CHANGED attribute set, it will scan for
 * this attribute, first in itself, then up the generic tree, until it
 * finds one. */
@reloc ATTR_PREF_REBOOT_STRING, 0, optr;

@vardata PrefMgrFeatures ATTR_PREF_REQUIRED_FEATURES;
/* features bits that MUST be set for this object to be usable. */

@vardata PrefMgrFeatures ATTR_PREF_PROHIBITED_FEATURES;
/* features bits that MUST NOT be set for this object to be usable. */

@vardata UIInterfaceLevel ATTR_PREF_MIN_LEVEL;
/* interface level below which this object will not be usable */

@vardata UIInterfaceLevel ATTR_PREF_MAX_LEVEL;
/* interface level above which this object will not be usable */


@endc;

/*============================================================================
 *
 *			    PrefValueClass
 *
 * A subclass of GenValue to implement MSG_GEN_RESET automatically, as well
 * as the standard functionality implemented by all Pref objects.
 * Unlike GenValueClass, this class only deals with word-sized INTEGER
 * values. 
 *
 *===========================================================================*/


@class PrefValueClass, PrefClass;
	@default Pref = GenValueClass;


@message void MSG_PREF_VALUE_SET_ORIGINAL_VALUE(word orig=cx,
						Boolean indeterminate=bp);
/*
 * Set the original value of a PrefValue object -- also sets the value
 * of the superclass.
 *
 *
 * Context:	usually sent during startup of pref module
 * Source:	app
 * Destination: any PrefValue object
 * Interception: not likely
 */

/*---------------------------------------------------------------------------
 *		INSTANCE DATA
 *---------------------------------------------------------------------------*/

@vardata void ATTR_PREF_VALUE_ORIG_IS_INDETERMINATE;

@vardata word ATTR_PREF_VALUE_ROUND;
/*
 * Specifies an integer value to which the value will be rounded on
 * init file reads/writes
 */

@protominor AttrPrefValueWrap

@vardata word ATTR_PREF_VALUE_WRAP;

@protoreset

/*
 * If the value is incremented beyond its top value, it will "wrap
 * around" to its bottom value, and vice versa.
 */

    @instance word	PVI_originalValue = 0;

@endc;

/*===========================================================================
 *
 *			PrefValueZeroPadClass
 *
 * A subclass of PrefValueClass.  This is used in PrefTimeDateControl
 * objects in the Dove project for ensuring that 2-digit numbers
 * (e.g. months, dates, hours) will appear with a leading 0 if they're less
 * than 10.
 *
 *=========================================================================*/
@class PrefValueZeroPadClass, PrefValueClass;
	@default Pref = GenValueClass;
/*---------------------------------------------------------------------------
 *		INSTANCE DATA
 *-------------------------------------------------------------------------*/

/*
 * Boolean flag to indicate whether this is an hour field or not.  The hour
 * field may need to have AM/PM inserted depending on whether the user's
 * selected 24-hour or 12-hour mode.
 */
    @instance Boolean	PVZPI_isHour = FALSE;

@endc;


/*===========================================================================
 *
 *			  PrefItemGroupClass
 *
 * This GenItemGroup subclass has extended functionality for
 * reading/writing strings to the .INI file -- setting text objects
 * from the selected item's moniker (there is also some functionality
 * in GenItemGroupClass to do this, but it was not there when this
 * class was first written), etc.
 *
 * INHERITANCE:
 * 
 * MSG_META_LOAD_OPTIONS - calls superclass, saves original state for RESET
 *			  mechanism, sends out status message.
 *
 * MSG_GEN_LOAD/SAVE_OPTIONS - can be configured to use item monikers or
 *			      optional additional strings to load/save options.
 *			      See PrefInitFileFlags for more info.
 *
 * MSG_GEN_APPLY - will update the text object specified in
 *		  ATTR_PREF_ITEM_GROUP_TEXT_DISPLAY, if any.
 *
 * MSG_GEN_RESET - will reset settings to original values, and also
 *		  update the text display
 *
 *===========================================================================*/

@class PrefItemGroupClass, PrefClass;
    @default Pref = GenItemGroupClass;

/*--------------------------------------------------------------------------
 *		MESSAGES		
 *--------------------------------------------------------------------------*/

@message void MSG_PREF_ITEM_GROUP_SET_ORIGINAL_SELECTION(word selection=cx);
/*
 * Set the "originalSelection" field of the item group.  Also, sends
 * MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION to superclass.
 *
 *
 * Context:	usually sent from app during startup of pref module
 * Source:	anywhere
 * Destination:  an EXCLUSIVE prefItemGroup
 * Interception: not likely
 */

@message word MSG_PREF_ITEM_GROUP_GET_SELECTED_ITEM_TEXT(char *buffer=cx:dx,
							 word bufSize=bp) = bp;
/*
 * Return the text in the moniker of the selected item. Value returned is the
 * number of characters in the string. If nothing selected, value returned is 0
 */


@message word MSG_PREF_ITEM_GROUP_GET_ITEM_MONIKER(@stack TCHAR *buffer,
						   word bufSize,
						   word identifier) = bp;
/*
 * Get the text in the moniker of one of the items of a PrefItemGroup.  Works
 * for dynamic list subclasses as well. Returns number of characters in the
 * returned text.
 */

@message void MSG_PREF_ITEM_GROUP_UPDATE_TEXT(ChunkHandle textObject=cx);
/* Update the specified text object with text of the currently selected
 * item.   The PrefItemGroup sends this to itself in conjunction with
 * either  ATTR_PREF_ITEM_GROUP_TEXT_DISPLAY or  
 * ATTR_PREF_ITEM_GROUP_STATUS_TEXT.   By default, this message will
 * also cause the text object to send out its status message.
 *
 * Source:	    self
 * Destination:     self
 * Interception:    default behavior is to fetch the moniker of the
 * 		    current selection, and sent that to the text.
 * 		    Subclasser can use different text, if desired
 */

#define PREF_ITEM_GROUP_STRING_BUFFER_SIZE	256
#define PREF_ITEM_GROUP_MAX_SELECTIONS 	    	16

typedef struct {
	TCHAR _near	*PIGSV_endPtr;
	word	    	PIGSV_selections[PREF_ITEM_GROUP_MAX_SELECTIONS];
	word 	    	PIGSV_numSelections;
	TCHAR	    	PIGSV_buffer[PREF_ITEM_GROUP_STRING_BUFFER_SIZE];
} PrefItemGroupStringVars;




/*----------------------------------------------------------------------------
 *		INSTANCE DATA		
 *----------------------------------------------------------------------------*/

	@instance PrefInitFileFlags	PIGI_initFileFlags = 0;
	@instance word	PIGI_originalSelection = 0;
	@instance word PIGI_originalNumSelections = 0;
	@instance byte PIGI_suspendCount = 0;


/*---------------------------------------------------------------------------
 *		VARDATA		
 *---------------------------------------------------------------------------*/

	@vardata PrefEnableData	ATTR_PREF_ITEM_GROUP_ENABLE;
	/* allows setting up an object to be enabled/disabled when
	 * settings are made in the item group */

	@vardata word	ATTR_PREF_ITEM_GROUP_OVERRIDE;
	/* This attribute is used to specify an item which will act
	 * as an OVERRIDE for all other items (in a non-exclusive
	 * item group).
	 *
	 * When the specified item is SELECTED, then all other items
	 * are DE-SELECTED.
	 *
	 * When any other item is SELECTED, the override item is
	 * DE-SELECTED. 
	 * 
	 * If all items are DE-SELECTED, the override item becomes SELECTED */

	@vardata ChunkHandle ATTR_PREF_ITEM_GROUP_TEXT_DISPLAY;
	/* chunk handle of a GenText object that will be updated
	 * with the moniker of the currently selected item on APPLY /
	 * RESET.  */

	@vardata ChunkHandle ATTR_PREF_ITEM_GROUP_STATUS_TEXT;
	/* chunk handle of a GenText object that will be updated every
	 * time this object receives a
	 * MSG_GEN_ITEM_GROUP_SEND_STATUS_MSG.   */


	@vardata TCHAR[] ATTR_PREF_ITEM_GROUP_EXTRA_STRING_SECTION;
	/* If a string is given -- the string will always be written
	 * out as the FIRST string section for the .INI file key.  For
	 * example, the "Memory" item group uses this to always insert
	 * "disk.geo" whenever writing out the memory types.  Note:
	 * this item is only written if the item group has either the
	 * PIFF_USE_ITEM_MONIKERS or PIFF_USE_ITEM_STRINGS set. */


@endc;

/*============================================================================
 *
 *			 PrefStringItemClass
 *
 * This GenItem subclass is used with PrefItemGroup, if the
 * "useItemStrings" flag is set.  Each item has a string that will be
 * written/read to the .INI file.  Note that if
 * PIFF_USE_ITEM_MONIKERS is used instead, then normal GenItem objects
 * can be used.
 *
 *============================================================================*/
@class PrefStringItemClass, GenItemClass;

/*---------------------------------------------------------------------------
 *	MESSAGES		
 *---------------------------------------------------------------------------*/
 
@message void MSG_PREF_STRING_ITEM_SET_INIT_FILE_STRING(const char *str=cx:dx);
/*
 * Set the string that's read/written to the init file.
 *
 * Context:	
 * Source:	    anywhere
 * Destination:     any StringItemClass object
 * Interception:    unlikely but possible.  Default behavior sets the
 *		    string and then checks again with the .INI file to make
 *		    sure item should be selected.
 */

@message Boolean MSG_PREF_STRING_ITEM_CHECK_IF_IN_INIT_FILE_KEY(PrefItemGroupStringVars *vars = ss:bp) = carry;
/*
 * Check the passed string to see if the string bound to this item is in one of
 * its pieces.
 *
 * Context:	    Sent by PrefItemGroup with PIFF_USE_ITEM_STRINGS set when it
 *		    is loading options.
 * Source:	    PrefItemGroup
 * Destination:	    PrefStringItem
 * Interception:    May be intercepted if the subclass needs to check other
 *		    things to decide whether it should be selected. If you wish
 *		    to also have the default behaviour, you may call the
 *		    superclass either before or after you've made your own
 *		    decision, as appropriate.
 *
 * Return:	TRUE if bound string is within the string stored in the local
 *		variable.
 */
	@instance ChunkHandle PSII_initFileString = 0;

@endc;

/*============================================================================
 *
 *			PrefBooleanGroupClass
 *
 *============================================================================*/
  
@class PrefBooleanGroupClass, PrefClass;
	@default Pref = GenBooleanGroupClass;

/*---------------------------------------------------------------------------
 *	MESSAGES
 *---------------------------------------------------------------------------*/
 
@message void MSG_PREF_BOOLEAN_GROUP_SET_ORIGINAL_STATE(word state = cx);
/*
 * Set the original state of the boolean group.
 *
 * Context:	
 * Source:	
 * Destination:  
 * Interception: 
 */

    @vardata void ATTR_PREF_BOOLEAN_GROUP_SEPARATE_BOOLEAN_KEYS;

	@instance PrefInitFileFlags	PBGI_initFileFlags = 0;
	@instance word	PBGI_originalState = 0;

@endc;

/*============================================================================
 *
 *			 PrefDynamicListClass
 *
 *============================================================================*/
@class PrefDynamicListClass, PrefItemGroupClass;
	@default Pref = GenDynamicListClass;

/*---------------------------------------------------------------------------
 *	MESSAGES		
 *---------------------------------------------------------------------------*/
@message void MSG_PREF_DYNAMIC_LIST_BUILD_ARRAY();
/*
 * Context:	The PrefDynamicList sends itself this message when it
 * 		receives MSG_INIT (normally sent when the dialog is
 *		initiated) 
 * Source:	PrefDynamicListClass
 * Destination:  SUBCLASS of PrefDynamicListClass
 * Interception: The subclasser should create an array of item strings
 * 		-- sorted, ideally.
 */
 
@message Boolean MSG_PREF_DYNAMIC_LIST_FIND_ITEM(word *itemPtr = multipleax,
						 const char *str = cx:dx,
						 Boolean ignoreCase = bp) = carry;
/*
 * Find an item given a (possible) item moniker.  
 *
 * Context:	Part of LOAD OPTIONS mechanism
 * Source:	PrefDynamicList sends this to itself when loading
 * 		options. 
 * Destination:  Any PrefDynamicList subclass
 * Interception: There is NO default behavior -- subclasser MUST handle
 * 		this. See PrefDeviceListClass and
 * 		PrefNetQListClass for examples of how this is handled.
 *
 * Return:	TRUE if found, *itemPtr = item #
 *	    	FALSE if not found, *itemPtr = first item after requested item
 *	    	    (lexicographically speaking)
 *			carry clear
 */


@message void MSG_PREF_DYNAMIC_LIST_TIMER();	/* private */
/*
 * INTERNAL -- the pref dynamic list sends this message to itself
 * a few seconds after a key is pressed to flush the keyboard buffer.
 */


/*---------------------------------------------------------------------------
 *	VARDATA		
 *---------------------------------------------------------------------------*/
 
#define PDL_CHAR_BUFFER_SIZE 	32
#define PDL_CHAR_MAX_COUNT  	(PDL_CHAR_BUFFER_SIZE -1)

typedef	struct {
	char	PDLKD_buffer[PDL_CHAR_BUFFER_SIZE];
	word	PDLKD_count; 	    /* # chars in buffer */

	word	PDLKD_timerHandle;
	word	PDLKD_timerID;
} PDLKbdData;


    @vardata PDLKbdData TEMP_PDL_KBD_DATA;

@endc;


/*============================================================================
 *
 *			   PrefIniDynamicListClass
 *
 *============================================================================*/

@class PrefIniDynamicListClass, PrefDynamicListClass;

	@instance optr	PIDLI_array = 0;

	@vardata TCHAR[] ATTR_PREF_INI_INIT_FILE_LIST_CATEGORY; 
	@vardata TCHAR[] ATTR_PREF_INI_INIT_FILE_LIST_KEY;

@endc 

/*============================================================================
 *
 *			   PrefTocListClass
 *
 *============================================================================*/
 
@class PrefTocListClass, PrefDynamicListClass;


@message Boolean MSG_PREF_TOC_LIST_GET_SELECTED_ITEM_INFO(word *infoPtr = multipleax) = carry;
/*
 * Return the info word about the currently selected item.  This
 * message can only be used with PrefTocLists that have the
 * TCF_EXTENDED_DEVICE_DRIVERS FLAG set.
 *			
 * Return:	FALSE if found, *infoPtr = info
 */

@message word MSG_PREF_TOC_LIST_GET_SELECTED_DRIVER_NAME(char *buf = cx:dx,
							 word bufSize = bp) = bp;
/*
 * Return the name of the driver for the selected device.  Can only be
 * called if TCF_EXTENDED_DEVICE_DRIVERS is set.
 *
 * Return:	returns # of chars returned if buffer big enough, else 0
 */

typedef struct {
    word	TIP_disk;	/* disk handle */
    MemHandle	TIP_pathBlock;	/* Handle of block holding path (locked) */
    char	*TIP_path;	/* Locked null-terminated absolute path */
} TocItemPath;

@message void
    MSG_PREF_TOC_LIST_GET_SELECTED_ITEM_PATH(TocItemPath *retValue = bpaxdxcx);

/* Get the absolute path of the selected item.
 *
 * Pass:	pointer to TocItemPath
 * Return:	TocItemPath filled in
 */

@message Boolean MSG_PREF_TOC_LIST_CHECK_DEVICE_AVAILABLE(word *retvalPtr = multipleax) = carry;
/*
 * Determine if the device selected by the list is available in the
 * machine.  May only be called for PrefTocLists that have the
 * TCF_EXTENDED_DEVICE_DRIVERS flag set.
 *

 * Return: TRUE if device is available. If driver is a video driver,
 * 	   *retvalPtr is set to the device's DisplayType.  FALSE if
 *         device isn't available. *retvalPtr is 0 if the device
 *         doesn't exist, or GeodeLoadError+1 if driver couldn't be
 *         loaded.
 */

@message void MSG_PREF_TOC_LIST_SET_TOKEN_CHARS(TokenChars *chars = ss:bp);

@protominor  NewForNDO2000

@message void MSG_PREF_TOC_LIST_GET_DOS_NAME(TCHAR *buf = cx:dx);

@protoreset

/*---------------------------------------------------------------------------
 *	INSTANCE DATA
 *---------------------------------------------------------------------------*/
	@instance TocUpdateCategoryFlags	PTLI_flags = 0;
	@instance TocCategoryStruct	PTLI_tocInfo = {"", 0, 0};
 

/*---------------------------------------------------------------------------
 *	VARIABLE DATA		
 *---------------------------------------------------------------------------*/
typedef struct {
	ChunkHandle PTEE_item;
	/* lptr of item name.  For device lists, this is the device.
	 * For others, this is the filename */

	ChunkHandle PTEE_driver;
	/* Driver name (for device lists ONLY) */

	word	PTEE_info;
	/* Extra word of information */
} PrefTocExtraEntry;


@vardata PrefTocExtraEntry	ATTR_PREF_TOC_LIST_EXTRA_ENTRY_1; 

@vardata PrefTocExtraEntry	ATTR_PREF_TOC_LIST_EXTRA_ENTRY_2 ;


@vardata char ATTR_PREF_TOC_LIST_INFO_KEY[];
/* This key is used to write the "info" word for device lists */

@vardata optr ATTR_PREF_TOC_LIST_CONTAINER;
/* PrefContainer object to which we should send the absolute path of the
 * preferences VM file/library associated with the current selection when
 * the selection changes. The file selected is the one whose FEA_NOTICE
 * extended attribute is the same as the longname of the selected
 * driver/library, after removing any "EC " prefix Glue might have prepended to
 * the name originally specified by the programmer. */

@protominor  NewForNDO2000

@vardata void ATTR_PREF_TOC_LIST_STORE_DOS_NAME;

@protoreset

@endc;

/*============================================================================
 *
 *			   TitledGlyphClass
 *
 *============================================================================*/

@class TitledGlyphClass, GenGlyphClass;
@endc;

/*============================================================================
 *
 *			 PrefInteractionClass
 *
 * INHERITANCE:
 *
 * MSG_META_LOAD/SAVE_OPTIONS - Sends these messages to each child that matches
 *			       the criteria based on its PrefAttrs record.
 *
 *============================================================================*/
@class PrefInteractionClass, PrefClass;
	@default Pref = GenInteractionClass;

typedef ByteFlags PrefInteractionAttrs;
#define	PIA_LOAD_OPTIONS_ON_INITIATE	0x80
	/* If set, then the dialog will send MSG_PREF_INIT, followed by
	 * MSG_META_LOAD_OPTIONS to itself when it receives a
	 * MSG_GEN_INTERACTION_INITIATE */

#define PIA_SAVE_OPTIONS_ON_APPLY   	0x40
	/* This flag is normally OFF, to allow non-dialog
	 * prefInteraction objects to reside inside other interactions
	 * without duplicate SAVE_OPTIONS messages being sent. */
#define PIA_COMPLETE_INTERACTION_ON_APPLY   	0x20

/*---------------------------------------------------------------------------
 *	INSTANCE DATA		
 *---------------------------------------------------------------------------*/
 
	@instance PrefInteractionAttrs	PII_attrs = 0;


@endc;



/*============================================================================
 *
 *			  PrefContainerClass
 *
 * An interaction that manages a read-only VM file or sub-library containing
 * other Pref objects, usually used to specify preferences for device drivers
 * or similar things that one doesn't wish to have dependent on the config
 * library.
 *
 * INHERITANCE:
 *
 * MSG_GEN_PATH_SET - Treats final component of path as file name, which it
 *		     strips off before passing it to its superclass. This is
 *		     how you tell it what file it should open.
 *
 *============================================================================*/

#define PREFVM_DOC_PROTO_MAJOR	2	/* Protocol number for an acceptable */
#define PREFVM_DOC_PROTO_MINOR	0	/*  VM file (must be outside library
					 *  segment so it can be used */

@class PrefContainerClass, PrefInteractionClass;
    @default Pref = GenInteractionClass;

@message void MSG_PC_CLOSE_HANDLE(word fileOrLibHandle=cx,
				  Boolean isLibrary = dx);
/* Close the VM file or unload the library containing the tree we were
 * managing.
 *
 * Context:	Sent by PrefContainer to itself using
 *		MSG_META_FLUSH_INPUT_QUEUES after having sent a
 *		MSG_META_BLOCK_FREE, if appropriate, to the tree it's
 *		been holding.
 * Source:	PrefContainerClass
 * Destination:	PrefContainerClass
 * Intercept:	Not intercepted.
 *
 */

typedef	struct {		/* Map block for a VM file this object can
				 *  handle. */
    dword	PVMMB_root;		/* Root of the object tree contained in
					 *  the VM file. Segment portion is VM
					 *  block handle */
} PrefVMMapBlock;

#define PREFVM_ATTRIBUTES	VMA_OBJECT_ATTRS or mask VMA_SYNC_UPDATE
					/* VMAttributes such a file must have.*/

    @instance word PCI_handle = 0;		/* Handle of open VM file, or
						 *  handle of library */
    @instance FileLongName PCI_fileName = _TEXT("");	/* Name of open file. */
    @instance ChunkHandle  PCI_templateMon = 0;	/* Template to use when
						 *  constructing our moniker.
						 *  \1 is replaced by the name
						 *  of the file whose objects
						 *  are being displayed. If 0,
						 *  no moniker is created. */
    @instance dword 	   PCI_dupRoot = 0; 	/* Root of duplicated tree. If
						 *  handle is 0, PCI_handle is
						 *  a VM file. */
    @default GI_states = @default & ~GS_USABLE;
@endc;



/*============================================================================
 *
 *			   PrefDialogClass
 *
 * INHERITANCE:
 * 
 * MSG_GEN_APPLY:
 *	Normally sends a MSG_META_SAVE_OPTIONS to all children.  If
 *	any of the children have their PA_REBOOT_IF_CHANGED flag set,
 *	then the dialog will determine if any children have changed
 *	state, and if so, will put up a reboot confirmation dialog
 *	box, before continuing.  Returns carry SET if apply aborted.
 *
 *
 *============================================================================*/
 
@class PrefDialogClass, PrefInteractionClass;
    @default Pref = GenInteractionClass;


@message void MSG_PREF_DIALOG_REBOOT();
/* Cause PC/GEOS to restart (doesn't return) */

@message Boolean MSG_PREF_DIALOG_CONFIRM_REBOOT(optr string = cx:dx) = carry;
/* Put up a yes/no dialog box asking user if s/he wants to restart the
 *  system to effect the change.
 *
 * Pass:	string - optr of string which will be inserted in a 
 *			 sentence of the form "The system software will
 *			 shut down and restart to change the XXX.
 *			 Do you wish to proceed?'
 * Return:	Boolean
 */

@message void MSG_PREF_DIALOG_RESTART_ACK(word restart=cx);
/* Internal message - sent by the kernel to the dialog object to
 * confirm that now is a good time to shutdown / restart.
 */

/*
 * GCN lists to which kids can add themselves. (step by 2)
 */
typedef enum {
    PDGCNLT_DIALOG_CHANGE=(int)_FIRST_PrefDialogClass,
    /* MSG_PREF_NOTIFY_DIALOG_CHANGE sent out. */
} GeoWorksPrefDialogGCNListType;

    @default GII_visibility = GIV_DIALOG;
    @default GII_type = GIT_PROPERTIES;
    @default GII_attrs = @default | GIA_NOT_USER_INITIATABLE |
    	GIA_MODAL;
    @default PII_attrs = @default | PIA_SAVE_OPTIONS_ON_APPLY;

/* 
 * VARDATA
 */

@vardata word ATTR_PREF_DIALOG_SYS_SHUTDOWN_TYPE;

@endc;

/*============================================================================
 *
 *			    PrefTextClass
 *
 * INHERITANCE:
 * 
 * MSG_META_LOAD_OPTIONS - saves text as originalText
 *
 * MSG_GEN_RESET - copies originalText string to current string
 *
 * MSG_PREF_HAS_STATE_CHANGED - compares originalText string to current
 *	string. 
 *
 *============================================================================*/

@class PrefTextClass, PrefClass;
	@default Pref = GenTextClass;

/*---------------------------------------------------------------------------
 *	INSTANCE DATA		
 *---------------------------------------------------------------------------*/
 
	@instance ChunkHandle PTI_originalText = 0;
	/* Text value immediately after LOAD_OPTIONS */

/*---------------------------------------------------------------------------
 *	VARDATA		
 *---------------------------------------------------------------------------*/
 
@vardata ChunkHandle ATTR_PREF_TEXT_INIT_FILE_CATEGORY_TARGET;
/* PrefTextClass has the wonderful ability that it can set another
 * object's init file category from its text.  Category gets updated
 * whenever the text object receives MSG_GEN_TEXT_SEND_STATUS_MSG */

@endc;


/*===========================================================================
 *	PrefTriggerClass.  This is not a "pref" class - it's just a
 *	normal old GenTrigger with the added functionality that
 *	additional messages can be sent out.
 *===========================================================================*/

@class PrefTriggerClass, GenTriggerClass;
/*---------------------------------------------------------------------------
 *	VARDATA		
 *---------------------------------------------------------------------------*/
typedef	struct {
	word	PTA_message;
	optr	PTA_dest;
} PrefTriggerAction;

@vardata PrefTriggerAction	ATTR_PREF_TRIGGER_ACTION;
/* Specifies an additional action to be performed.  There may be more
 * than one of these -- they'll be processed in order. */
    @reloc ATTR_PREF_TRIGGER_ACTION, PTA_dest, optr;

@endc;

/*===========================================================================
	PrefControlClass
 *===========================================================================*/
@class PrefControlClass, PrefInteractionClass;
	@default Pref = GenControlClass;
@endc;

/*===========================================================================
	PrefTimeDateControlClass
 *===========================================================================*/
@class PrefTimeDateControlClass, PrefControlClass;
	@default Pref = GenControlClass;

/* Internal messages */
@message void MSG_PTDC_TIMER_TICK();
@message void MSG_PTDC_MONTH_CHANGE();
@message void MSG_PTDC_YEAR_CHANGE();
@message void MSG_PTDC_SET_TIME();	
@message void MSG_PTDC_SET_DATE();

@protominor	NewPTDCMessagesForDove
@message void MSG_PTDC_TOGGLE_24_HOURS();
@message void MSG_PTDC_SET_12_OR_24_HOURS();
@message void MSG_PTDC_ADJUST_HOUR_DISPLAY();
@protoreset

@protominor	NewPTDCMessagesForGPC
@message void MSG_PTDC_GET_DATE();
@message void MSG_PTDC_SET_TIMEZONE();
@message (GEN_DYNAMIC_LIST_QUERY_MSG) MSG_PTDC_QUERY_TIMEZONE;
@message (GEN_ITEM_GROUP_STATUS_MSG) MSG_PTDC_TIMEZONE_SELECTED;
@protoreset

@instance dword    	PTDCI_timer;
@instance byte 		PTDCI_maxDays;
@instance byte 		PTDCI_month;
@instance word 		PTDCI_year;

@protominor	NewPTDCMessagesForGPC
@vardata word	ATTR_PREF_TIME_DATE_CONTROL_MINIMUM_YEAR;
/* Specifies the minimum year displayed by this object (default is 1980).
 * Values less than 1904 or more than 2099 will be ignored. */

@vardata word	ATTR_PREF_TIME_DATE_CONTROL_MAXIMUM_YEAR;
/* Specifies the maximum year displayed by this object (default is 2050).
 * Values less than 1904 or more than 2099 will be ignored. */
@protoreset

@endc;

/*===========================================================================
	PrefTimeDateControlClass
 *===========================================================================*/
@class PrefPortItemClass, PrefClass;
	@default Pref = PrefStringItemClass;

@message word MSG_PREF_PORT_ITEM_GET_STATUS();

/* Internal messages */
@message void MSG_PREF_PORT_ITEM_FREE_DRIVER();

/* Instance data */

typedef enum {
    PPIT_SERIAL_MOUSE,
    PPIT_SERIAL,
    PPIT_PARALLEL
} PrefPortItemType;


@instance word	PPII_portMask;
@instance byte	PPII_type;
@instance byte  PPII_status;

@endc;


/*---------------------------------------------------------------------------
 *	EXPORTED ROUTINES		
 *---------------------------------------------------------------------------*/

extern void _pascal ConfigBuildTitledMoniker(optr monikerList);
extern ChunkHandle
    _pascal ConfigBuildTitledMonikerUsingToken(GeodeToken *token,
					       MemHandle destBlock);


/* Video routines should probably be moved to a "Video" module, if
 * anyone ever creates one. */

extern void 
    _pascal PrefSaveVideo(void);
extern void 
    _pascal PrefRestoreVideo(void);
extern void 
    _pascal PrefDiscardSavedVideo(void);


extern word 
    _pascal TocSortedNameArrayAdd(word arr, const char *nameToAdd,
			       NameArrayAddFlags flags,
			       const void *data);

typedef WordFlags SortedNameArrayFindFlags;
#define SNAFF_IGNORE_CASE   0x0080

extern Boolean 
    _pascal TocSortedNameArrayFind(word arr, const char *nameToFind,
				SortedNameArrayFindFlags flags,
				void *buffer, word *elementNum);
 
extern Boolean 
    _pascal TocFindCategory(TocCategoryStruct *cat);
extern word 
    _pascal TocNameArrayFind(DBGroupAndItem array, const char *name,
			     void *buffer);
extern word 
    _pascal TocNameArrayGetElement(DBGroupAndItem array, word element,
				   void *buffer);
extern void 
    _pascal TocUpdateCategory(TocUpdateCategoryParams *params);
extern word 
    _pascal TocNameArrayAdd(DBGroupAndItem array, const char *nameToFind,
			    const void *data);
extern void *
    _pascal TocDBLock(DBGroupAndItem thing);
extern void *
    _pascal TocDBLockGetRef(DBGroupAndItem thing, optr *refPtr);

extern word 
    _pascal TocAddDisk(const char *diskName, const TocDiskStruct *diskDesc);
extern Boolean 
    _pascal TocCreateNewFile(void);

extern word
    _pascal TocGetFileHandle();


#ifdef __HIGHC__
pragma Alias(ConfigBuildTitledMoniker, "CONFIGBUILDTITLEDMONIKER");
pragma Alias(ConfigBuildTitledMonikerUsingToken, "CONFIGBUILDTITLEDMONIKERUSINGTOKEN");
pragma Alias(PrefSaveVideo, "PREFSAVEVIDEO");
pragma Alias(PrefRestoreVideo, "PREFRESTOREVIDEO");
pragma Alias(PrefDiscardSavedVideo, "PREFDISCARDSAVEDVIDEO");
pragma Alias(TocSortedNameArrayAdd, "TOCSORTEDNAMEARRAYADD");
pragma Alias(TocSortedNameArrayFind, "TOCSORTEDNAMEARRAYFIND");
pragma Alias(TocFindCategory, "TOCFINDCATEGORY");
pragma Alias(TocNameArrayFind, "TOCNAMEARRAYFIND");
pragma Alias(TocNameArrayGetElement, "TOCNAMEARRAYGETELEMENT");
pragma Alias(TocUpdateCategory, "TOCUPDATECATEGORY");
pragma Alias(TocNameArrayAdd, "TOCNAMEARRAYADD");
pragma Alias(TocDBLock, "TOCDBLOCK");
pragma Alias(TocDBLockGetRef, "TOCDBLOCKGETREF");
pragma Alias(TocAddDisk, "TOCADDDISK");
pragma Alias(TocCreateNewFile, "TOCCREATENEWFILE");
pragma Alias(TocGetFileHandle, "TOCGETFILEHANDLE");

#endif

@endlib
