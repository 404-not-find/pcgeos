COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) GeoWorks 1990 -- All Rights Reserved

PROJECT:	PC GEOS
MODULE:		Keyboard Driver
FILE:		keyboardConstant.def

AUTHOR:		Gene Anderson, Feb  8, 1990

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	eca	2/ 8/90		Initial revision


DESCRIPTION:
	Constants and structures for keyboard driver
		
	$Id: keyboardConstant.def,v 1.1 97/04/18 11:47:01 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

;
; Scan codes generated by keyboard hardware
;
ScanCodes		etype	byte
SCANCODE_LEFT_CTRL	enum	ScanCodes, 0x1d
SCANCODE_CAPS_LOCK	enum	ScanCodes, 0x3a
SCANCODE_RIGHT_ALT	enum	ScanCodes, 0x76
SCANCODE_JOYSTICK_0	enum	ScanCodes, 0x62
SCANCODE_JOYSTICK_45	enum	ScanCodes, 0x63
SCANCODE_JOYSTICK_90	enum	ScanCodes, 0x64
SCANCODE_JOYSTICK_135	enum	ScanCodes, 0x65
SCANCODE_JOYSTICK_180	enum	ScanCodes, 0x66
SCANCODE_JOYSTICK_225	enum	ScanCodes, 0x67
SCANCODE_JOYSTICK_270	enum	ScanCodes, 0x68
SCANCODE_JOYSTICK_315	enum	ScanCodes, 0x69
SCANCODE_ILLEGAL	enum	ScanCodes, 0xff	; used in CasioConvertToScanCode

;
; Supported keyboard options
;
KeyboardOptions	record
	:2
	KO_FORCE_XT:1		;TRUE: force XT mode
	KO_FORCE_AT:1		;TRUE: force AT mode
	KO_DOES_LEDS:1		; Non-zero if we think the keyboard
				;  can handle the SET_LED command
				;  that first came into existence
				;  on the AT with the 8042 controller.
				;  Thought up by a deranged engineer
				;  at IBM, this sequence has been
				;  emulated in a few PCs, but we won't
				;  go into that here...
	KO_ALT_GR:1		;TRUE: right <Alt> is <Alt Gr>
	KO_SHIFT_RELEASE:1	;TRUE: <Shift> release <Caps Lock>
	KO_SWAP_CTRL:1		;TRUE: swap <Ctrl> and <Caps Lock>
KeyboardOptions	end

;
; Scan codes of extended shift & ctrl keys. These keys do not
; really exist, but are generated by some extended keyboards.
;
EXT_LSHIFT_PRESS	equ	0xe02a
EXT_LSHIFT_RELEASE	equ	0xe0aa
EXT_RSHIFT_PRESS	equ	0xe036
EXT_RSHIFT_RELEASE	equ	0xe0b6

EXT_LCTRL_PRESS		equ	0xe11d
EXT_LCTRL_RELEASE	equ	0xe19d
EXT_RCTRL_PRESS		equ	0xe177
EXT_RCTRL_RELEASE	equ	0xe1f7

;----------------------------------------------------------------------------
;	Keyboard Driver Errors
;----------------------------------------------------------------------------

KBD_NESTED_INIT						enum FatalErrors
; Too many calls to init

KBD_NESTED_EXIT						enum FatalErrors
; Too many calls to exit

KBD_BAD_ROUTINE						enum FatalErrors
; Bad call to keyboard driver

KBD_BAD_ACCENT_TABLE					enum FatalErrors
; Bad table definition

KBD_ATSQ_DS_NOT_IDATA					enum FatalErrors

KBD_ATSQ_BUFFER_FULL					enum FatalErrors

KBD_SHOULD_NOT_HAPPEN_ON_ZOOMER				enum FatalErrors
; This routine should never be called on the Zoomer

KBD_BAD_SHORTCUT					enum FatalErrors

;----------------------------------------------------------------------------
;	Constants
;----------------------------------------------------------------------------

SEND_QUEUE_SIZE		equ	8	; Size of queue of bytes to send
					;	to keyboard

MAX_KEYS_DOWN		equ	12	; MAX # of keys that we can keep track
					; of as being down.

KEY_RELEASE		equ	80h	;flag: key is press or release

MAX_HOTKEYS		equ	16	; MAX # of hotkeys to watch for. This
					;  is not the number of calls to
					;  DR_KBD_ADD_HOTKEY that are allowed,
					;  as a single hotkey could result in
					;  multiple hotkey records being added.

if DBCS_PCGEOS
	;unused in DBCS
else
;
; EVENT_KBD_SCAN structure
;
KbdEvent	struct	
    KE_type			word	(?)
    KE_scanCode		word	(?)
    KE_na1			word	(?)
    KE_na2			word	(?)
    KE_handle		word	(?)
KbdEvent	ends
endif


;
; CURRENT KEYS DOWN LIST
;
					; Each element is composed of:
if DBCS_PCGEOS

KeyDownElement	struct	
    KDE_charValue	Chars
    KDE_charFlags	CharFlags
    KDE_shiftState	ShiftState
    KDE_toggleState	ToggleState
    KDE_scanCode	ScanCodes
    KDE_xState1		byte	(?)
    KDE_xState2		byte	(?)
KeyDownElement	ends

else

KeyDownElement	struct	
    KDE_charValue	word	(?)
    KDE_charFlags	CharFlags	(?)
    KDE_shiftState	byte	(?)
    KDE_toggleState	byte	(?)
    KDE_scanCode	byte	(?)
    KDE_xState1		byte	(?)
    KDE_xState2		byte	(?)
KeyDownElement	ends

endif

KbdStratFlags	record
    :2,
    KSF_ALL_HOTKEY:1,		; set if all keys should be considered hotkeys
    KSF_HOTKEY_PENDING:1,	; set if driver detected a hot key and keyboard
				;  is therefore inhibited and must remain that
				;  way. Used during DR_SUSPEND handling...
    KSF_HAVE_HOTKEY:1,		; set if driver has been given a hot key for
				;  which to watch.
    KSF_HAVE_INT_VEC:1,		; set if driver has control of interrupt vector
    KSF_USE_PC_ACK:1,		; set if must acknowledge kbd transmission by
				;  hand (PC and XT)
    KSF_SENDING:1,		; set if sending bytes from kbdSendQueue to kbd
KbdStratFlags	end



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		PC HARDWARE CONSTANTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

ifidn		HARDWARE_TYPE, <PC>

XTPort61	record	; I/O port 61h for XT
    XP61_KBD_STROBE:1		; Write 1 to clear keyboard latch. Write 0
				;  immediately following.
    XP61_KBD_DISABLE:1		; Write 0 to hold keyboard clock low, thus
				;  disabling the keyboard
    XP61_ENABLE_IOCHK:1		; Write 0 to enable IOCHK
    XP61_ENABLE_PARITY:1	; Write 0 to enable parity check
    XP61_READ_LOW_SWITCHES:1	; Write 0 to read low switches (?)
    :1
    XP61_SPEAKER_ENABLE:1	; Enable speaker data (1 = enable)
    XP61_TIMER_2_GATE:1		; Enable timer 2 (1 = enable)
XTPort61	end

;
; Interrupt ports
;
ICMASKPORT		equ	21h	; Mask of pending interrupts
ICEOIPORT		equ	20h	; Port to signal EOI to 8259
ICEOI			equ	20h 	; general EOI instruction for 8259

;
; Keyboard controller ports
;
KBD_DATA_PORT		equ	60h
				; keyboard data I/O port, used to receive
				; characters from the keyboard, as well
				; as send data to the controller & read info
				; from the controller.

KBD_RELEASE_FLAG	equ	0x80
				; bit is set in a scan code if it's for a key
				;  release, rather than a press.

KBD_PC_CTRL_PORT	equ	61h
				; Control port for the base PC. The high bit
				; is pulsed to acknowledge a keystroke and
				; prime the latches to receive another one.

KBD_STATUS_PORT		equ	64h

KeyboardStatusBits	record
   KSB_PARITY_ERROR:1		;bit 7 = 1 : last byte had even parity
   KSB_RECEIVE_TIME_OUT:1	;bit 6 = 1 : reception timed out
   KSB_TRANSMIT_TIME_OUT:1	;bit 5 = 1 : transmite timed out
   KSB_INHIBIT:1		;bit 4 = 0 : keyboard inhibited
   KSB_COMMAND_DATA_FLAG:1	;bit 3 = 0 : data ; = 1 : command
   KSB_SYSTEM_FLAG:1		;bit 2 = 0 : reset caused by power on
   KSB_INPUT_BUFFER_FULL:1	;bit 1 = 1 : input buffer full (DATA & CMD)
   KSB_OUTPUT_BUFFER_FULL:1	;bit 0 = 1 : output buffer full (DATA only)
KeyboardStatusBits	end

				; keyboard status port.  When read, returns:
				; bit 4:  0 if keyboard is inhibited
				; bit 1:  1 if keyboard controller input
				;	  buffer full. (Used for both
				;	  DATA and CMD ports)
				; bit 0:  1 if keyboard controller output
				;	  buffer is full (DATA port only)

KBD_COMMAND_PORT	equ	64h
				; keyboard controller command port.

KBD_ACKNOWLEDGE		equ	mask XP61_KBD_STROBE
				; for every keypress, need to acknowledge it


;
; Controller commands understood by controller via writes to KBD_COMMAND_PORT
;
KBD_CMD_GET_CCB		equ	20h
				; Get controller command byte. After sending
				; this command, the controller command byte
				; can be read from KBD_DATA_PORT.  Format is
				; the same as that used to set the command
				; byte using KBD_CMD_SET, below.

KBD_CMD_SET_CCB		equ	60h
				; Set controller command byte.  After sending
				; this command, send the desired command
				; byte to KBD_DATA_PORT, in the following
				;  format:
				;
				; bit 7:  RESERVED: should be written as 0
				; bit 6:  PC compatibility mode (?)
				; bit 5:  PC mode (?)
				; bit 4:  Disable Keyboard (active high)
				; bit 3:  Inhibit Override (active high)
				;	  -- forces override of 
				;	  "Disable Keyboard" function
				; bit 2:  System Flag (?) The value written
				;	  here is placed in the system flag bit
				;	  of the controller's status register
				; bit 1:  RESERVED: should be written as 0
				; bit 0:  Enable Output-Buffer-Full Interrupt
				;	  (active high)
KbdCommandBits	record
    :1=0			; reserved
    KCB_XLATE_SCAN_CODES:1	; translate from AT scan codes to XT scan codes
    KCB_XT_KEYBOARD:1		; support XT-style keyboard
    KCB_DISABLE_KEYBOARD:1	; prevent keyboard from sending anything
    KCB_OVERRIDE_DISABLE:1	; allows sending of data, but non-response
				;  bytes (i.e. scan codes) received are
				;  discarded.
    KCB_SYSTEM_FLAG:1		; see above
    KCB_AUX_IEN:1		; enable interrupts for auxiliary port
    KCB_INTERRUPT_ENABLE:1	; enable output-buffer-full interrupt
KbdCommandBits end
    


KBD_CMD_DISABLE_INTERFACE	equ	0adh
				; Disables the interface between an AT
				;  controller and its keyboard. Data
				;  can be neither sent nor received.

KBD_CMD_ENABLE_INTERFACE	equ	0aeh
				; Enables the interface between an AT
				;  controller and its keyboard.
; 
; Commands understood by the keyboard via writes to KBD_DATA_PORT
;
KBD_CMD_SET_LED		equ	0edh
				; Set state of keyboard leds.  Data should
				; be written to KBD_DATA_PORT in this format:
				; bit 2:  caps lock (active high)
				; bit 1:  num lock (active high)
				; bit 0:  scroll lock (active high)

KBD_CMD_ECHO		equ	0eeh
				; Echo command.  Keyboard will respond with
				; same byte as response

KBD_CMD_SET_TYPEMATIC	equ	0f3h
				; Sets typomatic delay, set by byte following.
				; Bits 6-5 are delay, 4-0 rate. Bit 7 = 0.

KBD_CMD_ENABLE		equ	0f4h
				; Keyboard responds w/ACK, clears output
				; buffer, and starts scanning.


;
; Keyboard response codes
;
KBD_RESP_ECHO		equ	0eeh	; response to echo command
					;	shouldn't occur
KBD_RESP_BREAK		equ	0f0h	; key release coming up
					;	(not used in mode we use)
KBD_RESP_ACK		equ	0fah	; command acknowledged
KBD_RESP_FAILURE	equ	0fdh	; diagnostic failure
KBD_RESP_RESEND		equ	0feh	; resend last transmission
KBD_RESP_OVERRUN	equ	00h	; commands sent to keyboard overran
					; 	keyboard's buffer. Shouldn't
					;	occur since we interrupt
					;	drive the keyboard

;
; Constants for inheriting/exheriting keyboard toggle state from/to BIOS.
; Info from PC Sourcebook p 183
;
BIOS_SEG		=40h		; Segment of BIOS data area
BIOS_KBD_STATE		=17h		; Word containing BiosKbdState

BIOS_KEYBOARD_BUFFER_HEAD_POINTER = 1ah	; offset of keyboard buffer head ptr
BIOS_KEYBOARD_BUFFER_TAIL_POINTER = 1ch ; offset of keyboard buffer tail ptr

BiosKbdState	record
    BKS_INSERT:1		; Ins key down
    BKS_CAPS_LOCK:1		; Caps Lock key down
    BKS_NUM_LOCK:1		; Num Lock key down
    BKS_SCROLL_LOCK:1		; Scroll Lock key down
    BKS_PAUSE:1			; Pause mode active
    BKS_SYS_REQ:1		; SysReq key down
    BKS_LEFT_ALT:1		; Left ALT key down
    BKS_LEFT_CTRL:1		; Left CTRL key down
    BKS_INSERT_ACTIVE:1		; Insert mode active
    BKS_CAPS_LOCK_ACTIVE:1	; Caps Lock mode active
    BKS_NUM_LOCK_ACTIVE:1	; Num Lock mode active
    BKS_SCROLL_LOCK_ACTIVE:1	; Scroll Lock mode active
    BKS_ALT_ACTIVE:1		; Left or Right ALT down
    BKS_CTRL_ACTIVE:1		; Left or Right CTRL down
    BKS_LEFT_SHIFT:1		; Left shift key down
    BKS_RIGHT_SHIFT:1		; Right shift key down
BiosKbdState	end

BIOS_ALT_KBD_STATE	=97h		; Byte containing extra state added
					;  when extended keyboards came into
					;  vogue...
BiosAltKbdState	record
    BAKS_ID_READ:1		; Kbd ID read in progress
    BAKS_FIRST_ID_RECVD:1	; First char of Kbd ID received
    BAKS_FORCE_NUM_LOCK:1	; Force Num Lock always
    BAKS_EXTENDED:1		; Set if 101/102 key kbd installed
    BAKS_RIGHT_ALT:1		; Right ALT key down
    BAKS_RIGHT_CTRL:1		; Right CTRL key down
    BAKS_E0_RECVD:1		; Last code was E0 hidden key (extended shift)
    BAKS_E1_RECVD:1		; Last code was E1 hidden key (extended ctrl)
BiosAltKbdState	end

BIOS_LED_STATE		=98h		; Byte describing state of LEDs and
					;  setting there of.
BiosLEDState	record
    BLS_XMIT_ERR:1		; Error transmitting to keyboard
    BLS_MODE_UPDATE:1		; Now updating LED indicators
    BLS_RESEND_RECVD:1		; RESEND command received
    BLS_ACK_RECVD:1		; ACK received
    :1=0
    BLS_LEDS:3			; Current LED state
BiosLEDState	end

BIOS_KBD_SCROLL_LOCK_OFFSET= 4		; Bit offset for toggle state

endif	; PC


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		ZOOMER HARDWARE CONSTANTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		VG-230 SCANNING KEYBOARD HARDWARE CONSTANTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		VG-230 SCANNING KEYBOARD HARDWARE CONSTANTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@


ifndef		VG230SCAN
	VG230SCAN	equ	FALSE
endif	; VG230SCAN

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	E3G (Responder, Penelope) SCANNING KEYBOARD HARDWARE CONSTANTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

if	_E3G_KBD_SCAN

;
; Interrupt ports
;
ICMASKPORT		equ	21h	; Mask of pending interrupts
ICEOIPORT		equ	20h	; Port to signal EOI to 8259
ICEOI			equ	20h 	; general EOI instruction for 8259

;
; Keyboard controller ports
;
KBD_RELEASE_FLAG	equ	0x80
				; bit is set in a scan code if it's for a key
				;  release, rather than a press.

;
; KBD_SCAN_ALL_MASK defines what output columns are used for the given
; hardware.
;
ErrMessage	<KBD_SCAN_ALL_MASK not defined for current HARDWARE_TYPE>

;
; KBD_INT_MODE defines what mode the E3G keyboard scanner is in when the
; driver is waiting for a keypress interrupt.
;
ErrMessage	<KBD_INT_MODE not defined for current HARDWARE_TYPE>

;
; KBD_POLL_MODE defines what mode the E3G keyboard scanner is in when a key
; or keys are already pressed and we are polling the keybaord for a release.
;
ErrMessage	<KBD_POLL_MODE not defined for current HARDWARE_TYPE>

;
; KBD_INT_ALL_MASK indicates which input lines for the keyboard should cause
; an interrupt.
;
ErrMessage	<KBD_INT_ALL_MASK not defined for current HARDWARE_TYPE>

; If E3G_KBD_COUNT_INTS is true, the number of keyboard interrupts and
; events send to the IM will be counted.
;
E3G_KBD_COUNT_INTS = FALSE


SHIFT_STICK_IMPLIES_SHIFT	equ	TRUE
				; When TS_SHIFTSTICK (shift-toggle) is on, key
				; presses are treated as treated as if they're
				; pressed with the L-shift key held down.

IGNORE_SHIFT_STATE_FOR_PGUP_PGDOWN	equ TRUE
				; When TS_SHIFTSTICK is on, the shift state
				; will be ignored for page up and page down
				; keys.

KBD_NUM_COLS		equ	8
				; 8 columns from, 0 to 7.

KBD_TYPEMATIC		equ	0x1404
				; 20 * 25ms = 500ms
				; 4 * 25ms = 100ms -> 10 chars/sec.

KBD_MAX_EXTENDED_DEF	equ	0x14
				; Number of defs in KbdExtendedDefTable

KBD_MAX_KEY_DEF		equ	0x80
				; Number of defs in KbdDefTable

KBD_MAX_KEYS_DOWN	equ	3
				; The max number of keys that can be down at
				; any given moment, assuming one of them is
				; the SHIFT key.

KBD_NUM_FUNCTION_KEYS	equ	9
				; The number of function keys on responder.

;
; Used to define the mapping from the keyboard matrix to scan codes.
;
KeyMatrixColumn	struct
	KMC_ROW1	byte
	KMC_ROW2	byte
	KMC_ROW3	byte
	KMC_ROW4	byte
	KMC_ROW5	byte
	KMC_ROW6	byte
	KMC_ROW7	byte
	KMC_ROW8	byte
	KMC_ROW9	byte
	KMC_ROW10	byte
KeyMatrixColumn	ends


endif	; _E3G_KBD_SCAN    (**NOT JUST RESPONDER**)

ifndef	SHIFT_STICK_IMPLIES_SHIFT
	SHIFT_STICK_IMPLIES_SHIFT		equ FALSE
endif
ifndef	ALT_STICK_IMPLIES_ALT
	ALT_STICK_IMPLIES_ALT			equ FALSE
endif
ifndef  IGNORE_SHIFT_STATE_FOR_PGUP_PGDOWN
	IGNORE_SHIFT_STATE_FOR_PGUP_PGDOWN	equ FALSE
endif
ifndef	DO_EXTENDED_CHARACTER_SET
	DO_EXTENDED_CHARACTER_SET		equ FALSE
endif

