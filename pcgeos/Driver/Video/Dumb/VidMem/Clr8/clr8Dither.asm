COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) GeoWorks 1991 -- All Rights Reserved

PROJECT:	PC GEOS
MODULE:		Video Drivers
FILE:		clr8Dither.asm

AUTHOR:		Jim DeFrisco, Oct 22, 1992

ROUTINES:
	Name			Description
	----			-----------

	
REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Jim	10/22/92		Initial revision


DESCRIPTION:
	Dither tables for 8-bit driver
		

	$Id: clr8Dither.asm,v 1.1 97/04/18 11:42:59 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@


		; the RGB cube that is part of the standard palette
		; is a 6x6x6 cube.  This table is basically 
		; 	output = floor(input/(255/5))
ditherBase	label	byte
		byte	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		byte	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		byte	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		byte	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		byte	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		byte	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		byte	0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01
		byte	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
		byte	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
		byte	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
		byte	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
		byte	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
		byte	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02
		byte	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02
		byte	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02
		byte	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02
		byte	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02
		byte	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02
		byte	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02
		byte	0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
		byte	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
		byte	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
		byte	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
		byte	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
		byte	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
		byte	0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04
		byte	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04
		byte	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04
		byte	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04
		byte	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04
		byte	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04
		byte	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05

		; this is a companion table to the one above.  While
		; ditherBase gives the floor (base) value, this gives
		; the remainder (modulo) value.  It is basically:
		;	output = input - floor(input/(255/5))
ditherMod	label	byte
		byte	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
		byte	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
		byte	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17
		byte	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
		byte	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27
		byte	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f
		byte	0x30, 0x31, 0x32, 0x00, 0x01, 0x02, 0x03, 0x04
		byte	0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c
		byte	0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14
		byte	0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c
		byte	0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24
		byte	0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c
		byte	0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x00, 0x01
		byte	0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09
		byte	0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11
		byte	0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19
		byte	0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21
		byte	0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29
		byte	0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31
		byte	0x32, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06
		byte	0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e
		byte	0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16
		byte	0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e
		byte	0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26
		byte	0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e
		byte	0x2f, 0x30, 0x31, 0x32, 0x00, 0x01, 0x02, 0x03
		byte	0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b
		byte	0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13
		byte	0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b
		byte	0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23
		byte	0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b
		byte	0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x00

		; When you lay out a 6x6x6 cube in a linear array, you
		; have to choose which ones to fix first.  The values
		; in this table reflect that organization.  The mapping
		; from RGB value to index goes like this:
		; index = (ditherRed[ditherBase[R]] + ditherGreen[ditherBase[G]
		;	   + ditherBlue[ditherBase[B]])
ditherRed	label	byte
		byte	0, 36, 72, 108, 144, 180
ditherGreen	label	byte
		byte	0, 6, 12, 18, 24, 30
ditherBlue	label	byte
		byte	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d

		; We are implementing a 4x4 matrix for dithering purposes.  
		; The ditherCutoff table takes the output of the ditherMod 
		; table and the (x,y) position of the pixel to determine 
		; the 16 indices that inhabit the dither matrix.  So, instead
		; of a single equation for the index (as shown above), we
		; actually have 16 separate equations, one for each spot in
		; the ditherMatrix. 
ditherCutoff	label	byte
		byte	0x00, 0x1a, 0x06, 0x20
		byte	0x27, 0x0d, 0x2d, 0x13
		byte	0x09, 0x23, 0x03, 0x1d
		byte	0x30, 0x16, 0x2a, 0x10


