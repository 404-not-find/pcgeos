COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) GeoWorks 1992 -- All Rights Reserved

PROJECT:	RFSD
FILE:		rfsdNotify.asm

AUTHOR:		Andrew Wilson, Jun  8, 1993

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	atw	6/ 8/93		Initial revision

DESCRIPTION:
	Contains routines and message handlers to transfer file change
	notifications to the remote machine.

	$Id: rfsdNotify.asm,v 1.1 97/04/18 11:46:16 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
Server	segment	resource



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		HandleIfNotOurDrive
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Handle the notification to drives not owned by us.

CALLED BY:	GLOBAL
PASS:		ax - disk handle
		dx - FileChangeNotificationType
RETURN:		carry set if not owned by us
DESTROYED:	es, ax
 
PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	atw	6/16/93   	Initial version
	simon	11/17/94	Handle special file notification for
				remote drives

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
HandleIfNotOurDrive	proc	near
		diskHandle	local	word	push	ax
	uses	di, si
	.enter
	;
	; First we check if the drive belongs to us
	;
	call	FSDLockInfoShared	; ax <- seg of FSIR
	mov	es, ax
	mov	di, ss:[diskHandle]
	mov	di, es:[di].DD_drive
	mov	di, es:[di].DSE_fsd
	cmp	es:[di].FSD_handle, handle 0
	jne	ownedByUs

	;
	; Check the notification type if it is what we care. Right
	; now, we only support Disk format notification on remote disks.
	;
	cmp	dx, FCNT_DISK_FORMAT
	stc
	jne	exit

	;
	; The remote side has formatted its disk in an exportable drive.
	; We call the RFSD Strategy to update this side's DiskDesc table
	; using DR_FS_DISK_INIT. We need to do this in order to update
	; the local disk table (DiskDesc) of the remote disk.
	;
	; If we do not do this, there is possibility that the DiskDesc of
	; this side will not be updated when the disk is re-accessed. 
	; It is because the system checks if the disk ID (DD_id) has been
	; changed. If not, it does not update DiskDesc which contains
	; the vol label, etc. In the case of quick format, the disk ID is not
	; changed. Thus, the new vol label is never updated on this side.
	;					-simon 11/17/94
	;
	mov	di, DR_FS_DISK_INIT
	mov	si, ss:[diskHandle]	; es:si <- DiskDesc
	mov	ah, FNA_SILENT
	push	bp			; save bp
	call	RFStrategy		; carry set if error
					; es may be fixed up
	pop	bp			; restore bp
	stc
	jmp	exit
	
ownedByUs:
	clc				; owned by us
	
exit:
	call	FSDUnlockInfoShared
	.leave
	ret
HandleIfNotOurDrive	endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RFSDNotifyFileChange
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Takes a file change notification, and sends it to the remote
		system.

CALLED BY:	GLOBAL
PASS:		bp - FileChangeNotificationData
		dx - FileChangeNotificationType
RETURN:		nada
DESTROYED:	nada
 
PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	atw	6/ 8/93   	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
RFSDNotifyFileChange	method	DispatchProcessClass, 
			MSG_NOTIFY_FILE_CHANGE
	tst	es:[closingConnection]
	LONG jnz	exit
	push	ax, dx, bp, es, ds

;	Append the header to the front of the block, and send it to the remote
;	system.

	mov	bx, bp
	call	MemLock			;Lock down the notification block
	mov	ds, ax

	mov	ax, ds:[FCND_disk]	;AX <- disk handle (if this is not a
					; batch notification)

;	Check for an empty batch notification - this will happen pretty often,
;	when GeoManager tries to batch up notifications and all the file
;	operations are happening remotely.

	cmp	dx, FCNT_BATCH
	jne	notBatch
	cmp	ds:[FCBND_end], size FileChangeBatchNotificationData
	je	noSend

	mov	ax, ds:[FCBND_items].FCBNI_disk

notBatch:
;	Check to see if this notifications was generated by RFSD itself in
;	RFSDRemoteFileChangeNotification - if so, ignore it.
;	
;	HACK - for batch notifications, we check to see if the first item
;	       was for a drive owned by us, and if so, we ignore the
;	       notification.
;
;	Not all notification for drives not owned by us can be
;	ignored, such as Disk format notification.  -simon 11/17/94

	call	HandleIfNotOurDrive	; carry set if notification is
					;   not for our drive
					; es, ax destroyed
	jc	noSend			;Don't send on if it wasn't our drive

	mov	ax, MGIT_SIZE
	call	MemGetInfo		;AX <- # bytes in the block

;	Allocate a block large enough for the notification data and an
;	RFSHeader/RFSDFileChangeNotificationData structure

	push	ax
	add	ax, size RFSHeader + size RFSDFileChangeNotificationData
	mov	cx, ALLOC_DYNAMIC_NO_ERR_LOCK
	call	RFSDMemAlloc	;Allocates block to hold the data + an
	mov	es, ax		; RFSHeader.

	mov	di, size RFSHeader + offset RFSDFCND_data
	clr	si
	pop	cx			;CX <- size of notification data
	call	strncpy

;	Initialize the header, and the notification type

	mov	es:[RPC_flags], RPC_CALL
	mov	es:[RPC_proc], RFS_REMOTE_NOTIFICATION
	mov	es:[size RFSHeader].RFSDFCND_type, dx

;	Send the data to the remote machine.

	segmov	ds, es
	clr	si
	add	cx, size RFSHeader + size RFSDFileChangeNotificationData
	segmov	es, dgroup, ax
	call	RFSendBufferWithRetries
if	DEBUGGING
	WARNING	SENT_NOTIFICATIONS_TO_REMOTE
endif


;	Free up the temp block we allocated, and unlock the notification block

	call	MemFree
noSend:
	pop	ax, dx, bp, es, ds
	mov	bx, bp
	call	MemUnlock
exit:
;
;	GRRRRR! It turns out that ObjCallSuperNoLock expects DS to be a
;	fix-uppable segment. In our case, our dgroup is not fixuppable,
;	but our stack segment will be, so use that instead.
;
	segmov	ds, ss, di
	mov	di, offset DispatchProcessClass
	GOTO	ObjCallSuperNoLock
RFSDNotifyFileChange	endp

Server	ends

Client	segment	resource

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MapRemoteDiskHandle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Maps a remote disk handle into a local one

CALLED BY:	GLOBAL
PASS:		si - remote disk handle
RETURN:		si - local disk handle
		carry set if error (disk handle could not be mapped)
DESTROYED:	nada
 
PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	atw	6/ 9/93   	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
MapRemoteDiskHandle	proc	near	uses	ax, bx, di, ds
	.enter
	call	FSDLockInfoShared
	mov	ds, ax

;	Start off the loop by making ds:di point to a pseudo-DiskDesc struct.
;	DS:DI.DD_next will point to the first DiskDesc in the list.

	mov	di, offset FIH_diskList - offset DD_next
next:
	mov	di, ds:[di].DD_next
	tst	di
	stc
	jz	notFound

EC <	xchg	si, di							>
EC <	call	ECCheckBounds						>
EC <	xchg	si, di							>

	mov	bx, ds:[di].DD_drive
	mov	bx, ds:[bx].DSE_fsd
	cmp	ds:[bx].FSD_handle, handle 0
	jne	next

;	This disk is owned by us - see if it corresponds to the passed remote
;	disk handle.

	mov	bx, ds:[di].DD_private
	cmp	ds:[bx], si
	jne	next
	mov	si, di			;SI <- local disk handle
	clc

notFound:
	call	FSDUnlockInfoShared
	.leave
	ret
MapRemoteDiskHandle	endp



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		GenerateLocalNotification
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Generates a file-system notification corresponding to the one
		we've received from the remote machine, if it was associated
		with a drive we've imported.

CALLED BY:	GLOBAL
PASS:		ds:si - FileChangeNotificationData
		ax - FileChangeNotificationType
		bp - non-zero if we want to batch this up
RETURN:		nada
DESTROYED:	nada
 
PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	atw	6/ 9/93   	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
GenerateLocalNotification	proc	near	uses	ax, bx, cx, dx, si
	.enter
EC <	cmp	ax, FCNT_BATCH						>
EC <	ERROR_E	ILLEGAL_FILE_CHANGE_NOTIFICATION_TYPE			>

EC <	cmp	ax, FileChangeNotificationType				>
EC <	ERROR_AE	ILLEGAL_FILE_CHANGE_NOTIFICATION_TYPE		>

EC <	call	ECCheckBounds						>

	movdw	cxdx, ds:[si].FCND_id	;CX.DX <- ID
	lea	bx, ds:[si].FCND_name	;DS:BX <- name
	mov	si, ds:[si].FCND_disk
	call	MapRemoteDiskHandle
	jc	exit
	tst	bp
	jz	noBatch
	call	FileBatchChangeNotifications
noBatch:
	call	FSDGenerateNotify
exit:
	.leave
	ret
GenerateLocalNotification	endp



;
; ===========================================================================
; 			RFSD PCMCIA EXTENSION
; ===========================================================================
;


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RFSDRemoteDriveChangeNotification
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Process drive change notifications from the remote site.

CALLED BY:	MSG_RFSD_REMOTE_DRIVE_CHANGE_NOTIFICATION
PASS:		ds	= dgroup
		cx	= packet buffer handle
RETURN:		nothing
DESTROYED:	nothing
SIDE EFFECTS:	

PSEUDO CODE/STRATEGY:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	SJ	6/30/94   	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
RFSDRemoteDriveChangeNotification	method dynamic DispatchProcessClass, 
				MSG_RFSD_REMOTE_DRIVE_CHANGE_NOTIFICATION
		uses	ax, bx, cx
		.enter
		mov_tr	bx, cx
		call	MemLock
		mov	es, ax
		call	ProcessRFSDriveChangeNotification
		.leave
		ret
RFSDRemoteDriveChangeNotification	endm



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		ProcessRFSDriveChangeNotification
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Create or delete the drive on this side according to the
		incoming remote drive change notification.

CALLED BY:	RemoteNotification

PASS:		ds = dgroup
		es = segment of call data
		bx = handle of call data
RETURN:		nothing
DESTROYED:	nothing
SIDE EFFECTS:	none

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	SJ	5/17/94    	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
ProcessRFSDriveChangeNotification	proc	near
		uses	ax,cx,dx
		.enter
	;
	; Ignore the drive change notification that will be caused by
	; creating a representation of remote drive in this routine.
	;
		push	bx
	;
	; Determine if this message is for drive creation or drive deletion
	; call the appropriate routine
	;		
		cmp	es:[size RFSHeader].RFSDDCND_type, GCNDCNT_CREATED
		jne	notCreated
		call	ProcessDriveCreation
		jmp	finish
notCreated:
		call	ProcessDriveDeletion
finish:
	;
	; Restore ignoreDriveChange variable to its previous state 
	;
	;	mov	ds:[ignoreDriveChange], 0
		pop	bx
		call	MemFree
		
		.leave
		ret
ProcessRFSDriveChangeNotification	endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		ProcessDriveCreation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Handle drive creation on the remote side.

CALLED BY:	ProcessRFSDriveChangeNotification
PASS:		es = segment of call data
RETURN:		nothing
DESTROYED:	ax, bx, cx, dx
SIDE EFFECTS:	none

PSEUDO CODE/STRATEGY:

1. Create an DriveStatus entry for this drive on this side.
2. Send MSG_NOTIFY_DRIVE_CHANGE to GCN list.

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	SJ	5/20/94    	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
ProcessDriveCreation	proc	near
		uses	si, di, ds, es, bp
		.enter
	;
	; Prepare arguments to call FSDInitDrive with
	;
		lea	di, es:[size RFSHeader].RFSDDCND_drive
	;
	; es:di = DriveInfoStruct which is a part of call data
	;
	; < FSDInitDrive arguments >
	; al :drive number	  = -1
	; ah :MediaType		  = DIS_defaultMedia
	; bx :private chunk	  = new lmem chunk handle
	; cx :DriveExtendedStatus = DIS_status
	; dx :FSDriver offset	  = dgroup:fsdOffset
	; ds:si :drive name	  = DIS_nameString
	;

	;
	; private data for RFSD ( the drive number on remote side that is )
	;
		call	FSDLockInfoExcl
		mov	ds, ax
		mov	cx, size RFSPrivateData
		call	LMemAlloc		;-> ax = handle of the chunk
		mov_tr	si, ax			;
		mov	al, es:[di].DIS_number	;
		mov	{byte}ds:[si], al	;
		call	FSDUnlockInfoExcl
		mov_tr	bx, si			; bx=private data chunk handle
	;
	; Other arguments for FSDInitDrive 
	;
		mov	al, -1				; drive number
		mov	ah, es:[di].DIS_defaultMedia	; drive media type
		mov	cx, es:[di].DIS_status		; drive status
		segmov	ds, dgroup, dx			;
		mov	dx, ds:[fsdOffset]		; FSDriver offset
		lea	si, es:[di].DIS_nameString	;
		segmov	ds, es, di			; ds:si = name string
	;
	; Create a DriveStatusEntry for this drive
	;
		call	FSDInitDrive
		.leave
		ret
ProcessDriveCreation	endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		ProcessDriveDeletion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Handle drive deletion at remote site

CALLED BY:	ProcessRFSDriveChangeNotification
PASS:		es = segment of the call data
RETURN:		nothing
DESTROYED:	ax, bx, cx, dx
SIDE EFFECTS:	none

PSEUDO CODE/STRATEGY:

1. Find the drive corresponding to the remote drive passed in
2. Destroy the drive(statusEntry) on this side.
3. Send an appropriate message to GCN list.

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	SJ	5/20/94    	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
ProcessDriveDeletion	proc	near
		uses	si, di, ds, es, bp
		.enter
	;
	; Find logical drive corresponding to the remote drive just deleted
	;
		clr	cx
		mov	cl, es:[size RFSHeader].RFSDDCND_drive.DIS_number
		
		call	FSDLockInfoShared	;-> ax,
		mov	es, ax			;   es = FSD info block seg
		mov	ax, MAX_DRIVE_NUMBER	; al = drive number
findLoop:
		call	DriveLocateByNumber	;-> es:si = drive status entry
		jc	nextDrive
	;
	; Check if the drive is owned by RFSD
	;
		mov	bx, es:[si].DSE_fsd
		cmp	es:[bx].FSD_handle, handle 0
		jne	nextDrive		; a local drive maybe
	;
	; This drive is owned by RFSD, now match the drive number on the remote
	; site ( *causion!!!* FSD info block is actually a LMem without
	;        handles. See LMF_NO_HANDLES for more info )
	;
		mov	di, es:[si].DSE_private
		cmp	{byte}es:[di], cl	; compare with drive number
						; passed in from the other side
		je	nukeDrive		; this is the drive that was
						; deleted at the remote site
nextDrive:
		dec	ax
		tst	ax
		jnz	findLoop
		jmp	done			; drive not found; do nothing
nukeDrive:
	;
	; Remove logical drive corresponding to the
	; one deleted at the remote site.
	;
		call	RFSDRemoveDrive
done:
		call	FSDUnlockInfoShared
		.leave
		ret
ProcessDriveDeletion	endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RFSDRemoveDrive
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Remove a drive entry in FSD info block, and also, notify
		everyone using the drive that the drive is going away.

CALLED BY:	ProcessDriveDeletion
PASS:		al = drive number
		es = FSInfo resource segment
		(es:si = drive status entry)
RETURN:		nothing
DESTROYED:	nothing
SIDE EFFECTS:	none

PSEUDO CODE/STRATEGY:
		

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	SJ	5/21/94    	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
RFSDRemoveDrive	proc	near
		uses	ax, bx, di, si
		.enter
startOver:
		mov	di, es:[FIH_diskList]
scanDiskList:
		mov	bx, es:[di].DD_drive
		cmp	es:[bx].DSE_number, al
		jne	nextDisk

		push	ax, di			;FFSRNotify destroys everything
		mov	bx, di			; bx = nptr.DriveDesc
		call	FFSRNotify
		pop	ax, di
nextDisk:
		mov	di, es:[di].DD_next
		tst	di
		jnz	scanDiskList
	;
	; Remove drive from kernel FSD
	; al = drive number
	;
		call	FSDDeleteDrive
		jnc	done
	;
	; Somebody has a file open on this drive
	; So, sleep until it is closed.
	;
		push	ax
		mov	ax, 8 * 60	; Sleep for 8 seconds and try nuking
		call	TimerSleep	; the drive again
		mov	es, ax
		pop	ax
		jmp	startOver
done:
		.leave
		ret
RFSDRemoveDrive	endp



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RFSDNotifyDriveChange
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Convert drive change notification into special RFSD message
		and send it to the other side.

CALLED BY:	MSG_NOTIFY_DRIVE_CHANGE

PASS:		cx	= GCNDriveChangeNotificationType
		dx	= drive number
		es	= dgroup
RETURN:		nothing
DESTROYED:	nothing
SIDE EFFECTS:	none

PSEUDO CODE/STRATEGY:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	SJ	5/17/94   	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
RFSDNotifyDriveChange	method dynamic DispatchProcessClass,
					MSG_NOTIFY_DRIVE_CHANGE
		
		uses	ax, bx, cx, di, si, es, ds
		.enter
		tst	es:[closingConnection]
	LONG	jnz 	exit
	;
	; Allocate a package block
	; Translate the meessage into RFS_REMOTE_NOTIFICATION
	;
	; ax = packet block size
	; cl = flags for block type
	; ch = flags for allocation method
	;
		push	cx
		mov	ax, size RFSHeader + \
			    size RFSDDriveChangeNotificationData
		mov	cx, ALLOC_DYNAMIC_NO_ERR_LOCK
		call	RFSDMemAlloc			;-> ax = seg addr
							;   bx = block handle
							;   CF = 1 if no memory
		mov	ds, ax
		pop	cx
	;
	; Compose packet
	;
		mov	ds:[RPC_flags], RPC_CALL
		mov	ds:[RPC_proc], RFS_REMOTE_NOTIFICATION
		mov	ds:[RPC_ID], RFSDFOD_driveChange
		mov	ds:[size RFSHeader].RFSDDCND_type, cx
	;
	; In case of drive creation, we can count on DriveStatusEntry being
	; there, but in case of drive removal we cannot.
	;
		lea	di, ds:[size RFSHeader].RFSDDCND_drive
		mov	ds:[di].DIS_number, dl
		
		cmp	cx, GCNDCNT_CREATED
		je	driveCreation
	;
	; In case of drive creation we need to send the information about the
	; new drive so that the remote RFSD can create a corresponding logical
	; drive. In case of drive deletion, we only need to send the ID of the
	; drive deleted.  RFSD on the other side should be able to find which
	; of the remote drives have been deleted with this original drive #.
	;
sendPacket:
	;
	; Send the packet
	;
		clr	si			; ds:si = the packet
		mov	cx, size RFSHeader + \
			    size RFSDDriveChangeNotificationData
		call	RFSendBufferWithRetries
	;
	; Free up used memory block
	;
		call	MemFree
exit:
done::
		.leave
		ret
driveCreation:
	;
	; If the drive uses rfsd as its fsd, it is an imported drive, so do not
	; send notification to remote site
	;
		push	bx
		call	FSDLockInfoShared
		mov	es, ax
		mov	ax, dx
		call	DriveLocateByNumber	; es:si = DriveStatusEntry
		mov	bx, es:[si].DSE_fsd
		mov	bx, es:[bx].FSD_strategy.segment
		cmp	bx, segment RFStrategy
		call	FSDUnlockInfoShared
		pop	bx
		je	exit
	;
	; Using the drive status entry found, fill in DriveInfoStruct of
	; notification packet
	;
		call	FSDLockInfoExcl
		mov	es, ax			; es = FSD info block
		mov	ax, dx
		call	DriveLocateByNumber	; es:si = DriveStatusEntry
		mov	cl, es:[si].DSE_defaultMedia
		mov	ds:[di].DIS_defaultMedia, cl
		mov	cx, es:[si].DSE_status
		mov	ds:[di].DIS_status, cx
		lea	di, ds:[di].DIS_nameString ; ds:di = name field
		push	es, si			; save DriveStatusEntry
	;
	; Store <serverName>-<driveName>
	;
		segmov	es, ds, ax		; es    = packet block
		segmov	ds, dgroup, ax		; ds:si = server name
		mov	si, offset serverName	; es:di = DIS_name
		call	strcpy			; pre-pend server name
		add	di, ax
		mov 	{char}es:[di-1], '-'
		pop	ds, si			; restore drive status entry
		lea	si, ds:[si].DSE_name 	; ds:si = drive name string
		call	strcpy			; copy name
		call	FSDUnlockInfoExcl
		segmov	ds, es, ax		; ds 	= packet block
		segmov	es, dgroup, ax		; es	= dgroup
		jmp	sendPacket

RFSDNotifyDriveChange	endm



COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RFSDRemoteFileChangeNotification
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Translates the remote file-change notification

CALLED BY:	GLOBAL
PASS:		cx - block containing:
			RFSHeader<>
			RFSDFileChangeNotificationData<>
RETURN:		nada
DESTROYED:	nada
 
PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	atw	6/ 9/93   	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
RFSDRemoteFileChangeNotification	method	DispatchProcessClass,
				MSG_RFSD_REMOTE_FILE_CHANGE_NOTIFICATION
	.enter
if	DEBUGGING
	WARNING	RECEIVED_REMOTE_NOTIFICATIONS
endif
	mov	bx, cx
	call	MemLock
	mov	ds, ax
	mov	ax, ds:[size RFSHeader].RFSDFCND_type
	lea	si, ds:[size RFSHeader].RFSDFCND_data
	cmp	ax, FCNT_BATCH
	je	batch

;	This is a single notification, so map the disk handle and pass it
;	on to the output

	clr	bp
	call	GenerateLocalNotification
exit:
	call	MemFree
	.leave
	ret
batch:

;	Have all of these notifications batched up

;
; DS:SI <- FileChangeBatchNotificationData
;
	mov	cx, ds:[si].FCBND_end
	add	cx, si			;DS:CX <- ptr after last item in array
	add	si, offset FCBND_items
	cmp	cx, si			;If nothing in here, exit
	je	exit

next:
;
;	DS:CX <- ptr beyond last item in the array
;	DS:SI <- ptr to FileChangeBatchNotificationItem
;

	cmp	cx, si
	je	done
EC <	ERROR_B	RFSD_INTERNAL_ERROR					>
	mov	ax, ds:[si].FCBNI_type

	add	si, offset FCBNI_disk
				;DS:SI <- ptr to FileChangeNotificationData
	mov	bp, -1		;We are creating a batch notification
	call	GenerateLocalNotification

;	If the type was FCNT_RENAME or FCNT_CREATE, then there is a
;	FileLongName attached to it. Otherwise, don't bother.

	add	si, size FCBNI_disk + FCBNI_id
	cmp	ax, FCNT_RENAME	
	ja	next
	add	si, size FileLongName
	jmp	next
done:
	call	FileFlushChangeNotifications
	jmp	exit
RFSDRemoteFileChangeNotification	endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RFSDFlushRemoteNotifications
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	This routine flushes out the remote file change notifications

CALLED BY:	GLOBAL
PASS:		es - dgroup
RETURN:		nada
DESTROYED:	nada
 
PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	atw	6/14/93   	Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
RFSDFlushRemoteNotifications	method	DispatchProcessClass,
					MSG_RFSD_FLUSH_REMOTE_NOTIFICATIONS
	.enter
	tst	es:[closingConnection]
	jnz	exit

;	If we match the current timerID, then nuke the timer

	call	GrabNotificationTimer
	cmp	bp, es:[notificationTimerID]
	jne	doVSem
	clr	es:[notificationTimer]		;Sets Z flag
EC <	ERROR_NZ	-1						>
doVSem:
	call	ReleaseNotificationTimer
	jne	exit

if	DEBUGGING
	WARNING	FLUSHING_REMOTE_FILE_CHANGE_NOTIFICATIONS
endif
	mov	cx, size RFSHeader
	sub	sp, cx
	mov	si, sp
	segmov	ds, ss		;DS:SI <- RFSHeader

	mov	ds:[si].RPC_proc, RFS_FLUSH_FILE_CHANGE_NOTIFICATIONS
	mov	ds:[si].RPC_flags, RPC_CALL
	call	RFSendBufferWithRetries
	add	sp, cx
exit:
	.leave
	ret
RFSDFlushRemoteNotifications	endp

Client	ends


