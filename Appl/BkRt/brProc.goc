@include <stdapp.goh>
@include <geoMisc.h>
#include <Ansi/string.h>
#include <Ansi/ctype.h>
@include "bkrt.goh"
@include "bckrst.goh"
#include <initfile.h>

/*
 *  External objects.
 */
@extern object BKRTApp;
@extern object BKRTFileList;
@extern object BKRTBackupSuccess;
@extern object BKRTBackupSuccessText;
@extern object BKRTDeleteText;
@extern object BKRTBackupFail;
@extern object BKRTViewOptions;
@extern object FileSelector;
@extern object MemoText;
@extern object MemoText2;
@extern object EmailBackupGroup;
@extern visMoniker AndEFax;
@extern object GroupSize;
@extern object BKRTRestoreStatus;
@extern object RestoreDone;
@extern object BKRTBackupAuto;
@extern object BKRTBackupReminder;
@extern object BKRTBackupSingle;
@extern object BKRTBackupDocDir;
@extern object DocDirSize;
@extern object DocDirBackup;
@extern object DocDirCancel;
@extern object BKRTRestoreTrigger;
@extern object BKRTDeleteTrigger;
@extern object FileSelectBackup;
@extern object FileSelectCancel;
@extern object BKRTDeleteConfirmation;
@extern object BKRTDeleteSuccess;
@extern object BKRTDeleteFail;
@extern object BKRTRestoreConfirmation;
@extern object BKRTRestoreText;
@extern object BKRTViewFolderTrigger;
@extern object BKRTViewAllDocFoldersTrigger;
@extern object BKRTPrimary;

@extern chunk RestorDocMon;
@extern chunk RestorDocFolderMon;
@extern chunk YourDocText;
@extern chunk BackedUpText;
@extern chunk CloseFileMsg;
@extern chunk CouldntGetSizeMsg;
@extern chunk NotEnufSpaceMsg;
@extern chunk GoodDocBUText;
@extern chunk AlreadyHaveText1;
@extern chunk AlreadyHaveText2;
@extern chunk AlreadyHaveText3;
@extern chunk SeveralDocsText;
@extern chunk SeveralDocsEMailText;
@extern chunk EmailWarningText;
@extern chunk InProgressMon;
@extern chunk RestoreComplMon;
@extern chunk RestoreFailMon;
@extern chunk AutoBackUpText;
@extern chunk DocsFolderText;
@extern chunk NoDocsStr;
@extern chunk NoFoldersStr;
@extern chunk DeleteDocBUText;
@extern chunk DeleteFolderBUText;
@extern chunk SysConfigMon;
@extern chunk FullSysMon;
@extern chunk BytesStr;

Boolean g_isEFax = FALSE;

void StatusCallbackRoutine(void);
void StatusCallbackRoutine2(void);
int day_of_year(int year, int month, int day);
Boolean CheckBackupDiskSpace(word diskHandleOrPathToken,
			     const char *relativePath);
char *CheckExistenceOfFile(word diskHandleOrPathToken,
			   const char *relativePath);
/*
 ***************************************************************************
 *		Code for BKRTDocumentClass
 ***************************************************************************
 */
@classdecl	BKRTProcessClass, neverSaved ;
@classdecl      BackupListClass;
@classdecl      MyItemGroupClass;
@classdecl      MyDocumentFolderWindowClass;
@classdecl      MyGenTextClass;
@classdecl      MyGenInteractionClass;
@classdecl      MyGenFileSelectorClass;
@classdecl      MyGenTriggerClass;

/***********************************************************************
 *	MSG_GEN_PROCESS_OPEN_APPLICATION for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    Tell the view of backup group list to initialize.
 * PARAMETERS:	    none
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	11/17/98   	Initial Revision
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
 Boolean	initError;


    /* do we offer to backup efax along with email? */
    initError = InitFileReadBoolean("eFax", "registered", &g_isEFax);
    if (initError) g_isEFax = FALSE;
    if (g_isEFax) {
	  @call EmailBackupGroup::MSG_GEN_USE_VIS_MONIKER(@AndEFax, VUM_NOW);
	  }

    /*
     * No file menu in CUI
     */
    if (UserGetDefaultUILevel() == UIIL_INTRODUCTORY) {
	@call BKRTPrimary::MSG_META_ADD_VAR_DATA(
	    ( HINT_PRIMARY_NO_FILE_MENU | VDF_SAVE_TO_STATE ),
	    0,
	    NULL );
    }
    @callsuper();
    /*
     *  Make the view of backup group list to initialize itself.
     */
    @call self::MSG_BKRTP_UPDATE_BACKUP_VIEW_LIST();
    /*
     *  Read ini file for setting options
     */
    @call self::MSG_BKRTP_READ_SETTING();
    return;
} /* End of MSG_GEN_PROCESS_OPEN_APPLICATION */


/***********************************************************************
 *	MSG_GEN_PROCESS_OPEN_APPLICATION for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    Tell the view of backup group list to initialize.
 * PARAMETERS:	    none
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	11/17/98   	Initial Revision
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_GEN_PROCESS_CLOSE_APPLICATION
{
    /*
     *  Write ini file for setting options
     */
    @call self::MSG_BKRTP_WRITE_SETTING();
    return @callsuper();
} /* End of MSG_GEN_PROCESS_CLOSE_APPLICATION */


/***********************************************************************
 *	MSG_BKRTP_UPDATE_BACKUP_VIEW_LIST for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    Update the view list with the selected backup group
 *                  type.
 * PARAMETERS:	    
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	11/17/98   	Initial Revision
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_BKRTP_UPDATE_BACKUP_VIEW_LIST
{
    optr chunkArray;
    word sel, num, maxFileLen;
    /*
     *  Get the selected type.
     */
    sel = @call BKRTViewOptions::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    /*
     *  Ask the backup/restore library for a list of backup groups.
     */
    chunkArray = BRListBackupGroups(&num, &maxFileLen, sel);
    if (chunkArray) {
	/*
	 *  Initialize our GenDynamic list with the list of backupgroups.
	 */
	@call BKRTFileList::MSG_BL_SET_LIST(chunkArray, num, maxFileLen);
    }
    else {
	/*  No backup data!
	 *  Remove all existing displaying items, and add a new item for
	 *  displaying "You don't have any backup".
	 */
	@call BKRTFileList::MSG_BL_CLEAR_LIST();
	num = @call BKRTFileList::MSG_GEN_DYNAMIC_LIST_GET_NUM_ITEMS();
	if (num)
	    @call BKRTFileList::MSG_GEN_DYNAMIC_LIST_REMOVE_ITEMS
		(GDLP_FIRST, num);
	@call BKRTFileList::MSG_GEN_DYNAMIC_LIST_ADD_ITEMS(GDLP_LAST, 1);
    }
    
    return;
} /* End of MSG_BKRTP_UPDATE_BACKUP_VIEW_LIST.	*/



/***********************************************************************
 *	MSG_BKRTP_VIEW_BACKUP_GROUP for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    View the content inside a backup group.
 * PARAMETERS:	    none
 * SIDE EFFECTS:    none
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	1/25/99   	Initial Revision
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_BKRTP_VIEW_BACKUP_GROUP
{
    word sel, itemSize, num, maxFileLen, count;
    IndexEntryInMem *entry;
    optr monikerChunk, chunkArray;
    /*
     *  Get the selected number from the selection window.
     */
    monikerChunk = @call BKRTFileList::MSG_BL_GET_LIST();
    sel = @call BKRTFileList::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    /*
     *  Get the info of the selected backup group.
     */
    if (monikerChunk && sel != GIGS_NONE) {
	/*
	 *  monikerChunk contains the list of backup groups.
	 */
	MemLock(HandleOf(monikerChunk));
	count = ChunkArrayGetCount(monikerChunk) - 1;
	entry = (IndexEntryInMem *)ChunkArrayElementToPtr
	    (monikerChunk, count - sel, &itemSize);
	/*
	 *  Now, the meat of viewing the content of a backup group.
	 */
	if ((entry->IEIM_type == BT_DOCUMENT_DIR) ||
	      (entry->IEIM_type == BT_DOC_W_EMAIL)) {
	    chunkArray = BRViewBackupGroup
		(entry->IEIM_groupID, &num, &maxFileLen);
	    if (chunkArray) {
		/*
		 *  Initialize our GenDynamic list with the list of 
		 *  backupgroups.
		 */
		@call BKRTFileList::MSG_BL_SET_LIST
		     (chunkArray, num, maxFileLen);
		/* NOTE, the above will free monikerChunk!!!! */
		/*
		 *  Change the bottom menu bar.
		 */
		@send BKRTViewFolderTrigger::MSG_GEN_SET_NOT_USABLE
		     (VUM_DELAYED_VIA_UI_QUEUE);
		MemLock (OptrToHandle(@RestorDocMon));
		@send BKRTRestoreTrigger::MSG_GEN_REPLACE_VIS_MONIKER_TEXT
			(LMemDeref(@RestorDocMon), VUM_DELAYED_VIA_UI_QUEUE);
		MemUnlock (OptrToHandle(@RestorDocMon));
		@send BKRTDeleteTrigger::MSG_GEN_SET_NOT_USABLE
		     (VUM_DELAYED_VIA_UI_QUEUE);
		@send BKRTViewAllDocFoldersTrigger::MSG_GEN_SET_USABLE
		     (VUM_DELAYED_VIA_UI_QUEUE);
		@send BKRTViewAllDocFoldersTrigger::MSG_GEN_SET_ENABLED
			(VUM_DELAYED_VIA_UI_QUEUE);
		/*
		 * Remember which selection number.  Later when we 
		 * we come back, show this selection on screen.
		 */
		@send BKRTViewAllDocFoldersTrigger::
		    MSG_MGT_SET_SELECTION(sel);
	    }
	    else
		MemUnlock(HandleOf(monikerChunk));
	}
	else
	    MemUnlock(HandleOf(monikerChunk));
    }
    return;
} /* End of MSG_BKRTP_VIEW_BACKUP_GROUP.	*/


/***********************************************************************
 *	MSG_BKRTP_VIEW_ALL_BACKUP_GROUPS for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    View the list of all backup groups.
 * PARAMETERS:	    none
 * SIDE EFFECTS:    none
 *
 * STRATEGY:     * THIS METHOD IS CALLED INSIDE(FROM) THE 
 *                 BACKUP-FOLDER CONTENT VIEW *
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	1/25/99   	Initial Revision
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_BKRTP_VIEW_ALL_BACKUP_GROUPS
{
    word sel;
    @send BKRTViewAllDocFoldersTrigger::MSG_GEN_SET_NOT_USABLE
	 (VUM_DELAYED_VIA_UI_QUEUE);
    @send BKRTViewFolderTrigger::MSG_GEN_SET_USABLE
	 (VUM_DELAYED_VIA_UI_QUEUE);
    MemLock (OptrToHandle(@RestorDocFolderMon));
    @send BKRTRestoreTrigger::MSG_GEN_REPLACE_VIS_MONIKER_TEXT
	 (LMemDeref(@RestorDocFolderMon), VUM_DELAYED_VIA_UI_QUEUE);
    MemUnlock (OptrToHandle(@RestorDocFolderMon));
    @send BKRTRestoreTrigger::MSG_GEN_SET_NOT_ENABLED
	 (VUM_DELAYED_VIA_UI_QUEUE);
    @send BKRTDeleteTrigger::MSG_GEN_SET_USABLE
	 (VUM_DELAYED_VIA_UI_QUEUE);
    /*
     *  Show the list of all backup groups.
     */
    @send self::MSG_BKRTP_UPDATE_BACKUP_VIEW_LIST();
    /*
     *  Show the previous selection.
     */
    sel = @call BKRTViewAllDocFoldersTrigger::
	MSG_MGT_GET_SELECTION();
    @send BKRTFileList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(sel,0);
    return;
}


/***********************************************************************
 *		MSG_BKRTP_QUIT_APP for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    Quit the application.
 * PARAMETERS:	    
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	11/17/98   	Initial Revision
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_BKRTP_QUIT_APP
{
    @send, forceQueue BKRTApp::MSG_META_QUIT();
    return;
} /* End of MSG_BKRTP_QUIT_APP.	*/




/***********************************************************************
 *	MSG_BKRTP_BACKUP_SELECTED_FILE for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    Back up the selected file.
 * PARAMETERS:	    none
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	11/27/98   	Initial Revision
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_BKRTP_BACKUP_SELECTED_FILE
{
    GroupID id;
    char description[LEN_DESCRIPTION+1], relativePath[PATH_BUFFER_SIZE], *cp;
    dword rslt = 0;
    word  diskHandleOrPathToken;
    Boolean ok = FALSE;

    /*
	*  Disable UI.
     */
    @call FileSelectBackup::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @call FileSelectCancel::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @send BKRTApp::MSG_GEN_APPLICATION_MARK_BUSY();
    /*
     *  Get the standard path token and relative path.
     */
    rslt = @call FileSelector::MSG_GEN_FILE_SELECTOR_GET_FULL_SELECTION_PATH
	(relativePath);

    if ((GFS_GET_ENTRY_FLAGS(rslt) & GFSEF_TYPE) == GFSET_FILE) {
	/*
	 *  A file has been selected.
	 */
	diskHandleOrPathToken=GFS_GET_FULL_SELECTION_PATH_DISK_HANDLE(rslt);
	/*
	 *  Check for available hard disk space.
	 */
	ok = CheckBackupDiskSpace(diskHandleOrPathToken, relativePath);
	if (ok == TRUE) {
	    /*
	     *  Get the description for the backup.
	     */
	    @call MemoText::MSG_VIS_TEXT_GET_ALL_PTR(description);
	    /*
	     *  Create a backup folder in the backup directory.
	     */
	    id = BRCreateBackupGroup(description, BT_SINGLE_FILE);
	    if (id != GROUPID_INVALID) {
		/*
		 *  Add the backup file into the backup folder.
		 */
		ok = BRBackupSingleFile(id, diskHandleOrPathToken, 
					relativePath);
	    }
	}
    }

    if (ok == TRUE) {
	@send BKRTViewOptions::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION
	     (BT_SINGLE_FILE,0);
	cp = strrchr(relativePath, '\\');
	if (cp) {
	    MemLock (OptrToHandle(@YourDocText));
	    @send BKRTBackupSuccessText::MSG_VIS_TEXT_REPLACE_ALL_PTR
		 (LMemDeref(@YourDocText),0);
	    @send BKRTBackupSuccessText::MSG_VIS_TEXT_APPEND_PTR(cp+1, 0);
	    @send BKRTBackupSuccessText::MSG_VIS_TEXT_APPEND_PTR
		 (LMemDeref(@BackedUpText), 0);
	    MemUnlock (OptrToHandle(@YourDocText));
	    @send BKRTBackupSuccess::MSG_GEN_INTERACTION_INITIATE();
	}
    }
    else {
	@send BKRTBackupFail::MSG_GEN_INTERACTION_INITIATE();
    }

    @send BKRTBackupSingle::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);

    /*
	*  Enable UI.
	*/
    @send FileSelectBackup::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send FileSelectCancel::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send BKRTApp::MSG_GEN_APPLICATION_MARK_NOT_BUSY();

    return;
} /* End of MSG_BKRTP_BACKUP_SELECTED_FILE.	*/


/***********************************************************************
 *	MSG_BKRTP_BACKUP_USER_DOC for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    Back up all files under the User Document directory
 * PARAMETERS:	    none
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	11/27/98   	Initial Revision
 *   jfh		02/24/00		added email
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_BKRTP_BACKUP_USER_DOC
{
char				description[LEN_DESCRIPTION+1];
BackupDrive		destination = BD_HARDISK;
TimerDateAndTime	current;
int				todayOfYear;
dword			totalSize, freeSpace, mailSize=0, faxSize=0;
word				email, mailFiles, faxFiles;
Boolean			emailBool = FALSE;


    /*
     *  Disable UI.
     */
    @call DocDirBackup::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @call DocDirCancel::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @send BKRTApp::MSG_GEN_APPLICATION_MARK_BUSY();

    /* See if we're backing up email */
    email = @call EmailBackupGroup::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    if (email) {
	  emailBool = TRUE;
	  BRGetInfoOnUserMailDir(&mailFiles, &mailSize);
	  if (g_isEFax) {
		BRGetInfoOnUserFaxDir(&faxFiles, &faxSize);
		mailSize += faxSize;
		}
	  }
    /*
	*  Check for enough hard disk space for backup.
	*/
    totalSize = @call DocDirSize::MSG_MGT_GET_TOTAL_FILE_SIZE();
    totalSize += mailSize;
    freeSpace = BRGetBackupDiskFreeSpace();
    if (totalSize && (freeSpace / totalSize) < 4) {
	/*
	 *  Not enough hard disk space. Bring up a warning dialog box.
	 */
	MemLock (OptrToHandle(@NotEnufSpaceMsg));
	UserStandardDialog((char *)0, (char *)0, (char *)0, (char *)0,
			   LMemDeref(@NotEnufSpaceMsg),
			   (CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
			   (GIT_NOTIFICATION <<
			    CDBF_INTERACTION_TYPE_OFFSET));
	MemUnlock (OptrToHandle(@NotEnufSpaceMsg));
	@send DocDirBackup::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);
	@send DocDirCancel::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);
     @send BKRTApp::MSG_GEN_APPLICATION_MARK_NOT_BUSY();
	return;
    }
    /*
	*  Get the description for the backup
     */
    @call MemoText2::MSG_VIS_TEXT_GET_ALL_PTR(description);
    /*
     *  Now ask the library to backup the USER DOCUMENT directory
     *  recursively.
     */
    if (BRBackupUserDoc(description, destination, emailBool, g_isEFax,
			(void (*)(void))StatusCallbackRoutine2) == FALSE) {
	@call BKRTBackupDocDir::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
	@send BKRTBackupFail::MSG_GEN_INTERACTION_INITIATE();
    }
    else {
	@send BKRTViewOptions::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION
	     (BT_DOCUMENT_DIR,0);
	@call BKRTBackupDocDir::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
	MemLock (OptrToHandle(@GoodDocBUText));
	@send BKRTBackupSuccessText::MSG_VIS_TEXT_REPLACE_ALL_PTR
		(LMemDeref(@GoodDocBUText),0);
	MemUnlock (OptrToHandle(@GoodDocBUText));
	@send BKRTBackupSuccess::MSG_GEN_INTERACTION_INITIATE();
	/*
	 *  Update the backup date in the ini file, to re-start the timing
	 *  for the next document folder backup.
	 */
	TimerGetDateAndTime(&current);
	InitFileWriteInteger("backupRestore", "lastBackupYear",
			     current.TDAT_year);
	todayOfYear = day_of_year(current.TDAT_year, 
				  current.TDAT_month,
				  current.TDAT_day);
	InitFileWriteInteger("backupRestore", "lastBackupDay", todayOfYear);
    }
    /*
	*  Enable UI.
	*/
    @send DocDirBackup::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);
    @send DocDirCancel::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);
    @send BKRTApp::MSG_GEN_APPLICATION_MARK_NOT_BUSY();

    return;
} /* End of MSG_BKRTP_BACKUP_USER_DOC.	*/


/***********************************************************************
 *	MSG_BKRTP_BACKUP_SYS_CONFIG for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    Back up the system configuration.
 * PARAMETERS:	    none
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	11/27/98   	Initial Revision
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_BKRTP_BACKUP_SYS_CONFIG
{
    char *description = NULL;
    BRBackupSystemConfig(description);
    return;
} /* End of MSG_BKRTP_BACKUP_SYS_CONFIG.	*/


/***********************************************************************
 *	MSG_BKRTP_BACKUP_FULL_SYS for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    Back up the full system.
 * PARAMETERS:	    none
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	11/27/98   	Initial Revision
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_BKRTP_BACKUP_FULL_SYS
{
    char *description = NULL;
/*    BRRecursiveBackupDir("BackupFullSys", SP_TOP, "", "c:\\full", NULL); */
    return;
} /* End of MSG_BKRTP_BACKUP_FULL_SYS.	*/


/***********************************************************************
 *	MSG_BKRTP_RESTORE_SYS_CONFIG for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    Restore system configuration, leaving the data files
 *                  intact.
 * PARAMETERS:	    none
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	11/27/98   	Initial Revision
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_BKRTP_RESTORE_SYS_CONFIG
{
    GroupID id = GROUPID_INVALID;

    BRRestoreBackupGroup(id, NULL, NULL, NULL);

    return;
} /* End of MSG_BKRTP_RESTORE_SYS_CONFIG.	*/


/***********************************************************************
 *	MSG_BKRTP_RESTORE_FULL_SYS for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    Restore system configuration.
 * PARAMETERS:	    none
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	11/27/98   	Initial Revision
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_BKRTP_RESTORE_FULL_SYS
{
    GroupID id = GROUPID_INVALID;

    BRRestoreBackupGroup(id, NULL, NULL, NULL);

    return;
} /* End of MSG_BKRTP_RESTORE_FULL_SYS.	*/


/***********************************************************************
 *	MSG_BKRTP_CONFIRMATION_ON_RESTORE for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    Bring up a restore confirmation box with an
 *                  appropriate warning.
 * PARAMETERS:	    none
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	11/27/98   	Initial Revision
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_BKRTP_CONFIRMATION_ON_RESTORE
{
    word sel, itemSize, count;
    IndexEntryInMem *entry;
    optr monikerChunk;
    char *fileName = NULL, *folder = NULL;
    /*
     *  Get the selected number.
     */
    monikerChunk = @call BKRTFileList::MSG_BL_GET_LIST();
    sel = @call BKRTFileList::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    /*
     *  Get the info of the selected backup group.
     */
    if (monikerChunk && sel != GIGS_NONE) {
	/*
	 *  monikerChunk contains the list of backup groups.
	 */
	MemLock(HandleOf(monikerChunk));
	count = ChunkArrayGetCount(monikerChunk) - 1;
	entry = (IndexEntryInMem *)ChunkArrayElementToPtr
	    (monikerChunk, count - sel, &itemSize);

	if (entry->IEIM_type == BT_SINGLE_FILE) {
	    /* Single file restoration, check for existence of the file. */
	    folder = ((char *)entry) + sizeof(IndexEntryInMem) +
		LEN_DATE + entry->IEIM_descriptionLen;
	    fileName = CheckExistenceOfFile(entry->IEIM_pathToken,
					    folder);
	    if (fileName) {
		/* 
		 * The file exists under the DOCUMENT directory, so
		 * let's give user a warning of overwriting it.
		 */
		MemLock (OptrToHandle(@AlreadyHaveText1));
		@send BKRTRestoreText::MSG_VIS_TEXT_REPLACE_ALL_PTR
			(LMemDeref(@AlreadyHaveText1), 0);
		@send BKRTRestoreText::MSG_VIS_TEXT_APPEND_PTR(fileName, 0);
		@send BKRTRestoreText::MSG_VIS_TEXT_APPEND_PTR
			(LMemDeref(@AlreadyHaveText2), 0);
		if (folder+1 != fileName) {
		    if (*folder != '\\')
			@send BKRTRestoreText::MSG_VIS_TEXT_APPEND_PTR
			    ("\\", 0);
		    @send BKRTRestoreText::MSG_VIS_TEXT_APPEND_PTR
			 (folder, fileName-folder-1);
		}
		@send BKRTRestoreText::MSG_VIS_TEXT_APPEND_PTR
			(LMemDeref(@AlreadyHaveText3), 0);
 		MemUnlock (OptrToHandle(@AlreadyHaveText1));
		@send BKRTRestoreConfirmation::MSG_GEN_SET_NOT_USABLE
		     (VUM_NOW);
		@send BKRTRestoreConfirmation::MSG_GEN_SET_USABLE
		     (VUM_NOW);
		@send BKRTRestoreConfirmation::MSG_GEN_INTERACTION_INITIATE();
	    }
	    else {
		/*
		 *  The file doesn't exist under the DOCUMENT directory.
		 *  No need to bring up a warning dialog box.
		 */
		@send process::MSG_BKRTP_RESTORE_GROUP();
	    }
	}
	else if (entry->IEIM_type == BT_EMAIL_ACCT){
	    MemLock (OptrToHandle(@EmailWarningText));
	    @send BKRTRestoreText::MSG_VIS_TEXT_REPLACE_ALL_PTR
		 (LMemDeref(@EmailWarningText), 0);
	    MemUnlock (OptrToHandle(@EmailWarningText));
	    @send BKRTRestoreConfirmation::MSG_GEN_INTERACTION_INITIATE();
	}
	else if (entry->IEIM_type == BT_DOC_W_EMAIL){
	    MemLock (OptrToHandle(@SeveralDocsEMailText));
	    @send BKRTRestoreText::MSG_VIS_TEXT_REPLACE_ALL_PTR
		 (LMemDeref(@SeveralDocsEMailText), 0);
	    MemUnlock (OptrToHandle(@SeveralDocsEMailText));
	    @send BKRTRestoreConfirmation::MSG_GEN_INTERACTION_INITIATE();
	}
	else {  /* doc folder */
	    MemLock (OptrToHandle(@SeveralDocsText));
	    @send BKRTRestoreText::MSG_VIS_TEXT_REPLACE_ALL_PTR
		 (LMemDeref(@SeveralDocsText), 0);
	    MemUnlock (OptrToHandle(@SeveralDocsText));
	    @send BKRTRestoreConfirmation::MSG_GEN_INTERACTION_INITIATE();
	}
	MemUnlock(HandleOf(monikerChunk));
    }
    return;
} /* End of MSG_BKRTP_CONFIRMATION_ON_RESTORE.	*/


/***********************************************************************
 *		MSG_BKRTP_RESTORE_GROUP for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    Restore a backup group.
 * PARAMETERS:      void
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	12/10/98   	Initial Revision
 *   jfh		02/28/00		added email
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_BKRTP_RESTORE_GROUP
{
    word sel, itemSize, numFiles, count;
    dword totalSize;
    IndexEntryInMem *entry;
    Boolean ok = FALSE;
    optr monikerChunk;

    @send BKRTRestoreConfirmation::MSG_GEN_GUP_INTERACTION_COMMAND
	 (IC_DISMISS);
    /*
     *  Get the selected number.
     */
    monikerChunk = @call BKRTFileList::MSG_BL_GET_LIST();
    sel = @call BKRTFileList::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    /*
     *  Get the info of the selected backup group.
     */
    if (monikerChunk && sel != GIGS_NONE) {
	/*
	 *  monikerChunk contains the list of backup groups.
	 */
	MemLock(HandleOf(monikerChunk));
	count = ChunkArrayGetCount(monikerChunk) - 1;
	entry = (IndexEntryInMem *)ChunkArrayElementToPtr
	    (monikerChunk, count - sel, &itemSize);
	/*
	 *  Show status
	 */
	if (entry->IEIM_type == BT_SINGLE_FILE) {
	    BRGetInfoOnBackupGroup(entry->IEIM_groupID, &numFiles,
				   &totalSize,
				   ((char *)entry) +
				   sizeof(IndexEntryInMem) +
				   LEN_DATE +
				   entry->IEIM_descriptionLen,
				   entry->IEIM_pathToken);
	}
	else if ((entry->IEIM_type == BT_DOCUMENT_DIR) ||
	    (entry->IEIM_type == BT_DOC_W_EMAIL)){
	    BRGetInfoOnBackupGroup(entry->IEIM_groupID, &numFiles,
				   &totalSize, NULL,NULL);
	}
	else if (entry->IEIM_type == BT_EMAIL_ACCT) {
	    BRGetInfoOnBackupGroup(entry->IEIM_groupID, &numFiles,
				   &totalSize,
				   ((char *)entry) +
					   sizeof(IndexEntryInMem) +
					   LEN_DATE +
					   entry->IEIM_descriptionLen +
					   15,
				   entry->IEIM_pathToken);
	}

	@call GroupSize::MSG_MGT_SET_NUM_FILES(numFiles, totalSize);
	MemLock (OptrToHandle(@InProgressMon));
	@call RestoreDone::MSG_GEN_REPLACE_VIS_MONIKER_TEXT
		(LMemDeref(@InProgressMon), VUM_NOW);
	MemLock (OptrToHandle(@InProgressMon));
	@call RestoreDone::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	@call BKRTRestoreStatus::MSG_GEN_INTERACTION_INITIATE();
	TimerSleep(1);
	/*
	 *  Now, the meat of restoring a file.
	 */
	@send BKRTApp::MSG_GEN_APPLICATION_MARK_BUSY();
	if (entry->IEIM_type == BT_SINGLE_FILE) {
	    ok = BRRestoreBackupGroup(entry->IEIM_groupID,
					 entry->IEIM_pathToken,
					 ((char *)entry) +
					 sizeof(IndexEntryInMem) +
					 LEN_DATE +
					 entry->IEIM_descriptionLen,
					 (void (*)(void))StatusCallbackRoutine);
	} 
	else if ((entry->IEIM_type == BT_DOCUMENT_DIR) ||
		    (entry->IEIM_type == BT_DOC_W_EMAIL)){
	    ok = BRRestoreBackupGroup(entry->IEIM_groupID,
				      NULL,NULL,
				      (void (*)(void))StatusCallbackRoutine);
	}
	else if (entry->IEIM_type == BT_EMAIL_ACCT) {
	    /* send the email account folder name & privdata folder token */
	    ok = BRRestoreBackupGroup(entry->IEIM_groupID,
					 entry->IEIM_pathToken,
					 ((char *)entry) +
						  sizeof(IndexEntryInMem) +
						  LEN_DATE +
						  entry->IEIM_descriptionLen +
						  15,
					 (void (*)(void))StatusCallbackRoutine);
	}
	MemUnlock(HandleOf(monikerChunk));
    }
    if (ok == TRUE) {
	MemLock (OptrToHandle(@RestoreComplMon));
	@send RestoreDone::MSG_GEN_REPLACE_VIS_MONIKER_TEXT
		(LMemDeref(@RestoreComplMon), VUM_DELAYED_VIA_UI_QUEUE);
	MemUnlock (OptrToHandle(@RestoreComplMon));
    }
    else {
	MemLock (OptrToHandle(@RestoreFailMon));
	@send RestoreDone::MSG_GEN_REPLACE_VIS_MONIKER_TEXT
		(LMemDeref(@RestoreFailMon), VUM_DELAYED_VIA_UI_QUEUE);
	MemUnlock (OptrToHandle(@RestoreFailMon));
    }
    @send RestoreDone::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);
    @send BKRTApp::MSG_GEN_APPLICATION_MARK_NOT_BUSY();

    return;
} /* End of MSG_BKRTP_RESTORE_GROUP */


/***********************************************************************
 *	MSG_BKRTP_DELETE_GROUP for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    Delete 
 * PARAMETERS:	    ()
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	11/27/98   	Initial Revision
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_BKRTP_DELETE_GROUP
{
    word sel, itemSize, count;
    IndexEntryInMem *entry;
    Boolean ok = FALSE;
    optr monikerChunk;
    /*
     *  Get the selected number.
     */
    monikerChunk = @call BKRTFileList::MSG_BL_GET_LIST();
    sel = @call BKRTFileList::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    /*
     *  Get the info of the selected backup group.
     */
    if (monikerChunk && sel != GIGS_NONE) {
	/*
	 *  monikerChunk contains the list of backup groups.
	 */
	MemLock(HandleOf(monikerChunk));
	count = ChunkArrayGetCount(monikerChunk) - 1;
	entry = (IndexEntryInMem *)ChunkArrayElementToPtr
	    (monikerChunk, count - sel, &itemSize);
	/*
	 *  Show status
	BRGetInfoOnBackupGroup(entry->IEIM_groupID, &numFiles, &totalSize);
	@call GroupSize::MSG_MGT_SET_NUM_FILES(numFiles, totalSize);
	@call RestoreDone::MSG_GEN_REPLACE_VIS_MONIKER_TEXT
	     ("In progress...", VUM_NOW);
	@call RestoreDone::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	@call BKRTRestoreStatus::MSG_GEN_INTERACTION_INITIATE();
	TimerSleep(1);
	 */
	/*
	 *  Now, the meat of deleting a file.
	 */
	if (entry->IEIM_type == BT_SINGLE_FILE) {
	    ok = BRDeleteBackupGroup(entry->IEIM_groupID,
				     entry->IEIM_pathToken,
				     ((char *)entry) + 
				     sizeof(IndexEntryInMem) + 
				     LEN_DATE +
				     entry->IEIM_descriptionLen,
				     (void (*)(void))StatusCallbackRoutine);
	} 
	else  {
	    ok = BRDeleteBackupGroup(entry->IEIM_groupID,
				     NULL,NULL,
				     (void (*)(void))StatusCallbackRoutine);
	}
	MemUnlock(HandleOf(monikerChunk));
	@send self::MSG_BKRTP_UPDATE_BACKUP_VIEW_LIST();
    }
    @send BKRTDeleteConfirmation::MSG_GEN_GUP_INTERACTION_COMMAND
	 (IC_DISMISS);
    if (ok ==  TRUE) {
	@send BKRTDeleteSuccess::MSG_GEN_INTERACTION_INITIATE();
    }
    else {
	@send BKRTDeleteFail::MSG_GEN_INTERACTION_INITIATE();
    }

    return;
} /* End of MSG_BKRTP_DELETE_GROUP */


/***********************************************************************
 *	MSG_BKRTP_READ_SETTING for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    Write current setting in the ini file.
 * PARAMETERS:	    ()
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *	Approximations can be used in the date-calculation math.  However,
 *	it is very important that whatever math used here must be identical
 *	to that used in CheckAutoBackup in
 *	Driver/Power/GPC1APM/gpc1apmCustom.asm.  Otherwise a scenario may
 *	happen where the power driver launches the app, but the app decides
 *	that no auto-backup should happen and then displays the default UI
 *	instead of the auto-backup UI.  This will appear strange to the user
 *	as if the app started by itself for no reason.
 *
 *	We approximate a month with 30 days and a year with 365 days.
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	11/27/98   	Initial Revision
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_BKRTP_READ_SETTING
{
    int iniFreqValue = -1;
    TimerDateAndTime current;
    int year=0, dayOfYear=0, todayOfYear=0;
    int period;

    if (!InitFileReadInteger("backupRestore","frequency",&iniFreqValue) &&
	(iniFreqValue >= 0 && iniFreqValue < 3)) {
	@send BKRTBackupAuto::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION
	     (iniFreqValue,0);

	if (iniFreqValue != AB_NEVER) {
	    /*
	     *  If the last backup date has expired by the freqency date,
	     *  then tell the user it's time to do backup again.
	     */
	    TimerGetDateAndTime(&current);
	    if (!InitFileReadInteger("backupRestore","lastBackupYear",&year) &&
		!InitFileReadInteger("backupRestore","lastBackupDay",&dayOfYear)){
		todayOfYear = day_of_year(current.TDAT_year, 
					  current.TDAT_month,
					  current.TDAT_day);
		period = (iniFreqValue == AB_WEEK) ? 7 : 30;

		if ((current.TDAT_year == year
		     && todayOfYear >= dayOfYear + period)
		    || (current.TDAT_year == year + 1
			&& todayOfYear + 365 >= dayOfYear + period)
		    || (current.TDAT_year >= year + 2)) {
		    @send BKRTBackupReminder::
			MSG_GEN_INTERACTION_INITIATE();
		} /* else last backup was in future.  Error. */
	    }
	}
    }
    else {
	InitFileWriteInteger("backupRestore","frequency",0);
	@send BKRTBackupAuto::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(0,0);
	TimerGetDateAndTime(&current);
	InitFileWriteInteger("backupRestore","lastBackupYear",current.TDAT_year);
	todayOfYear = day_of_year(current.TDAT_year, 
				current.TDAT_month,
				current.TDAT_day);
	InitFileWriteInteger("backupRestore","lastBackupDay", todayOfYear);
    }
    return;
} /* MSG_BKRTP_READ_SETTING */


/***********************************************************************
 *	MSG_BKRTP_WRITE_SETTING for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    Write current setting in the ini file.
 * PARAMETERS:	    ()
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	11/27/98   	Initial Revision
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_BKRTP_WRITE_SETTING
{
    int iniFreqValue;

    iniFreqValue = @call BKRTBackupAuto::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    if (iniFreqValue >= 0 && iniFreqValue < 3) {
	InitFileWriteInteger("backupRestore","frequency",iniFreqValue);
	InitFileCommit();
    }
    return;
} /* MSG_BKRTP_WRITE_SETTING */


int _far _pascal
STRCASENCMP (const char *a, const char *b, word n)
{
    int diff;

    for( ; n && *a && *b; a++, b++, n--) {
	diff = tolower(*a) - tolower(*b);
	if (diff)
	    return diff;
    }

    if (*a) return 1;			/* a was longer than b */
    if (*b) return -1;			/* a was shorter than b */
    return 0;				/* Exact match */
}	/* End of STRCASECMP.	*/

/***********************************************************************
 *	Internal sort routines for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    FindAPlaceToInsert, MainSort
 * PARAMETERS:	    ()
 * SIDE EFFECTS:    
 *
 * STRATEGY:      Create a new chunk arry store the correct order
 *                of the entries.  The arry is in the decreasing
 *                order.  QUERY_MONIKER message will reverse the
 *                order to be the increasing order.
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	1/1/99   	Initial Revision
 *   jfh		3/12/00	added datetime sort
 *
 ***********************************************************************/
void FindAPlaceToInsert
(optr newArray, IndexEntryInMem *entry, word entrySize, ListMenu field)
{
word				count, totalNum, newEntrySize, min;
IndexEntryInMem	*newEntry;
char				*newPtr, *oldPtr;  /* point to the field to be compared */
char				oldDateStr[15], newDateStr[15];


    MemLock(HandleOf(newArray));
    totalNum = count = ChunkArrayGetCount(newArray);
    /*
     *  Adjust the old pointer to the field of the entry to be copied
     *  into the correct position in the new array.
     */
    if (field == LM_FILENAME) {
	oldPtr = strrchr
	    (((char*)entry) + sizeof(IndexEntryInMem) + LEN_DATE + 
	     entry->IEIM_descriptionLen, '\\');
    }
    else if (field == LM_MEMO) {
	oldPtr = ((char*)entry) + sizeof(IndexEntryInMem) + LEN_DATE;
    }
    else  {  /* field == LM_DATETIME */
	oldPtr = ((char*)entry) + sizeof(IndexEntryInMem);
	/* rearrange date string into sortable order */
	strncpy(oldDateStr, oldPtr + 4, 4); /* year first */
	oldDateStr[4] = 0;
	strncat(oldDateStr, oldPtr, 4);  /* month & day */
	strncat(oldDateStr, oldPtr + 8, 6); /* hhmmss */
	oldPtr = &oldDateStr[0];
    }

    if (oldPtr) {
	while (count) {
	    newEntry = (IndexEntryInMem *)ChunkArrayElementToPtr
		(newArray, count-1, &newEntrySize);

	    if (field == LM_FILENAME) {
		/* sorted by file name */
		min = (newEntry->IEIM_fileLen < entry->IEIM_fileLen) ?
		    (newEntry->IEIM_fileLen) : (entry->IEIM_fileLen);
		newPtr = strrchr
		    (((char*)newEntry)+sizeof(IndexEntryInMem)+LEN_DATE+
		     newEntry->IEIM_descriptionLen, '\\');
		if (newPtr && STRCASENCMP(oldPtr, newPtr, min) < 0)
		    break;
	    } 
	    else if (field == LM_MEMO) {
		if (newEntry->IEIM_descriptionLen == 0)
		    break;
		min = (newEntry->IEIM_descriptionLen < 
		       entry->IEIM_descriptionLen) ?
		    (newEntry->IEIM_descriptionLen) : 
		    (entry->IEIM_descriptionLen);
		newPtr = ((char*)newEntry)+sizeof(IndexEntryInMem)+LEN_DATE;
		if (newPtr && STRCASENCMP(oldPtr, newPtr, min) < 0)
		    break;
	    }
	    else /* (field == LM_DATETIME) */ {
    //		EC_ERROR(-1);  /* It's not done here. OH YES IT IS!!! */
		newPtr = ((char*)newEntry)+ sizeof(IndexEntryInMem);
		/* rearrange date string into sortable order */
		strncpy(newDateStr, newPtr + 4, 4);
		newDateStr[4] = 0;
		strncat(newDateStr, newPtr, 4);
		strncat(newDateStr, newPtr + 8, 6);
		newPtr = &newDateStr[0];
		if (newPtr && STRCASENCMP(newPtr, oldPtr, 14) < 0)
		    break;
	    }
	    count--;
	}
    }
    /*
	*  Insert a place holder in the new chunk array.
	*/
    if (oldPtr && count == totalNum) { /* for the initial emtpy chunk array */
	newEntry = ChunkArrayAppend(newArray, entrySize);
    }
    else if (!oldPtr) {  /* for the document dir case */
	newEntry = (IndexEntryInMem *)ChunkArrayElementToPtr
	    (newArray, 0, &newEntrySize);
	newEntry = ChunkArrayInsertAt(newArray, newEntry, entrySize);
    }
    else {
	newEntry = (IndexEntryInMem *)ChunkArrayElementToPtr
	    (newArray, count, &newEntrySize);
	newEntry = ChunkArrayInsertAt(newArray, newEntry, entrySize);
    }
    /*
     *  Copy the entry content
     */
    memcpy(newEntry, entry, entrySize);

    MemUnlock(HandleOf(newArray));
    return;
}
void MainSort(ListMenu type)
{
    optr monikerChunk;
    MemHandle mem;
    ChunkHandle newChunk;
    word count, entrySize, num;
    IndexEntryInMem *entry;
    LMemBlockHeader *header;

    monikerChunk = @call BKRTFileList::MSG_BL_GET_LIST();
    if (!monikerChunk)
	return;
    MemLock(HandleOf(monikerChunk));
    num = count = ChunkArrayGetCount(monikerChunk);
    if (count) {
	mem = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
	if (mem) {
	    header = (LMemBlockHeader *)MemLock(mem);
	    header->LMBH_flags |= LMF_RETURN_ERRORS;
	    newChunk = ChunkArrayCreate(mem, 0, 0, 0);
	    if (newChunk) {
		/*
		 *  Insertion sort.
		 */
		while (count) {
		    count--;
		    entry = (IndexEntryInMem *)ChunkArrayElementToPtr
			(monikerChunk, count, &entrySize);
		    FindAPlaceToInsert(ConstructOptr(mem,
						     newChunk), 
				       entry, entrySize, type);
		}
	    }
	    MemUnlock(mem);
	}
    }
    MemUnlock(HandleOf(monikerChunk));
    @call BKRTFileList::MSG_BL_SET_LIST
	 (ConstructOptr(mem, newChunk), num, (word)-1);
    return;
}

/***********************************************************************
 *	MSG_BKRTP_SORT_DATETIME/FILENAME/MEMO for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    Sort the list entries according to different field.
 * PARAMETERS:	    ()
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	1/1/99   	Initial Revision
 *   jfh		3/12/00	fix date sort
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_BKRTP_SORT_DATETIME
{

    if (@call BKRTViewFolderTrigger::MSG_GEN_GET_USABLE())
	  /* we're seeing Document backups ...
	   * Simply rebuild the list from the index file. */
	  @call process::MSG_BKRTP_UPDATE_BACKUP_VIEW_LIST();
    else
	  /* we're seeing contents of Document */
	  MainSort(LM_DATETIME);

} /* MSG_BKRTP_SORT_FILENAME */
@method BKRTProcessClass, MSG_BKRTP_SORT_FILENAME
{
    MainSort(LM_FILENAME);
} /* MSG_BKRTP_SORT_MEMO */
@method BKRTProcessClass, MSG_BKRTP_SORT_MEMO
{
    MainSort(LM_MEMO);
} /* MSG_BKRTP_SORT_DATETIME */


/***********************************************************************
 *	MSG_BKRTP_AUTOMATIC_BACKUP for BKRTProcessClass
 ***********************************************************************
 * SYNOPSIS:	    Bring up the Automatic Backup diloag box.
 * PARAMETERS:	    ()
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	1/3/99   	Initial Revision
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_BKRTP_AUTOMATIC_BACKUP
{
    @call BKRTBackupReminder::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
    @call BKRTBackupDocDir::MSG_GEN_INTERACTION_INITIATE();
    MemLock (OptrToHandle(@AutoBackUpText));
    @call MemoText2::MSG_VIS_TEXT_REPLACE_ALL_PTR(LMemDeref(@AutoBackUpText), 0);
    MemUnlock (OptrToHandle(@AutoBackUpText));
    @call MemoText2::MSG_VIS_TEXT_SELECT_ALL();
    return;
}


/***********************************************************************
 *	MSG_BL_SET_LIST for BackupListClass
 ***********************************************************************
 * SYNOPSIS:	    Initialize the GenDynamic list with the list of 
 *                  backup groups
 * PARAMETERS:	    (optr chunkArray, word num, word maxFileLen)
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	11/27/98   	Initial Revision
 *
 ***********************************************************************/
@method BackupListClass, MSG_BL_SET_LIST
{
    /* Free any previous existing list */
    if (@self->BL_monikerChunk) {
	MemFree(HandleOf(@self->BL_monikerChunk));
	/*
	 *  Remove all list items.
	 */
	@call self::MSG_GEN_DYNAMIC_LIST_REMOVE_ITEMS
	     (GDLP_FIRST, @self->GDLI_numItems);
    }
    else if (@self->GDLI_numItems) {
        /* remove the string that says you don't have any backup */
	@call self::MSG_GEN_DYNAMIC_LIST_REMOVE_ITEMS
	     (GDLP_FIRST, @self->GDLI_numItems);
    }
    /* store the list */
    @self->BL_monikerChunk = chunkArray;
    /* store the length of the longest file name. */
    if (maxFileLen != (word)-1)
	@self->BL_maxFileLen = maxFileLen;
    /* add a number of monikers */
    @call BKRTFileList::MSG_GEN_DYNAMIC_LIST_ADD_ITEMS(GDLP_LAST, num);
    @call BKRTFileList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(num);
    return;
} /* End of MSG_BL_SET_LIST */


/***********************************************************************
 *	MSG_BL_GET_LIST for BackupListClass
 ***********************************************************************
 * SYNOPSIS:	    Return the moniker chunk.
 * PARAMETERS:	    optr ();
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	11/27/98   	Initial Revision
 *
 ***********************************************************************/
@method BackupListClass, MSG_BL_GET_LIST
{
    return (@self->BL_monikerChunk);
} /* End of MSG_BL_SET_LIST */

/***********************************************************************
 *	MSG_BL_CLEAR_LIST for BackupListClass
 ***********************************************************************
 * SYNOPSIS:	    Clear all the instance data.
 * PARAMETERS:	    optr ();
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	11/27/98   	Initial Revision
 *
 ***********************************************************************/
@method BackupListClass, MSG_BL_CLEAR_LIST
{
    if (@self->BL_monikerChunk) {
	MemFree(HandleOf(@self->BL_monikerChunk));
	@self->BL_monikerChunk = NULL;
	@self->BL_maxFileLen = 0;
    }
    return;
} /* End of MSG_BL_CLEAR_LIST */


/***********************************************************************
 *		CreateLMemGString
 ***********************************************************************
 *
 * SYNOPSIS:	Create an LMem-block-based grahpics string ready 
 *		for filling by the caller.
 * CALLED BY:	
 * RETURN:	gstate through which to draw, plus optr of the storage
 *		for the graphics string.
 * SIDE EFFECTS:
 *	
 * STRATEGY:
 *	
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	mzhu	9/ 4/96   	Initial Revision
 *
 ***********************************************************************/
GStateHandle
CreateLMemGString (optr *storagePtr)
{
    MemHandle		newBlock;
    ChunkHandle		newChunk;
    GStateHandle 	gstate;

    newBlock = MemAllocLMem(LMEM_TYPE_GENERAL, sizeof(LMemBlockHeader)); 
    ECCheckMemHandle(newBlock);
    MemModifyFlags(newBlock, HF_SHARABLE, 0);

    gstate = GrCreateGString(newBlock, GST_CHUNK, &newChunk);
    ECCheckGStateHandle(gstate);

    *storagePtr = ConstructOptr(newBlock, newChunk);
 
    return(gstate);
}	/* End of CreateLMemGString.	*/

/***********************************************************************
 *		MSG_BL_QUERY_MONIKER for BackupListClass
 ***********************************************************************
 * SYNOPSIS:	    Query the moniker.
 * PARAMETERS:void (word selection, word numSelections, byte stateFlags)
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	12/07/98   	Initial Revision
 *   jfh		02/27/00		Added email
 *
 ***********************************************************************/
#define MONIKER_SIZE		20
#define noFullY 2
#define noSec 3

@method BackupListClass, MSG_BL_QUERY_MONIKER
{
char temp[ (LEN_DATE+7+5) + PATH_LENGTH + LEN_DESCRIPTION], path[PATH_LENGTH];
IndexEntryInMem	*entry;
word				itemSize, count;
GStateHandle		gstate;
optr				gstring;


    if (@self->BL_monikerChunk) {
	/*
	 *  monikerChunk contains the list of backup groups.
	 */
	MemLock(HandleOf(@self->BL_monikerChunk));
	count = ChunkArrayGetCount(@self->BL_monikerChunk) - 1;
	entry = (IndexEntryInMem *)ChunkArrayElementToPtr
	    (@self->BL_monikerChunk, count - item, &itemSize);
	/*
	 *  Copy the date
	 */
	strncpy(temp, ((char*)entry) + sizeof(IndexEntryInMem), 2);   /* M */
	strcpy(temp+2, "/");
	strncpy(temp+3, ((char*)entry)+sizeof(IndexEntryInMem)+2,2);  /* D */
	strcpy(temp+5, "/");
	/* Y */
	strncpy(temp+6, 
		((char*)entry)+sizeof(IndexEntryInMem)+4+noFullY, 4-noFullY);
	strcpy(temp+10-noFullY, " ");
	strncpy(temp+11-noFullY, 
		((char*)entry)+sizeof(IndexEntryInMem)+8,2); /* H */
	strcpy(temp+13-noFullY, ":");
	strncpy(temp+14-noFullY, 
		((char*)entry)+sizeof(IndexEntryInMem)+10,2);/* M */
#if 0 /* don't display seconds */
	strcpy(temp+16-noFullY, ":");
	strncpy(temp+17-noFullY, 
		((char*)entry)+sizeof(IndexEntryInMem)+12,2);/* S */
	temp[19-noFullY] = ' ';
	temp[20-noFullY] = ' ';
#else
	temp[19-noFullY-noSec] = ' ';
	temp[20-noFullY-noSec] = ' ';
#endif
	/*
	 *  Copy the file Name
	 */
	path[0] = '\0';
	if (entry->IEIM_type == BT_SINGLE_FILE || entry->IEIM_type == BT_EMAIL_ACCT) {
#if 0 /* don't complete full path of the file */
	    endOfPath = path;
	    FileConstructFullPath(&endOfPath, PATH_LENGTH,
				  entry->IEIM_pathToken, 
				  ((char*)entry)+sizeof(IndexEntryInMem)+ 
				  LEN_DATE + entry->IEIM_descriptionLen,
				  TRUE);
	    strcpy(temp + LEN_DATE + 7 - noFullY - noSec, path);
#else /* show relative path name */ /* skip the first \ if there is any */
	    if ((((char*)entry)+sizeof(IndexEntryInMem)+ 
		LEN_DATE + entry->IEIM_descriptionLen)[0] == '\\')
		strcpy(temp + LEN_DATE + 7 - noFullY - noSec,
		       ((char*)entry)+sizeof(IndexEntryInMem)+ 
		       LEN_DATE + entry->IEIM_descriptionLen + 1);
	    else
		strcpy(temp + LEN_DATE + 7 - noFullY - noSec,
		       ((char*)entry)+sizeof(IndexEntryInMem)+ 
		       LEN_DATE + entry->IEIM_descriptionLen);
#endif
	}
	else if ((entry->IEIM_type == BT_DOCUMENT_DIR) ||
			(entry->IEIM_type == BT_DOC_W_EMAIL)){
	    MemLock (OptrToHandle(@DocsFolderText));
	    strcpy(temp + LEN_DATE + 7 - noFullY - noSec, LMemDeref(@DocsFolderText));
	    MemUnlock (OptrToHandle(@DocsFolderText));
	}
	else
	    temp[21-noFullY - noSec] = '\0';

	if (@self->BL_maxFileLen < 20)
	    @self->BL_maxFileLen = 20;
	/*
	 *  Copy the description
	 */
	if (entry->IEIM_descriptionLen > 0) {
	    if (@self->BL_maxFileLen > strlen(path)) {
		memset(temp + strlen(temp), ' ', 
		       @self->BL_maxFileLen - strlen(path));
		temp[LEN_DATE+7+@self->BL_maxFileLen] = '\0';
	    }
	    else {
		memset(temp + strlen(temp), ' ', 
		       @self->BL_maxFileLen - strlen(path));
		temp[LEN_DATE+7+@self->BL_maxFileLen] = '\0';
	    }
	    strncat(temp,
		   ((char*)entry)+sizeof(IndexEntryInMem)+ 
		   LEN_DATE, entry->IEIM_descriptionLen);
	}
	
	MemUnlock(HandleOf(@self->BL_monikerChunk));
	/*
	 *  Update the moniker in the definitions list.
	 */
	/* Create the gstring.*/
	gstate = CreateLMemGString(&gstring);
	GrSetFont(gstate, FID_DTC_URW_MONO, 0);
	GrDrawText(gstate, 0, 0, temp, strlen(temp));
	GrEndGString(gstate);
	GrDestroyGString(gstate, 0, GSKT_LEAVE_DATA);

	@call BKRTFileList::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_MONIKER
	     (item, 0, MONIKER_SIZE, MONIKER_SIZE, sizeof(gstring),
	      VMDT_GSTRING, VMST_OPTR, (dword)gstring );
	MemFree(HandleOf(gstring));
    } /* end of existing moniker chunk if */

    else {
	word sel = @call BKRTViewOptions::MSG_GEN_ITEM_GROUP_GET_SELECTION();
	/* Create the gstring.*/
	gstate = CreateLMemGString(&gstring);
	GrSetFont(gstate, FID_DTC_URW_MONO, 0);
	if (sel == BT_SINGLE_FILE) {
	    MemLock (OptrToHandle(@NoDocsStr));
	    GrDrawText(gstate, 0, 0,
			  LMemDeref(@NoDocsStr), 0);
	    MemUnlock (OptrToHandle(@NoDocsStr));
	    }
	else  {
	    MemLock (OptrToHandle(@NoFoldersStr));
	    GrDrawText(gstate, 0, 0,
			  LMemDeref(@NoFoldersStr), 0);
	    MemUnlock (OptrToHandle(@NoFoldersStr));
	    }
	GrEndGString(gstate);
	GrDestroyGString(gstate, 0, GSKT_LEAVE_DATA);

	@call BKRTFileList::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_MONIKER
	     (item, 0, MONIKER_SIZE, MONIKER_SIZE, sizeof(gstring),
	      VMDT_GSTRING, VMST_OPTR, (dword)gstring );
    }

    return;
}


/***********************************************************************
 *	MSG_META_START_SELECT for BackupListClass
 ***********************************************************************
 * SYNOPSIS:	    Ignore selection if there isn't any selectable item
 * PARAMETERS:void 
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	2/09/99   	Initial Revision
 *
 ***********************************************************************/
@method BackupListClass, MSG_META_START_SELECT
{
    if (@self->BL_monikerChunk)
	@callsuper();
    else
	retVal->flags = MRF_PROCESSED;
    
    return;
}

/***********************************************************************
 *	MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED for BackupListClass
 ***********************************************************************
 * SYNOPSIS:	    Intercept this message and disable some ui.
 * PARAMETERS:void 
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	12/29/98   	Initial Revision
 *
 ***********************************************************************/
@method BackupListClass, MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED
{
    @callsuper();
    @send BKRTRestoreTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);
    @send BKRTDeleteTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);
    @send BKRTViewFolderTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);
    return;
}


/***********************************************************************
 *	MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED for BackupListClass
 ***********************************************************************
 * SYNOPSIS:	    Intercept this message and enable some ui.
 * PARAMETERS:void 
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	12/29/98   	Initial Revision
 *
 ***********************************************************************/
@method BackupListClass, MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION
{
    @callsuper();
    @send BKRTRestoreTrigger::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);
    @send BKRTDeleteTrigger::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);
    @send BKRTViewFolderTrigger::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE);    return;
}


/***********************************************************************
 *	MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION for MyItemGroupClass
 ***********************************************************************
 * SYNOPSIS:	    Intercept the message and update Restore Button.
 * PARAMETERS:      void
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	12/16/98   	Initial Revision
 *
 ***********************************************************************/
@method MyItemGroupClass, MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION
{
    @callsuper();

    switch(identifier) {
    case BT_SINGLE_FILE:
	MemLock (OptrToHandle(@RestorDocMon));
	@send BKRTRestoreTrigger::MSG_GEN_REPLACE_VIS_MONIKER_TEXT
		(LMemDeref(@RestorDocMon), VUM_DELAYED_VIA_UI_QUEUE);
	MemUnlock (OptrToHandle(@RestorDocMon));
	@send BKRTViewFolderTrigger::MSG_GEN_SET_NOT_USABLE
	     (VUM_DELAYED_VIA_UI_QUEUE);
	@send BKRTViewAllDocFoldersTrigger::MSG_GEN_SET_NOT_USABLE
	     (VUM_DELAYED_VIA_UI_QUEUE);
	@send BKRTDeleteTrigger::MSG_GEN_SET_USABLE
	     (VUM_DELAYED_VIA_UI_QUEUE);
	MemLock (OptrToHandle(@DeleteDocBUText));
	@send BKRTDeleteText::MSG_VIS_TEXT_REPLACE_ALL_PTR
		(LMemDeref(@DeleteDocBUText), 0);
	MemUnlock (OptrToHandle(@DeleteDocBUText));
	break;
    case BT_DOCUMENT_DIR:
	MemLock (OptrToHandle(@RestorDocFolderMon));
	@send BKRTRestoreTrigger::MSG_GEN_REPLACE_VIS_MONIKER_TEXT
		(LMemDeref(@RestorDocFolderMon), VUM_DELAYED_VIA_UI_QUEUE);
	MemLock (OptrToHandle(@RestorDocFolderMon));
	@send BKRTViewFolderTrigger::MSG_GEN_SET_USABLE
		(VUM_DELAYED_VIA_UI_QUEUE);
	MemLock (OptrToHandle(@DeleteFolderBUText));
	@send BKRTDeleteText::MSG_VIS_TEXT_REPLACE_ALL_PTR
		(LMemDeref(@DeleteFolderBUText),0);
	MemUnlock (OptrToHandle(@DeleteFolderBUText));
	@send BKRTViewAllDocFoldersTrigger::MSG_GEN_SET_NOT_USABLE
		(VUM_DELAYED_VIA_UI_QUEUE);
	@send BKRTDeleteTrigger::MSG_GEN_SET_USABLE
		(VUM_DELAYED_VIA_UI_QUEUE);
	break;
    case BT_DOC_W_EMAIL:
	MemLock (OptrToHandle(@RestorDocFolderMon));
	@send BKRTRestoreTrigger::MSG_GEN_REPLACE_VIS_MONIKER_TEXT
		(LMemDeref(@RestorDocFolderMon), VUM_DELAYED_VIA_UI_QUEUE);
	MemLock (OptrToHandle(@RestorDocFolderMon));
	@send BKRTViewFolderTrigger::MSG_GEN_SET_USABLE
		(VUM_DELAYED_VIA_UI_QUEUE);
	MemLock (OptrToHandle(@DeleteFolderBUText));
	@send BKRTDeleteText::MSG_VIS_TEXT_REPLACE_ALL_PTR
		(LMemDeref(@DeleteFolderBUText),0);
	MemUnlock (OptrToHandle(@DeleteFolderBUText));
	@send BKRTViewAllDocFoldersTrigger::MSG_GEN_SET_NOT_USABLE
		(VUM_DELAYED_VIA_UI_QUEUE);
	@send BKRTDeleteTrigger::MSG_GEN_SET_USABLE
		(VUM_DELAYED_VIA_UI_QUEUE);
	break;
    case BT_SYS_CONFIG:
	MemLock (OptrToHandle(@SysConfigMon));
	@send BKRTRestoreTrigger::MSG_GEN_REPLACE_VIS_MONIKER_TEXT
		(LMemDeref(@SysConfigMon),VUM_DELAYED_VIA_UI_QUEUE);
	MemUnlock (OptrToHandle(@SysConfigMon));
	break;
    case BT_FULL_SYS:
	MemLock (OptrToHandle(@FullSysMon));
	@send BKRTRestoreTrigger::MSG_GEN_REPLACE_VIS_MONIKER_TEXT
		(LMemDeref(@FullSysMon),VUM_DELAYED_VIA_UI_QUEUE);
	MemUnlock (OptrToHandle(@FullSysMon));
    }
    @send process::MSG_BKRTP_UPDATE_BACKUP_VIEW_LIST();
    return;
} /* End of MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION */


/***********************************************************************
 *	MSG_VIS_OPEN for MyDocumentFolderWindowClass
 ***********************************************************************
 * SYNOPSIS:	    Intercept the message and update doc dir infomation
 * PARAMETERS:      void
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	12/17/98   	Initial Revision
 *
 ***********************************************************************/
@method MyDocumentFolderWindowClass, MSG_VIS_OPEN
{
word  numFiles, mailFiles, faxFiles, email;
dword totalSize, mailSize, faxSize;


    /*
     *  Get directory info under the user directory
     */
    BRGetInfoOnUserDocDir(&numFiles, &totalSize);

    /* See if we're backing up email */
    email = @call EmailBackupGroup::MSG_GEN_ITEM_GROUP_GET_SELECTION();
    if (email) {
	  BRGetInfoOnUserMailDir(&mailFiles, &mailSize);
	  numFiles += mailFiles;
	  totalSize += mailSize;
	  if (g_isEFax) {
		BRGetInfoOnUserFaxDir(&faxFiles, &faxSize);
		numFiles += faxFiles;
		totalSize += faxSize;
		}
	  }

    /*
     *  Display the information.
     */
    @call DocDirSize::MSG_MGT_SET_NUM_FILES(numFiles, totalSize);
    /*
     *  Clear some ui.
	*/
    @call MemoText2::MSG_VIS_TEXT_DELETE_ALL();


    @callsuper();
    return;
}


/***********************************************************************
 *
 * MESSAGE:	MSG_BKRTP_EMAIL_BACKUP_SELECTION_APPLY for BKRTProcessClass
 *
 * DESCRIPTION:	Handles an apply of user email selection
 *
 * PARAMETERS:  void (word selection, numSelections, flags)
 *
 * 
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *   jfh	04/11/00		Initial Revision
 *
 ***********************************************************************/
@method BKRTProcessClass, MSG_BKRTP_EMAIL_BACKUP_SELECTION_APPLY
{
word  numFiles, mailFiles, faxFiles;
dword totalSize, mailSize, faxSize;

    /* marking busy won't work (modal dbox) so I'm disabling the
	* backup trigger while the numbers are crunching */
    @send DocDirBackup::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);

    /* get the mail info */
    BRGetInfoOnUserMailDir(&mailFiles, &mailSize);
    if (g_isEFax) {
	  BRGetInfoOnUserFaxDir(&faxFiles, &faxSize);
	  mailFiles += faxFiles;
	  mailSize += faxSize;
	  }

    /* and the previous total info (may have mail in it) */
    totalSize = @call DocDirSize::MSG_MGT_GET_TOTAL_FILE_SIZE();
    numFiles = @call DocDirSize::MSG_MGT_GET_TOTAL_FILE_NUMBER();

    /* if the selection is for no email then subtract out the email
	* files and size, otherwise add it in
	*/
    if (selection)  {
	  /* add it */
	  totalSize += mailSize;
	  numFiles += mailFiles;
	  }
    else {
	  /* subtract it */
	  totalSize -= mailSize;
	  numFiles -= mailFiles;
	  }

    /*
	*  Display the new information.
     */
    @call DocDirSize::MSG_MGT_SET_NUM_FILES(numFiles, totalSize);
    @send DocDirBackup::MSG_GEN_SET_ENABLED(VUM_NOW);

}

/***********************************************************************
 *	MSG_MGT_SET_NUM_FILES for MyGenTextClass
 ***********************************************************************
 * SYNOPSIS:	    Set and initialize the object with values
 * PARAMETERS:      num - number of files to be operated on(i.e. restored)
 *                  totalSize - of bytes of these files.
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	12/18/98   	Initial Revision
 *   jfh		01/24/00		check for only dir info file
 *
 ***********************************************************************/
@method MyGenTextClass, MSG_MGT_SET_NUM_FILES
{
    char size[100], temp[15];

    @self->MGT_numOfFiles = num;
    @self->MGT_totalSize = totalSize;
    @self->MGT_doneSoFar = 0;

    if (oself == @DocDirSize) {
	if (!num) @call DocDirBackup::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	else @call DocDirBackup::MSG_GEN_SET_ENABLED(VUM_NOW);
	itoa(num, temp);
	strcpy(size, temp);
    }
    else {
	/*  This is restore ui.  Show the progress */
	strcpy(size, "0/");
	itoa(num, temp);
	strcat(size, temp);
    }
    strcat(size, "\r");
    UtilHex32ToAscii(temp, totalSize, UHTAF_NULL_TERMINATE);
    strcat(size, temp);
    MemLock (OptrToHandle(@BytesStr));
    strcat(size, LMemDeref(@BytesStr));
    MemUnlock (OptrToHandle(@BytesStr));
    @call self::MSG_VIS_TEXT_REPLACE_ALL_PTR(size, 0);
} /* End of MSG_MGT_SET_NUM_FILES */


/***********************************************************************
 *	MSG_MGT_INC_COUNT for MyGenTextClass
 ***********************************************************************
 * SYNOPSIS:	    Increment of the number of files that have been
 *                  operated(i.e. restored).
 * PARAMETERS:      ()
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	12/18/98   	Initial Revision
 *
 ***********************************************************************/
@method MyGenTextClass, MSG_MGT_INC_COUNT
{
    char size[100], temp[15];
    @self->MGT_doneSoFar++;

    itoa(@self->MGT_doneSoFar, temp);
    strcpy(size, temp);
    strcat(size, "/");
    itoa(@self->MGT_numOfFiles, temp);
    strcat(size, temp);
    strcat(size, "\r");
    UtilHex32ToAscii(temp, @self->MGT_totalSize, UHTAF_NULL_TERMINATE);
    strcat(size, temp);
    MemLock (OptrToHandle(@BytesStr));
    strcat(size, LMemDeref(@BytesStr));
    MemUnlock (OptrToHandle(@BytesStr));
    @call self::MSG_VIS_TEXT_REPLACE_ALL_PTR(size, 0);
    TimerSleep(1);
} /* End of MSG_MGT_INC_COUNT */


/***********************************************************************
 *	MSG_MGT_GET_TOTAL_FILE_SIZE for MyGenTextClass
 ***********************************************************************
 * SYNOPSIS:	    Return the total size of files in document dir.
 *                  The value is updated only if the object is brought
 *                  up to be visible.
 * PARAMETERS:      ()
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	12/18/98   	Initial Revision
 *
 ***********************************************************************/
@method MyGenTextClass, MSG_MGT_GET_TOTAL_FILE_SIZE
{
    return @self->MGT_totalSize;
} /* End of MSG_MGT_GET_TOTAL_FILE_SIZE */


/***********************************************************************
 *	MSG_MGT_GET_TOTAL_FILE_NUMBER for MyGenTextClass
 ***********************************************************************
 * SYNOPSIS:	    Return the total number of files in document dir.
 *                  The value is updated only if the object is brought
 *                  up to be visible.
 * PARAMETERS:      ()
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jfh	12/18/98   	Initial Revision
 *
 ***********************************************************************/
@method MyGenTextClass, MSG_MGT_GET_TOTAL_FILE_NUMBER
{
    return @self->MGT_numOfFiles;
} /* End of MSG_MGT_GET_TOTAL_FILE_NUMBER */

/***********************************************************************
 *	MSG_VIS_OPEN for MyGenInteractionClass
 ***********************************************************************
 * SYNOPSIS:	    Intercept and disable some ui.
 * PARAMETERS:      
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	12/28/98   	Initial Revision
 *
 ***********************************************************************/
@method MyGenInteractionClass, MSG_VIS_OPEN
{
    @callsuper();
    @call BKRTFileList::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(0);
    return;
}


/***********************************************************************
 *	MSG_META_NULL for MyGenFileSelectorClass
 ***********************************************************************
 * SYNOPSIS:	    Intercept and disable some ui.
 * PARAMETERS:      
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	12/28/98   	Initial Revision
 *
 ***********************************************************************/
@method MyGenFileSelectorClass, MSG_META_NULL
{
    dword attr = 0;
    @callsuper();
    attr = @call FileSelector::MSG_GEN_FILE_SELECTOR_GET_FULL_SELECTION_PATH
	(NULL);
    if ((GFS_GET_ENTRY_FLAGS(attr) & GFSEF_TYPE) == GFSET_FILE) {
    	@send FileSelectBackup::MSG_GEN_SET_ENABLED
	     (VUM_DELAYED_VIA_UI_QUEUE);
    }
    else {
	@send FileSelectBackup::MSG_GEN_SET_NOT_ENABLED
	     (VUM_DELAYED_VIA_UI_QUEUE);
    }
    return;
}

@method MyGenTriggerClass, MSG_MGT_SET_SELECTION
{
    @self->MGT_selection = sel;
    return;
}

@method MyGenTriggerClass, MSG_MGT_GET_SELECTION
{
    return @self->MGT_selection;
}

/***********************************************************************
 *	StatusCallbackRoutine
 ***********************************************************************
 * SYNOPSIS:	    Callback routine for the backup/restore library
 *                  to notify that one file has been restored.
 * PARAMETERS:      ()
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	12/18/98   	Initial Revision
 *
 ***********************************************************************/
void StatusCallbackRoutine(void)
{
    @call GroupSize::MSG_MGT_INC_COUNT();
    return;
}


/***********************************************************************
 *	StatusCallbackRoutine
 ***********************************************************************
 * SYNOPSIS:	    Callback routine for the backup/restore library
 *                  to notify that one file has been restored.
 * PARAMETERS:      ()
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	12/18/98   	Initial Revision
 *
 ***********************************************************************/
void StatusCallbackRoutine2(void)
{
    @call DocDirSize::MSG_MGT_INC_COUNT();
    return;
}


/***********************************************************************
 *	day_of_year
 ***********************************************************************
 * SYNOPSIS:	    Calculate the day of the year.
 * PARAMETERS:      today's date: year, month, day.
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	12/27/98   	Initial Revision
 *
 ***********************************************************************/
static char daytab[2][13] = {
    { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
    { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};
int day_of_year(int year, int month, int day)
{
    int i, leap;

    leap = year%4 == 0 && year%100 != 0 || year%400 == 0;
    for (i = 1; i < month; i++)
	day += daytab[leap][i];
    return day;
}


/***********************************************************************
 *	CheckBackupDiskSpace
 ***********************************************************************
 * SYNOPSIS:	    Check if the backup disk space has room a for a
 *                  single file.
 * PARAMETERS:      diskHandleOrPathToken - of the file that we want to
 *                                          backup.
 *                  relativePath - the path plus the name of the file.
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	1/05/99   	Initial Revision
 *   jfh		3/8/99		added file already open error
 *
 ***********************************************************************/
Boolean CheckBackupDiskSpace(word diskHandleOrPathToken,
			     const char *relativePath)
{
Boolean		ok = TRUE;
char			*fileName, save;
FileHandle	fh;
dword		totalSize, freeSpace;
char			errorText[50];


    /*
     *  Check for enough hard disk space for backup.
     */
    fileName = strrchr(relativePath, '\\');
    if (fileName) {
	  save = fileName[0];
	  fileName[0] = '\0';
	  if (!FileSetCurrentPath(diskHandleOrPathToken, relativePath)) {
		ok = FALSE;
		}
	  fileName[0] = save;

	  fh = FileOpen(fileName+1, FILE_ACCESS_R | FILE_DENY_RW);
	  if (fh) {
		totalSize = FileSize(fh);
		FileClose(fh,0);
		}
	  else {
		/* couldn't open file */
		/* was it already open ? */
		if (ThreadGetError() == ERROR_SHARING_VIOLATION) {
		   MemLock (OptrToHandle(@CloseFileMsg));
		   UserStandardDialog((char *)0, (char *)0, (char *)0, (char *)0,
			   LMemDeref(@CloseFileMsg),
			   (CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
			   (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET));
		   MemUnlock (OptrToHandle(@CloseFileMsg));
		   return (FALSE);
		   }
		ok = FALSE;  /* some other error */
		}
	  } /* end of good filename if */
    else  {
	   ok = FALSE;
	   }
    /* end of found/ not found file */

    if (!ok) {
	  /* couldn't find/open file to get size */
	  MemLock (OptrToHandle(@CouldntGetSizeMsg));
	  UserStandardDialog((char *)0, (char *)0, (char *)0, (char *)0,
			   LMemDeref(@CouldntGetSizeMsg),
			   (CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
			   (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET));
	  MemUnlock (OptrToHandle(@CouldntGetSizeMsg));
	  return (FALSE);
	  }

    freeSpace = BRGetBackupDiskFreeSpace();  
    if (totalSize && (freeSpace / totalSize) < 3) {
	/*
	 *  Not enough hard disk space. Bring up a warning dialog box.
	 */
	MemLock (OptrToHandle(@NotEnufSpaceMsg));
	UserStandardDialog((char *)0, (char *)0, (char *)0, (char *)0,
			   LMemDeref(@NotEnufSpaceMsg),
			   (CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
			   (GIT_NOTIFICATION <<
			    CDBF_INTERACTION_TYPE_OFFSET));
	MemUnlock (OptrToHandle(@NotEnufSpaceMsg));
	return FALSE;
    }
    return ok;
}


/***********************************************************************
 *	CheckExistenceOfFile
 ***********************************************************************
 * SYNOPSIS:	    Check if the file exists in the given path.
 *                  
 * PARAMETERS:      diskHandleOrPathToken - of the file that we want to
 *                                          check
 *                  relativePath - the path plus the name of the file.
 * RETURN:          char *fileName if it exists.  NULL if not found.
 *
 * SIDE EFFECTS:    
 *
 * STRATEGY:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	edwin	2/08/99   	Initial Revision
 *
 ***********************************************************************/
char *CheckExistenceOfFile(word diskHandleOrPathToken,
			     const char *relativePath)
{
    Boolean ok = TRUE;
    char *fileName, save;
    FileHandle fh;
    FilePushDir();
    /*
     *  Check for enough hard disk space for backup.
     */
    fileName = strrchr(relativePath, '\\');

    if (fileName) {
	save = fileName[0];
	fileName[0] = '\0';
	if (!FileSetCurrentPath(diskHandleOrPathToken, relativePath))
	    ok = FALSE;
	fileName[0] = save;

	fh = FileOpen(fileName+1, FILE_ACCESS_R | FILE_DENY_W);
	if (fh) {
	    FileClose(fh,0);
	}
	else
	    ok = FALSE;
    }
    else {
	ok = FALSE;
    }
    
    FilePopDir();

    if (ok == TRUE)
	return (fileName+1);
    
    return NULL;
}
