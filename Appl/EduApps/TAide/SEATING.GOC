/***********************************************************************
 *
 *
 * PROJECT: Breadbox Teacher's Aide
 * FILE:    SEATING.GOC
 * AUTHOR:  Lysle E. Shields 6/99
 *
 * DESCRIPTION:
 *  This is the code to handle the UI of the seating layout module
 *
 * WHATS NEW:  Beginning of version 0.0
 *
 *
 ***********************************************************************/

/*
 ***************************************************************************
 *      Include files
 ***************************************************************************
 */

@include "taide.goh"
@include "seating.goh"
@include "externs.goh"

/* Size of names drawn in labels and the font to be used. */
#define NAME_LABEL_POINT_SIZE          10
#define NAME_LABEL_FONT                FID_DTC_URW_SANS

#define STUDENT_NAME_FIRST_NAME_MAX    14
#define STUDENT_NAME_LAST_NAME_MAX     14

typedef struct {
    StudentLabel SN_label ;
    char SN_firstName[STUDENT_NAME_FIRST_NAME_MAX+1] ;
    char SN_lastName[STUDENT_NAME_LAST_NAME_MAX+1] ;
} T_studentName ;

#define MAX_STUDENT_NAMES       100

typedef struct {
    word SNB_numNames ;
    T_studentName SNB_nameArray[MAX_STUDENT_NAMES] ;
} T_studentNameBlock ;

#define STUDENT_NAME_NONE       0xFFFF


#define SEATING_TIME_BETWEEN_UPDATES 6

/* Information about desk sizes */
static XYSize G_deskTypeSizeArray[SEATING_DESK_TYPE_UNKNOWN] = {
	 { /*60, 60*/ 85, 85 },         /* SEATING_DESK_TYPE_SQUARE */
} ;

#define LockClass()  ((SeatingClassBlock *)VMLock(pself->SSI_file, pself->SSI_data, &mem))
#define DirtyClass()  (VMDirty(mem))
#define UnlockClass()  (VMUnlock(mem))
#define LockNames()  ((T_studentNameBlock *)MemLock(pself->SSI_studentLabels))
#define UnlockNames()  (MemUnlock(pself->SSI_studentLabels))

@classdecl StudentSeatingVisClass ;

@method StudentSeatingVisClass, MSG_SEATING_GET_MODE
{
    EC_ERROR_IF(pself->SSI_mode >= SEATING_MODE_UNKNOWN, -1) ;
    return (pself->SSI_mode) ;
}

@method StudentSeatingVisClass, MSG_SEATING_SET_MODE
{
    EC_ERROR_IF(mode >= SEATING_MODE_UNKNOWN, -1) ;
    pself->SSI_mode = mode ;

    /* Update any attached UI objects */
    @call oself::MSG_SEATING_UPDATE_UI() ;
}

@method StudentSeatingVisClass, MSG_SEATING_GET_LAYOUT
{
    EC_ERROR_IF(pself->SSI_currentLayout >= SEATING_LAYOUT_UNKNOWN, -1) ;
    return (pself->SSI_currentLayout) ;
}

@method StudentSeatingVisClass, MSG_SEATING_SET_LAYOUT
{
    EC_ERROR_IF(layout >= SEATING_LAYOUT_UNKNOWN, -1) ;

    /* Only change if there is a change */
    if (pself->SSI_currentLayout != layout)  {
        pself->SSI_currentLayout = layout ;

        /* Need to be totally redrawn */
        @call oself::MSG_VIS_INVALIDATE();

        /* Update any attached UI objects */
        @call oself::MSG_SEATING_UPDATE_UI() ;
    }
}

@method StudentSeatingVisClass, MSG_SEATING_GET_DESTINATION
{
    return pself->SSI_destination ;
}

@method StudentSeatingVisClass, MSG_SEATING_SET_DESTINATION
{
    pself->SSI_destination = dest ;
}

@method StudentSeatingVisClass, MSG_SEATING_GET_MODE_GROUP
{
    return pself->SSI_modeGroup ;
}

@method StudentSeatingVisClass, MSG_SEATING_SET_MODE_GROUP
{
    pself->SSI_modeGroup = modeGroup ;
}

@method StudentSeatingVisClass, MSG_SEATING_GET_LAYOUT_GROUP
{
    return pself->SSI_layoutGroup ;
}

@method StudentSeatingVisClass, MSG_SEATING_SET_LAYOUT_GROUP
{
    pself->SSI_layoutGroup = layoutGroup ;
}

@method StudentSeatingVisClass, MSG_SEATING_QUERY_HAS_CHANGED
{
    Boolean changed = FALSE ;
    SeatingClassBlock *p_block ;
    MemHandle mem ;

    if (pself->SSI_data)  {
        p_block = LockClass() ;
        changed = p_block->SCB_isDirty ;
        UnlockClass() ;
    } else {
        @call oself::MSG_SEATING_ERROR(SEATING_ERROR_NO_DATA) ;
    }

    return changed ;
}

@method StudentSeatingVisClass, MSG_SEATING_LOAD_DATA
{
    SeatingClassBlock *p_block ;
    MemHandle mem ;

    if (!pself->SSI_data)
        pself->SSI_data = MemAlloc(sizeof(*p_block), HF_DYNAMIC, 0) ;

    /* Copy over the new data */
    if (pself->SSI_data)  {
        p_block = LockClass() ;
        memcpy(p_block, p_class, sizeof(*p_block)) ;
        DirtyClass() ;
        UnlockClass() ;

        /* Need to be totally redrawn */
	   @call oself::MSG_VIS_INVALIDATE();
    } else {
        @call oself::MSG_SEATING_ERROR(SEATING_ERROR_NO_DATA) ;
    }
}

@method StudentSeatingVisClass, MSG_SEATING_SAVE_DATA
{
    SeatingClassBlock *p_block ;
    MemHandle mem ;

    /* Transfer over the data */
    if (pself->SSI_data)  {
        p_block = LockClass() ;
        memcpy(p_class, p_block, sizeof(*p_class)) ;

        /* Note that we are no longer dirty because we saved */
        p_class->SCB_isDirty = FALSE ;
        DirtyClass() ;
        UnlockClass() ;
    } else {
        /* If we have no data, zero out the data */
        memset(p_class, 0, sizeof(*p_class)) ;
    }
}

@method StudentSeatingVisClass, MSG_SEATING_LOAD_LAYOUT
{
    SeatingClassBlock *p_block ;
    MemHandle mem ;

    if (pself->SSI_data)  {
        p_block = LockClass() ;
        memcpy(
            p_block->SCB_layoutArray+pself->SSI_currentLayout,
            p_layout,
            sizeof(*p_layout)) ;
        DirtyClass() ;
        UnlockClass() ;

        /* Need to be totally redrawn */
        @call oself::MSG_VIS_INVALIDATE();
    } else {
        @call oself::MSG_SEATING_ERROR(SEATING_ERROR_NO_DATA) ;
    }
}

@method StudentSeatingVisClass, MSG_SEATING_SAVE_LAYOUT
{
    SeatingClassBlock *p_block ;
    MemHandle mem ;

    if (pself->SSI_data)  {
        p_block = LockClass() ;
        memcpy(
            p_layout,
            p_block->SCB_layoutArray+pself->SSI_currentLayout,
            sizeof(*p_layout)) ;
        UnlockClass() ;
    } else {
        @call oself::MSG_SEATING_ERROR(SEATING_ERROR_NO_DATA) ;
    }
}

@method StudentSeatingVisClass, MSG_SEATING_ADD_DESK
/*
word
            sword x,
            sword y,
            word angle,
            SeatingDeskType type
*/
{
    SeatingClassBlock *p_block ;
    SeatingDeskLayout *p_layout ;
    SeatingDeskPosition *p_desk ;
    word newDesk = SEATING_DESK_NONE ;
    word num ;
    MemHandle mem ;

    if (pself->SSI_data)  {
        /* Try adding a new block to the layer */
        p_block = LockClass() ;
        p_layout = p_block->SCB_layoutArray + pself->SSI_currentLayout ;
        num = p_layout->SDL_numDesks ;
        if (num < SEATING_MAX_DESKS)  {
            newDesk = num ;
            p_desk = p_layout->SDL_deskArray + newDesk ;
            if (pself->SSI_gridSize)  {
                x /= pself->SSI_gridSize ;
                x *= pself->SSI_gridSize ;
                y /= pself->SSI_gridSize ;
                y *= pself->SSI_gridSize ;
            }
            p_desk->SDP_x = x ;
            p_desk->SDP_y = y ;
            p_desk->SDP_angle = angle ;
            p_desk->SDP_type = type ;
            p_desk->SDP_label = STUDENT_LABEL_NONE ;
            p_layout->SDL_numDesks++ ;
            p_block->SCB_isDirty = TRUE ;

            /* Put in a request to draw the new desk */
            @call oself::MSG_SEATING_INVALIDATE_DESK(newDesk) ;
        }
        DirtyClass() ;
        UnlockClass() ;
    } else {
        @call oself::MSG_SEATING_ERROR(SEATING_ERROR_NO_DATA) ;
    }

    return newDesk ;
}

@method StudentSeatingVisClass, MSG_SEATING_REMOVE_DESK
/* (word index, Boolean removeLabelAndDesk) */
{
    SeatingClassBlock *p_block ;
    SeatingDeskLayout *p_layout ;
    word num ;
    MemHandle mem ;
    SeatingDeskPosition *p_desk ;
    StudentLabel oldLabel ;

    if (pself->SSI_data)  {
        /* Try adding a new block to the layer */
        p_block = LockClass() ;
        p_layout = p_block->SCB_layoutArray + pself->SSI_currentLayout ;
        EC_ERROR_IF(index >= p_layout->SDL_numDesks, -1) ;
        if (index < p_layout->SDL_numDesks)  {
            /* Invalidate the region that we are about to erase */
            @call oself::MSG_SEATING_INVALIDATE_DESK(index) ;

            p_desk = p_layout->SDL_deskArray + index ;
            oldLabel = p_desk->SDP_label ;
            p_desk->SDP_label = STUDENT_LABEL_NONE ;
            if ((removeLabelAndDesk) || (oldLabel == STUDENT_LABEL_NONE))  {
                /* Delete the desk by shifting up the rest */
                p_layout->SDL_numDesks-- ;
                num = p_layout->SDL_numDesks - index ;
                memcpy(
                    p_layout->SDL_deskArray + index,
                    p_layout->SDL_deskArray + index + 1,
                    num * sizeof(p_layout->SDL_deskArray[0])) ;
            }
            p_block->SCB_isDirty = TRUE ;
            DirtyClass() ;
        } else {
            @call oself::MSG_SEATING_ERROR(SEATING_ERROR_ILLEGAL_INDEX) ;
        }
        UnlockClass() ;
    } else {
        @call oself::MSG_SEATING_ERROR(SEATING_ERROR_NO_DATA) ;
    }
}

@method StudentSeatingVisClass, MSG_SEATING_BRING_TO_TOP
/* (word index) */
{
    SeatingClassBlock *p_block ;
    SeatingDeskLayout *p_layout ;
    word num ;
    SeatingDeskPosition desk ;
    word newIndex = SEATING_DESK_NONE ;
    MemHandle mem ;

    if (pself->SSI_data)  {
        /* Try adding a new block to the layer */
        p_block = LockClass() ;
        p_layout = p_block->SCB_layoutArray + pself->SSI_currentLayout ;
        EC_ERROR_IF(index >= p_layout->SDL_numDesks, -1) ;
        if (index < p_layout->SDL_numDesks)  {
            if (index < (p_layout->SDL_numDesks-1))  {
                /* Hold onto the old data */
                desk = p_layout->SDL_deskArray[index] ;

                /* Delete the desk by shifting up the rest */
                p_layout->SDL_numDesks-- ;
                num = p_layout->SDL_numDesks - index ;
                memcpy(
                    p_layout->SDL_deskArray + index,
                    p_layout->SDL_deskArray + index + 1,
                    num * sizeof(p_layout->SDL_deskArray[0])) ;

                /* Now add to the end */
                newIndex = p_layout->SDL_numDesks ;
                p_layout->SDL_numDesks++ ;
                p_layout->SDL_deskArray[newIndex] = desk ;

                p_block->SCB_isDirty = TRUE ;

                @call oself::MSG_SEATING_INVALIDATE_DESK(newIndex) ;
            } else {
                newIndex = index ;
            }
        } else {
            @call oself::MSG_SEATING_ERROR(SEATING_ERROR_ILLEGAL_INDEX) ;
        }
        DirtyClass() ;
        UnlockClass() ;
    } else {
        @call oself::MSG_SEATING_ERROR(SEATING_ERROR_NO_DATA) ;
    }

    return newIndex ;
}

@method StudentSeatingVisClass, MSG_SEATING_ROTATE_DESK
/* (word index, word rotation) */
{
    SeatingClassBlock *p_block ;
    SeatingDeskLayout *p_layout ;
    SeatingDeskPosition *p_desk ;
    MemHandle mem ;

    if (pself->SSI_data)  {
        /* Find the desk first */
        p_block = LockClass() ;
        p_layout = p_block->SCB_layoutArray + pself->SSI_currentLayout ;
        EC_ERROR_IF(index >= p_layout->SDL_numDesks, -1) ;
        if (index < p_layout->SDL_numDesks)  {
            /* Rotate the desk by the given angle */
            p_desk = p_layout->SDL_deskArray + index ;
            p_desk->SDP_angle += rotation ;

            /* All new desks match this angle */
            pself->SSI_lastAngle = p_desk->SDP_angle ;
            p_block->SCB_isDirty = TRUE ;
        } else {
            @call oself::MSG_SEATING_ERROR(SEATING_ERROR_ILLEGAL_INDEX) ;
        }
        DirtyClass() ;
        UnlockClass() ;

        /* Invalidate the desk position */
        @call oself::MSG_SEATING_INVALIDATE_DESK(index) ;
    } else {
        @call oself::MSG_SEATING_ERROR(SEATING_ERROR_NO_DATA) ;
    }
}


@method StudentSeatingVisClass, MSG_SEATING_LABEL_DESK
/* (word index, StudentLabel label) */
{
    SeatingClassBlock *p_block ;
    SeatingDeskLayout *p_layout ;
    SeatingDeskPosition *p_desk ;
    word i ;
    MemHandle mem ;

    if (pself->SSI_data)  {
        /* Find the desk first */
        p_block = LockClass() ;
        p_layout = p_block->SCB_layoutArray + pself->SSI_currentLayout ;
        EC_ERROR_IF(index >= p_layout->SDL_numDesks, -1) ;
        if (index < p_layout->SDL_numDesks)  {
            /* Clear out any old labels */
            p_desk = p_layout->SDL_deskArray ;
            for (i=0; i<p_layout->SDL_numDesks; i++, p_desk++)  {
                if ((p_desk->SDP_label == label) && (i != index))  {
                    /* Remove a previous label */
                    p_desk->SDP_label = STUDENT_LABEL_NONE ;
                    p_block->SCB_isDirty = TRUE ;
                    @call oself::MSG_SEATING_INVALIDATE_DESK(i) ;
                }
            }
            /* Store the new label */
            p_desk = p_layout->SDL_deskArray + index ;
            p_desk->SDP_label = label ;
            p_block->SCB_isDirty = TRUE ;
        } else {
            @call oself::MSG_SEATING_ERROR(SEATING_ERROR_ILLEGAL_INDEX) ;
        }
        DirtyClass() ;
        UnlockClass() ;

        /* Invalidate the desk position */
        @call oself::MSG_SEATING_INVALIDATE_DESK(index) ;
    } else {
        @call oself::MSG_SEATING_ERROR(SEATING_ERROR_NO_DATA) ;
    }
}

@method StudentSeatingVisClass, MSG_SEATING_MOVE_DESK
/* (word index, sword x, sword y) ; */
{
    SeatingClassBlock *p_block ;
    SeatingDeskLayout *p_layout ;
    SeatingDeskPosition *p_desk ;
    MemHandle mem ;
    Boolean isDifferent = FALSE ;

    /* don't move off document */
	 if ((pself->SSI_data)&& (x>0+30 && x<72*8-30) && (y>0+30 && y <72*10.5-30))  {
        /* Find the desk */
        p_block = LockClass() ;
        p_layout = p_block->SCB_layoutArray + pself->SSI_currentLayout ;
        EC_ERROR_IF(index >= p_layout->SDL_numDesks, -1) ;
        if (index < p_layout->SDL_numDesks)  {
            /* Store the new location */
            p_desk = p_layout->SDL_deskArray + index ;
            if (pself->SSI_gridSize)  {
                x /= pself->SSI_gridSize ;
                x *= pself->SSI_gridSize ;
                y /= pself->SSI_gridSize ;
                y *= pself->SSI_gridSize ;
            }
            if ((x != p_desk->SDP_x) || (y != p_desk->SDP_y))  {
                /* Invalidate the old location */
                @call oself::MSG_SEATING_INVALIDATE_DESK(index) ;

                p_desk->SDP_x = x ;
                p_desk->SDP_y = y ;
                p_block->SCB_isDirty = TRUE ;
                isDifferent = TRUE ;
            }
        } else {
            @call oself::MSG_SEATING_ERROR(SEATING_ERROR_ILLEGAL_INDEX) ;
        }
        DirtyClass() ;
        UnlockClass() ;

        /* Invalidate the new desk position (if moved) */
        if (isDifferent)
            @send ,forceQueue oself::MSG_SEATING_INVALIDATE_DESK(index) ;
    } else {
        @call oself::MSG_SEATING_ERROR(SEATING_ERROR_NO_DATA) ;
    }
}

@method StudentSeatingVisClass, MSG_SEATING_INVALIDATE_DESK
/* (word index) ; */
{
    SeatingClassBlock *p_block ;
    SeatingDeskLayout *p_layout ;
    SeatingDeskPosition *p_desk ;
    GStateHandle gstate ;
    word width, height ;
    MemHandle mem ;

    if (pself->SSI_data)  {
        /* Find the desk */
        p_block = LockClass() ;
        p_layout = p_block->SCB_layoutArray + pself->SSI_currentLayout ;
        EC_ERROR_IF(index >= p_layout->SDL_numDesks, -1) ;
        if (index < p_layout->SDL_numDesks)  {
            /* Now get the gstate handle */
            p_desk = p_layout->SDL_deskArray + index ;
            gstate = @call oself::MSG_VIS_VUP_CREATE_GSTATE() ;

            /* Invalidate a rectangle the size of the desk */
            width = (G_deskTypeSizeArray[p_desk->SDP_type].XYS_width+1)>>1 ;
            height = (G_deskTypeSizeArray[p_desk->SDP_type].XYS_height+1)>>1 ;
            GrInvalRect(
                gstate,
                p_desk->SDP_x + pself->VI_bounds.R_left-width,
                p_desk->SDP_y + pself->VI_bounds.R_top-height,
                p_desk->SDP_x + pself->VI_bounds.R_left + width,
                p_desk->SDP_y + pself->VI_bounds.R_top + height) ;

            /* Done */
            GrDestroyState(gstate) ;
        } else {
            @call oself::MSG_SEATING_ERROR(SEATING_ERROR_ILLEGAL_INDEX) ;
        }
        UnlockClass() ;
    } else {
        @call oself::MSG_SEATING_ERROR(SEATING_ERROR_NO_DATA) ;
    }
}

@method StudentSeatingVisClass, MSG_SEATING_INVALIDATE_STUDENT
/* (StudentLabel labelID) ; */
{
    word index ;

    /* Is there a desk with that label? */
    index = @call oself::MSG_SEATING_FIND_STUDENT(labelID) ;
    if (index != SEATING_DESK_NONE)  {
        /* If so, then invalidate that desk */
        @send ,forceQueue oself::MSG_SEATING_INVALIDATE_DESK(index) ;
    }
}


@method StudentSeatingVisClass, MSG_SEATING_FIND_DESK
/*
(sword x, sword y) ;
*/
{
    SeatingClassBlock *p_block ;
    SeatingDeskLayout *p_layout ;
    SeatingDeskPosition *p_desk ;
    word foundDesk = SEATING_DESK_NONE ;
    sword i ;
    sword width, height ;
    MemHandle mem ;

    if (pself->SSI_data)  {
        /* Try adding a new block to the layer */
        p_block = LockClass() ;
        p_layout = p_block->SCB_layoutArray + pself->SSI_currentLayout ;
        p_desk = p_layout->SDL_deskArray ;

        /* Go in reverse order so we get the top first */
        p_desk += (i=p_layout->SDL_numDesks-1) ;
        width = (G_deskTypeSizeArray[p_desk->SDP_type].XYS_width+1)>>1 ;
        height = (G_deskTypeSizeArray[p_desk->SDP_type].XYS_height+1)>>1 ;
        for (; i>=0; i--, p_desk--)  {
            if ((p_desk->SDP_x - width <= x) &&
                (p_desk->SDP_x + width  > x) &&
                (p_desk->SDP_y - height <= y) &&
                (p_desk->SDP_y + height > y))  {
                /* Found a desk */
                foundDesk = i ;
                break ;
            }
        }
        UnlockClass() ;
    } else {
        @call oself::MSG_SEATING_ERROR(SEATING_ERROR_NO_DATA) ;
    }

    return foundDesk ;
}

@method StudentSeatingVisClass, MSG_SEATING_FIND_STUDENT
/*
(StudentLabel labelID) ;
*/
{
    SeatingClassBlock *p_block ;
    SeatingDeskLayout *p_layout ;
    SeatingDeskPosition *p_desk ;
    word foundDesk = SEATING_DESK_NONE ;
    sword i ;
    MemHandle mem ;

    if (pself->SSI_data)  {
        /* Only look for a valid label */
        if (labelID != STUDENT_LABEL_NONE)  {
            /* Try adding a new block to the layer */
            p_block = LockClass() ;
            p_layout = p_block->SCB_layoutArray + pself->SSI_currentLayout ;
            p_desk = p_layout->SDL_deskArray ;

            /* Search in order */
            for (i=0; i<p_layout->SDL_numDesks; i++, p_desk++)  {
                if (p_desk->SDP_label == labelID)  {
                    /* Found a matching student in a desk */
                    foundDesk = i ;
                    break ;
                }
            }
            UnlockClass() ;
        }
    } else {
        @call oself::MSG_SEATING_ERROR(SEATING_ERROR_NO_DATA) ;
    }

    return foundDesk ;
}

@method StudentSeatingVisClass, MSG_SEATING_XY_PRESS
/*
                      sword x,
                      sword y,
                      Boolean isRightClick) ;
*/
{
    word index ;

    index = @call oself::MSG_SEATING_FIND_DESK(x, y) ;
    switch (pself->SSI_mode)  {
        case SEATING_MODE_ADD:
            index = @call oself::MSG_SEATING_ADD_DESK(
                         x-pself->VI_bounds.R_left,
                         y-pself->VI_bounds.R_top,
                         pself->SSI_lastAngle,
                         SEATING_DESK_TYPE_SQUARE) ;
            if (index == SEATING_DESK_NONE)  {
                /* Error message! */
                @call oself::MSG_SEATING_ERROR(
                          SEATING_ERROR_ALREADY_MAX_DESKS) ;
            }
            break ;
        case SEATING_MODE_REMOVE:
            if (index != SEATING_DESK_NONE)
                @call oself::MSG_SEATING_REMOVE_DESK(index, FALSE) ;
            break ;
        case SEATING_MODE_MOVE:
            if (index != SEATING_DESK_NONE)  {
                index = @call oself::MSG_SEATING_BRING_TO_TOP(index) ;
                pself->SSI_currentDesk = index ;
                if (index != SEATING_DESK_NONE)
                    @call oself::MSG_VIS_GRAB_MOUSE();
            } else {
                pself->SSI_currentDesk = SEATING_DESK_SELECTION_NONE ;
            }
            break ;
        case SEATING_MODE_ROTATE:
            if (index != SEATING_DESK_NONE)  {
                index = @call oself::MSG_SEATING_BRING_TO_TOP(index) ;
                @call oself::MSG_SEATING_ROTATE_DESK(
                          index,
                          (word)((isRightClick)?45:-45)) ;
            }
            break ;
        case SEATING_MODE_LABEL:
            if (index != SEATING_DESK_NONE)  {
                index = @call oself::MSG_SEATING_BRING_TO_TOP(index) ;
                if (pself->SSI_nextLabel != STUDENT_LABEL_NONE)
                    @call oself::MSG_SEATING_LABEL_DESK(
                              index,
                              pself->SSI_nextLabel) ;
                /* Time to get the next label */
                /* Send back a message to get the next one */
                if ((pself->SSI_destination) && (pself->SSI_nextLabelMsg))  {
                    @send (pself->SSI_destination)::
                          {PROTOMSG_SEATING_NEXT_LABEL}
                          (pself->SSI_nextLabelMsg)
                          (oself, pself->SSI_nextLabel) ;
                }
            }
            break ;
    }
}

@method StudentSeatingVisClass, MSG_SEATING_XY_DRAG,
                                MSG_SEATING_XY_RELEASE
/*
                      sword x,
                      sword y,
*/
{
    @callsuper() ;

    /* Only process commands that move desks */
    if (pself->SSI_mode == SEATING_MODE_MOVE)  {
        /* Make sure we selected a desk at one point */
        if (pself->SSI_currentDesk != SEATING_DESK_SELECTION_NONE)  {
                /* Move to the new location */
                @call oself::MSG_SEATING_MOVE_DESK(
                          pself->SSI_currentDesk,
                          x,
                          y) ;
            if (message == MSG_SEATING_XY_RELEASE)  {
                 @call oself::MSG_VIS_RELEASE_MOUSE();
                 pself->SSI_currentDesk = SEATING_DESK_SELECTION_NONE ;
            }
        }
    }
}

@method StudentSeatingVisClass, MSG_META_PTR
{
    @callsuper() ;

    if (inputState & BI_B0_DOWN)
         @call oself::MSG_SEATING_XY_DRAG(xPosition, yPosition) ;

    /* Note that we have processed the mouse event */
    retVal->flags |= MRF_PROCESSED ;
}

@method StudentSeatingVisClass, MSG_META_START_SELECT,
                                MSG_META_START_MOVE_COPY
/*
MouseReturnParams *retVal = bpaxdxcx,
                  sword xPosition = cx,
                  sword yPosition = dx,
                  word inputState = bp);
*/
{
    @callsuper() ;

    @call oself::MSG_SEATING_XY_PRESS(
              xPosition-pself->VI_bounds.R_left,
              yPosition-pself->VI_bounds.R_top,
              (inputState & (BI_B1_DOWN|BI_B2_DOWN))?TRUE:FALSE) ;

    /* Note that we have processed the mouse event */
    retVal->flags |= MRF_PROCESSED ;
}

@method StudentSeatingVisClass, MSG_META_END_OTHER,
                                MSG_META_END_SELECT
/*
MouseReturnParams *retVal = bpaxdxcx,
                  sword xPosition = cx,
                  sword yPosition = dx,
                  word inputState = bp);
*/
{
    @callsuper() ;

    @call oself::MSG_SEATING_XY_RELEASE(
              xPosition-pself->VI_bounds.R_left,
              yPosition-pself->VI_bounds.R_top) ;

    /* Note that we have processed the mouse event */
    retVal->flags |= MRF_PROCESSED ;
}

@method StudentSeatingVisClass, MSG_META_DRAG_OTHER,
                                MSG_META_DRAG_SELECT
/*
MouseReturnParams *retVal = bpaxdxcx,
                  sword xPosition = cx,
                  sword yPosition = dx,
                  word inputState = bp);
*/
{
    @callsuper() ;

    @call oself::MSG_SEATING_XY_DRAG(
              xPosition-pself->VI_bounds.R_left,
              yPosition-pself->VI_bounds.R_top) ;

    /* Note that we have processed the mouse event */
    retVal->flags |= MRF_PROCESSED ;
}

@method StudentSeatingVisClass, MSG_SEATING_SET_NEXT_LABEL
{
    pself->SSI_nextLabel = newLabel ;
}

@method StudentSeatingVisClass, MSG_VIS_OPEN
{
    if (!pself->SSI_data)
        pself->SSI_data = MemAlloc(sizeof(SeatingClassBlock), HF_DYNAMIC, HAF_ZERO_INIT) ;

    @call oself::MSG_META_GRAB_FOCUS_EXCL() ;
    @call oself::MSG_SEATING_UPDATE_UI() ;
/*
    @call oself::MSG_SEATING_INTERNAL_FIND_MISSING_LABELS() ;
*/

    @callsuper() ;
}

@method StudentSeatingVisClass, MSG_META_FUP_KBD_CHAR
{
    if (((flags & CF_RELEASE)==0) &&
            ((flags & ((SS_LALT|SS_RALT|SS_LCTRL|SS_RCTRL)<<8))==0))  {
        if (!(@call oself::MSG_SEATING_KEY_PRESSED(character & 0x00FF)))
            return @callsuper() ;
    } else {
        return @callsuper() ;
    }

    return FALSE ;
}

@method StudentSeatingVisClass, MSG_SEATING_KEY_PRESSED
{
    typedef struct {
        byte key ;
        word index ;
        Boolean isLayout ;
    } T_lookupKeystroke ;
    static T_lookupKeystroke keystrokeTable[] = {
        { 'A', SEATING_MODE_ADD,              FALSE },
        { 'D', SEATING_MODE_REMOVE,           FALSE },
        { 'M', SEATING_MODE_MOVE,             FALSE },
        { 'R', SEATING_MODE_ROTATE,           FALSE },
        { 'L', SEATING_MODE_LABEL,            FALSE },
        { '1', SEATING_LAYOUT_A,              TRUE  },
        { '2', SEATING_LAYOUT_B,              TRUE  },
        { '3', SEATING_LAYOUT_C,              TRUE  },
    } ;
    #define NUM_KEYSTROKE_CHECKS  (sizeof(keystrokeTable)/sizeof(keystrokeTable[0]))
    word i ;
    Boolean isUsed = FALSE ;

    hotKey = toupper(hotKey) ;
    for (i=0; i<NUM_KEYSTROKE_CHECKS; i++)  {
        if (keystrokeTable[i].key == hotKey)
            break ;
    }

    if (i != NUM_KEYSTROKE_CHECKS)  {
        isUsed = TRUE ;
        if (keystrokeTable[i].isLayout)  {
            @send ,forceQueue oself::MSG_SEATING_SET_LAYOUT(keystrokeTable[i].index) ;
        } else {
            @send ,forceQueue oself::MSG_SEATING_SET_MODE(keystrokeTable[i].index) ;
        }
    }

    return isUsed ;
}

@method StudentSeatingVisClass, MSG_SEATING_UPDATE_UI
{
    word item ;

    if (pself->SSI_modeGroup)  {
        item = @call (pself->SSI_modeGroup)::MSG_GEN_ITEM_GROUP_GET_SELECTION() ;
        if (item != pself->SSI_mode)
            @send ,forceQueue (pself->SSI_modeGroup)::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(
                      pself->SSI_mode,
                      FALSE) ;
    }
    if (pself->SSI_layoutGroup)  {
        item = @call (pself->SSI_layoutGroup)::MSG_GEN_ITEM_GROUP_GET_SELECTION() ;
        if (item != pself->SSI_currentLayout)
            @send ,forceQueue (pself->SSI_layoutGroup)::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(
                      pself->SSI_currentLayout,
                      FALSE) ;
    }
    if (pself->SSI_gridGroup)  {
        item = @call (pself->SSI_gridGroup)::MSG_GEN_ITEM_GROUP_GET_SELECTION() ;
        if (item != pself->SSI_gridSize)
            @send ,forceQueue (pself->SSI_gridGroup)::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(
                      pself->SSI_gridSize,
                      FALSE) ;
    }
}

T_studentName *IFindStudentName(
                   T_studentNameBlock *p_block,
                   StudentLabel labelID)
{
    word i ;
    T_studentName *p_name ;

    /* Search the list looking for a match */
    for (i=0, p_name=p_block->SNB_nameArray;
         i<p_block->SNB_numNames;
         i++, p_name++)
        if (labelID == p_name->SN_label)
            break ;

    /* If no match was found, use the correct return value for none */
    if (i == p_block->SNB_numNames)
        p_name = NULL ;

    return p_name ;
}

T_studentName *IAllocStudentName(T_studentNameBlock *p_block)
{
    T_studentName *p_name = NULL ;

    if (p_block->SNB_numNames < MAX_STUDENT_NAMES)
        p_name = p_block->SNB_nameArray + (p_block->SNB_numNames++) ;

    return p_name ;
}

void IDeleteStudent(T_studentNameBlock *p_block, StudentLabel labelID)
{
    T_studentName *p_from, *p_to ;
    word num ;
    word i ;

    /* Shrinp up the list of names removing all instances of labelID */
    num = p_block->SNB_numNames ;
    p_from = p_block->SNB_nameArray ;
    p_to = p_block->SNB_nameArray ;
    for (i=0; i<num; i++, p_from++)  {
        /* Copy over an entry (unless its the same one) */
        if (p_to != p_from)
            memcpy(p_to, p_from, sizeof(*p_to)) ;

        /* If we didn't find the label, don't overwrite this field twice */
        if (p_to->SN_label != labelID)  {
            p_to++ ;
        } else {
            /* Found a match.  Overwrite it in the next pass AND decrement */
            /* the total count. */
            p_block->SNB_numNames-- ;
        }
    }
}

@method StudentSeatingVisClass, MSG_SEATING_REPLACE_LABEL
/*
                      StudentLabel labelID,
                      char *p_labelTop,
                      word sizeLabelTop,
                      char *p_labelBottom,
                      word sizeLabelBottom) ;
*/
{
    T_studentNameBlock *p_names ;
    T_studentName *p_name ;

    /* Don't allow 'none' labels */
    if (labelID == STUDENT_LABEL_NONE)
        return ;

    /* Create the name block if we are missing it */
    if (!pself->SSI_studentLabels)  {
        pself->SSI_studentLabels =
            MemAlloc(
               sizeof(T_studentNameBlock),
               HF_DYNAMIC,
               HAF_ZERO_INIT) ;

    }

    /* Only process if we have data to process */
    if (pself->SSI_studentLabels)  {
        /* FInd the student if already in the data listing */
        p_names = LockNames() ;
        p_name = IFindStudentName(p_names, labelID) ;

        /* Create a new student if necessary */
        if (!p_name)
            p_name = IAllocStudentName(p_names) ;

        /* Ok, copy over the data */
        if (p_name)  {
            if (!sizeLabelTop)
                sizeLabelTop = strlen(p_labelTop) ;
            if (!sizeLabelBottom)
                sizeLabelBottom = strlen(p_labelBottom) ;

            if (sizeLabelTop > STUDENT_NAME_FIRST_NAME_MAX)
                sizeLabelTop = STUDENT_NAME_FIRST_NAME_MAX ;
            if (sizeLabelBottom > STUDENT_NAME_LAST_NAME_MAX)
                sizeLabelBottom = STUDENT_NAME_LAST_NAME_MAX ;

            /* Reset and copy over the data */
            memset(p_name, 0, sizeof(*p_name)) ;
            p_name->SN_label = labelID ;
            memcpy(p_name->SN_firstName, p_labelTop, sizeLabelTop);
            memcpy(p_name->SN_lastName, p_labelBottom, sizeLabelBottom) ;

            /* Change the label, show it differently */
            @send ,forceQueue oself::MSG_SEATING_INVALIDATE_STUDENT(labelID) ;
        }

        /* Done, unlock */
        UnlockNames() ;
    }
}

@method StudentSeatingVisClass, MSG_SEATING_INTERNAL_FIND_MISSING_LABELS
{
    SeatingClassBlock *p_block ;
    SeatingDeskLayout *p_layout ;
    SeatingDeskPosition *p_desk ;
    sword i ;
    T_studentNameBlock *p_names ;
    MemHandle mem ;

/* Force in two test cases for student id #1 and #2 */
@if 0
static Boolean isOnce = FALSE ;
if (!isOnce)  {
@call oself::MSG_SEATING_REPLACE_LABEL(
                      1,
                      "Michael A.",
                      0,
                      "Dupperstein",
                      5) ;
@call oself::MSG_SEATING_REPLACE_LABEL(
                      2,
                      "Jason K.",
                      6,
                      "Hammerfeld",
                      0) ;
isOnce = TRUE ;
}
@endif
    /* Don't do this if there is no callback routine */
    if ((pself->SSI_destination) && (pself->SSI_queryLabelMsg))  {
        /* Create the name block if we are missing it */
        if (!pself->SSI_studentLabels)  {
            pself->SSI_studentLabels =
                MemAlloc(
                   sizeof(T_studentNameBlock),
                   HF_DYNAMIC,
                   HAF_ZERO_INIT) ;

        }

        if ((pself->SSI_data) && (pself->SSI_studentLabels))  {
            /* Try adding a new block to the layer */
            p_block = LockClass() ;
            p_names = LockNames() ;
            p_layout = p_block->SCB_layoutArray + pself->SSI_currentLayout ;
            p_desk = p_layout->SDL_deskArray ;

            /* Look at all the desks and see if there are any missing */
            /* labels (one not the label list) */
            for (i=0; i<p_layout->SDL_numDesks; i++, p_desk++)  {
                if (p_desk->SDP_label)  {
                    if (!IFindStudentName(p_names, p_desk->SDP_label))  {
                        /* Request the label be replaced */
                        @send ,forceQueue (pself->SSI_destination)::
                                 {PROTOMSG_SEATING_QUERY_LABEL}
                                 (pself->SSI_queryLabelMsg)
                                 (oself, p_desk->SDP_label) ;
                    }
                }
            }
            UnlockNames() ;
            UnlockClass() ;
        }
    }
}

@method StudentSeatingVisClass, MSG_SEATING_DELETE_LABEL_LIST
{
    /* Drop the memory block if it exists.  */
    /* It'll get recreated when needed */
    if (pself->SSI_studentLabels)  {
        MemFree(pself->SSI_studentLabels) ;
        pself->SSI_studentLabels = NullHandle ;
    }
}

@method StudentSeatingVisClass, MSG_META_DETACH
{
    @callsuper() ;
    @call oself::MSG_SEATING_DELETE_LABEL_LIST() ;
}

@method StudentSeatingVisClass, MSG_VIS_DRAW
{
    SeatingClassBlock *p_block ;
    SeatingDeskLayout *p_layout ;
    SeatingDeskPosition *p_desk ;
    word i ;
    T_studentNameBlock *p_names = NULL ;
    T_studentName *p_name ;
    MemHandle mem ;
    sword x, y ;

    @callsuper() ;

    if (pself->SSI_studentLabels)
        p_names = LockNames() ;

    /* Draw a grid if we have one */
    if (pself->SSI_gridSize)  {
        GrSaveState(gstate) ;
        GrSetLineColor(gstate, CF_INDEX, C_LIGHT_BLUE, 0, 0) ;
        for (y=0; y<72*11; y+=pself->SSI_gridSize)  {
            GrDrawHLine(gstate, 0, y, 72*8.5) ;
        }
        for (x=0; x<72*8.5; x+=pself->SSI_gridSize)  {
            GrDrawVLine(gstate, x, 0, 72*11) ;
        }
        GrRestoreState(gstate) ;
    }

    /* Only draw data if we have data */
    if (pself->SSI_data)  {
        GrSaveState(gstate) ;
        GrSetAreaColor(gstate, CF_INDEX, C_WHITE, 0, 0) ;
        GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0) ;
        GrApplyTranslation(
            gstate,
            MakeWWFixed(pself->VI_bounds.R_left),
            MakeWWFixed(pself->VI_bounds.R_top)) ;
        /* Try adding a new block to the layer */
        p_block = LockClass() ;
        p_layout = p_block->SCB_layoutArray + pself->SSI_currentLayout ;
        p_desk = p_layout->SDL_deskArray ;
        for (i=0; i<p_layout->SDL_numDesks; i++, p_desk++)  {
            GrSaveState(gstate) ;
            GrApplyTranslation(
                gstate,
                MakeWWFixed(
                    p_desk->SDP_x /* -
                    (G_deskTypeSizeArray[p_desk->SDP_type].XYS_width>>1) */),
                MakeWWFixed(
                    p_desk->SDP_y /* -
                    (G_deskTypeSizeArray[p_desk->SDP_type].XYS_height>>1) */)) ;
            GrApplyRotation(gstate, MakeWWFixed(p_desk->SDP_angle));
            switch (p_desk->SDP_type)  {
                case SEATING_DESK_TYPE_SQUARE:
				  /*      GrFillRect(gstate, -20, 20, 20, -10) ;
                    GrDrawRect(gstate, -20, 20, 20, -10) ;
                    GrFillRect(gstate, -12, -10, 12, -20) ;
                    GrDrawRect(gstate, -12, -10, 12, -20) ;
                    GrSetAreaColor(gstate, CF_INDEX, C_BLACK, 0, 0) ;
                    GrFillRect(gstate, -12, -16, 12, -20) ;
						  GrSetAreaColor(gstate, CF_INDEX, C_WHITE, 0, 0) ;   */
						  /* try a bigger desk */
						  GrFillRect(gstate, -30, 30, 30, -20) ;
						  GrDrawRect(gstate, -30, 30, 30, -20) ;
						  GrFillRect(gstate, -20, -20, 20, -30) ;
						  GrDrawRect(gstate, -20, -20, 20, -30) ;
                    GrSetAreaColor(gstate, CF_INDEX, C_BLACK, 0, 0) ;
                    GrFillRect(gstate, -20, -26, 20, -30) ;
                    GrSetAreaColor(gstate, CF_INDEX, C_WHITE, 0, 0) ;
						  break ;
            }
//				GrApplyRotation(gstate, -MakeWWFixed(p_desk->SDP_angle));
// try rotating the name with the desk...
            /* Try drawing a label on top */
            if (p_desk->SDP_label)  {
                /* Draw the outline of the name */
				//    GrFillRect(gstate, -29, -10, 29, 14) ;
				//    GrDrawRect(gstate, -29, -10, 29, 14) ;
            //    GrDrawRect(gstate, -28, -9, 28, 13) ;
                GrSaveState(gstate) ;
                GrSetClipRect(gstate, PCT_REPLACE, -26, -8, 26, 12) ;
                GrSetFont(gstate, NAME_LABEL_FONT, MakeWWFixed(NAME_LABEL_POINT_SIZE)) ;

                /* Look up the name now */
                if (p_names)
                    p_name = IFindStudentName(p_names, p_desk->SDP_label) ;
                else
                    p_name = NULL ;
                if (p_name)  {
                    GrDrawText(gstate, -26, -11, p_name->SN_firstName, 0) ;
                    GrDrawText(gstate, -26, -11+NAME_LABEL_POINT_SIZE, p_name->SN_lastName, 0) ;
                } else {
                    GrDrawText(gstate, -26, -11+(NAME_LABEL_POINT_SIZE/2), "?", 0) ;
                }

                GrRestoreState(gstate) ;
            }
				GrApplyRotation(gstate, -MakeWWFixed(p_desk->SDP_angle));
            GrRestoreState(gstate) ;
        }
        UnlockClass() ;
        GrRestoreState(gstate) ;
    }

    if (p_names)
        UnlockNames() ;

    /* Double check and make sure all the labels were found */
/*
    @send ,forceQueue oself::MSG_SEATING_INTERNAL_FIND_MISSING_LABELS() ;
*/
}

@method StudentSeatingVisClass, MSG_SEATING_DELETE_LABEL
/* (StudentLabel labelID) ; */
{
    SeatingClassBlock *p_block ;
    SeatingDeskLayout *p_layout ;
    SeatingDeskPosition *p_desk ;
    word layout ;
    word i ;
    T_studentNameBlock *p_names = NULL ;
  /*  T_studentName *p_name ; */
    MemHandle mem ;

    if ((pself->SSI_data) && (pself->SSI_studentLabels))  {
        p_names = LockNames() ;
        p_block = LockClass() ;

        /* Find all desks that use this student label and delete them */
        for (layout=0; layout<SEATING_NUM_LAYOUTS; layout++)  {
            p_layout = p_block->SCB_layoutArray + layout ;
            p_desk = p_layout->SDL_deskArray ;
            for (i=0; i<p_layout->SDL_numDesks; i++, p_desk++)  {
                /* Look for students on desks */
                if (p_desk->SDP_label == labelID)  {
                    p_desk->SDP_label = STUDENT_LABEL_NONE ;
                    if (layout == pself->SSI_currentLayout)
                        @call oself::MSG_SEATING_INVALIDATE_DESK(i) ;
                    p_block->SCB_isDirty = TRUE ;
                }
            }
        }

        /* Now remove the student from the database */
        IDeleteStudent(p_names, labelID) ;

        DirtyClass() ;
        UnlockClass() ;
        UnlockNames() ;
    } else {
        @call oself::MSG_SEATING_ERROR(SEATING_ERROR_NO_DATA) ;
    }
}


@method StudentSeatingVisClass, MSG_SEATING_SET_VM_SETTINGS
/*
                      VMFileHandle file,
                      VMBlockHandle block) ;
*/
{
    pself->SSI_file = file ;
    pself->SSI_data = block ;
}

@method StudentSeatingVisClass, MSG_SEATING_SET_GRID
/* (word pixelSpacing) ; */
{
    if (pself->SSI_gridSize != pixelSpacing)  {
        pself->SSI_gridSize = pixelSpacing ;
        @call oself::MSG_VIS_INVALIDATE() ;
    }
}

@method StudentSeatingVisClass, MSG_SEATING_GET_GRID
{
    return pself->SSI_gridSize ;
}

@method StudentSeatingVisClass, MSG_SEATING_GET_NUM_DESKS
{
    word numDesks = 0 ;
    SeatingClassBlock *p_block ;
    MemHandle mem ;

    /* Try adding a new block to the layer */
    p_block = LockClass() ;
    numDesks = p_block->SCB_layoutArray[pself->SSI_currentLayout].SDL_numDesks ;
    UnlockClass() ;

    return numDesks ;
}

@method StudentSeatingVisClass, MSG_SEATING_GET_SORTED_DESK_LIST
/* (word *p_list, word max) ; */
{
    word i, j, k ;
    word num = 0 ;
    SeatingClassBlock *p_block ;
    SeatingDeskLayout *p_layout ;
    SeatingDeskPosition *p_desk ;
    sword bestX, bestY ;
    word bestI ;
    MemHandle mem ;

    /* Copy over the new data */
    if (pself->SSI_data)  {
        p_block = LockClass() ;
        p_layout = p_block->SCB_layoutArray + pself->SSI_currentLayout ;
        num = p_layout->SDL_numDesks ;
        /* Do an 'apple pick' sort pull out the best */
        for (i=0; i<num; i++)
            p_list[i] = i ;

        for (i=0; i<num; i++)  {
            bestI = i ;
            p_desk = p_layout->SDL_deskArray + p_list[i] ;
            bestX = p_desk->SDP_x ;
            bestY = p_desk->SDP_y ;
            for (j=i+1; j<num; j++)  {
                p_desk = p_layout->SDL_deskArray + p_list[j] ;
                if ((p_desk->SDP_y > bestY) ||
                    ((p_desk->SDP_y == bestY) && (p_desk->SDP_x < bestX)))  {
                    bestX = p_desk->SDP_x ;
                    bestY = p_desk->SDP_y ;
                    bestI = j ;
                }
            }

            /* Swap values if not the same location */
            if (bestI != i)  {
                k = p_list[i] ;
                p_list[i] = p_list[bestI] ;
                p_list[bestI] = k ;
            }
        }

        UnlockClass() ;

        /* Need to be totally redrawn */
        @call oself::MSG_VIS_INVALIDATE();
    } else {
        @call oself::MSG_SEATING_ERROR(SEATING_ERROR_NO_DATA) ;
    }

    return num ;
}

/***********************************************************************
 *
 * MESSAGE:	MSG_PRINT_START_PRINTING for StudentSeatingVisClass
 *
 * DESCRIPTION:	prints the seating chart
 *
 *
 ***********************************************************************/
@method StudentSeatingVisClass, MSG_PRINT_START_PRINTING
{


    GrSaveState(gstate);

    /* Draw seating chart */
    @call self::MSG_VIS_DRAW(DF_PRINT, gstate);

    GrRestoreState(gstate);

    GrNewPage(gstate, PEC_FORM_FEED);

    @send TASeatingPrintControl::MSG_PRINT_CONTROL_PRINTING_COMPLETED();

}

