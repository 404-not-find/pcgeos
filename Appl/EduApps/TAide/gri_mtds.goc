/***************************************************************************
 *  FILE:           gri_mtds.goc
 *  PROJECT:        Breadbox Teacher's Aide
 *  DESCRIPTION:    This file has methods for grid manipulation
 *
 **************************************************************************
 */
/*
 ***************************************************************************
 *      Include files
 ***************************************************************************
 */

@include "taide.goh"
@include "externs.goh"

Boolean g_noTyping = FALSE;
/*
 ***************************************************************************
 *      Class & Message Definitions
 ***************************************************************************
 */

/*
 ***************************************************************************
 *      Code for Grid Manipulation
 ***************************************************************************
 */

/***********************************************************************
 *
 * FUNCTION:    GetAttCode
 *
 * CALLED BY:
 *
 * STRATEGY:
 *
 *
 ***********************************************************************/
 byte GetAttCode(word row,
              word column,
              FileHandle docFileHan,
              VMBlockHandle stuDBHan,
              VMBlockHandle curStuIndex,
              word curGradePd)
{
 BasicDBFieldID fieldID;
 BasicDBError       error;
 MemHandle      mh;
 word           start, i;
 char           attString[ATT_STRING_SIZE];


    /* first get the student record */
    error = BasicDBGetRecordByIndex(docFileHan,
                       stuDBHan,
                       curStuIndex,
                       row,
                       &mh);
    /* now the att data */
    fieldID = BasicDBGetFieldID(mh, BDBFHE_CATEGORY, STU_ATTENDANCE, 1);
    BasicDBGetFieldData(mh, fieldID, attString, ATT_STRING_SIZE);
    BasicDBDiscardRecord(mh);

    /* get to the selected grade period */
    start = 0;
    if (curGradePd) {
      for (i = 0; i < curGradePd; i++)  {
        while (attString[start] != '*') start++;
        start++;
        }
      }

    /* advance to the selected date */
    start += column;

    return (attString[start]);

}

/*-------------------------------------------------------------------------
 | Method:  TADocumentClass::MSG_GRID_DRAW_CELL_GROUP
 *-------------------------------------------------------------------------
 |
 | Description:
 |    This message is called by the GRID object (usually in the UI thread)
 |    to draw the given cell region.  Because the work is usually always
 |    the same, the action is usually done by VisGridUtilityDrawGroup().
 |
 | Inputs:
 |    optr visGridObj             -- Vis grid doing call
 |    word startColumn, startRow  -- Upper left of region
 |    word endColumn, endRow      -- Lower right of region
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  07/22/99  Created
 |
 *-----------------------------------------------------------------------*/
@extern method TADocumentClass, MSG_GRID_DRAW_CELL_GROUP
{
    VisGridUtilityDrawGroup(
        visGridObj,
        startColumn,
        startRow,
        endColumn,
        endRow) ;
}

/***********************************************************************
 *
 * MESSAGE: MSG_DRAW_MODULE_NAME_LIST for TADocumentClass
 *                (VIS_GRID_DRAW_CELL)
 *                           GStateHandle gstate,
 *                      word column,
 *                           word row,
 *                           word width,
 *                           word height,
 *                           optr grid,
 *                           GridDrawFlags flags) ;
 * DESCRIPTION:
 *
 *
 ***********************************************************************/
@extern method TADocumentClass, MSG_DRAW_MODULE_NAME_LIST
{
 BasicDBError       error;
 word           size;
 char           nameString[NAME_SIZE];
 char           fullString[NAME_SIZE * 3];
 BasicDBFieldID fieldID;
 MemHandle      mh;


    /* return out of range draw request...*/
    if ((row >= (pself->TADI_numStudents)) || (column >0)) return;

    /* Draw in the correct color based on flags */
    if (flags & GRID_DRAW_FLAG_SELECTED)
       GrSetTextColor(gstate, CF_INDEX, C_WHITE, 0, 0) ;
    else  GrSetTextColor(gstate, CF_INDEX, C_BLACK, 0, 0) ;

    /* get the names */
    error = BasicDBGetRecordByIndex(pself->GDI_fileHandle,
                       pself->TADI_stuDBHan,
							  pself->TADI_curStuIndex,
                       row,
                       &mh);
    if (!error)  {
		if (pself->TADI_curStuIndex == pself->TADI_stuNameIndex) {
			/* show names */
			fieldID = BasicDBGetFieldID(mh,
                            BDBFHE_CATEGORY,
                            STU_L_NAME,
                            1);
			size = BasicDBGetFieldData(mh,
                            fieldID,
                            fullString,
                            NAME_SIZE);
			fullString[size] = 0;
			strcat(fullString, ", ");
			fieldID = BasicDBGetFieldID(mh,
                            BDBFHE_CATEGORY,
                            STU_F_NAME,
                            1);
			size = BasicDBGetFieldData(mh,
                            fieldID,
                            nameString,
                            NAME_SIZE);
			nameString[size] = 0;
			strcat(fullString, nameString);
			strcat(fullString, " ");
			fieldID = BasicDBGetFieldID(mh,
                            BDBFHE_CATEGORY,
                            STU_M_NAME,
                            1);
			size = BasicDBGetFieldData(mh,
                            fieldID,
                            nameString,
                            NAME_SIZE);
			nameString[size] = 0;
			strcat(fullString, nameString);
			BasicDBDiscardRecord(mh);
			} /* end of show names if */
		else {
			/* show number & last name */
			fieldID = BasicDBGetFieldID(mh,
                            BDBFHE_CATEGORY,
									 STU_NUMBER,
                            1);
			size = BasicDBGetFieldData(mh,
                            fieldID,
                            fullString,
                            NAME_SIZE);
			fullString[size] = 0;
			if (@call SSSFNumberNameGroup::
							MSG_GEN_ITEM_GROUP_GET_SELECTION() == NUM_AND_NAME) {
				strcat(fullString, ", ");
				fieldID = BasicDBGetFieldID(mh,
                            BDBFHE_CATEGORY,
									 STU_L_NAME,
                            1);
				size = BasicDBGetFieldData(mh,
                            fieldID,
                            nameString,
                            NAME_SIZE);
				nameString[size] = 0;
				strcat(fullString, nameString);
            }
			} /* end of show numbers else */
      }
	 else {
		MemLock(OptrToHandle(@ErrorStr));
		strcpy(fullString, LMemDeref(@ErrorStr));
		MemUnlock(OptrToHandle(@ErrorStr));
		}

    /* and draw the name */
    GrDrawText(gstate, 1, 1, fullString, 0);


}

/***********************************************************************
 *
 * MESSAGE: MSG_DRAW_ATT_TITLE for TADocumentClass
 *                (VIS_GRID_DRAW_CELL)
 *                           GStateHandle gstate,
 *                      word column,
 *                           word row,
 *                           word width,
 *                           word height,
 *                           optr grid,
 *                           GridDrawFlags flags) ;
 * DESCRIPTION:
 *
 *
 ***********************************************************************/
@extern method TADocumentClass, MSG_DRAW_ATT_TITLE
{
 VMMapStruct        *VMmapPtr;
 MemHandle      mh;
 VMBlockHandle      vmbh;
 TimerDateAndTime   date;
 char           dateString[DATE_TIME_BUFFER_SIZE + 1], cStr[2];
 word           dateNum, i, numCodes;
 word           numHolidays, startNum, endNum;
 dword          dayOfWeek;
 byte           month, day;
 AttCodeStruct      *attCodePtr;
 HolidaysStruct *holidayPtr;
 word		 tWidth, start;


    /* return out of range draw request...*/
    if (pself->TADI_curGradePd < MAX_GRADE_PDS) {
	  /* regular grade period */
	  if ((row > 0) || (column >= (pself->TADI_curNumAttDays + 2)))
		return;
	  }
    /* summary grade period */
    else if ((row > 0) || (column >= (pself->TADI_numGradePds + 1)))
	  return;

    /* set the text */
    /* Draw in the correct color based on flags */
    if (flags & GRID_DRAW_FLAG_SELECTED)
       GrSetTextColor(gstate, CF_INDEX, C_WHITE, 0, 0) ;
    else  GrSetTextColor(gstate, CF_INDEX, C_BLACK, 0, 0) ;
    GrSetFont(gstate, FID_DTC_URW_SANS, MakeWWFixed(10));
    GrSetTextStyle(gstate, TS_BOLD, TS_ITALIC);

    if (column < pself->TADI_curNumAttDays) { /* show the date */
	  /* get the starting date */
	  vmbh = VMGetMapBlock(pself->GDI_fileHandle);
	  VMmapPtr = VMLock(pself->GDI_fileHandle, vmbh, &mh);
	  dateNum = VMmapPtr->VMMS_gpStart[pself->TADI_curGradePd];
	  VMUnlock(mh);

	  if (pself->TADI_showWeekends)  dateNum += column;
	  else  {
		/* need to eliminate w/e dates */
		FloatDwordToFloat((dword)(dateNum));
		FloatDateNumberGetWeekday();
		dayOfWeek = FloatFloatToDword();
		switch (dayOfWeek) {
		   case 1:
			 dateNum++;
			 dateNum += column + (2*(column/5));
			 break;
		   case 2:
			 dateNum += column + (2*(column/5));
			 break;
		   case 3:
			 if (column < 4) dateNum += column;
			 else dateNum += column + (2*((column+1)/5));
			 break;
		   case 4:
			 if (column < 3) dateNum += column;
			 else dateNum += column + (2*((column+2)/5));
			 break;
		   case 5:
			 if (column < 2) dateNum += column;
			 else dateNum += column + (2*((column+3)/5));
			 break;
		   case 6:
			 if (column < 1) dateNum += column;
			 else dateNum += column + (2*((column+4)/5));
			 break;
		   case 7:
			 dateNum += 2;
			 dateNum += column + (2*(column/5));
			 break;
		   } /* end of dow switch */
		} /* end of eliminate w/e dates else*/

	  /* see if it is a holiday or teacher work day */
	  vmbh = VMFind(pself->GDI_fileHandle, NullHandle, HOLIDAY);
	  VMLock(pself->GDI_fileHandle, vmbh ,&mh);
	  numHolidays = ChunkArrayGetCountHandles(mh, pself->TADI_holidayChunkArray);
	  for (i = 0; i < numHolidays; i++)  {
		holidayPtr = ChunkArrayElementToPtrHandles(
			    mh,
			    pself->TADI_holidayChunkArray,
			    i,
			    0);
		startNum = holidayPtr->HS_start;
		endNum = holidayPtr->HS_end;

		if (((!endNum) && (dateNum == startNum)) ||
			 (endNum && (dateNum >= startNum) && (dateNum <= endNum)))  {
		   /* it is one or the other */
		   GrSetTextStyle(gstate, TS_ITALIC, TS_BOLD);
		   if (holidayPtr->HS_tWork)
			 GrSetTextColor(gstate, CF_INDEX, C_RED, 0, 0);
		   else GrSetTextColor(gstate, CF_INDEX, C_GREEN, 0, 0);
		   i = numHolidays;
		   }  /* end of holiday if */
		} /* end of check holidays for */
	  VMUnlock(mh);

	  FloatDwordToFloat((dword)dateNum);  /* FloatWordToFloat is broken */
	  FloatDateNumberGetWeekday();
	  dayOfWeek = FloatFloatToDword();

	  MemLock (OptrToHandle(@SunString));
	  strcpy(dateString, LMemDeref(ConstructOptr(
	  	HandleOf(@SunString), 
		(word) ChunkOf(@SunString) + (word)(dayOfWeek - 1))));
	  MemUnlock (OptrToHandle(@SunString));

	  /* and draw the day of the week */
	  tWidth = GrTextWidth(gstate, dateString, strlen(dateString));
	  start = (ATT_WIDTH - tWidth)/2;
	  GrDrawText(gstate, start, 7, dateString, 0);

	  FloatDwordToFloat((dword)dateNum);
	  FloatDateNumberGetMonthAndDay(&month, &day);
	  date.TDAT_month = (word)month;
	  date.TDAT_day = (word)day;
	  LocalFormatDateTime(dateString, DTF_MD_SHORT, &date);

	  /* and draw the date */
	  tWidth = GrTextWidth(gstate, dateString, strlen(dateString));
	  start = (ATT_WIDTH - tWidth)/2;
	  GrDrawText(gstate, start, 20, dateString, 0);
	  }  /* end of show the date if */

    else  { /* show the codes */
	  /* find out how many codes in the list */
	  vmbh = VMFind(pself->GDI_fileHandle, NullHandle, ATT_CODE);
	  VMLock(pself->GDI_fileHandle, vmbh ,&mh);
	  numCodes = ChunkArrayGetCountHandles(mh, pself->TADI_attCodeChunkArray);
	  VMUnlock(mh);
	  if (pself->TADI_curGradePd < MAX_GRADE_PDS) {
		/* show the cur grade pd summary */
		/* is col GP or YTD */
		MemLock (OptrToHandle(@GPStr));
		if (column == pself->TADI_curNumAttDays) {
		   /* show the gp */
			strcpy(dateString, LMemDeref(@GPStr));
			strcat(dateString, " ");
			UtilHex32ToAscii(cStr,
				(sdword) (pself->TADI_curGradePd + 1),
				UHTAF_NULL_TERMINATE);
		   strcat(dateString, cStr);
		   }
		else {
			strcpy(dateString, LMemDeref(@YTDStr));
			strcat(dateString, " ");
			}
		MemUnlock (OptrToHandle(@GPStr));
		tWidth = GrTextWidth(gstate, dateString, strlen(dateString));
		start = (ATT_SUMMARY_WIDTH - tWidth)/2;
		GrDrawText(gstate, start, 7, dateString, 0);
		} /* end of show the grade pd summary if */
	  else { /* show the summary grade period titles */
		/* is col GP or YTD */
		MemLock (OptrToHandle(@GPStr));
		if (column < pself->TADI_numGradePds) {
		   /* show the gp */
			strcpy(dateString, LMemDeref(@GPStr));
			strcat(dateString, " ");
			UtilHex32ToAscii(cStr,
				(sdword) (column + 1),
				UHTAF_NULL_TERMINATE);
		   strcat(dateString, cStr);
		   }
		else {
			strcpy(dateString, LMemDeref(@YTDStr));
			strcat(dateString, " ");
			}
		MemUnlock (OptrToHandle(@GPStr));
		tWidth = GrTextWidth(gstate, dateString, strlen(dateString));
		start = (ATT_SUMMARY_WIDTH - tWidth)/2;
		GrDrawText(gstate, start, 7, dateString, 0);
		}
	  /* put our string together */
	  vmbh = VMFind(pself->GDI_fileHandle, NullHandle, ATT_CODE);
	  VMLock(pself->GDI_fileHandle, vmbh ,&mh);
	  dateString[0] = 0;
	  for (i = 0; i < numCodes; i++)  {
		attCodePtr = ChunkArrayElementToPtrHandles(
				   mh,
				   pself->TADI_attCodeChunkArray,
				   i,
				   0);
		strcat(dateString, attCodePtr->ACS_code);
		if (i != (numCodes - 1))  {
		   strcat(dateString, " / ");
		   }
		}
	  VMUnlock(mh);
	  tWidth = GrTextWidth(gstate, dateString, strlen(dateString));
	  start = (ATT_SUMMARY_WIDTH - tWidth)/2;
	  GrDrawText(gstate, start, 20, dateString, 0);
       } /* end of show the att code else */


}

/***********************************************************************
 *
 * MESSAGE: MSG_DRAW_MAIN_ATTEND for TADocumentClass
 *                (VIS_GRID_DRAW_CELL)
 *                           GStateHandle gstate,
 *                      word column,
 *                           word row,
 *                           word width,
 *                           word height,
 *                           optr grid,
 *                           GridDrawFlags flags) ;
 * DESCRIPTION:
 *
 *
 ***********************************************************************/
@extern method TADocumentClass, MSG_DRAW_MAIN_ATTEND
{
 char           attCode[2];
 BasicDBFieldID fieldID;
 BasicDBError       error;
 MemHandle      mh;
 word           start, i, count, j, numCodes, gp;
 char           attString[ATT_STRING_SIZE], string[50], numString[15];
 VMBlockHandle      vmbh;
 AttCodeStruct      *attCodePtr;
 word			tWidth, pos;


    /* return out of range draw request...*/
    if (pself->TADI_curGradePd < MAX_GRADE_PDS) {
	  /* regular grade period */
	  if ((row >= pself->TADI_numStudents) ||
		   (column >= pself->TADI_curNumAttDays + 2))
		return;
	  }
    /* summary grade period */
    else if ((row >= pself->TADI_numStudents) ||
			  (column >= pself->TADI_numGradePds + 1))
	  return;


    if (column < pself->TADI_curNumAttDays) {
	  /* get the code letter */
	  attCode[0] = GetAttCode(row, column,
                         pself->GDI_fileHandle,
                         pself->TADI_stuDBHan,
                         pself->TADI_curStuIndex,
                         pself->TADI_curGradePd);
	  attCode[1] = 0;

	  /* show the code */
	  tWidth = GrTextWidth(gstate, attCode, strlen(attCode));
	  pos = (ATT_WIDTH - tWidth)/2;
	  GrDrawText(gstate, pos, 1, attCode, 0);
	  }

    else {  /* show totals */
	  GrSetFont(gstate, FID_DTC_URW_SANS, MakeWWFixed(g_sysPointSize));
	  vmbh = VMFind(pself->GDI_fileHandle, NullHandle, ATT_CODE);
	  VMLock(pself->GDI_fileHandle, vmbh ,&mh);
	  numCodes = ChunkArrayGetCountHandles(mh, pself->TADI_attCodeChunkArray);
	  VMUnlock(mh);

	  /* first get the student record */
	  error = BasicDBGetRecordByIndex(pself->GDI_fileHandle,
                       pself->TADI_stuDBHan,
                       pself->TADI_curStuIndex,
                       row,
                       &mh);
	  /* now the att data */
	  fieldID = BasicDBGetFieldID(mh, BDBFHE_CATEGORY, STU_ATTENDANCE, 1);
	  BasicDBGetFieldData(mh, fieldID, attString, ATT_STRING_SIZE);
	  BasicDBDiscardRecord(mh);

	  /* summary or single gp */
	  if (pself->TADI_curGradePd < MAX_GRADE_PDS)  {
		/* single grade period */
		start = 0;
		/* is col GP or YTD */
		if (column == pself->TADI_curNumAttDays) {
		   /* get to the selected grade period */
		   if (pself->TADI_curGradePd) {
			 for (i = 0; i < pself->TADI_curGradePd; i++)  {
			    while (attString[start] != '*') start++;
			    start++;
			    }
			 }
		   }

		/* cycle thru the code letters */
		vmbh = VMFind(pself->GDI_fileHandle, NullHandle, ATT_CODE);
		VMLock(pself->GDI_fileHandle, vmbh ,&mh);
		string[0] = 0;
		for (i = 0; i < numCodes; i++)  {
		   j = start;
		   attCodePtr = ChunkArrayElementToPtrHandles(
					 mh,
					 pself->TADI_attCodeChunkArray,
					 i,
					 0);
		   /* count the codes */
		   count = 0;
		   if (column == pself->TADI_curNumAttDays) {  /* in this GP */
			 while (attString[j] != '*') {
			    if (attString[j] == attCodePtr->ACS_code[0]) count++;
			    j++;
			    }
			 }
		   else {
			 gp = 0;
			 while (gp < MAX_GRADE_PDS) {  /* YTD */
			    if (attString[j] == attCodePtr->ACS_code[0]) count++;
			    else if (attString[j] == '*') gp++;
			    j++;
			    }
			 }
		   UtilHex32ToAscii(numString, (sdword) count, UHTAF_NULL_TERMINATE);
		   strcat (string, numString);
		   if (i != numCodes - 1) {
			 strcat(string, " / ");
			 }
		   } /* end of cycle thru for */
		VMUnlock(mh);
		} /* end of single gp if */

	  else  { /* this is the summary screen */
		start = 0;
		/* is col GP or YTD */
		if (column < pself->TADI_numGradePds) {
		   /* get to the selected grade period */
		   for (i = 0; i < column; i++)  {
			 while (attString[start] != '*') start++;
			 start++;
			 }
		   }

		/* cycle thru the code letters */
		vmbh = VMFind(pself->GDI_fileHandle, NullHandle, ATT_CODE);
		VMLock(pself->GDI_fileHandle, vmbh ,&mh);
		string[0] = 0;
		for (i = 0; i < numCodes; i++)  {
		   j = start;
		   attCodePtr = ChunkArrayElementToPtrHandles(
					 mh,
					 pself->TADI_attCodeChunkArray,
					 i,
					 0);

		   /* count the codes */
		   count = 0;
		   if (column < pself->TADI_numGradePds) {  /* in this GP */
			 while (attString[j] != '*') {
			    if (attString[j] == attCodePtr->ACS_code[0]) count++;
			    j++;
			    }
			 }
		   else {
			 gp = 0;
			 while (gp < pself->TADI_numGradePds) {  /* YTD */
			    if (attString[j] == attCodePtr->ACS_code[0]) count++;
			    else if (attString[j] == '*') gp++;
			    j++;
			    }
			 }
		   UtilHex32ToAscii(numString, (sdword) count, UHTAF_NULL_TERMINATE);
		   strcat (string, numString);
		   if (i != numCodes - 1) {
			 strcat(string, " / ");
			 }
		   } /* end of cycle thru for */
		VMUnlock(mh);
		} /* end of summary screen else */
	  /* and show the count */
	  tWidth = GrTextWidth(gstate, string, strlen(string));
	  pos = (ATT_SUMMARY_WIDTH - tWidth)/2;
	  GrDrawText(gstate, pos, 1, string, 0);

	  }  /* end of show totals else */

}

/***********************************************************************
 *
 * MESSAGE: MSG_SHOW_ATTENDANCE_GRID_DATA for TADocumentClass
 *                (VIS_TEXT_GRID_QUERY_DATA)
 | Inputs:
 |    word column, row            -- Cell to get data for
 |    optr gridObjet              -- VisTextGrid object in use
 |    optr textObject             -- What text object to change
 |
 | Outputs:
 |    Boolean                     -- TRUE if data exists now in text object,
 |                                   else FALSE.
 * DESCRIPTION:
 *
 *
 ***********************************************************************/
@extern method TADocumentClass, MSG_SHOW_ATTENDANCE_GRID_DATA
{
 char           attCode[2];


    if ((column < pself->TADI_curNumAttDays) && !g_noTyping) {

      /* get the code letter */
      attCode[0] = GetAttCode(row, column,
                         pself->GDI_fileHandle,
                         pself->TADI_stuDBHan,
                         pself->TADI_curStuIndex,
                         pself->TADI_curGradePd);
      attCode[1] = 0;

      /* and show it */
      if (attCode[0]) @call textObject::MSG_VIS_TEXT_REPLACE_ALL_PTR(attCode, 0);

      /* make it editable */
      @call gridObject::MSG_VIS_TEXT_GRID_SHOW_TEXT_AT(column, row) ;
      }
    else {
      @call gridObject::MSG_VIS_TEXT_GRID_HIDE_TEXT() ;
    }

}

/***********************************************************************
 *
 * MESSAGE: MSG_SAVE_ATTENDANCE_GRID_DATA for TADocumentClass
 *                (VIS_TEXT_GRID_SAVE_DATA)
 | Inputs:
 |    word column, row            -- Cell to get data for
 |    optr gridObjet              -- VisTextGrid object in use
 |    optr textObject             -- What text object to change
 |
 * DESCRIPTION:
 *
 *
 ***********************************************************************/
@extern method TADocumentClass, MSG_SAVE_ATTENDANCE_GRID_DATA
{
 char           attCode[2];
 BasicDBFieldID fieldID;
 BasicDBRecordID    recordID;
 BasicDBError       error;
 MemHandle      mh;
 word           place, i, numCodes;
 char           attString[ATT_STRING_SIZE];
 VMBlockHandle      vmbh;


    /* get the code letter */
    @call textObject::MSG_VIS_TEXT_GET_ALL_PTR(attCode);

    /* get the student record */
    error = BasicDBGetRecordByIndex(pself->GDI_fileHandle,
                       pself->TADI_stuDBHan,
                       pself->TADI_curStuIndex,
                       row,
                       &mh);
    /* now the att data */
    fieldID = BasicDBGetFieldID(mh, BDBFHE_CATEGORY, STU_ATTENDANCE, 1);
    BasicDBGetFieldData(mh, fieldID, attString, ATT_STRING_SIZE);

    /* put the user entered code into the att string */
    /* get to the selected grade period */
    place = 0;
    if (pself->TADI_curGradePd) {
      for (i = 0; i < pself->TADI_curGradePd; i++)  {
        while (attString[place] != '*') place++;
        place++;
        }
      }
    place += column;
    if (!attCode[0])  attCode[0] = ' ';
    attString[place] = attCode[0];

    /* set the new att string */
    error = BasicDBSetFieldData(mh, fieldID, attString, strlen(attString));
    /* and store the record */
    error = BasicDBSaveRecord(pself->GDI_fileHandle,
                       pself->TADI_stuDBHan,
                       mh,
                       StudentsCallback,
                       &recordID);

    /* force the totals to update */
    vmbh = VMFind(pself->GDI_fileHandle, NullHandle, ATT_CODE);
    VMLock(pself->GDI_fileHandle, vmbh ,&mh);
    numCodes = ChunkArrayGetCountHandles(mh, pself->TADI_attCodeChunkArray);
    VMUnlock(mh);
    @call gridObject::MSG_VIS_GRID_INVALIDATE_CELL_RANGE(
                       pself->TADI_curNumAttDays,
                       row,
                       pself->TADI_curNumAttDays + (numCodes * 2),
                       row);


}

/***********************************************************************
 *
 * MESSAGE: MSG_DRAW_GRADE_TITLE for TADocumentClass
 *                (VIS_GRID_DRAW_CELL)
 *                           GStateHandle gstate,
 *                      word column,
 *                           word row,
 *                           word width,
 *                           word height,
 *                           optr grid,
 *                           GridDrawFlags flags) ;
 * DESCRIPTION:
 *
 *
 ***********************************************************************/
@extern method TADocumentClass, MSG_DRAW_GRADE_TITLE
{
 VMBlockHandle      vmbh;
 MemHandle      	mh;
 GradeElementStruct*    element;
 GradeTypeStruct*   type;
 char           	dStr[DATE_SIZE], tStr[NAME_SIZE], sStr[GRADE_DESCRIPT];
 word           	numElements, sem1Col, sem2Col;
 word			smstr = 0;
 word			tWidth, eWidth, numChars, start;


    /* return out of range draw request...*/
    if (pself->TADI_showSemesters) smstr = 2;
    if (pself->TADI_curGradePd < MAX_GRADE_PDS) {
      /* regular grade period */
      if ((row > 0) ||
	    (column >= (pself->TADI_numElements[pself->TADI_curGradePd] + pself->TADI_numTypes + 1))) {
	   return;
        }
      }
    /* summary grade period */
    else if ((row > 0) ||
	    (column >= ((pself->TADI_numGradePds) + 1 + smstr))) {
	 return;
      }

    /* set the text */
    /* Draw in the correct color based on flags */
    if (flags & GRID_DRAW_FLAG_SELECTED)
       GrSetTextColor(gstate, CF_INDEX, C_WHITE, 0, 0) ;
    else  GrSetTextColor(gstate, CF_INDEX, C_BLACK, 0, 0) ;
    GrSetFont(gstate, FID_DTC_URW_SANS, MakeWWFixed(10));

    /* see how many elements in the list */
    if ((pself->TADI_curGradePd) < MAX_GRADE_PDS) {
	 numElements = pself->TADI_numElements[pself->TADI_curGradePd];
	 }
    else numElements = 0; /* summary pd */

    /* get the grade title info */
    if (column < numElements) {  /* the element info */
	 GrSetTextStyle(gstate, 0, TS_BOLD); /* set to plain */
	 vmbh = VMFind(pself->GDI_fileHandle,
			NullHandle,
			GRADE_ELEM_1 + pself->TADI_curGradePd);
	 VMLock(pself->GDI_fileHandle, vmbh, &mh);
	 /* get the info */
	 element = ChunkArrayElementToPtrHandles(
		 mh,
		 pself->TADI_gradeElemChunkArray[pself->TADI_curGradePd],
		 column,
		 0);
	 strcpy(tStr, element->GES_type);
	 strcpy(sStr, element->GES_description);
	 strcpy(dStr, element->GES_date);
	  VMUnlock(mh);
	 }

    else {  /* the type calculation info or summary */
	 GrSetTextStyle(gstate, TS_BOLD, 0); /* set to bold */
	 sStr[0] = 0;
	 vmbh = VMFind(pself->GDI_fileHandle,
			NullHandle,
			GRADE_TYPES);
	 VMLock(pself->GDI_fileHandle, vmbh, &mh);
	 if ((pself->TADI_curGradePd) < MAX_GRADE_PDS)  {
	   if (column < (numElements + pself->TADI_numTypes)) {
		 /* get the info */
		 type = ChunkArrayElementToPtrHandles(
			 mh,
			 pself->TADI_gradeTypesChunkArray,
			 column - numElements,
			 0);
		 strcpy(tStr, type->GTS_type);
		 UtilHex32ToAscii(dStr,
				(dword) (type->GTS_weight[pself->TADI_curGradePd]),
				UHTAF_NULL_TERMINATE);
		 strcat(dStr, "%");
		 }
	   else {
		 MemLock(OptrToHandle(@FinalStr));
		 strcpy(tStr, LMemDeref(@FinalStr));
		 MemUnlock(OptrToHandle(@FinalStr));
		 dStr[0] = 0;
		 }
	   }
	 else { /* summary titles */
	   if (column < (pself->TADI_numGradePds + smstr)) {
		 if (!smstr) { /* no semesters to show */
			 MemLock(OptrToHandle(@GradePStr));
			 strcpy(tStr, LMemDeref(@GradePStr));
		    UtilHex32ToAscii(dStr,
				    (dword) (column + 1),
				    UHTAF_NULL_TERMINATE);
			 MemUnlock(OptrToHandle(@GradePStr));
			 }
		 else { /* show the semesters */
		    if(pself->TADI_numGradePds == 6) {
			  sem1Col = 3;
			  sem2Col = 7;
			  }
		    else {
			  sem1Col = 2;
			  sem2Col = 5;
			  }

			 MemLock(OptrToHandle(@SemesterStr));
			 if ((column == sem1Col) || (column == sem2Col)) {
			  strcpy(tStr, LMemDeref(@SemesterStr));
			  if (column == sem1Col) strcpy(dStr, "1");
			  else strcpy(dStr, "2");
			  }
		    else {
			  strcpy(tStr, LMemDeref(@GradePStr));
			  if (column < sem1Col) {
				UtilHex32ToAscii(dStr,
				    (dword) (column + 1),
				    UHTAF_NULL_TERMINATE);
				}
			  else if (column < sem2Col) {
				UtilHex32ToAscii(dStr,
				    (dword) (column),
				    UHTAF_NULL_TERMINATE);
				}
			  }
			 MemUnlock(OptrToHandle(@SemesterStr));

		    }  /* end of show semesters else */
		 } /* end of gp/smstr if */
        else {
			  MemLock(OptrToHandle(@FinalStr));
			  strcpy(tStr, LMemDeref(@FinalStr));
			  MemUnlock(OptrToHandle(@FinalStr));
			  dStr[0] = 0;
           }
	   } /* end of summary titles */
      VMUnlock(mh);
      }

    eWidth = 8;
    /* fill in the type */
    if (tStr[0]) {
	  tWidth = GrTextWidth(gstate, tStr, strlen(tStr));
	  if(tWidth > (GRADE_WIDTH - 3))  {
		/* truncate text and add ellipsis */
		while (tWidth > (GRADE_WIDTH - 3 - eWidth)) {
		   numChars = strlen(tStr);
		   tStr[numChars - 1] = 0;
		   tWidth = GrTextWidth(gstate, tStr, strlen(tStr));
		   }
		strcat(tStr, "...");
		start = 2;
		}
	  else { /* center it */
		start = (GRADE_WIDTH - tWidth)/2;
		}
	  GrDrawText(gstate, start, 2, tStr, 0) ;
	  }
    if (sStr[0]) {
	  tWidth = GrTextWidth(gstate, sStr, strlen(sStr));
	  if(tWidth > (GRADE_WIDTH - 3))  {
		/* truncate text and add ellipsis */
		while (tWidth > (GRADE_WIDTH - 3 - eWidth)) {
		   numChars = strlen(sStr);
		   sStr[numChars - 1] = 0;
		   tWidth = GrTextWidth(gstate, sStr, strlen(sStr));
		   }
		strcat(sStr, "...");
		start = 2;
		}
	  else { /* center it */
		start = (GRADE_WIDTH - tWidth)/2;
		}
	  GrDrawText(gstate, start, 12, sStr, 0) ;
	  }
    if (dStr[0]) {
	  tWidth = GrTextWidth(gstate, dStr, strlen(dStr));
	  if(tWidth > (GRADE_WIDTH - 3))  {
		/* truncate text and add ellipsis */
		while (tWidth > (GRADE_WIDTH - 3 - eWidth)) {
		   numChars = strlen(dStr);
		   dStr[numChars - 1] = 0;
		   tWidth = GrTextWidth(gstate, dStr, strlen(dStr));
		   }
		strcat(dStr, "...");
		start = 2;
		}
	  else { /* center it */
		start = (GRADE_WIDTH - tWidth)/2;
		}
	  GrDrawText(gstate, start, 26, dStr, 0) ;
	  }
    GrSetTextStyle(gstate, 0, TS_BOLD); /* set to plain */

}

/***********************************************************************
 *
 * MESSAGE: MSG_DRAW_MAIN_GRADE for TADocumentClass
 *                (VIS_GRID_DRAW_CELL)
 *                           GStateHandle gstate,
 *                      word column,
 *                           word row,
 *                           word width,
 *                           word height,
 *                           optr grid,
 *                           GridDrawFlags flags) ;
 * DESCRIPTION:
 *
 *
 ***********************************************************************/
@extern method TADocumentClass, MSG_DRAW_MAIN_GRADE
{
 MemHandle      mh;
 char           string[15], tempStr[5];
 word           numElements, count, i, place, sem1Col, sem2Col, gpToGet;
 BasicDBFieldID fieldID;
 BasicDBError       error;
 byte           grades[MAX_ELEMENTS];
 dword          grade;
 WWFixedAsDWord gradeSum[MAX_GRADE_TYPES];
 WWFixedAsDWord total, avg;
 word			smstr = 0;
 word		tWidth, pos;
 Boolean		letters = FALSE;


    /* return out of range draw request...*/
    if (pself->TADI_showSemesters) smstr = 2;
    if (pself->TADI_curGradePd < MAX_GRADE_PDS) {
	  /* regular grade period */
	  if ((row >= (pself->TADI_numStudents)) ||
		(column >= (pself->TADI_numElements[pself->TADI_curGradePd] + pself->TADI_numTypes + 1))) {
		return;
		}
	  }
    /* summary grade period */
    else if ((row >= (pself->TADI_numStudents)) ||
	    (column >= ((pself->TADI_numGradePds) + 1 + smstr))) {
	  return;
       }

    if (g_showLetters) {
	  letters = TRUE;
	  if (!g_letterFileHan)  letters = FALSE;
	  }


    /* see how many items in the list */
    if ((pself->TADI_curGradePd) < MAX_GRADE_PDS) {
	 numElements = pself->TADI_numElements[pself->TADI_curGradePd];
	 }
    else numElements = 0; /* summary pd */

    /* for the grade period display */
    if ((pself->TADI_curGradePd) < MAX_GRADE_PDS) {
	  /* get the grade element data */
	  if (column < numElements) {
		/* first get the student record */
		error = BasicDBGetRecordByIndex(pself->GDI_fileHandle,
                       pself->TADI_stuDBHan,
				   pself->TADI_curStuIndex,
				   row,
				   &mh);
		/* get the grade field */
		fieldID = BasicDBGetFieldID(mh,
				BDBFHE_CATEGORY,
				STU_GRADES_1  + pself->TADI_curGradePd,
				1);
		BasicDBGetFieldData(mh, fieldID, grades, MAX_ELEMENTS);
		BasicDBDiscardRecord(mh);
		/* convert the column'th grade into a string */
		if (grades[column] == NO_GRADE) strcpy(string, " ");
		else {
		   grade = grades[column];
		   UtilHex32ToAscii(string, grade, UHTAF_NULL_TERMINATE);
		   }
		if (letters && (grades[column] != NO_GRADE)) {
		   strcat(string, " ");
		   GetLetterGrade(MakeWWFixed(grades[column]), tempStr);
		   strcat(string, tempStr);
		   }
		} /* end of entered grades if */

	  else { /* get the grade type average or final */
		/* first get the student record */
		error = BasicDBGetRecordByIndex(pself->GDI_fileHandle,
				   pself->TADI_stuDBHan,
				   pself->TADI_curStuIndex,
				   row,
				   &mh);
		/* get the grade summary field */
		fieldID = BasicDBGetFieldID(mh,
				BDBFHE_CATEGORY,
				STU_GRADE_SUM_1  + pself->TADI_curGradePd,
				1);
		BasicDBGetFieldData(mh, fieldID, gradeSum, (MAX_GRADE_TYPES * sizeof(dword)));
		BasicDBDiscardRecord(mh);
		GrSetFont(gstate, FID_DTC_URW_SANS, MakeWWFixed(g_sysPointSize));

		/* convert the selected grade into a string */
		if (gradeSum[column - numElements] == NO_SUMMARY) strcpy(string, " ");
		else {
		   LocalFixedToAscii(string, gradeSum[column - numElements], 3);
		   place = 0; /* LFTA doesn't work for 2 places... */
		   while ((string[place] != '.') && (place < strlen(string))) place++;
		   if ((strlen(string) - place) > 3) string[place + 3] = 0;
		   }
		if (letters && (gradeSum[column - numElements] != NO_SUMMARY)) {
		   strcat(string, " ");
		   GetLetterGrade(gradeSum[column - numElements], tempStr);
		   strcat(string, tempStr);
		   }
		} /* end of type average else */
	  } /* end of grade period display */

    else { /* summary display */
	  GrSetFont(gstate, FID_DTC_URW_SANS, MakeWWFixed(g_sysPointSize));
	  /* get the student record */
	  error = BasicDBGetRecordByIndex(pself->GDI_fileHandle,
				   pself->TADI_stuDBHan,
				   pself->TADI_curStuIndex,
				   row,
				   &mh);
	  /* is it a grade period final or semester ? */
	  if (column < (pself->TADI_numGradePds + smstr)) {
		if (smstr) {
		   if(pself->TADI_numGradePds == 6) {
			 sem1Col = 3;
			 sem2Col = 7;
			 }
		   else {
			 sem1Col = 2;
			 sem2Col = 5;
			 }
		   if (column < sem1Col) gpToGet = column;
		   else if (column < sem2Col) gpToGet = column - 1;
		   }
		else gpToGet = column;
		if (!smstr || ((column != sem1Col) && (column != sem2Col))) {
		   /* this is a grade period column */
		   /* get the grade summary field */
		   fieldID = BasicDBGetFieldID(mh,
				BDBFHE_CATEGORY,
				STU_GRADE_SUM_1 + gpToGet,
				1);
		   BasicDBGetFieldData(mh, fieldID, gradeSum, (MAX_GRADE_TYPES * sizeof(dword)));
		   /* get the corresponding grade */
		   /*  & convert the selected grade into a string */
		   if (gradeSum[pself->TADI_numTypes] == NO_SUMMARY) strcpy(string, " ");
		   else {
			 LocalFixedToAscii(string, gradeSum[pself->TADI_numTypes], 3);
			 place = 0; /* LFTA doesn't work for 2 places... */
			 while ((string[place] != '.') && (place < strlen(string))) place++;
			 if ((strlen(string) - place) > 3) string[place + 3] = 0;
			 }
		   if (letters && (gradeSum[pself->TADI_numTypes] != NO_SUMMARY)) {
			 strcat(string, " ");
			 GetLetterGrade(gradeSum[pself->TADI_numTypes], tempStr);
			 strcat(string, tempStr);
			 }
		   } /* end of grade period column if */
		else if (smstr && ((column == sem1Col) || (column == sem2Col))) {
		    /* this is a semester column */
		    if (column == sem1Col) gpToGet = 0;
		    else gpToGet = sem1Col;
		    count = 0;
		    total = MakeWWFixed(0);
		    for (i = gpToGet; i < (gpToGet + sem1Col); i++) {
			  /* get the grade summary field */
			  fieldID = BasicDBGetFieldID(mh,
						  BDBFHE_CATEGORY,
						  STU_GRADE_SUM_1 + i,
				            1);
			  BasicDBGetFieldData(mh, fieldID, gradeSum, (MAX_GRADE_TYPES * sizeof(dword)));
			  if (gradeSum[pself->TADI_numTypes] != NO_SUMMARY) {
				total += gradeSum[pself->TADI_numTypes];
				count++;
				}
			  } /* end of loop thru grade pds for */
		   /*  convert the grade into a string */
		   if (!total) strcpy(string, " ");
		   else {
			 avg = GrUDivWWFixed(total, MakeWWFixed(count));
			 LocalFixedToAscii(string, avg, 3);
			 place = 0; /* LFTA doesn't work for 2 places... */
			 while ((string[place] != '.') && (place < strlen(string))) place++;
			 if ((strlen(string) - place) > 3) string[place + 3] = 0;
			 }
		   if (letters && total) {
			 strcat(string, " ");
			 GetLetterGrade(avg, tempStr);
			 strcat(string, tempStr);
			 }
		   } /* end of semester column if */
		} /* end of grade period or semester column if */

	  else { /* calculate the final final */
		count = 0;
		total = MakeWWFixed(0);
		for (i = 0; i < (pself->TADI_numGradePds); i++) {
		    /* get the grade summary field */
		    fieldID = BasicDBGetFieldID(mh,
						  BDBFHE_CATEGORY,
						  STU_GRADE_SUM_1 + i,
				            1);
		    BasicDBGetFieldData(mh, fieldID, gradeSum, (MAX_GRADE_TYPES * sizeof(dword)));
		    if (gradeSum[pself->TADI_numTypes] != NO_SUMMARY) {
			  total += gradeSum[pself->TADI_numTypes];
			  count++;
			  }
		    } /* end of loop thru grade pds for */
		/*  convert the grade into a string */
		if (!total) strcpy(string, " ");
		else {
		   avg = GrUDivWWFixed(total, MakeWWFixed(count));
		   LocalFixedToAscii(string, avg, 3);
		   place = 0; /* LFTA doesn't work for 2 places... */
		   while ((string[place] != '.') && (place < strlen(string))) place++;
		   if ((strlen(string) - place) > 3) string[place + 3] = 0;
		   }
		if (letters && total) {
		   strcat(string, " ");
		   GetLetterGrade(avg, tempStr);
		   strcat(string, tempStr);
		   }
		} /* end of calc final final else */
	  BasicDBDiscardRecord(mh);
	  } /* end of summary display else */

    tWidth = GrTextWidth(gstate, string, strlen(string));
    pos = (GRADE_WIDTH - tWidth - 2);
    GrDrawText(gstate, pos, 1, string, 0);



}

/***********************************************************************
 *
 * MESSAGE: MSG_SHOW_GRADE_GRID_DATA for TADocumentClass
 *                (VIS_TEXT_GRID_QUERY_DATA)
 | Inputs:
 |    word column, row            -- Cell to get data for
 |    optr gridObjet              -- VisTextGrid object in use
 |    optr textObject             -- What text object to change
 |
 | Outputs:
 |    Boolean                     -- TRUE if data exists now in text object,
 |                                   else FALSE.
 * DESCRIPTION:
 *
 *
 ***********************************************************************/
@extern method TADocumentClass, MSG_SHOW_GRADE_GRID_DATA
{
 MemHandle      mh;
 char           string[5];
 word           numElements;
 BasicDBFieldID fieldID;
 BasicDBError       error;
 byte           grades[MAX_ELEMENTS];
 dword          grade;


    if ((pself->TADI_curGradePd) < (pself->TADI_numGradePds)) {
	 numElements = pself->TADI_numElements[pself->TADI_curGradePd];

      /* get the data if it is in range */
	 if (column < numElements) {
        /* first get the student record */
        error = BasicDBGetRecordByIndex(pself->GDI_fileHandle,
                       pself->TADI_stuDBHan,
                       pself->TADI_curStuIndex,
                       row,
                       &mh);
        /* now the grade field */
        fieldID = BasicDBGetFieldID(mh,
                    BDBFHE_CATEGORY,
                    STU_GRADES_1  + pself->TADI_curGradePd,
                    1);
        BasicDBGetFieldData(mh, fieldID, grades, MAX_ELEMENTS);
        BasicDBDiscardRecord(mh);

        /* convert the column'th grade into a string */
        if (grades[column] == NO_GRADE) strcpy(string, " ");
        else {
           grade = grades[column];
           UtilHex32ToAscii(string, grade, UHTAF_NULL_TERMINATE);
           }

        /* and show it */
        @call textObject::MSG_VIS_TEXT_REPLACE_ALL_PTR(string, 0);

        /* make it editable */
        @call gridObject::MSG_VIS_TEXT_GRID_SHOW_TEXT_AT(column, row) ;
        } /* end of grade element if */

	 else  @call gridObject::MSG_VIS_TEXT_GRID_HIDE_TEXT() ;
	 } /* end of regular grade period if */

    else  @call gridObject::MSG_VIS_TEXT_GRID_HIDE_TEXT() ;

}

/***********************************************************************
 *
 * MESSAGE: MSG_SAVE_GRADE_GRID_DATA for TADocumentClass
 *                (VIS_TEXT_GRID_SAVE_DATA)
 | Inputs:
 |    word column, row            -- Cell to get data for
 |    optr gridObjet              -- VisTextGrid object in use
 |    optr textObject             -- What text object to change
 |
 * DESCRIPTION:
 *
 *
 ***********************************************************************/
@extern method TADocumentClass, MSG_SAVE_GRADE_GRID_DATA
{
 VMBlockHandle      vmbh;
 char           string[5], gTypeString[NAME_SIZE];
 BasicDBFieldID gradeFieldID, sumFieldID;
 MemHandle      dbmh, mh;
 BasicDBError       error;
 byte           grades[MAX_ELEMENTS];
 dword          grade;
 WWFixedAsDWord avg;
 dword          gradeSum[MAX_GRADE_TYPES];
 BasicDBRecordID    recordID;
 word           length, numElements, typeNum;
 word           i;
 GradeTypeStruct*   type;
 GradeElementStruct*    element;


    /* get the grade */
    length = @call textObject::MSG_VIS_TEXT_GET_ALL_PTR(string);

    /* get the student record */
    error = BasicDBGetRecordByIndex(pself->GDI_fileHandle,
                       pself->TADI_stuDBHan,
                       pself->TADI_curStuIndex,
                       row,
                       &dbmh);
    /* now the grade field */
    gradeFieldID = BasicDBGetFieldID(dbmh,
                    BDBFHE_CATEGORY,
                    STU_GRADES_1  + pself->TADI_curGradePd,
                    1);
    BasicDBGetFieldData(dbmh, gradeFieldID, grades, MAX_ELEMENTS);
    /* and the grade summary field */
    sumFieldID = BasicDBGetFieldID(dbmh,
                    BDBFHE_CATEGORY,
                    STU_GRADE_SUM_1  + pself->TADI_curGradePd,
                    1);
    BasicDBGetFieldData(dbmh, sumFieldID, gradeSum, (MAX_GRADE_TYPES * sizeof(dword)));

    /* convert the string */
    if (length) {
      if (string[0] == ' ') grade = NO_GRADE;
      else UtilAsciiToHex32(string, &grade);
      }
    else grade = NO_GRADE;

    /* and put it into the array */
    grades[column] = (byte) grade;

    /* set the new field data */
    error = BasicDBSetFieldData(dbmh, gradeFieldID, grades, MAX_ELEMENTS);

    /* update the effected type's average */
    /* first see what grade type the column is */
    vmbh = VMFind(pself->GDI_fileHandle,
			NullHandle,
			GRADE_ELEM_1 + pself->TADI_curGradePd);
    VMLock(pself->GDI_fileHandle, vmbh, &mh);
    numElements = pself->TADI_numElements[pself->TADI_curGradePd];
    element = ChunkArrayElementToPtrHandles(
                    mh,
                    pself->TADI_gradeElemChunkArray[pself->TADI_curGradePd],
                    column,
                    0);
    strcpy(gTypeString, element->GES_type);
    VMUnlock(mh);

    /* recalc the given type's avg */
    avg = CalcTypeAvg (numElements,
			   pself->GDI_fileHandle,
			   pself->TADI_curGradePd,
			   gTypeString,
			   pself->TADI_gradeElemChunkArray[pself->TADI_curGradePd],
			   grades);

    /* now store that avg in the proper array element */
    vmbh = VMFind(pself->GDI_fileHandle,
			NullHandle,
			GRADE_TYPES);
    VMLock(pself->GDI_fileHandle, vmbh, &mh);
    for (i = 0; i < pself->TADI_numTypes; i++)  {
	 type = ChunkArrayElementToPtrHandles(
			 mh,
			 pself->TADI_gradeTypesChunkArray,
			 i,
			 0);
	 if (!strcmp(gTypeString, type->GTS_type)) {
	   /* found it */
	   typeNum = i;
	   i = pself->TADI_numTypes;
	   }
	 }
    VMUnlock(mh);

    /* and put it into the array */
    gradeSum[typeNum] = avg;

    /* now recalculate the final for that grade period */
    avg = CalcGPFinal (pself->TADI_numTypes,
			   pself->GDI_fileHandle,
			   pself->TADI_curGradePd,
			   pself->TADI_gradeTypesChunkArray,
			   gradeSum);


    /* and put the final into the array */
    if (avg) gradeSum[pself->TADI_numTypes] = avg;
    else gradeSum[pself->TADI_numTypes] = NO_SUMMARY;


    /* set the new summary data */
    error = BasicDBSetFieldData(dbmh, sumFieldID, gradeSum, (MAX_GRADE_TYPES * sizeof(dword)));
    /* and store the record */
    error = BasicDBSaveRecord(pself->GDI_fileHandle,
				   pself->TADI_stuDBHan,
                       dbmh,
                       StudentsCallback,
                       &recordID);



    /* force the avg grade cell & final cell to redraw */
    @call gridObject::MSG_VIS_GRID_INVALIDATE_CELL_RANGE(
                       numElements + typeNum,
                       row,
                       numElements + typeNum,
                       row);
    @call gridObject::MSG_VIS_GRID_INVALIDATE_CELL_RANGE(
				   numElements + pself->TADI_numTypes,
                       row,
				   numElements + pself->TADI_numTypes,
                       row);


}

/***********************************************************************
 *
 * MESSAGE: MSG_META_START_SELECT for VisCornerModuleCompClass
 *          MouseReturnParams   *retVal
 *             sword            xPosition
 *             sword            yPosition
 *             word             inputState
 *
 * DESCRIPTION: Looks for doubleclick on corner view and opens
 *                  grading period selector
 *               except in seating module
 ***********************************************************************/
@extern method VisCornerModuleCompClass, MSG_META_START_SELECT
{
EventHandle     event;

    if (@call SeatingModuleItem::MSG_GEN_GET_ENABLED()) {
	  if (inputState & BI_DOUBLE_PRESS)  {
		/* Open the grading period selector */
		event = @record TADocumentClass::MSG_OPEN_GRADE_PERIODS();
		@call TAApp::MSG_META_SEND_CLASSED_EVENT(event, TO_MODEL);
		}
	  }

    @callsuper();

}

/***********************************************************************
 *
 * MESSAGE: MSG_META_START_SELECT for NameVisGridClass
 *          MouseReturnParams   *retVal
 *             sword            xPosition
 *             sword            yPosition
 *             word             inputState
 *
 * DESCRIPTION: Looks for doubleclick on a name and opens stu dbox
 *
 *
 ***********************************************************************/
@extern method NameVisGridClass, MSG_META_START_SELECT
{
EventHandle     event;
dword           curStudent;


    if (inputState & BI_DOUBLE_PRESS)  {
      curStudent = @call self::MSG_VIS_GRID_FIND_ROW(yPosition);
      /* set the cur stu */
      event = @record TADocumentClass::MSG_TADOC_SET_CUR_STUDENT(curStudent);
      @call TAApp::MSG_META_SEND_CLASSED_EVENT(event, TO_MODEL);

      /* Open the dialog box with cur stu info */
      event = @record TADocumentClass::MSG_OPEN_STUDENT(@ManageStudentsMenuItem);
      @call TAApp::MSG_META_SEND_CLASSED_EVENT(event, TO_MODEL);
      }

    @callsuper();

}

/***********************************************************************
 *
 * MESSAGE: MSG_VIS_GRID_SELECT_CELL for NameVisGridClass
 *             word            column
 *             word            row
 *
 * DESCRIPTION: passes selected name to seating
 *
 *
 ***********************************************************************/
@extern method NameVisGridClass, MSG_VIS_GRID_SELECT_CELL
{
 optr       doc;

    /* get the doc optr */
    doc = @call ConstructOptr(OptrToHandle(oself), OptrToChunk(@TADisplay))
			 ::MSG_GEN_DISPLAY_GET_DOCUMENT();
    /* and tell the seating */
    @send doc::MSG_TADOC_SEATING_SET_CURRENT(row) ;

    @callsuper() ;
}

/***********************************************************************
 *
 * MESSAGE: MSG_META_START_SELECT for GTitleVisGridClass
 *          MouseReturnParams   *retVal
 *             sword            xPosition
 *             sword            yPosition
 *             word             inputState
 *
 * DESCRIPTION: Looks for doubleclick on a grade title and opens dbox
 *                  if over an element - nothing over type title
 *
 ***********************************************************************/
@extern method GTitleVisGridClass, MSG_META_START_SELECT
{
EventHandle     event;
word                column, numElements;
optr                doc;
FileHandle      docFileHan;
word                curGradePd;
ChunkHandle     gradeElemChunkArray;
VMBlockHandle       vmbh;
MemHandle           mh;


    if (inputState & BI_DOUBLE_PRESS)  {
      column = @call self::MSG_VIS_GRID_FIND_COLUMN(xPosition);
      /* find out if this is an element title */

      /* get the instance data */
      doc = @call ConstructOptr(OptrToHandle(oself), OptrToChunk(@TADisplay))
                ::MSG_GEN_DISPLAY_GET_DOCUMENT();
      docFileHan = @call doc::MSG_TADOC_GET_FILE_HANDLE();
      curGradePd = @call doc::MSG_TADOC_GET_CUR_GRADE_PD();
      gradeElemChunkArray = @call doc::MSG_TADOC_GET_GRADE_ELEMENT_ARRAY(
                                            curGradePd);

      /* see how many elements in the list */
      vmbh = VMFind(docFileHan,
                 NullHandle,
                 GRADE_ELEM_1 + curGradePd);
      VMLock(docFileHan, vmbh ,&mh);
      numElements = ChunkArrayGetCountHandles(mh, gradeElemChunkArray);
      VMUnlock(mh);

      if (column < numElements) {
        /* Open the dialog box with cur stu info */
	   event = @record TADocumentClass::MSG_OPEN_GRADE_ELEMENT(column);
	   @call TAApp::MSG_META_SEND_CLASSED_EVENT(event, TO_MODEL);
	   }
      }

    @callsuper();

}

/***********************************************************************
 *
 * MESSAGE: MSG_META_START_SELECT for MainAttVisTextGridClass
 *          MouseReturnParams   *retVal
 *             sword            xPosition
 *             sword            yPosition
 *             word             inputState
 *
 * DESCRIPTION: Looks for doubleclick on an att cell and opens dbox
 *                  if over an element - nothing over summary
 *
 ***********************************************************************/
@extern method MainAttVisTextGridClass, MSG_META_START_SELECT
{
/*EventHandle     	event;
word                column, numDays;
optr                doc;


    if (inputState & BI_DOUBLE_PRESS)  {
	 g_noTyping = TRUE;
	 column = @call self::MSG_VIS_GRID_FIND_COLUMN(xPosition);
      /* find out if this is an attendance element */

      /* get the instance data */
/*	 doc = @call ConstructOptr(OptrToHandle(oself), OptrToChunk(@TADisplay))
                ::MSG_GEN_DISPLAY_GET_DOCUMENT();
	 numDays = @call doc::MSG_TADOC_GET_CUR_NUM_ATT_DAYS();

	 if (column < numDays) {
	   /* Open the dialog box */
/*	   event = @record TADocumentClass::MSG_OPEN_ATT_CODE_DBL_CLICK();
	   @call TAApp::MSG_META_SEND_CLASSED_EVENT(event, TO_MODEL);
	   }
	 }
    else g_noTyping = FALSE;
*/
    @callsuper();


}

/***********************************************************************
 *
 * MESSAGE: MSG_VIS_GRID_SELECT_CELL for MainVisTextGridClass
 *             word            column
 *             word            row
 *
 * DESCRIPTION: Selects name & title for selected main cell
 *
 *
 ***********************************************************************/
@extern method MainVisTextGridClass, MSG_VIS_GRID_SELECT_CELL
{
 optr       doc;


    /* get the doc optr */
    doc = @call ConstructOptr(OptrToHandle(oself), OptrToChunk(@TADisplay))
			 ::MSG_GEN_DISPLAY_GET_DOCUMENT();

    if (row != VIS_GRID_SELECTION_NONE)
	  /* set the cur stu */
	  @send doc::MSG_TADOC_SET_CUR_STUDENT(row);

    if ((row != VIS_GRID_SELECTION_NONE) && (column != VIS_GRID_SELECTION_NONE))
	  /* select the name on that row */
	  @send doc::MSG_TADOC_SELECT_TITLES(row, column);

    @callsuper();


}

/***********************************************************************
 *
 * MESSAGE: MSG_TADOC_SELECT_TITLES for TADocumentClass
 *          word            row
 *             word         column
 *
 * DESCRIPTION: Selects title for selected main cell
 *
 *
 ***********************************************************************/
@extern method TADocumentClass, MSG_TADOC_SELECT_TITLES
{

    /* select the name on that row */
    @call ConstructOptr(pself->GDI_display, OptrToChunk(@MCANamesGrid))::
                              MSG_VIS_GRID_SELECT_CELL(0, row);

    /* see whether we're in grades or attendance */
    if (@call AttendModuleItem::MSG_GEN_GET_ENABLED())
      @call ConstructOptr(pself->GDI_display, OptrToChunk(@MCGradeTitlesGrid))::
                              MSG_VIS_GRID_SELECT_CELL(column, 0);
    else
      @call ConstructOptr(pself->GDI_display, OptrToChunk(@MCAttTitlesGrid))::
                              MSG_VIS_GRID_SELECT_CELL(column, 0);


}

@extern method TADocumentClass, MSG_TADOC_QUERY_STUDENT_LABEL
/* optr seating, StudentLabel labelID */
{
    StudentSeatingLabelDeclare(pself->GDI_fileHandle,
                pself->TADI_stuDBHan,
                pself->TADI_curStuIndex,
                OptrToHandle(seatingObj),
                labelID,
                FALSE) ;
}

@extern method TADocumentClass, MSG_TADOC_GET_NEXT_STUDENT_LABEL
/* optr seating, StudentLabel labelID */
{
    /* By moving the selected down to the next one, it will caues */
    /* VIS_GRID_SELECT_CELL to be call and thus a call to */
    /* set the next student label. */
    @call ConstructOptr(
              OptrToHandle(seatingObj),
              OptrToChunk(@MCANamesGrid))::
                  MSG_VIS_GRID_SELECT_CELL_MOVE_DOWN() ;

}

