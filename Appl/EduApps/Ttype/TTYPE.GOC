/***************************************************************************
 *  FILE:  TTYPE.GOC
 ***************************************************************************/

/************************************************************************
    Copyright (c) Peter Vanspauwen 1998

    Project :   Educational Applications
    Module :    Typing Tutor
    File :      ttype.goc

    Author :    Peter Vanspauwen, June 7, 1998

    Routines :
            Name            Description
            ----            -----------

    Revision history :
            Name    Date        Description
            ----    ----        -----------
            PV      06/07/98    Start
            PV      08/10/98    Student's info can be entered
            PV      08/19/98    Calculation of speed optimized
                                Added Introduction Screen
            PV      08/25/98    Layout improvements
            PV      11/09/98    Changed UI of Welcome Screen
                                Added Exercises and three practise levels
                                Added menu items (not operational yet)
            PV      01/03/99    Added G_isNewExercise exercises
                                Solved some navigation problems
                                Solved redraw problems in keyboard
                                Moved Introduction to Book Reader file
            PV      ../../99    Added help functionality (no help file yet)
                                Solved some more navigation problems
                                Added pages to Introduction file
            LES 04/23/99        Exercise Editor Stuff added
		  LES 05/03/99        Taken over by Lysle Shields

		  jfh 10/21/99		  fixed the lagging key to press bug
						  see G_currentKey  files: ttkeyhan & ttkeyobj
                                and the chopped descenders bug: ttui
		  jfh 10/23/99		  set step one top four to SINGLE_LINE to prevent
		                        the window from getting taller
						  turned off cursor in step 1 dummy text
						    (only works on 3.x versions of Geos)
						  added a capslock warning in step1
		  jfh 10/26/99		  Release v1.0
		  jfh 10/27/99        fixed lesson 8 step 2 letter to type 
		  jfh 11/01/99		  fixed shifted char on kbd problem
		  jfh 11/08/99		  Release v1.0 0-9
		  jfh 06/25/02		  Added user names to title bar
								  Made it more localize friendly

************************************************************************/

/***************************************************************************
 *      Include files
 ***************************************************************************/

@include <stdapp.goh>

#include <gstring.h>
#include <geode.h>
#include <Ansi\string.h>
#include <graphics.h>
#include <Ansi\stdio.h>
#include <initfile.h>
#include <localize.h>
#include <timer.h>
@include "ttdefs.goh"
@include <externs.goh>
@include "ttclass.goh"
@include "options.goh"

void DetectSystemType(void) ;

/***************************************************************************
 *      Global variables:
 ***************************************************************************/

/* Position being typed at in phase 1 */
word G_inputPosition ;

/* Position being typed at in phase 2 */
word G_inputPosition2 ;

/* Position where a set of letters can be found. */
/* 4 letters at a time for phase 1 */
/* 50 letters at a time for phase 2 */
word G_letterDataPosition ;

/* TRUE when the user is allowed to type, else FALSE */
Boolean G_canType ;

/* TRUE when time timer is activated after the first key press */
Boolean G_canIncTime ;

/* Currently calcualted words per minute */
word G_wordsPerMinute ;

/* Percent accuracy (in 1's) */
word G_accuracy ;

/* Number of mistaken keystrokes */
word G_numMistakes ;

/* Current step / phase of the current lesson */
word G_step ;

/* Current lesson being done */
word G_lessonNum ;

/* Character name if not just a the character (line Space for " ") */
char G_charType[10] ;

/* What the user typed */
char G_typedCharacter ;

/* Current list of characters to type for phase 1 and 2 */
char G_goalLine[70] ;

/* What key is the user typing now?
 jfh  This is actually to show the NEXT key to press */
char G_currentKey ;

/* Timer used to display amount of time gone by */
TimerHandle G_displayTimer = NullHandle ;
word G_displayTimerID ;

/* Total number of seconds that have occured */
word G_totalSeconds ;

/* Current time in minutes and seconds */
word G_timeMinutes ;
word G_timeSeconds ;

/* Database file to use */
VMFileHandle G_studentDBFile = 0 ;

/* Current student selected from database */
word G_currentStudent = GIGS_NONE ;
word G_currentViewStudent = 0 ;

/* Current map item for database */
DBGroupAndItem G_dbMap ;

/* Number of items in the map block */
word G_dbMapSize ;

/* Exercises database */

/* Current database entry copied to memory */
char G_titleString[MAX_TITLE_LEN] ;
char G_exerciseString[MAX_EXERCISE_LEN] ;

/* How many exercises are in the database? */
word G_numExercises ;
word G_hiddenExercises;

/* What is the current exercise? */
word G_currentExercise = 0 ;

/* Note if the exercise is new (when editing) */
Boolean G_isNewExercise = FALSE ;

/* Current database opened for exercises */
VMFileHandle G_exerciseDBFile = NullHandle;  /* handle to the vm file. */

/* Which lesson and exercise selected */
word G_lessonSelected ;
word G_exerciseSelected ;

char G_keyboardLayout[8][20] ;
char G_fingerLayout[8][20] ;

/* Remember if the shift key is pressed */
TTShiftState G_shiftState = 0 ;

/* Keep track if this is a visitor and if that person has been warned
   that their data will not be saved */
Boolean G_isVisitor = FALSE ;

/* What viewing mode to use */
T_progressViewMode G_progressViewMode = PROGRESS_VIEW_MODE_WPM ;

/* Total amount of time to spend on an exercise */
word G_timeLimit = TIME_LIMIT ;

/* Detect the type of device we are on and record info here */
Boolean G_geoBookHasPCMCIA = FALSE ;
Boolean G_isGeoBook = FALSE ;

/***************************************************************************
 *      Data tables:
 ***************************************************************************/

/* Left position for the four boxes used in phase 1 */
word G_leftPositions[4] = {2, 34, 40, 51} ;

/*=========================================================================*
 *  INTERNAL ROUTINE PROTOTYPES:
 *=========================================================================*/
void Step3UnderlineChar(word index) ;

/*=========================================================================*
 *  METHODS FOR CLASS:  TypeProcessClass
 *=========================================================================*/

@classdecl TypeProcessClass, neverSaved ;
@extern method TypeProcessClass, MSG_EXERCISELIST_MONIKER_QUERY ;
@extern method TypeProcessClass, MSG_EXERCISELIST_APPLY ;
@extern method TypeProcessClass, MSG_TTEX_NEW_EXERCISE ;
@extern method TypeProcessClass, MSG_TTEX_SAVE_EXERCISE ;
@extern method TypeProcessClass, MSG_TTEX_DELETE_EXERCISE ;
@extern method TypeProcessClass, MSG_TTYPE_ERASE_PASSWORD ;
@extern method TypeProcessClass, MSG_TTYPE_DELETE_STUDENT ;
@extern method TypeProcessClass, MSG_TTYPE_EDIT_STUDENT_PREFERENCES ;


void IConvert(void)
{
    MemHandle mh ;
    T_exerciseDatabaseMap *mapPtr ;
    word i ;
    MemHandle memOld ;
    MemHandle memNew ;
    T_exerciseRecordOld *p_old ;
    T_exerciseRecord *p_new ;
    VMBlockHandle newRecord ;

    mapPtr = VMLock(G_exerciseDBFile, VMGetMapBlock(G_exerciseDBFile), &mh) ;

    for (i=0; i<mapPtr->MS_number; i++)  {
        p_old = VMLock(G_exerciseDBFile, mapPtr->MS_exercises[i], &memOld) ;
        newRecord = VMAlloc(G_exerciseDBFile, sizeof(T_exerciseRecord), 0) ;
        p_new = VMLock(G_exerciseDBFile, newRecord, &memNew) ;
        strncpy(p_new->ES_title, p_old->ES_title, sizeof(p_new->ES_title)-1) ;
        strncpy(p_new->ES_exercise, p_old->ES_exercise, sizeof(p_new->ES_exercise)-1) ;
        VMDirty(memNew) ;
        VMUnlock(memNew) ;
        VMUnlock(memOld) ;
        VMFree(G_exerciseDBFile, mapPtr->MS_exercises[i]) ;
        mapPtr->MS_exercises[i] = newRecord ;
    }

    /* Retrieve the first exercise */
    VMDirty(mh) ;
    VMUnlock(mh) ;
}

/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_GEN_PROCESS_OPEN_APPLICATION
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Opens up the student database and the exercise database.  If
 |    the student database does not exist, it creates one with a
 |    Visitor and a Teacher.  If the exercise database does not exist,
 |    a dummy database is created with three simple lessons.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |    jfh  06/26/02  Made layouts localizable
 |
 *-----------------------------------------------------------------------*/
@method TypeProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
 MemHandle mh ;
 VMBlockHandle vmbh ;
 int i ;
 T_exerciseDatabaseMap *mapPtr ;
 word a, numItems ;
 optr	key[8] = {@KeyLayout1, @KeyLayout2, @KeyLayout3, @KeyLayout4,
					 @KeyLayout5, @KeyLayout6, @KeyLayout7, @KeyLayout8};
 optr	finger[8] = {@FingerLayout1, @FingerLayout2, @FingerLayout3, @FingerLayout4,
						 @FingerLayout5, @FingerLayout6, @FingerLayout7, @FingerLayout8};
 Boolean		initError, editAll;


    /* First, determine the system we are on */
    DetectSystemType() ;

    /* Setup the keyboard layout for this configuration */
	 MemLock (OptrToHandle(@KeyLayout1));
	 for (a = 0; a < 8; a++)  {
		  strcpy(G_keyboardLayout[a], LMemDeref(key[a])) ;
		  strcpy(G_fingerLayout[a], LMemDeref(finger[a])) ;
        /*strcpy(G_keyboardLayout[a], BelgExtKeys[a]) ;
        strcpy(G_fingerLayout[a], BelgExtFingers[a]);*/
    }
	 MemUnlock (OptrToHandle(@KeyLayout1));

    numItems = StudentDatabaseOpen() ;

    /* Start up the list with the given number of items with Visitor as
       the default person. */
    @call NameSelectionBox::MSG_GEN_DYNAMIC_LIST_INITIALIZE(numItems) ;
    if (numItems >= MAX_STUDENTS)  {
       @call NewNameBox::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
    } else {
       @call NewNameBox::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
    }

    @call SPStudentList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(numItems) ;
    @call NameSelectionBox::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(0, FALSE) ;
	 MemLock(OptrToHandle(@VisitorString));
	 @call NewNameEntry::MSG_VIS_TEXT_REPLACE_ALL_PTR(LMemDeref(@VisitorString), 0) ;
	 MemUnlock(OptrToHandle(@VisitorString));

	/* jfh - 4/12/04  Let's check the ini to see if we're allowed to
		edit ALL the exercises */
	initError = InitFileReadBoolean("TType", "editAll", &editAll);
	if (initError || !editAll) {
		G_hiddenExercises = 9*3;
		}
	else  {
		G_hiddenExercises = 0;
		}

	 /* Now we need to open up the exercise database */
    /* If the file doesn't exist, it will be created */
    G_exerciseDBFile = VMOpen(
                           EXERCISE_DATABASE_FILENAME,
                           0,
                           VMO_CREATE_ONLY,
                           0) ;

    /* If we have a handle, we were able to create the file, so fill */
    /* in the details */
    if (G_exerciseDBFile != 0)  {
        /* Setup the map block */
        vmbh = VMAlloc(G_exerciseDBFile, sizeof(T_exerciseDatabaseMap), 0) ;
        mapPtr = VMLock(G_exerciseDBFile, vmbh, &mh) ;
        memset(mapPtr, 0, sizeof(*mapPtr)) ;
        VMDirty(mh) ;
        VMUnlock(mh) ;
        VMSetMapBlock(G_exerciseDBFile, vmbh) ;

        /* Put in the dummy exercises */
        for (i=0; i < NUM_EXERCISES; i++)  {
            /* Put default items into the array */
            vmbh = VMGetMapBlock(G_exerciseDBFile) ;
            mapPtr = VMLock(G_exerciseDBFile, vmbh, &mh) ;

				MemLock(OptrToHandle(@ExTitle1));
				switch (i)  {
                case 0:
						  strcpy(G_titleString, LMemDeref(@ExTitle1)) ;
						  strcpy(G_exerciseString, LMemDeref(@ExString1)) ;
                    break ;
                case 1:
						  strcpy(G_titleString, LMemDeref(@ExTitle2)) ;
						  strcpy(G_exerciseString, LMemDeref(@ExString2)) ;
                    break ;
                case 2:
						  strcpy(G_titleString, LMemDeref(@ExTitle3)) ;
						  strcpy(G_exerciseString, LMemDeref(@ExString3)) ;
                    break ;
            } /* end of switch */
				MemUnlock(OptrToHandle(@ExTitle1));
				StoreExercise(i) ;
        } /* end of loop */

        VMSave(G_exerciseDBFile) ;
    } else  {
        /* Could not create, so open the file and get the data */
        G_exerciseDBFile = VMOpen(
                               EXERCISE_DATABASE_FILENAME,
                               0,
                               VMO_OPEN,
                               0) ;
        /* Get our map block */
        vmbh = VMGetMapBlock(G_exerciseDBFile) ;
        mapPtr = VMLock(G_exerciseDBFile, vmbh, &mh) ;

        /* Retrieve the info */
        G_numExercises = mapPtr->MS_number ;

        /* Retrieve the first exercise */
        VMUnlock(mh) ;

//IConvert() ;
    }

    @call ExerciseList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(
				  (G_numExercises>G_hiddenExercises)?
                   G_numExercises-G_hiddenExercises:
                   0) ;
    @call SaveButton::MSG_GEN_SET_NOT_ENABLED(VUM_NOW) ;

    /* Ok, now that we have our databases open, let the UI initialize */
    @callsuper() ;

    /* Initialize the practise issues */
    G_lessonNum = 1 ;
    G_step = 1 ;
    G_lessonSelected = 0 ;

    @call WelcomeDialog::MSG_GEN_INTERACTION_INITIATE() ;
}

/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_GEN_PROCESS_CLOSE_APPLICATION
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Close out the database files and make sure any running timers
 |    have been killed.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |
 *-----------------------------------------------------------------------*/
@method TypeProcessClass, MSG_GEN_PROCESS_CLOSE_APPLICATION
{
    /* Close the database of students */
    VMUpdate(G_studentDBFile) ;
    VMClose(G_studentDBFile, FALSE) ;

    /* Close the database of exercises */
    VMSave(G_exerciseDBFile) ;
    VMClose(G_exerciseDBFile, FALSE) ;

    /* Stop the display timer (if running) */
    if (G_displayTimer)  {
        if (G_displayTimer)  {
            TimerStop(G_displayTimer, G_displayTimerID) ;
            G_displayTimer = NULL ;
        }
    }

    @callsuper() ;

    return NULL ;
}

/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_TYPE_START_NEW_LESSON
 *-------------------------------------------------------------------------
 |
 | Description:
 |    When the user clicks on a lesson, this method is called.  The
 |    current lesson changes to that new lesson.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |
 *-----------------------------------------------------------------------*/
@method TypeProcessClass, MSG_TYPE_START_NEW_LESSON
{
    /* Reset all our variables and turn off typing */
    G_lessonSelected = 0 ;
    G_canType = FALSE ;
    G_canIncTime = FALSE ;

    /* User can now hit the Next button if they want to skip */
    @call NextButton::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;

    /* Go ahead and jump to the new lesson */
    G_lessonNum = lessonNum ;

    /* If we are doing a bunch of teacher based lessons, change out */
    /* the UI (or make sure we are back on 1). */
    if (G_lessonNum == 10)  {
        @call KeyboardView::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
        @call KeyboardView::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
        @call Step1Interaction::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
        @call Step1Interaction::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
        @call Step2Interaction::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
        @call Step2Interaction::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
        @call Step3Interaction::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
        @call Step3Interaction::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
        G_exerciseSelected = 0 ;
        @call process::MSG_TYPE_LESSON10_INITIALIZER() ;
        G_exerciseSelected = (9*3) ;
        G_step = 3;
        @call process::MSG_TYPE_STEP3_INITIALIZER() ;
    } else  {
        G_step = 1 ;
        @call Step2Interaction::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
        @call Step2Interaction::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
        @call Step3Interaction::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
        @call Step3Interaction::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
        @call Step1Interaction::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
        @call Step1Interaction::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
        @call KeyboardView::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
        @call KeyboardView::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
        @call process::MSG_TYPE_STEP1_INITIALIZER() ;
    }
}

/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_TYPE_NAVIGATOR
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Many of the buttons in the UI come here to change to a different
 |    step/phase of the typing tutor.  This part fixes up the UI and
 |    goes to the correct phase.  Only really two types of actions can
 |    happen, restart the exercise or go to the next exercise.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |
 *-----------------------------------------------------------------------*/

@method TypeProcessClass, MSG_TYPE_NAVIGATOR
{
@ifdef COMPILE_OPTION_TEST_SHORTCUT_BUTTON
    if (trigger == @TestButton)  {
        @send ,forceQueue oself::MSG_TYPE_END_OF_ROUND() ;
        return ;
    }
@endif

    if (trigger == @ResultsAgainButton)
        trigger = @AgainButton ;

    if (trigger == @ResultsNextButton)
        trigger = @NextButton ;

    if (trigger == @TypeTutorButton)
        G_lessonNum = 1 ;

    if (trigger == @AgainButton)  {
        /* If we doing the exercise again, reset based on the step */
        G_shiftState = TT_SHIFT_STATE_NONE ;
        switch (G_step)  {
            case 1 :
                @call process::MSG_TYPE_STEP1_INITIALIZER() ;
                break ;
            case 2 :
                @call process::MSG_TYPE_STEP2_INITIALIZER() ;
                break ;
            case 3 :
                if (G_lessonNum == 10)  {
                    @call process::MSG_TYPE_START_NEW_LESSON(10) ;
                } else {
                    @call process::MSG_TYPE_STEP3_INITIALIZER() ;
                }
                break ;
        }
    }

    if (trigger == @NextButton)  {
        /* Reset the shift state if we are going to the next */
        G_shiftState = TT_SHIFT_STATE_NONE ;

        /* Based on the current step, correctly go to the next and */
        /* setup the UI appropriately */
        switch(G_step)  {
            case 1:
                @call Step1Interaction::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
                @call Step1Interaction::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;

                @call process::MSG_TYPE_STEP2_INITIALIZER() ;

                @call Step2Interaction::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
                @call Step2Interaction::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
                break ;

            case 2:
                @call Step2Interaction::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
                @call Step2Interaction::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
                @call KeyboardView::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
                @call KeyboardView::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;

                @call process::MSG_TYPE_STEP3_INITIALIZER() ;

                @call Step3Interaction::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
                @call Step3Interaction::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
                break ;

            case 3:
                /* For phase 3, it is handled differently */
                if (G_lessonNum == 9)  {
                    /* If we are on type 9, we just start a new lesson */
                    /* trigger = @Lesson10Button ; */
                    G_lessonNum = 10 ;
                    @call process::MSG_TYPE_START_NEW_LESSON(G_lessonNum) ;
                } else {
                    /* If we are not type 10, we just reset to step 1 */
                    if (G_lessonNum != 10)  {
                        @call Step3Interaction::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
                        @call Step3Interaction::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;

                        G_lessonNum++ ;
                        G_step = 1 ;
                        @call process::MSG_TYPE_STEP1_INITIALIZER() ;
                        @call Step1Interaction::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
                        @call Step1Interaction::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
                        @call KeyboardView::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
                        @call KeyboardView::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
                    } else {
                        /* If we are type 10, this means we need to jump */
                        /* to the next exercise (but only 3 of them) */
                        G_step = 3 ;
                        G_exerciseSelected++ ;
                        if (G_exerciseSelected >= G_numExercises-1)
                            @call NextButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
                        @call process::MSG_TYPE_LESSON10_INITIALIZER() ;
                        @call Step3Interaction::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
                        @call Step3Interaction::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
                    }
                }
        }
    }
}

/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_TYPE_LETTERS
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Starts the current phase by reseting the calculations and putting
 |    the initial group of letters up to be read.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |
 *-----------------------------------------------------------------------*/
@method TypeProcessClass, MSG_TYPE_LETTERS
{
    word b ;

    /* Reset all the timing and placement variables */
    G_totalSeconds = 0 ;
    G_timeMinutes = 0 ;
    G_timeSeconds = 0 ;
    G_inputPosition = 0 ;
    G_inputPosition2 = 0 ;
    G_numMistakes = 0 ;
    G_canIncTime = TRUE ;
    G_canType = TRUE ;
    G_letterDataPosition = 0 ;

    /* Reset the timer text and other traits */
    @call TickerText::MSG_VIS_TEXT_REPLACE_ALL_PTR("00:00", 0) ;
    @call AccuracyText::MSG_VIS_TEXT_REPLACE_ALL_PTR("100", 0) ;
    @call SpeedText::MSG_VIS_TEXT_REPLACE_ALL_PTR("0", 0) ;
    @call MissedLettersBox::MSG_VIS_TEXT_REPLACE_ALL_PTR("", 0) ;

    /* Determine which lesson we are going to do, but abort if past the
       number of lessons in the database. */
    G_lessonSelected = G_lessonNum - 1 ;
    if (G_lessonSelected != 9)
        G_exerciseSelected = (G_step - 1) + (G_lessonSelected * 3) ;
    if (G_lessonSelected * 3 >= G_numExercises)
        return ;

    /* Ok, grab that group of data */
    RetrieveExercise(G_exerciseSelected) ;
    G_currentExercise = G_exerciseSelected ;

    /* Call the appropriate routine to start up the data for typing */
    switch (G_step)  {
        case 1 :
            /* See if there are characters we can type */
            b = strlen(G_exerciseString) ;
            if (G_letterDataPosition + 5 > b)
               return ;

            /* Present these 4 letters */
            Step1TypeLetters(G_exerciseString, G_letterDataPosition) ;
            break ;

        case 2 :
            /* Setup the letters for the 2nd phase */
            Step2TypeLetters(G_exerciseString, G_letterDataPosition) ;
            @call Step2EnteredTextBox::MSG_VIS_TEXT_DELETE_ALL() ;
            @call Step2TextToTypeBox::MSG_VIS_TEXT_GET_ALL_PTR(G_goalLine) ;
            sprintf(G_charType, "%c", G_goalLine[G_inputPosition2]) ;
            break ;

        case 3 :
            /* Setup the letters for the 3rd part */
            @call Step3TextToTypeBox::MSG_VIS_TEXT_DELETE_ALL() ;
            @call Step3EnteredTextBox::MSG_VIS_TEXT_DELETE_ALL() ;
            @call Step3TextToTypeBox::MSG_VIS_TEXT_REPLACE_ALL_PTR(G_exerciseString, 0) ;
            @call Step3TextToTypeBox::MSG_VIS_TEXT_SELECT_START();
            sprintf(G_charType, "%c", G_exerciseString[0]) ;
            @call Step3CharToTypeGlyph::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(G_charType, VUM_NOW) ;
            Step3UnderlineChar(0) ;
    }
}

void Step3UnderlineChar(word index)
{
    dword end, n ;

    n = index ;

    /* Clear all underlining and bold if the first character */
    if (index == 0)  {
        @call Step3TextToTypeBox::MSG_VIS_TEXT_SET_TEXT_STYLE(
                  0,
                  0,
                  TS_UNDERLINE|TS_BOLD,
                  0,
                  TEXT_ADDRESS_PAST_END,
                  0) ;
    }
    end = @call Step3TextToTypeBox::MSG_VIS_TEXT_GET_TEXT_SIZE() ;
    if ((n+1)< end)  {
        if (n>0)  {
            @call Step3TextToTypeBox::MSG_VIS_TEXT_SET_TEXT_STYLE(
                      0,
                      0,
                      TS_UNDERLINE,
                      0,
                      n,
                      n-1) ;
        }
        @call Step3TextToTypeBox::MSG_VIS_TEXT_SET_TEXT_STYLE(
                  0,
                  0,
                  0,
                  TS_UNDERLINE|TS_BOLD,
                  n+1,
                  n) ;
    }
}

/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_TYPE_STEP1_INITIALIZER
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Setup step 1 of the lesson.  This basically involves stopping the
 |    timer, warning a visitor if he just entered, checking for a
 |    password, and drawing the next key to be played.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |    jfh  06/25/02  Added student name to title bar & made localizable
 *-----------------------------------------------------------------------*/

@method TypeProcessClass, MSG_TYPE_STEP1_INITIALIZER
{
 GStateHandle gstate ;
 WindowHandle win ;
 T_studentInfo info ;
 char		newTitle[70];
 optr		lesson[10] = {@LessonName1, @LessonName2, @LessonName3, @LessonName4,
							  @LessonName5, @LessonName6, @LessonName7, @LessonName8,
							  @LessonName9, @LessonName10};

	 G_step = 1 ;

    /* Stop the timer */
    if (G_displayTimer)  {
        TimerStop(G_displayTimer, G_displayTimerID) ;
        G_displayTimer = NullHandle ;
    }

	 /* Get the current student's name */
	 GetStudentInfo(G_currentStudent, &info) ;
	 strcpy(newTitle, info.SI_name);
	 strcat(newTitle, " - ");

	 /* Show the lesson name */
	 MemLock (OptrToHandle(@LessonName1));
	 strcat(newTitle, LMemDeref(lesson[G_lessonNum - 1]));
	 MemUnlock (OptrToHandle(@LessonName1));
	 @call TypePrimary::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
				  newTitle,
				  VUM_NOW) ;

    /* Hidden text input that catches the input */
    @call Step1DummyText::MSG_META_GRAB_FOCUS_EXCL() ;

    /* Start up the keyboard system */
    @call self::MSG_TYPE_LETTERS() ;
    G_currentKey = G_exerciseString[0] ;
    G_typedCharacter = '\0' ;

    /* Draw which key */
    win = @call KeyboardView::MSG_GEN_VIEW_GET_WINDOW() ;
    gstate = GrCreateState(win) ;
    WhichKey(gstate) ;
    GrDestroyState(gstate) ;
}


/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_TYPE_STEP2_INITIALIZER
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Setup step 2 of a lesson by stopping the timer, grabbing the
 |    text box, starting up the input, redrawing anything we need.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |
 *-----------------------------------------------------------------------*/
@method TypeProcessClass, MSG_TYPE_STEP2_INITIALIZER
{
    GStateHandle gstate ;
    WindowHandle win ;

    G_step = 2 ;

    /* Stop the timer */
    if (G_displayTimer)  {
        TimerStop(G_displayTimer, G_displayTimerID) ;
        G_displayTimer = NullHandle ;
    }

    /* Make the text box grab the keystrokes */
    @call Step2EnteredTextBox::MSG_META_GRAB_FOCUS_EXCL() ;

    /* Start up the input */
    @call self::MSG_TYPE_LETTERS() ;
    G_currentKey = G_exerciseString[0] ;
    G_typedCharacter = '\0' ;

    /* Redraw the keys and keyboard */
    win = @call KeyboardView::MSG_GEN_VIEW_GET_WINDOW() ;
    gstate = GrCreateState(win) ;
    WhichKey(gstate) ;
    GrDestroyState(gstate) ;
}


/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_TYPE_STEP3_INITIALIZER
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Start the 3rd step by stop the timer, grab the focus, and start
 |    the input.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |
 *-----------------------------------------------------------------------*/

@method TypeProcessClass, MSG_TYPE_STEP3_INITIALIZER
{
    /* Stop the timer */
    if (G_displayTimer)  {
        TimerStop(G_displayTimer, G_displayTimerID) ;
        G_displayTimer = NullHandle ;
    }

    G_step = 3 ;

    /* This is the easy one.  Grab the focus on the text box and */
    /* start up the letters */
    @call Step3EnteredTextBox::MSG_META_GRAB_FOCUS_EXCL() ;
    @call self::MSG_TYPE_LETTERS() ;
}


/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_TYPE_UPDATE_TIMER
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Each time the timer goes, this method is called.  Its has three main
 |    jobs.  1) It updates the time on the screen, 2) It determines when
 |    when the current round is over, and 3) calculate the words per
 |    minute.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |
 *-----------------------------------------------------------------------*/
@method TypeProcessClass, MSG_TYPE_UPDATE_TIMER
{
    /* Buffers to translate the time into strings */
    char timeStr[15] = "00:00" ;
    char speedStr[30] ;
    char accuracyString[30] ;

    /* Update the time count */
    G_totalSeconds++ ;
    G_timeSeconds++ ;
    if (G_timeSeconds == 60)  {
        /* Roll over the minutes */
        G_timeMinutes++ ;
        G_timeSeconds = 0 ;
    }

    /* Stop the exercise if past the limit */
    if (G_totalSeconds > G_timeLimit)  {
        if (G_displayTimer)  {
            TimerStop(G_displayTimer, G_displayTimerID) ;
            G_displayTimer = NullHandle ;
        }
        @send ,forceQueue process::MSG_TYPE_END_OF_ROUND() ;
    } else  {
        /* Setup the string */
        sprintf(timeStr, "%02u:%02u", G_timeMinutes, G_timeSeconds) ;

        /* Stop if we are past the end */
        if (G_inputPosition >= strlen(G_exerciseString))  {
            TimerStop(G_displayTimer, G_displayTimerID) ;
            @send ,forceQueue process::MSG_TYPE_END_OF_ROUND() ;
        }
    }

    /* Only calculate the words per minute if any time has gone by */
    if (G_totalSeconds > 0)  {
        /* Here is the calculation for words per minute */
//        G_wordsPerMinute = (((float)G_inputPosition/G_totalSeconds)*60)/5 ;
        /* Optimized at 60 times a second, 5 characters per word */
        G_wordsPerMinute = (G_inputPosition*12)/G_totalSeconds ;

        /* Show this on the screen */
        sprintf(speedStr, "%u", G_wordsPerMinute) ;
        @call SpeedText::MSG_VIS_TEXT_REPLACE_ALL_PTR(speedStr, 0) ;

/*        G_accuracy = 100 - (100/(float)G_inputPosition)*(float)G_numMistakes ; */
        if (G_inputPosition)
            G_accuracy = 100 - ((100 * G_numMistakes)/G_inputPosition) ;
        else
            G_accuracy = 100 ;
        if ((G_accuracy < 1) | (G_accuracy > 100))
            G_accuracy = 0 ;
        sprintf(accuracyString, "%u", G_accuracy) ;
        @call AccuracyText::MSG_VIS_TEXT_REPLACE_ALL_PTR(accuracyString, 0) ;
        @call TickerText::MSG_VIS_TEXT_REPLACE_ALL_PTR(timeStr, 0) ;
    }
}


/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_TYPE_END_OF_ROUND
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Determine the appropriate response and show either the ResultsDialog
 |    or the ExerciseEnd dialog.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |
 *-----------------------------------------------------------------------*/
@method TypeProcessClass, MSG_TYPE_END_OF_ROUND
{
    char SpeedResult[100] ;
    char AccuracyResult[100] ;
    char ResultText[100] ;
    Boolean doAgain = FALSE ;
    T_studentInfo info ;

    /* Stop the timer */
    if (G_displayTimer)  {
        TimerStop(G_displayTimer, G_displayTimerID) ;
        G_displayTimer = NULL ;
    }

    G_canType = FALSE ;

    GetStudentInfo(G_currentStudent, &info) ;

    /* We have reached the end of the round, play a notify sound */
    /* and show a dialog */
    UserStandardSound(SST_NOTIFY) ;

    /* Determine the rating we want to give the user in both accuracy */
    /* and speed */
    @call process::MSG_TYPE_EVALUATE(SpeedResult, AccuracyResult, ResultText) ;

    /* Now that we have decided which text to use, let's update the dialogs */
    @call SpeedResultGlyph::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
              SpeedResult,
              VUM_NOW) ;
    @call AccuracyResultGlyph::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
              AccuracyResult,
              VUM_NOW) ;
    @call ResultTextGlyph::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
              ResultText,
              VUM_NOW) ;

    /* If either goal was not met, we need to repeat */
    if ((info.SI_wpmGoal > G_wordsPerMinute) ||
        (info.SI_accuracyGoal > G_accuracy))  {
        doAgain = TRUE ;
    }

    /* Put up the appropriate dialog */
    if (G_step == 3)  {
        /* Report what the last testing resulted in */
        StudentUpdateStats(
            G_currentStudent,
            G_totalSeconds,
            G_wordsPerMinute,
            G_accuracy) ;

        /* Record the third session. */
        StudentUpdateReport(
            G_currentStudent,
            G_currentExercise,
            G_totalSeconds,
            G_wordsPerMinute,
            G_accuracy) ;

        @send ,forceQueue ResultsDialog::MSG_GEN_INTERACTION_INITIATE() ;
    } else {
        /* Report the stats */
        UserDoDialog(@ExerciseEnd) ;
        if (doAgain)  {
            @call oself::MSG_TYPE_NAVIGATOR(@AgainButton) ;
        } else {
            @call oself::MSG_TYPE_NAVIGATOR(@NextButton) ;
        }
    }
}


/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_NEW_STUDENT
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Create a new student in the database.
 |
 |    NOTE:  This method changes the UI directly and then calls the routine
 |    that reads the UI.  I don't like this.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |
 *-----------------------------------------------------------------------*/
@method TypeProcessClass, MSG_NEW_STUDENT
{
    char studentname[MAX_NAME_LEN+1] ;

    @call NewNameEntry::MSG_VIS_TEXT_GET_ALL_PTR(studentname) ;
    AddNewStudent(studentname) ;
}

/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_TYPE_NEW_REPORT
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Generate a new report for the given student.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |
 *-----------------------------------------------------------------------*/
@method TypeProcessClass, MSG_TYPE_NEW_REPORT
{
    /* LES !!! To be done! */
}

/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_PICKLIST_MONIKER_QUERY
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Process the query message for showing the list of students.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |
 *-----------------------------------------------------------------------*/
@method TypeProcessClass, MSG_PICKLIST_MONIKER_QUERY
{
    T_studentInfo info ;

    /* Just look up the nth student's name */
    GetStudentInfo(item, &info) ;
    @call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_TEXT(
              item,
              info.SI_name) ;
}


/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_TYPE_START_TUTOR
 *-------------------------------------------------------------------------
 |
 | Description:
 |    The user has selected a student.  We are now ready to actually use
 |    the student.  Prepare the system.
 |
 | Called by:
 |    Start Tutor trigger in the Welcome dialog.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/17/99  Created.
 |
 *-----------------------------------------------------------------------*/
@method TypeProcessClass, MSG_TYPE_START_TUTOR
{
    Boolean haveCorrectPassword = FALSE ;
    T_studentInfo info ;

    @call SPErasePassword::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
    G_currentStudent = @call NameSelectionBox::
                                 MSG_GEN_ITEM_GROUP_GET_SELECTION() ;
    G_currentViewStudent = G_currentStudent ;
    @call SPStudentList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(
              G_currentStudent,
              FALSE) ;

    /* Visitors have no stats */
	 if (G_currentStudent == TTYPE_VISITOR_SLOT)
        ClearVisitorStats() ;

    GetStudentInfo(G_currentStudent, &info) ;
    @call PPNameText::MSG_VIS_TEXT_REPLACE_ALL_PTR(info.SI_name, 0) ;
    @call PPGWordsPerMinute::MSG_GEN_VALUE_SET_INTEGER_VALUE(
              info.SI_wpmGoal,
              FALSE) ;
    @call PPGAccuracy::MSG_GEN_VALUE_SET_INTEGER_VALUE(
              info.SI_accuracyGoal,
              FALSE) ;
    @call PPGTimeToSpend::MSG_GEN_VALUE_SET_INTEGER_VALUE(
              info.SI_timeGoal,
              FALSE) ;
    G_timeLimit = info.SI_timeGoal ;

    /* Are we a visitor ? */
    if (G_currentStudent == TTYPE_VISITOR_SLOT)  {
        /* Visitors have no password */
        @call ChangePassword::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
        haveCorrectPassword = TRUE ;

        /* Ok, warn the visitor that we don't save any data */
        UserStandardSound(SST_NOTIFY) ;
        MemLock( OptrToHandle( @VisitorText) ) ;
        UserStandardDialog( (char*)0,
                    (char*)0,
                    (char*)0,
                    (char*)0,
                LMemDeref( @VisitorText ),
                ( CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET ) |
                ( GIT_NOTIFICATION <<
                CDBF_INTERACTION_TYPE_OFFSET ) ) ;
        MemUnlock( OptrToHandle( @VisitorText ) ) ;
    } else {
        /* Only non-visitors can change the password */
        @call ChangePassword::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;

        /* Ask for the user's password (a new one if a new student) */
        haveCorrectPassword = @call oself::MSG_TYPE_CHECK_PASSWORD() ;
    }

    /* Disable the teacher's corner unless this is a teacher */
    if (G_currentStudent == TTYPE_TEACHER_SLOT)  {
        @call TeachersCorner::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
        @call TeachersCorner::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
    } else {
        @call TeachersCorner::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
        @call TeachersCorner::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
	 }

    if (haveCorrectPassword)
        @call oself::MSG_TYPE_START_NEW_LESSON(1) ;
    else
        @call WelcomeDialog::MSG_GEN_INTERACTION_INITIATE() ;

}

/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_TYPE_CHECK_PASSWORD
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Asks the current user (G_currentStudent) for a password and returns
 |    TRUE if the user enters the right password, else FALSE.
 |    Visitors are not required to enter a password.
 |
 | Called by:
 |    MSG_TYPE_START_TUTOR
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/17/99  Created.
 |
 *-----------------------------------------------------------------------*/
@method TypeProcessClass, MSG_TYPE_CHECK_PASSWORD
{
    Boolean gotPassword = FALSE ;
    T_studentInfo info ;
    char password[MAX_PASSWORD_CHARS] ;

	 /* Visitors are not required to have a password */
    @call AskPasswordText::MSG_VIS_TEXT_DELETE_ALL() ;
    if (G_currentStudent == TTYPE_VISITOR_SLOT)  {
        gotPassword = TRUE ;
    } else {
        if (GetStudentInfo(G_currentStudent, &info))  {
            if (info.SI_password[0] == '\0')  {
                /* If no password recorded, don't ask. */
                gotPassword = TRUE ;
            } else {
                /* Wait for the user to enter a password. */
                if (UserDoDialog(@AskPasswordDialog) == IC_APPLY)  {
                    /* Now we need to compare the passwords */
                    @call AskPasswordText::MSG_VIS_TEXT_GET_ALL_PTR(password) ;
                    if (((G_currentStudent == TTYPE_TEACHER_SLOT) &&
                              (strcmp(password, "t9T9b-k")==0)) ||
                          (strcmp(password, info.SI_password) == 0))  {
                        gotPassword = TRUE ;
                    } else {
                        UserStandardDialogOptr(
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            @PasswordIncorrectText,
                            ( CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET ) |
                                ( GIT_NOTIFICATION <<
                                    CDBF_INTERACTION_TYPE_OFFSET ) ) ;
                    }
                }
            }
        }
    }
    @call AskPasswordText::MSG_VIS_TEXT_DELETE_ALL() ;

    return gotPassword ;
}

/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_TYPE_CHANGE_PASSWORD
 *-------------------------------------------------------------------------
 |
 | Description:
 |    First, determine if the password entries match and if they do,
 |    make that the new password.
 |
 | Called by:
 |    ChangePassword dialog
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/17/99  Created.
 |
 *-----------------------------------------------------------------------*/
@method TypeProcessClass, MSG_TYPE_CHANGE_PASSWORD
{
    char password[MAX_PASSWORD_CHARS] ;
    char confirmPassword[MAX_PASSWORD_CHARS] ;

    /* Get the two passwords */
    @call NewPassword::MSG_VIS_TEXT_GET_ALL_PTR(password) ;
    @call ConfirmPassword::MSG_VIS_TEXT_GET_ALL_PTR(confirmPassword) ;

    /* See if they match */
    if (strcmp(password, confirmPassword) != 0)  {
        UserStandardDialogOptr(
            NULL,
            NULL,
            NULL,
            NULL,
            @PasswordBadRetype,
            ( CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET ) |
                ( GIT_NOTIFICATION <<
                    CDBF_INTERACTION_TYPE_OFFSET ) ) ;

        /* They do not match.  Inform the user. */
        @call ChangePassword::MSG_GEN_INTERACTION_INITIATE() ;
    } else {
        /* They do match.  Let's make the change and inform the user */
        /* that the password has changed */
        if (SetStudentPassword(G_currentStudent, password))  {
            UserStandardDialogOptr(
                NULL,
                NULL,
                NULL,
                NULL,
                @PasswordHasChanged,
                ( CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET ) |
                    ( GIT_NOTIFICATION <<
                        CDBF_INTERACTION_TYPE_OFFSET ) ) ;
        } else {
            /* Setting the password failed? */
            /* If that happens, we had a really bad thing happen */
EC(         FatalError(-1) ; )
        }
    }

    @call NewPassword::MSG_VIS_TEXT_DELETE_ALL() ;
    @call ConfirmPassword::MSG_VIS_TEXT_DELETE_ALL() ;
}

/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_PICKLIST_APPLY
 *-------------------------------------------------------------------------
 |
 | Description:
 |    The user has clicked on a student name.  Move things around to
 |    setup the UI.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |
 *-----------------------------------------------------------------------*/
@method TypeProcessClass, MSG_PICKLIST_APPLY
{
    T_studentInfo info ;

    /* Make the current selection the current student */
    G_currentStudent = selection ;

    /* Get the student info and put in the UI */
    GetStudentInfo(G_currentStudent, &info) ;
    @call NewNameEntry::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
    @call NewNameOkButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
    @call NewNameEntry::MSG_VIS_TEXT_REPLACE_ALL_PTR(info.SI_name, 0) ;
}


/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_PICKLIST_CHANGE_VIEW
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Change the viewed student in the teacher's progress viewer.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/20/99  Created.
 |
 *-----------------------------------------------------------------------*/
@method TypeProcessClass, MSG_PICKLIST_CHANGE_VIEW
{
    T_studentInfo info ;

    /* Make the current selection the current student */
    G_currentViewStudent = selection ;

    ViewInvalidate(@StudentProgressView) ;

    GetStudentInfo(selection, &info) ;
    if ((info.SI_password[0]) &&
            (selection != TTYPE_VISITOR_SLOT) &&
                (selection != TTYPE_TEACHER_SLOT))  {
        @call SPErasePassword::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
    } else {
        @call SPErasePassword::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
    }
}

/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_TTYPE_STORE_PREFERENCES
 *-------------------------------------------------------------------------
 |
 | Description:
 |    The student has changed the name and goal settings.  This method
 |    pulls all the data out of the UI and stores it into the user.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  05/20/99  Created.
 |
 *-----------------------------------------------------------------------*/
@method TypeProcessClass, MSG_TTYPE_STORE_PREFERENCES
{
    T_studentInfo info ;

    GetStudentInfo(G_currentStudent, &info) ;
    @call PPNameText::MSG_VIS_TEXT_GET_ALL_PTR(info.SI_name) ;
    info.SI_wpmGoal = @call PPGWordsPerMinute::MSG_GEN_VALUE_GET_INTEGER_VALUE() ;
    info.SI_accuracyGoal = @call PPGAccuracy::MSG_GEN_VALUE_GET_INTEGER_VALUE() ;
    info.SI_timeGoal = @call PPGTimeToSpend::MSG_GEN_VALUE_GET_INTEGER_VALUE() ;
    G_timeLimit = info.SI_timeGoal ;
    SetStudentInfo(G_currentStudent, &info) ;
}

/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_TYPE_OPEN_NEW_NAME_ENTRY
 *-------------------------------------------------------------------------
 |
 | Description:
 |     The user has requested to enter a new user.  Change the UI to
 |     allow that to happen.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |
 *-----------------------------------------------------------------------*/

@method TypeProcessClass, MSG_TYPE_OPEN_NEW_NAME_ENTRY
{
    @call NewNameEntry::MSG_VIS_TEXT_DELETE_ALL() ;
    @call NewNameEntry::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
    @call NewNameEntry::MSG_META_RELEASE_FOCUS_EXCL() ;
    @call NewNameEntry::MSG_META_GRAB_FOCUS_EXCL() ;
    @call NewNameOkButton::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
    @call self::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_UI_QUEUE) ;
}

/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_TYPE_EVALUATE
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Evaluate the speed and accuracy and fill in the dialogs with with
 |    appropriate description information information.
 |
 | Inputs:
 |    char *SpeedResult           -- Speed comment
 |    char *AccuracyResult        -- Accuracy comment
 |    char *ResultText            -- Composite result text
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |    LES  05/21/99  Modified to take input buffers instead of modifying
 |                   the UI directly.
 |
 *-----------------------------------------------------------------------*/

@method TypeProcessClass, MSG_TYPE_EVALUATE
{
    word SpeedLevel = 2;
    word AccuracyLevel = 2;

	 MemLock(OptrToHandle(@MissingString));
	 strcpy(SpeedResult, LMemDeref(@MissingString)) ;
	 strcpy(AccuracyResult, LMemDeref(@MissingString)) ;
	 strcpy(ResultText, LMemDeref(@MissingString)) ;
    if (G_wordsPerMinute >= 45)  {
		  strcpy(SpeedResult, LMemDeref(@Speed1)) ;
        SpeedLevel = 3 ;
    } else if (G_wordsPerMinute < 45 && G_wordsPerMinute >= 20)  {
		  strcpy(SpeedResult, LMemDeref(@Speed2)) ;
        SpeedLevel = 2 ;
    } else if (G_wordsPerMinute < 20 && G_wordsPerMinute >= 10)  {
		  strcpy(SpeedResult, LMemDeref(@Speed3)) ;
        SpeedLevel = 1 ;
    } else if (G_wordsPerMinute < 10)  {
		  strcpy(SpeedResult, LMemDeref(@Speed4)) ;
        SpeedLevel = 0 ;
    }

    if (G_accuracy >= 96)  {
		  strcpy(AccuracyResult, LMemDeref(@Accuracy1)) ;
        AccuracyLevel = 3 ;
    } else if (G_accuracy < 96 && G_accuracy >= 85)  {
		  strcpy(AccuracyResult, LMemDeref(@Accuracy2)) ;
        AccuracyLevel = 2 ;
    } else if (G_accuracy < 85 && G_accuracy >= 80)  {
		  strcpy(AccuracyResult, LMemDeref(@Accuracy3)) ;
        AccuracyLevel = 1 ;
    } else if (G_accuracy < 80)  {
		  strcpy(AccuracyResult, LMemDeref(@Accuracy4)) ;
        AccuracyLevel = 0 ;
    }

	 if (SpeedLevel == 3 && AccuracyLevel == 3)  {
		  strcpy(ResultText, LMemDeref(@Result1)) ;
    } else if (SpeedLevel == 3 && AccuracyLevel == 2)  {
		  strcpy(ResultText, LMemDeref(@Result2)) ;
	 } else if (SpeedLevel == 3 && AccuracyLevel == 1)  {
		  strcpy(ResultText, LMemDeref(@Result3)) ;
	 } else if (SpeedLevel == 2 && AccuracyLevel == 3)  {
		  strcpy(ResultText, LMemDeref(@Result4)) ;
    } else if (SpeedLevel == 2 && AccuracyLevel == 2)  {
		  strcpy(ResultText, LMemDeref(@Result5)) ;
    } else if (SpeedLevel == 2 && AccuracyLevel == 1)  {
		  strcpy(ResultText, LMemDeref(@Result6)) ;
	 } else if (SpeedLevel == 1 && AccuracyLevel == 3)  {
		  strcpy(ResultText, LMemDeref(@Result7)) ;
    } else if (SpeedLevel == 1 && AccuracyLevel == 2)  {
		  strcpy(ResultText, LMemDeref(@Result8)) ;
	 } else if (SpeedLevel == 1 && AccuracyLevel == 1)  {
		  strcpy(ResultText, LMemDeref(@Result9)) ;
	 } else if (SpeedLevel == 0 || AccuracyLevel == 0)  {
		  strcpy(ResultText, LMemDeref(@Result10)) ;
	 }
	 MemUnlock(OptrToHandle(@MissingString));

	 strcat(SpeedResult, " ") ;
    strcat(SpeedResult, AccuracyResult) ;
    AccuracyResult[0] = '\0' ;
}

/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_TYPE_LESSON10_INITIALIZER
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Lesson 10+ are just the normal full screen actions
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |    jfh  06/26/02  Added user name & made localizable
 *-----------------------------------------------------------------------*/

@method TypeProcessClass, MSG_TYPE_LESSON10_INITIALIZER
{
T_studentInfo info ;
char		newTitle[70];

	 /* Stop the previous timer */
    TimerStop(G_displayTimer, G_displayTimerID) ;

	 /* Get the current student's name */
	 GetStudentInfo(G_currentStudent, &info) ;
	 strcpy(newTitle, info.SI_name);
	 strcat(newTitle, " - ");

	 /* Show the lesson name */
	 MemLock (OptrToHandle(@LessonName10));
	 strcat(newTitle, LMemDeref(@LessonName10));
	 MemUnlock (OptrToHandle(@LessonName10));
	 @call TypePrimary::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
				  newTitle,
				  VUM_NOW) ;

	 @call self::MSG_TYPE_LETTERS() ;
}

/*-------------------------------------------------------------------------
 | Method:  TypeProcessClass::MSG_META_EXPOSED
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Draw the student progress status.  (End of a lesson report)
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |
 *-----------------------------------------------------------------------*/

@method TypeProcessClass, MSG_META_EXPOSED
{
    word a = 1 ;
    char achar[50] ;
    GStateHandle gstate ;
    T_studentSummary summary ;
    word value ;

    @callsuper() ;

    StudentGenerateReport(G_currentViewStudent, &summary) ;

    /* Start an update */
    gstate = GrCreateState(win) ;
    GrBeginUpdate(gstate) ;

    /* Prepare the state of the drawing */
    GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0) ;
    GrSetTextColor(gstate, CF_INDEX, C_BLACK, 0, 0) ;
    GrSetFont(gstate, FID_DTC_URW_SANS, MakeWWFixed(12)) ;
    GrSetTextStyle(gstate, TS_BOLD, 0) ;

    /* Draw the major text areas (and student name) */
	 /* While clearing the place for numbers */
	 MemLock(OptrToHandle(@WordsPerString));
	 if (summary.SS_hasPassword)
        GrDrawText(gstate, 15, 3, "*", 1) ;
    GrDrawText(gstate, 20, 3, summary.SS_name, 0) ;
    if (G_progressViewMode == PROGRESS_VIEW_MODE_WPM)
        GrDrawText(gstate, 230, 3, LMemDeref(@WordsPerString), 0) ;
    else
		  GrDrawText(gstate, 230, 3, LMemDeref(@PctAccuracyString), 0) ;
    GrSetTextStyle(gstate, 0, TS_BOLD) ;
	 GrDrawText(gstate, 20, 25, LMemDeref(@LastGoalString), 0) ;
    GrSetLineWidth(gstate, MakeWWFixed(2)) ;
    GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0) ;
    GrDrawRect(gstate, 20, 40, 100, 65) ;
    GrSetAreaColor(gstate, CF_INDEX, C_WHITE, 0, 0) ;
    GrFillRect(gstate, 21, 41, 99, 64) ;

    /* Draw the last goal on the view */
    GrSetFont(gstate, FID_DTC_URW_SANS, MakeWWFixed(14)) ;
    GrSetTextStyle(gstate, TS_BOLD, 0) ;
    if (G_progressViewMode == PROGRESS_VIEW_MODE_WPM)   {
		  sprintf(&achar, LMemDeref(@WPMSPFString), summary.SS_goalWPM) ;
        GrDrawText(gstate, 31, 43, achar, 0) ;
    } else  {
        sprintf(&achar, "%u %%", summary.SS_goalAccuracy) ;
        GrDrawText(gstate, 43, 43, achar, 0) ;
    }
    GrSetTextStyle(gstate, 0, TS_BOLD) ;

	 GrDrawText(gstate, 20, 75, LMemDeref(@LastResultString), 0) ;
    GrDrawRect(gstate, 20, 92, 100, 117) ;
    GrFillRect(gstate, 21, 93, 99, 116) ;

    /* Draw the last result on the view */
    GrSetFont(gstate, FID_DTC_URW_SANS, MakeWWFixed(14)) ;
    GrSetTextStyle(gstate, TS_BOLD, 0) ;
    if (G_progressViewMode == PROGRESS_VIEW_MODE_WPM)  {
		  sprintf(&achar, LMemDeref(@WPMSPFString), summary.SS_lastWPM) ;
        GrDrawText(gstate, 31, 95, achar, 0) ;
    } else  {
        sprintf(&achar, "%u %%", summary.SS_lastAccuracy) ;
        GrDrawText(gstate, 43, 95, achar, 0) ;
    }
    GrSetTextStyle(gstate, 0, TS_BOLD) ;

    /* Draw x- and y-axis */
    GrSetLineWidth(gstate, MakeWWFixed(1)) ;
    GrDrawVLine(gstate, 150, 30, 120) ;
    GrDrawHLine(gstate, 150, 120, 420) ;

    /* Draw titles for x- and y-axis */
    GrSetFont(gstate, FID_DTC_URW_SANS, MakeWWFixed(10)) ;
    if (G_progressViewMode == PROGRESS_VIEW_MODE_WPM)
		  GrDrawText(gstate, 134, 18, LMemDeref(@WPMString), 0) ;
    else
		  GrDrawText(gstate, 134, 18, LMemDeref(@PctAccString), 0) ;

	 GrDrawText(gstate, 134, 125, LMemDeref(@LessonString), 0) ;
	 MemUnlock(OptrToHandle(@WordsPerString));

	 /* Draw the Lesson numbers and positions on the x-axis */
    for (a=1; a<=10; a++)  {
        GrDrawVLine(gstate, 150 + (a * 25), 117, 123) ;
        sprintf(&achar, "%u", a) ;
        GrDrawText(gstate, 147 + (a * 25), 125, achar, 0) ;
    }

    if (G_progressViewMode == PROGRESS_VIEW_MODE_WPM)  {
        /* Draw the G_wordsPerMinute numbers and position on the y-axis */
        for (a=1; a<=8; a++)
            GrDrawHLine(gstate, 148, 120 - (a * 10), 152) ;
        for (a=1; a<=4; a++)  {
            sprintf(&achar, "%u", a*20) ;
            GrDrawText(gstate, 134, 112 - (a * 20), achar, 0) ;
        }
    } else {
        /* Draw the accuracy numbers and position on the y-axis */
        for (a=1; a<=10; a++)
            GrDrawHLine(gstate, 148, 120 - (a * 8), 152) ;
        for (a=1; a<=5; a++)  {
            sprintf(&achar, "%u", a*20) ;
            GrDrawText(gstate, 131, 112 - (a * 16), achar, 0) ;
        }
    }

    /* Draw the summary values for wpm */
    GrSetAreaColor(gstate, CF_INDEX, C_BLACK, 0, 0) ;
    if (G_progressViewMode == PROGRESS_VIEW_MODE_WPM)  {
        for (a=0; a<10; a++)  {
            value = summary.SS_wpm[a] ;
            if (value > 90)
                value = 90 ;
            GrFillRect(
                gstate,
                175 + (a*25)-7,
                120 - value,
                175 + (a*25)+8,
                120) ;
        }
    } else  {
        /* Draw the accuracy marks */
        for (a=0; a<10; a++)  {
            value = summary.SS_accuracy[a] ;
            value *= 8 ;
            value /= 10 ;
            if (value > 90)
                value = 90 ;
            GrFillRect(
                gstate,
                175 + (a*25)-7,
                120 - value,
                175 + (a*25)+8,
                120) ;
        }
    }

    /* Show the goal on the chart */
    GrSetLineStyle(gstate, LS_DOTTED, 1, 0, 1) ;
/*     GrDrawHLine(gstate, 150, 120 - G_lastWPMGoal, 420); */
    if (G_progressViewMode == PROGRESS_VIEW_MODE_WPM)  {
        /* Draw the G_wordsPerMinute numbers and position on the y-axis */
        for (a=1; a<=4; a++)
            GrDrawHLine(gstate, 148, 120 - (a * 20), 420) ;
    } else {
        /* Draw the accuracy numbers and position on the y-axis */
        for (a=1; a<=5; a++)
            GrDrawHLine(gstate, 148, 120 - (a * 16), 420) ;
    }
    GrSetLineStyle(gstate, LS_DASHED, 2, 0, 2) ;
    if (G_progressViewMode == PROGRESS_VIEW_MODE_WPM)  {
        value = summary.SS_goalWPM ;
        if (value > 90)
            value = 90 ;
        GrDrawHLine(gstate, 148, 120-value, 420) ;
    } else  {
        value = summary.SS_goalAccuracy ;
        value *= 8 ;
        value /= 10 ;
        GrDrawHLine(gstate, 148, 120-value, 420) ;
    }

    GrEndUpdate(gstate) ;
    GrDestroyState(gstate) ;
}

@start TabAndStyleResource, data ;
    /*---------------------------------------------------------------------*/
    @chunk Tab tabGroup1[] = {
        SIMPLE_TAB(2.5),
        {4.5*8*PIXELS_PER_INCH, TT_RIGHT, SDM_100, 0*8, 0, 0},
        {6.25*8*PIXELS_PER_INCH, TT_RIGHT, SDM_100, 0*8, 0, '%'},
        TAB_GROUP_END
    } ;
    @chunk Tab tabLine[] = {
        {6.5*8*PIXELS_PER_INCH, (TL_LINE<<TabLeader_OFFSET)|TT_LEFT, SDM_100, 0*8, 0, 0},
        TAB_GROUP_END
    } ;
    /*---------------------------------------------------------------------*/
@end TabAndStyleResource ;

@method TypeProcessClass, MSG_TTYPE_GENERATE_REPORT
{
    word i, num ;
    word j;
    T_studentSummary summary ;
    char buffer[80] ;

    @call textObj::MSG_META_SUSPEND() ;
    @RT_FONT(FID_DTC_URW_SANS) ;
    @RT_SIZE(MakeWWFixed(14.0)) ;
	 @RT_STYLE(TS_BOLD) ;
	 MemLock(OptrToHandle(@ReportTitle));
	 @RT_APPEND(LMemDeref(@ReportTitle)) ;

    num = StudentDBGetCount() ;
    for (i=1+TTYPE_TEACHER_SLOT; i<num; i++)  {
        StudentGenerateReport(i, &summary) ;

        @RT_SIZE(MakeWWFixed(4.0)) ;
        @RT_TAB_GROUP(@tabLine) ;
        @RT_APPEND("\t\r") ;
        @RT_SIZE(MakeWWFixed(12.0)) ;

        @RT_SIZE(MakeWWFixed(12.0)) ;
        @RT_STYLE(TS_BOLD) ;
        @RT_APPEND("  ") ;
        @RT_APPEND(summary.SS_name) ;
        @RT_APPEND("\r") ;

        @RT_SIZE(MakeWWFixed(4.0)) ;
        @RT_TAB_GROUP(@tabLine) ;
        @RT_APPEND("\t\r") ;
        @RT_SIZE(MakeWWFixed(12.0)) ;

        @RT_STYLE(TS_BOLD) ;
        @RT_TAB_GROUP(@tabGroup1) ;

		  @RT_APPEND(LMemDeref(@ReportTimeAcc)) ;

        @RT_STYLE(0) ;
        sprintf(
            buffer,
				LMemDeref(@ReportGoals),
            summary.SS_goalWPM,
            summary.SS_goalAccuracy) ;
        @RT_APPEND(buffer) ;
        sprintf(
            buffer,
				LMemDeref(@ReportLast),
				summary.SS_lastTime,
            summary.SS_lastWPM,
            summary.SS_lastAccuracy) ;
        @RT_APPEND(buffer) ;

        for (j=0; j<10; j++)  {
            if (summary.SS_numReports[j])  {
                sprintf(
						  buffer,
						  LMemDeref(@ReportLesson),
                    j+1,
                    summary.SS_time[j],
                    summary.SS_wpm[j],
                    summary.SS_accuracy[j]) ;
                @RT_APPEND(buffer) ;
            }
        }

        @RT_SIZE(MakeWWFixed(4.0)) ;
        @RT_TAB_GROUP(@tabLine) ;
        @RT_APPEND("\t\r") ;
        @RT_SIZE(MakeWWFixed(12.0)) ;

        @RT_APPEND("\r\r\r") ;
    }
	 MemUnlock(OptrToHandle(@ReportTitle));
	 @call textObj::MSG_VIS_TEXT_SELECT_START() ;
    @call textObj::MSG_META_UNSUSPEND() ;
}

void ViewInvalidate(optr view)
{
    WindowHandle win ;
    GStateHandle gstate ;

    win = @call view::MSG_GEN_VIEW_GET_WINDOW() ;
    gstate = GrCreateState(win) ;
    GrInvalRect(gstate, 0, 0, 30000, 30000) ;
    GrDestroyState(gstate) ;
}

@method TypeProcessClass, MSG_TYPE_SET_PROGRESS_VIEW_MODE
{
    static optr view1, view2 ;

    view1 = @ProgressView ;
    view2 = @StudentProgressView ;

    G_progressViewMode = mode ;
    ViewInvalidate(@ProgressView) ;
    ViewInvalidate(@StudentProgressView) ;
}

/*=========================================================================*
 *  Routines:
 *=========================================================================*/

/*-------------------------------------------------------------------------
 | Routine:  DrawButton
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Generic routine to draw a button usually directly on the keyboard
 |
 | Inputs:
 |    GStateHandle gstate         -- Where to draw
 |    word left, top, right, bottom -- Bounds of rectangular button
 |    char lowchar                -- Single character to draw
 |    Color rectcolor             -- Area color
 |    Color linecolor             -- Edge color
 |    Color charcolor             -- Text color
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |
 *-----------------------------------------------------------------------*/
void DrawButton(
         GStateHandle gstate,
         word left,
         word top,
         word right,
         word bottom,
         char lowchar,
         Color rectcolor,
         Color linecolor,
         Color charcolor)
{
    GrSetLineWidth(gstate, MakeWWFixed(1)) ;
    GrSetLineColor(gstate, CF_INDEX, linecolor, 0, 0) ;
    GrDrawRect(gstate, left, top, right, bottom) ;
    GrSetAreaColor(gstate, CF_INDEX, rectcolor, 0, 0) ;
    GrFillRect(gstate, left+1, top+1, right, bottom) ;
    GrSetFont(gstate, FID_DTC_URW_SANS, MakeWWFixed(12)) ;
    GrSetTextColor(gstate, CF_INDEX, charcolor, 0, 0) ;
    GrDrawText(gstate, left+5, top+2, &lowchar, 1) ;
}

/*-------------------------------------------------------------------------
 | Routine:  DrawSpecialButton
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Draw a special key in a smaller font but as a string instead of
 |    one character.
 |
 | Inputs:
 |    GStateHandle gstate         -- Where to draw
 |    word left, top, right, bottom -- Bounds of rectangular button
 |    char lowchar[]              -- String of characters to draw
 |    Color rectcolor             -- Area color
 |    Color linecolor             -- Edge color
 |    Color charcolor             -- Text color
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    PV   ??/??/??  Created.
 |
 *-----------------------------------------------------------------------*/
void DrawSpecialButton(
         GStateHandle gstate,
         word left,
         word top,
         word right,
         word bottom,
         char lowchar[],
         Color rectcolor,
         Color linecolor,
         Color charcolor)
{
    GrSetLineWidth(gstate, MakeWWFixed(1)) ;
    GrSetLineColor(gstate, CF_INDEX, linecolor, 0, 0) ;
    GrDrawRect(gstate, left, top, right, bottom) ;
    GrSetAreaColor(gstate, CF_INDEX, rectcolor, 0, 0) ;
    GrFillRect(gstate, left+1, top+1, right, bottom) ;
    GrSetTextColor(gstate, CF_INDEX, charcolor, 0, 0) ;
    GrSetFont(gstate, FID_DTC_URW_SANS, MakeWWFixed(10)) ;
    GrDrawText(gstate, left+3, top+3, lowchar, strlen(lowchar)) ;
}


/*-------------------------------------------------------------------------
 | Routine:  DetectSystemType
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Determines the type of system and sets G_isGeobook and
 |    G_geoBookHasPCMCIA appropriately.
 |    NOTE:  You should call this routine once when opening the app
 |           usually in MSG_GEN_PROCESS_OPEN_APPLICATION.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  07/12/99  Modified from John's code in the installer.
 |
 *-----------------------------------------------------------------------*/
void DetectSystemType(void)
{
    Boolean initReadErr;
    char uiStr[50];
    word size;

    /* Reset to false */
    G_isGeoBook = FALSE ;
    G_geoBookHasPCMCIA = FALSE ;

    /* if we're on a Yago machine set the flag */
    initReadErr = InitFileReadStringBuffer(
                      "ui",
                      "specific",
                      &uiStr,
                      50,
                      &size);
    if (!initReadErr)  {
        if (!strcmp(uiStr, "yago.geo"))  {
            /* it is a Bro UI... */
            /* now check to see if it is BroWorks on a PC */
            initReadErr = InitFileReadStringBuffer(
                              "ui",
                              "productName",
                              &uiStr,
                              50,
                              &size);
            if (strcmp(uiStr, "Yago PC-Demo"))
                G_isGeoBook = TRUE;
        }
    }

    /* if a GeoBook see if there is a PC memory card */
    if (G_isGeoBook)  {
        if (DriveGetStatus(4))  {  /* drive e (pc slot)*/
            G_geoBookHasPCMCIA = TRUE ;
        }
    }
}

/***************************************************************************
 *  END OF FILE:  TTYPE.GOC
 ***************************************************************************/
