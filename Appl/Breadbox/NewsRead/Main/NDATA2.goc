@include <stdapp.goh>

#include <Ansi/string.h>
#include <Ansi/stdlib.h>

/* Compile options */
@include "options.goh"

@include "newsdata.goh"
@include "Localize/strings.goh"
#include "news.h"
#include "bucketha.h"
@include "utils.goh"
@include "errors.goh"


#ifdef DEBUG
void ECValidateGroupIndex(word groupIndex) ;
void ECValidateUnsubGroupIndex(word groupIndex) ;
void ECValidateGroupPtr(NewsgroupEntry *p_group) ;
void ECValidateThreadIndex(word threadIndex) ;
void ECValidateThreadPtr(ThreadEntry *p_thread) ;
void ECValidateArticleIndex(word articleIndex) ;
void ECValidateArticlePtr(ArticleEntry *p_article) ;
#else
#define ECValidateGroupIndex(index)
#define ECValidateUnsubGroupIndex(index)
#define ECValidateGroupPtr(p_group)
#define ECValidateThreadIndex(index)
#define ECValidateThreadPtr(p_thread)
#define ECValidateArticleIndex(index)
#define ECValidateArticlePtr(p_article)
#endif

extern MemHandle G_mapBlockMem ;
extern word G_lockMapBlockCount ;

extern NewsgroupEntry *G_group ;

#define INDEX_BAD   0xFFFFFFFF

/*-------------------------------------------------------------------------
 | Internal types:
 *-----------------------------------------------------------------------*/
#define MAX_REFERENCES_PER_LIST    8
typedef struct {
    byte MRL_numRef ;
    word  MRL_offsets[MAX_REFERENCES_PER_LIST] ;
    dword MRL_hash[MAX_REFERENCES_PER_LIST] ;
} T_msgRefList ;

/*-------------------------------------------------------------------------
 | Prototypes:
 *-----------------------------------------------------------------------*/
void ICreateDatabase(void) ;
dword ICreateHashForMsgID(byte *p_msgId) ;
void ICreateRefList(char *p_refLine, T_msgRefList *p_refList) ;
word IFindThreadWithReference(char *p_refLine, T_msgRefList *refList) ;
word IFindArticleWithReference(char *p_refLine, T_msgRefList *refList) ;
Boolean ICompareRefs(char *p_refLine, T_msgRefList *refList) ;
void IAppendText(optr text, BucketHugeArrayHandle linesArray,
            dword start, dword end) ;
void IAppendTextWithPrefix(optr text, char *p_prefix) ;
dword IArticleIDToIndex(NewsUniqueID articleID) ;
dword IArticleIDToHashIndex(NewsUniqueID articleID) ;
void IInsertHashEntry(ArticleEntry *p_article) ;
dword IFindArticleWithHash(
				char *p_string, 
				NewsUniqueID articleID,
				dword hashValue) ;
dword IFindFirstArticleWithHash(dword hashValue) ;
word IFindArticleInThread(NewsUniqueID articleID) ;
void ISelectThreadWithID(NewsUniqueID threadID) ;

/*-------------------------------------------------------------------------
 | Routine:  InsertSortIntoBucketHugeArray
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Insert a string alphabetically into a huge array of variable length
 |    character strings.
 |    The list MUST be already alphabetically sorted.  Takes time Log2 to
 |    insert once.
 |
 | Inputs:
 |    VMFileHandle file           -- File with huge array
 |    VMBlockHandle hugeArray     -- Huge array in file
 |    void *p_data                -- Data structure with string
 |    word sizeStructu            -- Complete size of structure
 |    word offsetText             -- Offset to text string in structure
 |
 | Outputs:
 |    dword                       -- Element position it was placed
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/03/98  Created
 |
 *-----------------------------------------------------------------------*/
dword InsertSortIntoBucketHugeArray(
         VMFileHandle file,
         VMBlockHandle hugeArray,
         void *p_data,
         word sizeStruct,
         word offsetText)
{
    dword start, end, middle ;
    word size ;
    void *p_pos ;
    char *p_string ;
    char *p_str2 ;

    p_string = ((char *)p_data) + offsetText ;

    /* Do a binary search. */
    start = 0 ;
    end = BucketHugeArrayGetCount(file, hugeArray) ;
    while (end > start)  {
        middle = (start+end)>>1 ;
        BucketHugeArrayLock(file, hugeArray, middle, &p_pos, &size) ;
        p_str2 = ((char *)p_pos)+offsetText ;

        if (strcmp(p_string, p_str2) >= 0)  {
            /* After the middle position */
            start = middle+1 ;
        } else {
            /* Before the middle position */
            end = middle ;
        }
        BucketHugeArrayUnlock(p_pos) ;
    }

    /* Now insert before end position */
    BucketHugeArrayInsert(file, hugeArray, sizeStruct, end, p_data) ;

    return end ;
}

/*-------------------------------------------------------------------------
 | Routine:  NewsDataCreateUnsubGroup
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Create a new unsubscribed newsgroup with given name at the end.
 |
 | Inputs:
 |    char *p_name                -- Name to use for newsgroup.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/06/98  Created
 |
 *-----------------------------------------------------------------------*/
word NewsDataCreateUnsubGroup(char *p_name)
{
    dword subcount ;
    UnsubscribedGroupEntry newGroup ;
    word newIndex = NEWS_DATA_NEWSGROUP_NONE ;

    NewsDataLock() ;

    /* Check if the group is already on the list and report an error if */
    /* it already is. */
    subcount = NewsDataCountNewsgroups() ;

    /* Are we past the limit? */
    if (subcount < MAX_UNSUBSCRIBED_NEWSGROUPS)  {
        /* Create a new message list array */
        /* Initialize the NewsgroupEntry data structure */
        memset(&newGroup, 0, sizeof(newGroup)) ;
        strncpy(
            newGroup.UGE_text,
            p_name,
            MAX_GROUP_NAME_SIZE) ;

        /* Append the new entry to the end of the subscription list */
        newIndex = InsertSortIntoBucketHugeArray(
                       G_databaseVMFH,
                       G_mapBlock->DMB_groupsArray,
                       &newGroup,
                       strlen(newGroup.UGE_text)+1,
                       offsetof(UnsubscribedGroupEntry, UGE_text)) ;
    }

    NewsDataUnlock() ;

    return newIndex ;
}

/*-------------------------------------------------------------------------
 | Routine:  NewsDataGroupCreateThread
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Create a thread to hold articles in the current newsgroup.
 |
 | Outputs:
 |    word                        -- Index of newly created thread, or
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/06/98  Created
 |
 *-----------------------------------------------------------------------*/
word NewsDataGroupCreateThread(void)
{
    ThreadEntry thread ;
    word newIndex = NEWS_DATA_THREAD_NONE;

    ECValidateGroupPtr(G_group) ;

    /* Create an array of articles */
    if (NewsDataGroupCountThreads() < MAX_THREADS_PER_GROUP)  {
        /* Create a new article array for the thread */
        thread.TE_articleArray =
            BucketHugeArrayCreate(
                G_databaseVMFH,
                sizeof(ArticleReferenceEntry),
                0) ;
        EC_ERROR_IF(
            thread.TE_articleArray==NullHandle,
            ERROR_NEWS_DATA_CANT_CREATE_THREAD_ARRAY) ;

        /* Assign the next thread id and dirty the count */
        thread.TE_threadID = G_group->NE_nextThreadID++ ;
        thread.TE_unread = 0 ;
        BucketHugeArrayDirty(G_group) ;

        /* Append the new entry to the end of the threads in the */
        /* newsgroup */
        newIndex = BucketHugeArrayAppend(
                       G_databaseVMFH,
                       G_group->NE_threadArray,
                       1,
                       &thread) ;
    }

    return newIndex ;
}

/*-------------------------------------------------------------------------
 | Routine:  NewsDataInitArticle
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Setup up an article in the database without attaching it to anything.
 |    The passed in article entry is filled with the default data.
 |    NOTE:  No memory allocation of p_article is done here.
 |
 | Inputs:
 |    ArticleEntry *p_article     -- Entry to fill with new settings
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/06/98  Created
 |
 *-----------------------------------------------------------------------*/
void NewsDataInitArticle(ArticleEntry *p_article)
{
    /* Clear the structure for the default */
    memset(p_article, 0, sizeof(ArticleEntry)) ;

    /* Create an array of lines for header and body */
    p_article->AE_headers = BucketHugeArrayCreate(G_databaseVMFH, 0, 0);
    p_article->AE_body = BucketHugeArrayCreate(G_databaseVMFH, 0, 0);
}

/*-------------------------------------------------------------------------
 | Routine:  ICreateDatabase                               * INTERNAL *
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Creates a brand new database file.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/06/98  Created
 |
 *-----------------------------------------------------------------------*/
void ICreateDatabase(void)
{
    VMBlockHandle mapBlockVMH ;

    /* Ok, just wasn't there.  Whew!  */
    /* Thought it was a real problem. */
    /* Let's create a new database */
    G_databaseVMFH = VMOpen(
                         "News Reader Database",
                         VMAF_FORCE_READ_WRITE | VMAF_FORCE_DENY_WRITE,
                         VMO_CREATE,
                         0);

    /* Quit if that failed */
    if (G_databaseVMFH == NullHandle) {
        ErrorMessage(@ErrorCreatingFile);
        @send application::MSG_META_QUIT();
    } else {
        /* Setup the map block */
        mapBlockVMH = VMAlloc(
                          G_databaseVMFH,
                          sizeof(DatabaseMapBlock),
                          0);
        VMSetMapBlock(G_databaseVMFH, mapBlockVMH);
        G_mapBlock = VMLock(G_databaseVMFH, mapBlockVMH, &G_mapBlockMem);

        /* Create empty arrays for the subscribed and groups array */
        G_mapBlock->DMB_groupsArray = BucketHugeArrayCreate(G_databaseVMFH, 0, 0);
        G_mapBlock->DMB_subscribedArray = BucketHugeArrayCreate(G_databaseVMFH, 0, 0);
        VMDirty(G_mapBlockMem);
        VMUnlock(G_mapBlockMem);

        BucketHugeArraySave();
        VMSave(G_databaseVMFH) ;
    }
}

/*************************************************************************/

MemHandle NewDataArticleGetMessageID(word index)
{
    ArticleEntry *p_article;
    MemHandle retValue = 0;
    
    p_article = NewsDataArticleLock(index) ;

    if(p_article)
    {
        char *p_msgId ;

        /* First, we need to update the article's own hash value */
        p_msgId = NewsDataLockArticleMessageID(p_article) ;

        if (p_msgId)
        {
            word offset;            
 
            /* search reference start */
            offset = 0;
            while(p_msgId[offset])
            {
                if(p_msgId[offset] == '<')
                {
                    word start = offset;

                    offset ++;

                    while(p_msgId[offset])
                    {
                        if(p_msgId[offset] == '>')
                        {
                            offset ++;

                            retValue = MemAlloc(offset - start + 1,
                                            HF_SWAPABLE, HAF_LOCK);
                        
                            if(retValue)
                            {
                                strncpy(MemDeref(retValue), &p_msgId[start], offset - start);
                                ((char*)MemDeref(retValue))[offset - start] = 0;

                                break;
                            }
                        
                            MemUnlock(retValue);
                        }

                        offset ++;
                    }

                    break;
                }

                offset ++;
            }

            NewsDataUnlockHeaderLine(p_msgId) ;
        }

        NewsDataArticleUnlock(p_article);
    }

    return(retValue);
}

/*-------------------------------------------------------------------------
 | Routine:  NewsDataThreadMarkRead
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Mark read a thread in the currently selected newsgroup.
 |
 | Inputs:
 |    word index                  -- Index to thread to mark read
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    FR   01/04/98  Created
 |
 *-----------------------------------------------------------------------*/
void NewsDataThreadMarkRead(word index)
{
    word numArticles ;

    ECValidateThreadIndex(index) ;

    /* Make sure nothing is locked */
    NewsDataThreadSelectArticle(NEWS_DATA_ARTICLE_NONE) ;
    NewsDataGroupSelectThread(index) ;

    /* First, we need to delete all the articles */
    numArticles = NewsDataThreadCountArticles() ;

    /* Delete the articles in reverse */
    while (numArticles)  {
        NewsDataArticleMarkRead(--numArticles) ;
    }

    NewsDataGroupSelectThread(NEWS_DATA_THREAD_NONE) ;
}

/*************************************************************************/

void NewsDataThreadDeleteRead(word index)
{
    word numArticles ;

    ECValidateThreadIndex(index) ;

    /* Make sure nothing is locked */
    NewsDataThreadSelectArticle(NEWS_DATA_ARTICLE_NONE) ;
    NewsDataGroupSelectThread(index) ;

    /* First, we need to delete all the articles */
    numArticles = NewsDataThreadCountArticles() ;

    /* Delete the articles in reverse */
    while (numArticles)  {
        ArticleEntryFlags flags;

        numArticles --;

        NewsDataThreadSelectArticle(numArticles);

        flags = G_article->AE_flags ;

        NewsDataThreadSelectArticle(NEWS_DATA_ARTICLE_NONE) ;

        if(flags & AEF_READ)
            NewsDataThreadDeleteArticle(numArticles) ;
    }

    NewsDataGroupSelectThread(NEWS_DATA_THREAD_NONE) ;
}

/*************************************************************************/

Boolean NewsDataGroupDeleteRead(word index, word threadIndex)
{
    word numThreads ;
    Boolean threadDeleted = FALSE ;

    NewsDataLock() ;

    ECValidateGroupIndex(index) ;

    /* Make sure nothing is locked */
    NewsDataThreadSelectArticle(NEWS_DATA_ARTICLE_NONE) ;
    NewsDataGroupSelectThread(NEWS_DATA_THREAD_NONE) ;
    NewsDataSelectGroup(index) ;

    /* First, we need to delete all the threads */
    numThreads = NewsDataGroupCountThreads() ;

    /* Delete the threads in reverse */
    while (numThreads)  {

        word articlesCount ;

        NewsDataThreadDeleteRead(--numThreads) ;

        NewsDataGroupSelectThread(numThreads) ;
        articlesCount = NewsDataThreadCountArticles();
        NewsDataGroupSelectThread(NEWS_DATA_THREAD_NONE) ;
        
        if(!articlesCount)
        {
            if(threadIndex == numThreads)
                threadDeleted = TRUE ;
            
            NewsDataGroupDeleteThread(numThreads) ;
        }
    }

    NewsDataSelectGroup(NEWS_DATA_NEWSGROUP_NONE) ;

    NewsDataUnlock() ;

    BucketHugeArraySave();
    VMSave(G_databaseVMFH) ;

    return(threadDeleted);
}

/*************************************************************************/

void NewsDataGroupMarkRead(word index)
{
    word numThreads ;

    NewsDataLock() ;

    ECValidateGroupIndex(index) ;

    /* Make sure nothing is locked */
    NewsDataThreadSelectArticle(NEWS_DATA_ARTICLE_NONE) ;
    NewsDataGroupSelectThread(NEWS_DATA_THREAD_NONE) ;
    NewsDataSelectGroup(index) ;

    /* First, we need to delete all the threads */
    numThreads = NewsDataGroupCountThreads() ;

    /* Delete the threads in reverse */
    while (numThreads)  {
        NewsDataThreadMarkRead(--numThreads) ;
    }

    NewsDataSelectGroup(NEWS_DATA_NEWSGROUP_NONE) ;

    NewsDataUnlock() ;

    BucketHugeArraySave();
    VMSave(G_databaseVMFH) ;
}

/*-------------------------------------------------------------------------
 | Routine:  NewsDataOpen
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Open the News Reader database or try creating the file.
 |
 | Outputs:
 |    Boolean                     -- TRUE if opened/created, else FALSE
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/06/98  Created
 |
 *-----------------------------------------------------------------------*/
Boolean NewsDataOpen(void)
{
    word error ;
    EC_ERROR_IF(G_databaseVMFH != NullHandle, ERROR_NEWS_DATA_FILE_ALREADY_OPEN) ;

    /* Don't reopen */
    if (G_databaseVMFH == NullHandle)  {
        BucketsStart("News Reader News") ;

        /* Go open the news reader database */
        FilePushDir();
        FileSetCurrentPath(SP_PRIVATE_DATA, "News Reader News");
        G_databaseVMFH = VMOpen(
                             "News Reader Database",
                             VMAF_FORCE_READ_WRITE | VMAF_FORCE_DENY_WRITE,
                             VMO_OPEN,
                             0);

        if (G_databaseVMFH == NullHandle) {
            /* Oh, oh, no file.  What type of error? */
            error = ThreadGetError();
            switch (error) {
                case VM_FILE_NOT_FOUND:
                    ICreateDatabase() ;
                    break;
                case VM_OPEN_INVALID_VM_FILE:
                case VM_SHARING_DENIED:
                case VM_WRITE_PROTECTED:
                case VM_CANNOT_OPEN_SHARED_MULTIPLE:
                case VM_FILE_FORMAT_MISMATCH:
                default:
                    /* Just can't open */
                    ErrorMessage(@ErrorOpeningFile);
                    break ;
            }
        } else
            VMRevert(G_databaseVMFH) ;

        FilePopDir();

    }
    EC(ECVMCheckVMFile(G_databaseVMFH);)

    /* Return TRUE if we have a database file handle */
    return ((G_databaseVMFH != NullHandle)?TRUE:FALSE);
}

/*-------------------------------------------------------------------------
 | Routine:  NewsDataClose
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Close out the database.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/06/98  Created
 |
 *-----------------------------------------------------------------------*/
void NewsDataClose(void)
{
    EC_ERROR_IF(
        G_lockMapBlockCount > 0,
        ERROR_NEWS_DATA_FILE_CLOSE_WHILE_MAP_BLOCK_IS_LOCKED) ;
    while (G_lockMapBlockCount)
        NewsDataUnlock() ;

    NewsDataThreadSelectArticle(NEWS_DATA_ARTICLE_NONE) ;
    NewsDataGroupSelectThread(NEWS_DATA_THREAD_NONE) ;
    NewsDataSelectGroup(NEWS_DATA_NEWSGROUP_NONE) ;

    /* Close out the database */
    if (G_databaseVMFH != NullHandle) {
        VMClose(G_databaseVMFH, FALSE); /*returns error if failed*/
        BucketsEnd() ;
    }
}


/*-------------------------------------------------------------------------
 | Routine:  NewsDataDeleteGroup
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Delete a newsgroup and all associated data.
 |
 | Inputs:
 |    word index                  -- Index to group to destroy
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/10/98  Created
 |
 *-----------------------------------------------------------------------*/
void NewsDataDeleteGroup(word index)
{
    word numThreads ;

    NewsDataLock() ;

    ECValidateGroupIndex(index) ;

    /* Make sure nothing is locked */
    NewsDataThreadSelectArticle(NEWS_DATA_ARTICLE_NONE) ;
    NewsDataGroupSelectThread(NEWS_DATA_THREAD_NONE) ;
    NewsDataSelectGroup(index) ;

    /* First, we need to delete all the threads */
    numThreads = NewsDataGroupCountThreads() ;

    /* Delete the threads in reverse */
    while (numThreads)  {
        NewsDataGroupDeleteThread(--numThreads) ;
    }

    /* Get rid of the threads array */
    BucketHugeArrayDestroy(G_databaseVMFH, G_group->NE_threadArray) ;
    /* ... hashing table ... */
    BucketHugeArrayDestroy(G_databaseVMFH, G_group->NE_articleHashArray) ;
    /* ... and articles */
    BucketHugeArrayDestroy(G_databaseVMFH, G_group->NE_articleArray) ;

    NewsDataSelectGroup(NEWS_DATA_NEWSGROUP_NONE) ;

    /* Now that all the threads are deleted, delete the actual entry */
    BucketHugeArrayDelete(
        G_databaseVMFH,
        G_mapBlock->DMB_subscribedArray,
        1,
        index) ;

    NewsDataUnlock() ;

    BucketHugeArraySave();
    VMSave(G_databaseVMFH) ;
}

/*-------------------------------------------------------------------------
 | Routine:  NewsDataGroupDeleteThread
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Delete a thread in the currently selected newsgroup.
 |
 | Inputs:
 |    word index                  -- Index to thread to destroy
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/10/98  Created
 |
 *-----------------------------------------------------------------------*/
void NewsDataGroupDeleteThread(word index)
{
    word numArticles ;

    ECValidateThreadIndex(index) ;

    /* Make sure nothing is locked */
    NewsDataThreadSelectArticle(NEWS_DATA_ARTICLE_NONE) ;
    NewsDataGroupSelectThread(index) ;

    /* First, we need to delete all the articles */
    numArticles = NewsDataThreadCountArticles() ;

    /* Delete the articles in reverse */
    while (numArticles)  {
        NewsDataThreadDeleteArticle(--numArticles) ;
    }

    /* Get rid of the articles array */
    BucketHugeArrayDestroy(G_databaseVMFH, G_thread->TE_articleArray) ;

    NewsDataGroupSelectThread(NEWS_DATA_THREAD_NONE) ;

    /* Now that all the articles are deleted, delete the actual entry */
    BucketHugeArrayDelete(
        G_databaseVMFH,
        G_group->NE_threadArray,
        1,
        index) ;
}

/*-------------------------------------------------------------------------
 | Routine:  NewsDataThreadDeleteArticle
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Delete an article in the currently selected thread.
 |
 | Inputs:
 |    word index                  -- Index to thread to destroy
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/10/98  Created
 |
 *-----------------------------------------------------------------------*/
void NewsDataThreadDeleteArticle(word index)
{
	NewsUniqueID articleID ;
	dword hashValue ;

    ECValidateArticleIndex(index) ;

    /* Make sure nothing is locked */
    NewsDataThreadSelectArticle(index) ;

    /* Get rid of all associated data */
    BucketHugeArrayDestroy(G_databaseVMFH, G_article->AE_headers) ;
    BucketHugeArrayDestroy(G_databaseVMFH, G_article->AE_body) ;

    if(!(G_article->AE_flags & AEF_READ))
    {
        G_group->NE_unread -- ;
        BucketHugeArrayDirty(G_group) ;
        G_thread->TE_unread -- ;
        BucketHugeArrayDirty(G_thread) ;
    }

	articleID = G_article->AE_articleID ;
	hashValue = G_article->AE_hashValue ;

    NewsDataThreadSelectArticle(NEWS_DATA_THREAD_NONE) ;

	/* remove the article from the article list */
    BucketHugeArrayDelete(
        G_databaseVMFH,
        G_group->NE_articleArray,
        1,
        IArticleIDToIndex(articleID)) ;

	/* remove the article from the article hash list */
    BucketHugeArrayDelete(
        G_databaseVMFH,
        G_group->NE_articleHashArray,
        1,
        IFindArticleWithHash(0, articleID, hashValue)) ;

    /* Now that all the articles are deleted, delete the actual entry */
    BucketHugeArrayDelete(
        G_databaseVMFH,
        G_thread->TE_articleArray,
        1,
        index) ;
}

/*-------------------------------------------------------------------------
 | Routine:  NewsDataThreadGetName
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Determine the name of the current thread
 |
 | Inputs:
 |    char *p_name                -- Pointer to name
 |    word len                    -- Available space for string
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/10/98  Created
 |    LES  11/12/98  Made thread names not start with Re:
 |
 *-----------------------------------------------------------------------*/
void NewsDataThreadGetName(char *p_name, word len)
{
    ArticleEntry *p_article ;
    char *p_line ;
    word offset ;

    /* Results differ based on the number of articles */
    if (NewsDataThreadCountArticles() == 0)  {
        p_line = NULL ;
        p_article = NULL ;
    } else {
        /* Thread name is always first article's subject */
        p_article = NewsDataArticleLock(0) ;
        p_line = NewsDataLockArticleHeaderLine(p_article, "Subject:") ;
        NewsDataArticleUnlock(p_article) ;
    }

    if (p_line)  {
        /* Use the subject line found (past Subject:), then unlock */
        /* And strip off any Re: on the thread name */
        offset = 9 ;
        if ((toupper((byte) p_line[9]) == 'R') &&
            (toupper((byte) p_line[10]) == 'E') &&
            (p_line[11] == ':') &&
            (p_line[12] == ' '))
            offset = 13 ;
        strncpy(p_name, p_line+offset, len) ;
        NewsDataUnlockHeaderLine(p_line) ;
    } else {
        /* If no subject (or no articles), use the same default text */
        MemLock(OptrToHandle(@UntitledThread)) ;
        p_line = LMemDeref(@UntitledThread) ;
        MemUnlock(OptrToHandle(@UntitledThread)) ;
        strncpy(p_name, p_line, len) ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  NewsDataArticleAppendHeadersToText
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Add all the headers of the current article to the text object
 |
 | Inputs:
 |    optr text                   -- Text object to receive text
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/12/98  Created
 |
 *-----------------------------------------------------------------------*/
void NewsDataArticleAppendHeadersToText(optr text)
{
    IAppendTextWithPrefix(text, "Subject: ") ;
    IAppendTextWithPrefix(text, "From: ") ;
    IAppendTextWithPrefix(text, "Date: ") ;
//    IAppendTextWithPrefix(text, "Message-ID: ") ;
//    IAppendTextWithPrefix(text, "References: ") ;
//    @call text::MSG_VIS_TEXT_APPEND_PTR("\r", 1) ;
}

/*-------------------------------------------------------------------------
 | Routine:  NewsDataArticleAppendBodyToText
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Add all the body lines of the current article to the text object
 |
 | Inputs:
 |    optr text                   -- Text object to receive text
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/12/98  Created
 |
 *-----------------------------------------------------------------------*/
void NewsDataArticleAppendBodyToText(optr text)
{
    dword start, end ;

    start = 0 ;
    end = BucketHugeArrayGetCount(G_databaseVMFH, 
                                       G_article->AE_body) ;

    if(G_article->AE_flags & AEF_PARSED) {
        
        start = G_article->AE_separationLine ;
    
    } 

    if(start <= end) {

        IAppendText(text, G_article->AE_body, start, end) ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  IAppendText
 *-------------------------------------------------------------------------
 |
 | Description:
 |    All all the lines of a bucket huge array to the given text object
 |
 | Inputs:
 |    optr text                   -- Text object to receive text
 |    BucketHugeArrayHandle linesArray -- Huge array of null terminated lines
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/12/98  Created
 |
 *-----------------------------------------------------------------------*/
void IAppendText(optr text, BucketHugeArrayHandle linesArray,
            dword start, dword end)
{
    dword count ;
    dword lineNum ;
    char *p_line ;
    word len ;

    count = end - start ;
    lineNum = start ;
    while(count--)  {
        BucketHugeArrayLock(
            G_databaseVMFH,
            linesArray,
	        lineNum,
            (void**)&p_line,
            &len);

        if(len - 1) {

            @call text::MSG_VIS_TEXT_APPEND_PTR(p_line, len-1) ;
        }

        BucketHugeArrayUnlock(p_line) ;

        @call text::MSG_VIS_TEXT_APPEND_PTR("\r", 1) ;
        lineNum++ ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  IAppendTextWithPrefix
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Find the header with a given prefix and append it.
 |    Use the current article.
 |
 | Inputs:
 |    optr text                   -- Text object to receive text
 |    char *p_prefix              -- Prefix to find
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/12/98  Created
 |
 *-----------------------------------------------------------------------*/
void IAppendTextWithPrefix(optr text, char *p_prefix)
{
    char *p_line ;

    p_line = NewsDataLockArticleHeaderLine(G_article, p_prefix) ;
    if (p_line)  {
        @call text::MSG_VIS_TEXT_APPEND_PTR("\t", 1) ;
        @call text::MSG_VIS_TEXT_APPEND_PTR(p_prefix, strlen(p_prefix)) ;
        @call text::MSG_VIS_TEXT_APPEND_PTR(p_line + strlen(p_prefix), 0) ;
        @call text::MSG_VIS_TEXT_APPEND_PTR("\r", 1) ;
        NewsDataUnlockHeaderLine(p_line) ;
    }
}

/*-------------------------------------------------------------------------
 | Routine:  NewsDataArticleAppendBodyText
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Add one line of text to the current article
 |
 | Inputs:
 |    char *p_text                -- Line to add
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/12/98  Created
 |
 *-----------------------------------------------------------------------*/
void NewsDataArticleAppendBodyText(char *p_text)
{
    word len = strlen(p_text) + 1 ;
    ECValidateArticlePtr(G_article) ;

    /* Append the string to the end */
    BucketHugeArrayAppend(
        G_databaseVMFH,
        G_article->AE_body,
        len,
        p_text) ;
}

/*-------------------------------------------------------------------------
 | Routine:  NewsDataArticleMarkRead
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Add one line of text to the current article
 |
 | Inputs:
 |    char *p_text                -- Line to add
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/12/98  Created
 |
 *-----------------------------------------------------------------------*/
void NewsDataArticleMarkRead(word articleIndex)
{
    ECValidateArticleIndex(articleIndex) ;

    /* Make sure nothing is locked */
    NewsDataThreadSelectArticle(articleIndex) ;
   
    if(!(G_article->AE_flags & AEF_READ))
    {
        G_article->AE_flags |= AEF_READ;

        G_group->NE_unread -- ;
        BucketHugeArrayDirty(G_group) ;
        G_thread->TE_unread -- ;
        BucketHugeArrayDirty(G_thread) ;

        NewsDataArticleDirty(G_article);
    }

    NewsDataThreadSelectArticle(NEWS_DATA_THREAD_NONE) ;
}

/*-------------------------------------------------------------------------
 | Routine:  NewsDataCreateGroup
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Create a new newsgroup with given name.
 |
 | Inputs:
 |    char *p_name                -- Name to use for newsgroup.
 |    Boolean doErrorMsg          -- TRUE if want error messages.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/06/98  Created
 |
 *-----------------------------------------------------------------------*/
word NewsDataCreateGroup(char *p_name, Boolean doErrorMsg)
{
    NewsgroupEntry *checkGroup;
    word count;
    word subcount ;
    Boolean found = FALSE ;
    word newIndex = NEWS_DATA_NEWSGROUP_NONE ;
    NewsgroupEntryBuffer newGroup ;

    NewsDataLock() ;

    /* Check if the group is already on the list and report an error if */
    /* it already is. */
    subcount = NewsDataCountNewsgroups() ;

    /* Are we past the limit? */
    if (subcount < MAX_SUBSCRIBED_NEWSGROUPS)  {
        for (count = 0; count < subcount; count++) {

            checkGroup = NewsDataGroupLock(count) ;
            if (strcmp(p_name, checkGroup->NE_groupName) == 0) {

                found = TRUE ;

                if (doErrorMsg)  {
                    ErrorMessage(@ErrorAlreadySubscribed);
                }
                NewsDataGroupUnlock(checkGroup) ;
                break;
            }
            NewsDataGroupUnlock(checkGroup) ;
        }

        if (!found)  {
            /* Didn't find a duplicate */

            /* Create a new message list array */
            /* Initialize the NewsgroupEntry data structure */
            memset(&newGroup, 0, sizeof(newGroup)) ;
            strncpy(
                newGroup.NEB_header.NE_groupName,
                p_name,
                MAX_GROUP_NAME_SIZE) ;

            /* Create an empty array of threads */
            newGroup.NEB_header.NE_threadArray = BucketHugeArrayCreate(
                G_databaseVMFH,
                sizeof(ThreadEntry),
                0);

            /* Create an empty array of articles */
            newGroup.NEB_header.NE_articleArray = BucketHugeArrayCreate(
                G_databaseVMFH,
                sizeof(ArticleEntry),
                0);

            /* Create the hash search table */
            newGroup.NEB_header.NE_articleHashArray = BucketHugeArrayCreate(
                G_databaseVMFH,
                sizeof(ArticleHashEntry),
                0);

            /* Append the new entry to the end of the subscription list */
            newIndex = BucketHugeArrayAppend(
                           G_databaseVMFH,
                           G_mapBlock->DMB_subscribedArray,
                           sizeof(NewsgroupEntry) +
                               strlen(newGroup.NEB_header.NE_groupName) + 1,
                           &newGroup);
        }

    } else {
        /* We are past the limit, report an error (if needed) */
        if (doErrorMsg)
            ErrorMessage(@ErrorTooManySubscribed);
    }

    NewsDataUnlock() ;

    return newIndex ;
}

/*-------------------------------------------------------------------------
 | Routine:  NewsDataClearUnsubGroups
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Clear the unsubscribed groups list.
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/10/98  Created
 |
 *-----------------------------------------------------------------------*/
void NewsDataClearUnsubGroups(void)
{
    NewsDataLock() ;

    /* Destroy the old one */
    BucketHugeArrayDestroy(G_databaseVMFH, G_mapBlock->DMB_groupsArray) ;

    /* Create a new one and mark the map block changed */
    G_mapBlock->DMB_groupsArray = BucketHugeArrayCreate(G_databaseVMFH, 0, 0) ;
    VMDirty(G_mapBlockMem) ;
    NewsDataUnlock() ;
}

#ifdef DEBUG
/*-------------------------------------------------------------------------
 | Routine:  ECValidateGroupIndex                           * INTERNAL *
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Determines if an group index is valid for the listing.  EC error
 |    if it is not.
 |
 | Inputs:
 |    word groupIndex             -- Group index #
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/06/98  Created
 |
 *-----------------------------------------------------------------------*/
void ECValidateGroupIndex(word groupIndex)
{
    EC_ERROR_IF(
        groupIndex >= NewsDataCountNewsgroups(),
        ERROR_NEWS_DATA_BAD_GROUP_INDEX) ;
}

/*-------------------------------------------------------------------------
 | Routine:  ECValidateUnsubGroupIndex                      * INTERNAL *
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Determines if an group index is valid for the listing.  EC error
 |    if it is not.
 |
 | Inputs:
 |    word groupIndex             -- Group index #
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/06/98  Created
 |
 *-----------------------------------------------------------------------*/
void ECValidateUnsubGroupIndex(word groupIndex)
{
    EC_ERROR_IF(
        groupIndex >= NewsDataCountUnsubNewsgroups(),
        ERROR_NEWS_DATA_BAD_GROUP_INDEX) ;
}

/*-------------------------------------------------------------------------
 | Routine:  ECValidateGroupPtr                             * INTERNAL *
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Check if the pointer to a group is valid.
 |
 | Inputs:
 |    NewsgroupEntry *p_group     -- Group pointer
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/06/98  Created
 |
 *-----------------------------------------------------------------------*/
void ECValidateGroupPtr(NewsgroupEntry *p_group)
{
    EC_ERROR_IF(p_group==NullHandle, ERROR_NEWS_DATA_GROUP_IS_NULL) ;
}

/*-------------------------------------------------------------------------
 | Routine:  ECValidateThreadIndex                          * INTERNAL *
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Determines if a thread index is valid for the current group.  EC error
 |    if it is not.
 |
 | Inputs:
 |    word groupIndex             -- Thread index #
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/06/98  Created
 |
 *-----------------------------------------------------------------------*/
void ECValidateThreadIndex(word threadIndex)
{
    EC_ERROR_IF(
        threadIndex >= NewsDataGroupCountThreads(),
        ERROR_NEWS_DATA_BAD_THREAD_INDEX) ;
}

/*-------------------------------------------------------------------------
 | Routine:  ECValidateThreadPtr                            * INTERNAL *
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Determines if a thread ptr is valid for the current group.  EC error
 |    if it is not.
 |
 | Inputs:
 |    ThreadEntry *p_thread       -- Pointer to a thread entry
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/06/98  Created
 |
 *-----------------------------------------------------------------------*/
void ECValidateThreadPtr(ThreadEntry *p_thread)
{
    EC_ERROR_IF(
        p_thread == NullHandle,
        ERROR_NEWS_DATA_THREAD_IS_NULL) ;
}

/*-------------------------------------------------------------------------
 | Routine:  ECValidateArticlePtr                           * INTERNAL *
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Checks to see if the current article pointed at is valid.
 |
 | Inputs:
 |    ArticleEntry *p_article     -- Pointer to an article entry
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/06/98  Created
 |
 *-----------------------------------------------------------------------*/
void ECValidateArticlePtr(ArticleEntry *p_article)
{
    EC_ERROR_IF(p_article==NULL, ERROR_NEWS_DATA_ARTICLE_IS_NULL) ;
    EC_ERROR_IF(
        p_article->AE_headers==INDEX_BAD,
        ERROR_NEWS_DATA_ARTICLE_HAS_NO_HEADERS) ;
}

/*-------------------------------------------------------------------------
 | Routine:  ECValidateArticleIndex                         * INTERNAL *
 *-------------------------------------------------------------------------
 |
 | Description:
 |    Determines if a article index is valid for the current thread.
 |    EC error if it is not.
 |
 | Inputs:
 |    word articleIndex             -- Article index
 |
 | Revision History:
 |    Who  Date:     Comments:
 |    ---  --------  ---------
 |    LES  11/06/98  Created
 |
 *-----------------------------------------------------------------------*/
void ECValidateArticleIndex(word articleIndex)
{
    EC_ERROR_IF(
        articleIndex >= NewsDataThreadCountArticles(),
        ERROR_NEWS_DATA_BAD_ARTICLE_INDEX) ;
}

#endif

