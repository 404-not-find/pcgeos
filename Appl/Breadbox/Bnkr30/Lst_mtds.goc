
/**************************************************************
 *  ==CONFIDENTIAL INFORMATION==
 *  COPYRIGHT 1994-2000 BREADBOX COMPUTER COMPANY --
 *  ALL RIGHTS RESERVED  --
 *  THE FOLLOWING CONFIDENTIAL INFORMATION IS BEING DISCLOSED TO YOU UNDER A
 *  NON-DISCLOSURE AGREEMENT AND MAY NOT BE DISCLOSED OR FORWARDED BY THE
 *  RECIPIENT TO ANY OTHER PERSON OR ENTITY NOT COVERED BY THE SAME
 *  NON-DISCLOSURE AGREEMENT COVERING THE RECIPIENT. USE OF THE FOLLOWING
 *  CONFIDENTIAL INFORMATION IS RESTRICTED TO THE TERMS OF THE NON-DISCLOSURE
 *  AGREEMENT.
 **************************************************************/

/*
 **************************************************************************
 *  FILE:			lst_mtds.goc
 *  PROJECT:		GPC Banker
 *  DESCRIPTION:	This file has methods for the cat and pay pick list
 *				functions
 **************************************************************************
 */
/*
 ***************************************************************************
 *		Include files
 ***************************************************************************
 */

@include "bnkr30.goh"
@include "externs.goh"

/*
 ***************************************************************************
 *		Class & Message Definitions
 ***************************************************************************
 */

/* class defined in bnkr.goh */
@classdecl	CatPayGenInteractionClass;
@classdecl	NewPayGenInteractionClass;



/****************************************************************************
 *		Code for GPCBnkrProcessClass cat & pay list stuff
 ***************************************************************************
 */

/***********************************************************************
 *
 * FUNCTION:	DeleteCategory(char newCatName[ENTRY_SIZE])
 *
 * CALLED BY:	MSG_DELETE_CATEGORY, MSG_MODIFY_CATEGORY
 *
 * STRATEGY:
 *
 *
 ***********************************************************************/
 void DeleteCategory(char newCatName[ENTRY_SIZE])
{
MemHandle		mh;
CatPickStruct	*pickElement;
VMBlockHandle	vmbh;
VMMapStruct	*VMmapPtr;
char			oldCatName[ENTRY_SIZE];
char			parentCatName[CAT_SIZE];
char			catName[ENTRY_SIZE];
AcctStruct	*account;
TransStruct	*trans;
DBItem		transItem;
DBGroup		acctgroup;
DBMapStruct*	mapPtr; 
word           i, j, k, acctNumTrans;
word			length, numSubs, whileNumSubs;
TransSortStruct	*trArrayElement;
Boolean		isSub;


    /* get the current Cat */
    catListVMBHandle = VMFind(GPCBnkrFile, NullHandle, CATLIST);
    VMLock(GPCBnkrFile, catListVMBHandle ,&mh);
    pickElement = ChunkArrayElementToPtrHandles(
		   mh,
		   catListChunkArray,
		   currentCat,
		   0);
    strcpy(oldCatName, pickElement->CPS_category);
    numSubs = pickElement->CPS_numSubs;
    if (pickElement->CPS_isSub) {
	  strcpy(parentCatName, pickElement->CPS_subOf);
	  isSub = TRUE;
	  }
    else isSub = FALSE;
    /* delete this cat */
    ChunkArrayDeleteHandle(catListChunkArray, pickElement);
    VMDirty(mh);
    VMUnlock(mh);
    catNumItems--;
    /* if a cat w/subs delete the subs */
    if (numSubs)  {
	  for (i = 0; i < numSubs; i++)  {
		catListVMBHandle = VMFind(GPCBnkrFile, NullHandle, CATLIST);
		VMLock(GPCBnkrFile, catListVMBHandle ,&mh);
		pickElement = ChunkArrayElementToPtrHandles(
					mh,
					catListChunkArray,
					currentCat,
					0);
		ChunkArrayDeleteHandle(catListChunkArray, pickElement);
		VMDirty(mh);
		VMUnlock(mh);
		catNumItems--;
		}
	  }  /* end of deleting sub cats of parent if */
    /* if a subcat then we need to adjust the parent's numSubs */
    if (isSub)  {
	  catListVMBHandle = VMFind(GPCBnkrFile, NullHandle, CATLIST);
	  VMLock(GPCBnkrFile, catListVMBHandle ,&mh);
	  /* back  up until we see a number in CPS_numSubs */
	  i = currentCat;
	  whileNumSubs = numSubs;
	  while (!whileNumSubs)  {
		pickElement = ChunkArrayElementToPtrHandles(
					mh,
					catListChunkArray,
					i,
					0);
		whileNumSubs = pickElement->CPS_numSubs;
		i--;
		}
	  /* OK - got it */
	  i++;
	  pickElement = ChunkArrayElementToPtrHandles(
				mh,
				catListChunkArray,
				i,
				0);
	  (pickElement->CPS_numSubs)--;
	  VMDirty(mh);
	  VMUnlock(mh);
	  } /* end of fixing parent's numSubs if */

    /* now adjust the cat name string to reflect what is stored in the
	* transaction's cat field */
    if (isSub)  {
	  strcpy(catName, parentCatName);
	  strcat(catName, ":");
	  strcat(catName, oldCatName);
	  }
    else if (numSubs) {
	  strcpy(catName, oldCatName);
	  strcat(catName, ":");
	  }
    else  strcpy(catName, oldCatName);

    /* now on to the fun of going thru all the transactions
	* IN ALL THE ACCOUNTS IN THIS FILE!!! */
    for (k = 0; k < numAccounts; k++)  {
       /* Normal db setup */
	  mapPtr = DBLockMap(GPCBnkrFile);
       account = (AcctStruct *) (mapPtr + sizeof(DBMapStruct));
       acctgroup = account[k].AS_group;
       /* get the # trans in this acct */
	  acctNumTrans = account[k].AS_numTrans;
       DBUnlock(mapPtr);

       /* cycle thru the index elements */
	  for (i=0; i<acctNumTrans; i++)  {
          /* get the index array VMBlock */
		transListVMBHandle = VMFind(GPCBnkrFile, NullHandle, (k*10)+ALLSORT);
          VMLock(GPCBnkrFile, transListVMBHandle, &mh);
          /* get the ith element info */
		trArrayElement = ChunkArrayElementToPtrHandles(
		   mh,
		   transListChunkArray,
		   i,
		   0);
		transItem = trArrayElement->TSS_item;
          VMUnlock(mh);

		/* Get the selected transaction */
		trans = DBLock(GPCBnkrFile, acctgroup, transItem);
		/* get the comparison length */
		if (numSubs)  {
		   /* we're dealing all the sub cats too so just compare till the : */
		   length = strlen(catName);
		   }
		else  { /* get the longer */
		   if (strlen(trans->TS_category) >= strlen(catName))
			    length = strlen(trans->TS_category);
		   else length = strlen(catName);
		   }

		/* is it one we want to change? */
		if (!LocalCmpStringsNoCase(trans->TS_category, catName, length))  {
		   /* delete the cat from the trans info */
		   if (!newCatName[0]) trans->TS_category[0] = 0;
		   else {
			 /* change the cat in the trans info */
			 if (!isSub && !numSubs) strcpy(trans->TS_category, newCatName);
			 else if (numSubs)  {
			    strcpy(oldCatName, trans->TS_category);
			    /* save the sub-cat name */
			    j = 0;
			    while (oldCatName[j] != ':') j++;
			    strcpy(trans->TS_category, newCatName);
			    strcat(trans->TS_category, ":");
			    strcat(trans->TS_category, &oldCatName[j + 1]);
			    }
			 else {
			    strcpy(trans->TS_category, parentCatName);
			    strcat(trans->TS_category, ":");
			    strcat(trans->TS_category, newCatName);
			    }
			 }
             DBDirty(trans);
		   }

          DBUnlock(trans);
		}  /* end of cycle through transactions for */
	  }  /* end of cycle through accounts for */

    /* put the new number of items into the map */
    vmbh = VMGetMapBlock(GPCBnkrFile);
    VMmapPtr = VMLock(GPCBnkrFile, vmbh, &mh);
    VMmapPtr->MS_catNumber = catNumItems;
    VMDirty(mh);
    VMUnlock(mh);

    /* init the register dlist to show the changes in cat names */
    if (numTrans > DEFAULT_LIST_LINES-1)
	  @send RegisterDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(numTrans);
    else
	  @send RegisterDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(DEFAULT_LIST_LINES);

}

/***********************************************************************
 *
 * MESSAGE:	MSG_OPEN_MODIFY_CATEGORY for GPCBnkrProcessClass
 *
 * DESCRIPTION:	Calls the open new cat or sub-cat
 *                  depending on the list selection
 *
 *              
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_OPEN_MODIFY_CATEGORY
{
MemHandle		mh;
CatPickStruct	*pickElement;
Boolean		isSub;


    catListVMBHandle = VMFind(GPCBnkrFile, NullHandle, CATLIST);
    VMLock(GPCBnkrFile, catListVMBHandle ,&mh);
    pickElement = ChunkArrayElementToPtrHandles(
				mh,
				catListChunkArray,
				currentCat,
				0);
    isSub = pickElement->CPS_isSub;
    VMUnlock(mh);

    if (!isSub)  @send process::MSG_OPEN_NEW_CATEGORY(@CatModify);
    else  @send process::MSG_OPEN_NEW_SUBCATEGORY(@CatModify);

}

/***********************************************************************
 *
 * MESSAGE:	MSG_OPEN_SELECT_CATEGORIES for GPCBnkrProcessClass
 *
 * DESCRIPTION:	Calls the dialog box when the menu
 *                  item is selected
 *                called by cat button on form, cat menu item, and
 *                  cat button on new payee form
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_OPEN_SELECT_CATEGORIES
{
word		length;
char		catString[ENTRY_SIZE];


    /* save who opened us */
	 catSelOpenedBy = trigger;

	 if (trigger == @NEFCatButton) {
		 length = @call NEFCatText::MSG_VIS_TEXT_GET_ALL_PTR(catString);
		 if (length) {
			 MemLock (OptrToHandle(@MultCatText));
			 if (!strcmp(LMemDeref(@MultCatText), catString)) {
				 /* the user is trying to make a multi into a single cat */
				 if (AckDBox(0, 0, @MultiToSingleCatMsg) == ACK_NO) {
					 MemUnlock (OptrToHandle(@MultCatText));
					 return;
					 }
				 else  {
					 @send NEFCatText::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
					 @send NEFCatText::MSG_GEN_SET_ATTRS(0, GA_READ_ONLY);
					 @send NEFCatText::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
                }
				 }
			 MemUnlock (OptrToHandle(@MultCatText));
			 }
		 }
                        
    /* disable reply group (except new) until something is selected */
    @send CatUse::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @send CatModify::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @send CatDelete::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @send CatNewSub::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);

    /* and set the d list to no selections */
    @send CatDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(catNumItems);
    @send CatDList::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(FALSE);
    newCatSel = GIGS_NONE;
    currentCat = GIGS_NONE;


    /* Open the dialog box */
    @call CatListGroup::MSG_GEN_INTERACTION_INITIATE();

    /* show add dbox if a cat has been entered in our caller */
    if (trigger != @CatTrigger)  {
	  if (trigger == @NPCatButton)
		length = @call NPCat::MSG_VIS_TEXT_GET_ALL_PTR(catString);
	  else
		length = @call NEFCatText::MSG_VIS_TEXT_GET_ALL_PTR(catString);
	  if (length)  {
		CheckIsNewCat(catString);
		}
	  }

}

/***********************************************************************
 *
 * MESSAGE:	MSG_USE_CATEGORY for GPCBnkrProcessClass
 *
 * DESCRIPTION:	 
 *              
 *     
 *              
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_USE_CATEGORY
{
MemHandle		mh;
CatPickStruct	*pickElement;
char		pickString[ENTRY_SIZE];


    /* get our list's block using its ID # */
    catListVMBHandle = VMFind(GPCBnkrFile, NullHandle, CATLIST);
    VMLock(GPCBnkrFile, catListVMBHandle ,&mh);
    pickElement = ChunkArrayElementToPtrHandles(
		   mh,
		   catListChunkArray,
		   currentCat, 
		   0);
    if (pickElement->CPS_isSub) {
	  strcpy(pickString, pickElement->CPS_subOf);
	  strcat(pickString, ":");
	  strcat(pickString, pickElement->CPS_category);
	  }
    else strcpy(pickString, pickElement->CPS_category);
    VMUnlock(mh);

	 if (catSelOpenedBy == @NPCatButton)
	  @call NPCat::MSG_VIS_TEXT_REPLACE_ALL_PTR(pickString, 0);
	 else
	  @call NEFCatText::MSG_VIS_TEXT_REPLACE_ALL_PTR(pickString, 0);

    /* set the d list to no selections */
    @send CatDList::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(FALSE);
    newCatSel = GIGS_NONE;
    /* disable the use button */
    @send CatUse::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    /* close dbox if ini set to */
	 if (closeOnUse) {
		 @send CatListGroup::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
	  	 @send NewEntryDBox::MSG_META_GRAB_FOCUS_EXCL(); 
	 if (catSelOpenedBy == @NPCatButton)
	  @send NPCat::MSG_META_GRAB_FOCUS_EXCL();
	 else
	  @send NEFCatText::MSG_META_GRAB_FOCUS_EXCL();
		 }

}

/***********************************************************************
 *
 * MESSAGE:	MSG_OPEN_NEW_CATEGORY for GPCBnkrProcessClass
 *
 * DESCRIPTION:	Calls the dialog box when the trigger
 *                  item is selected
 *
 *              
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_OPEN_NEW_CATEGORY
{
char			pickString[ENTRY_SIZE];
MemHandle		mh;
CatPickStruct	*pickElement;


    if (trigger == @CatNew)  {
	  /* put in the right title and button */
	  MemLock (OptrToHandle(@NewCatMoniker));
	  @call NewCatDBox::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@NewCatMoniker),
			   VUM_DELAYED_VIA_APP_QUEUE);
	  @call NCCancel::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@CancelMoniker),
			   VUM_DELAYED_VIA_APP_QUEUE);
	  MemUnlock (OptrToHandle(@NewCatMoniker));
	  @send NCEnter::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	  @send ModCEnter::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);

	  @call NEFCatText::MSG_VIS_TEXT_GET_ALL_PTR(pickString);
	  @call NCName::MSG_VIS_TEXT_REPLACE_ALL_PTR(pickString, 0);
	  @send NCClass::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(CTYPE_EXP, FALSE);
	  }
    else {
	  /* put in the right title and button */
	  MemLock (OptrToHandle(@ModCatMoniker));
	  @call NewCatDBox::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@ModCatMoniker),
			   VUM_DELAYED_VIA_APP_QUEUE);
	  @call NCCancel::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@DontChangeMoniker),
			   VUM_DELAYED_VIA_APP_QUEUE);
	  MemUnlock (OptrToHandle(@ModCatMoniker));
	  @send NCEnter::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	  @send ModCEnter::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	  
	  /* get our list's block using its ID # */
	  catListVMBHandle = VMFind(GPCBnkrFile, NullHandle, CATLIST);
	  VMLock(GPCBnkrFile, catListVMBHandle ,&mh);
	  pickElement = ChunkArrayElementToPtrHandles(
				mh,
				catListChunkArray,
				currentCat,
				0);
	  @call NCName::MSG_VIS_TEXT_REPLACE_ALL_PTR(pickElement->CPS_category, 0);
	  @call NCClass::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(
					  pickElement->CPS_type, FALSE);
	  VMUnlock(mh);
	  }

    /* Open the dialog box */
    @call NewCatDBox::MSG_GEN_INTERACTION_INITIATE();

}

/***********************************************************************
 *
 * MESSAGE:	MSG_NEW_CATEGORY for GPCBnkrProcessClass
 *
 * DESCRIPTION:	Creates a new category.
 *
 * STRATEGY:    
 *              
 *              
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_NEW_CATEGORY
{
char			pickString[ENTRY_SIZE], parentString[CAT_SIZE];
word			type, i;
Boolean		isDupe = FALSE;
MemHandle		mh;
CatPickStruct	*pickElement;
Boolean		hasColon = FALSE;


	 /* colon warning */
	 if (trigger == @NCEnter)
		 @call NCName::MSG_VIS_TEXT_GET_ALL_PTR(pickString);
	 else
		 @call NSCName::MSG_VIS_TEXT_GET_ALL_PTR(pickString);
	 for (i = 0; i < strlen(pickString); i++)  {
		 if (pickString[i] == ':') hasColon = TRUE;
		 }
	 if (hasColon) {
		 NotifyDBox(0, @ColonWarnMsg);
		 return;
		 }

	 /* are we adding a new cat or a new sub-cat */
	 if (trigger == @NCEnter)  {
	  @call NCName::MSG_VIS_TEXT_GET_ALL_PTR(pickString);
	  type = @call NCClass::MSG_GEN_ITEM_GROUP_GET_SELECTION();
	  strcpy(parentString, "");
	  }
	 else  {  /* sub cat */
	  @call NSCName::MSG_VIS_TEXT_GET_ALL_PTR(pickString);
	  catListVMBHandle = VMFind(GPCBnkrFile, NullHandle, CATLIST);
	  VMLock(GPCBnkrFile, catListVMBHandle ,&mh);
	  pickElement = ChunkArrayElementToPtrHandles(
				mh,
				catListChunkArray,
				currentCat,
				0);
	  strcpy(parentString, pickElement->CPS_category);
	  type = pickElement->CPS_type;
	  VMUnlock(mh);
	  }

    /* add it or find out it's a dupe */
    isDupe = AddCatCheck(pickString, parentString, type);

    /* was it a dupe? */
    if (isDupe)  {
       /* tell the user and bail */
	  NotifyDBox(0, @DupeCatMsg);
	  return;
       }

    /* it's OK: inc numcats, save to VMBlock map & update cat lists */
    AddCatOK();

}

/***********************************************************************
 *
 * MESSAGE:	MSG_MODIFY_CATEGORY for GPCBnkrProcessClass
 *
 * DESCRIPTION:	Modifies a category and changes that cat name in 
 *              all transactions affected in all accounts in the file!
 * STRATEGY:    
 *              
 *              
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_MODIFY_CATEGORY
{
MemHandle		mh, tempHeapHandle;
CatPickStruct	*pickElement, *tempElement;
char			oldCatName[ENTRY_SIZE], newCatName[ENTRY_SIZE];
char			parentCatName[CAT_SIZE];
Boolean		isDupe, isSub;
word			type, numSubs, i, reAddedCat;
ChunkHandle    tempChunkArray;


    /* get the new cat name */
    if (trigger == @ModCEnter)  {
	  @call NCName::MSG_VIS_TEXT_GET_ALL_PTR(newCatName);
	  if (!strlen(newCatName)) return;
	  type = @call NCClass::MSG_GEN_ITEM_GROUP_GET_SELECTION();
	/*  isDupe = AddCatCheck(newCatName, "", type); */
	  isDupe = CatThere(newCatName);
	  /* was it a dupe? */
	  if (isDupe)  {
		/* tell the user and bail */
		NotifyDBox(0, @DupeCatMsg);
		return;
		}


	  @send NewCatDBox::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
	  isSub = FALSE;
	  }
    else  {
	  @call NSCName::MSG_VIS_TEXT_GET_ALL_PTR(newCatName);
	  if (!strlen(newCatName)) return;
	  @send NewSubCatDBox::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
	  isSub = TRUE;
	  }

	 /* get the old cat name */
    catListVMBHandle = VMFind(GPCBnkrFile, NullHandle, CATLIST);
    VMLock(GPCBnkrFile, catListVMBHandle ,&mh);
    pickElement = ChunkArrayElementToPtrHandles(
		   mh,
		   catListChunkArray,
		   currentCat,
		   0);
    strcpy(oldCatName, pickElement->CPS_category);
    numSubs = pickElement->CPS_numSubs;
	 if (isSub)  {
		 strcpy(parentCatName, pickElement->CPS_subOf);
		 type = pickElement->CPS_type;
		 }
    else  strcpy(parentCatName, "");
    VMUnlock(mh);

    /* put up do you wanna box */
    if (AckDBox(oldCatName, newCatName, @ModCatMsg) == ACK_NO) return;

    if (numSubs && !isSub)  {
	  /* save the subs to add back in since deleting parents deletes kids too */
	  /* create a mem block to hold the info temporarily */
	  tempHeapHandle = MemAlloc(
					1024,
					HF_SWAPABLE,
					HAF_LOCK);
	  LMemInitHeap(tempHeapHandle,
				   LMEM_TYPE_GENERAL,
				   0,
				   sizeof(LMemBlockHeader),
				   STD_INIT_HANDLES,
				   STD_INIT_HEAP);
	  /* create the chunk array  */
	  tempChunkArray = ChunkArrayCreate(
					tempHeapHandle,
					sizeof(CatPickStruct),
					0,
					0);  
	  MemUnlock(tempHeapHandle);
	  catListVMBHandle = VMFind(GPCBnkrFile, NullHandle, CATLIST);
	  VMLock(GPCBnkrFile, catListVMBHandle ,&mh);
	  MemLock(tempHeapHandle);
	  for (i = 0; i < numSubs; i++)  {
		pickElement = ChunkArrayElementToPtrHandles(
					mh,
					catListChunkArray,
					currentCat + i + 1,
					0);
		tempElement = ChunkArrayAppendHandles(
					   tempHeapHandle,
					   tempChunkArray,
					   0);
		/* put cat info into temp array */
		strcpy(tempElement->CPS_category, pickElement->CPS_category);
		tempElement->CPS_type = pickElement->CPS_type;
		/* and the unused */
		strcpy(tempElement->CPS_subOf, "");
		tempElement->CPS_numSubs = 0;
		tempElement->CPS_isSub = FALSE;
          tempElement->CPS_isSelected = FALSE;
		}
	  VMUnlock(mh);
	  MemUnlock(tempHeapHandle);
	  }

    /* delete the old from the cat list and change the existing cats */
    DeleteCategory(newCatName);

    /* add the new cat to the cat list */
    isDupe = AddCatCheck(newCatName, parentCatName, type);
    if (!isDupe)  AddCatOK();
    reAddedCat = currentCat;

    if (numSubs)  {
	  /* now add the kids back in */
	  for (i = 0; i < numSubs; i++)  {
		MemLock(tempHeapHandle);
		tempElement = ChunkArrayElementToPtrHandles(
					tempHeapHandle,
					tempChunkArray,
					i,
					0);
		isDupe = AddCatCheck(tempElement->CPS_category,
						 newCatName,
						 tempElement->CPS_type);
		if (!isDupe)  AddCatOK();
		MemUnlock(tempHeapHandle);
		}
	  MemFree(tempHeapHandle);
	  }


    /* disable the buttons */
    @send CatUse::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @send CatModify::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @send CatDelete::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @send CatNewSub::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);

    /* redraw the list */
    currentCat = reAddedCat;
    newCatSel = reAddedCat;
  /*  @call CatDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(catNumItems); */
    @call CatDList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(currentCat, FALSE);
    @call process::MSG_CAT_DLIST_MONIKER_QUERY(
						    @CatDList,
						    currentCat);

    /* and send the focus back to the cat dbox */
    @send CatListGroup::MSG_META_GRAB_FOCUS_EXCL();

}

/***********************************************************************
 *
 * MESSAGE:	MSG_DELETE_CATEGORY for GPCBnkrProcessClass
 *
 * DESCRIPTION:	Deletes a category and removes that cat name in
 *              all transactions affected in all accounts in the file!
 * STRATEGY:    if it is a cat with subs, delete all the subs too
 *
 *              
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_DELETE_CATEGORY
{
MemHandle		mh;
CatPickStruct	*pickElement;
char		oldCatName[ENTRY_SIZE];


    /* get the cat name */
    catListVMBHandle = VMFind(GPCBnkrFile, NullHandle, CATLIST);
    VMLock(GPCBnkrFile, catListVMBHandle ,&mh);
    pickElement = ChunkArrayElementToPtrHandles(
		   mh,
		   catListChunkArray,
		   currentCat,    
		   0);
    strcpy(oldCatName, pickElement->CPS_category);
    VMUnlock(mh);

    /* put up do you wanna box */
    if (AckDBox(oldCatName, 0, @DelCatMsg) == ACK_NO) return;

    /* delete it */
    DeleteCategory("");

    /* now update the cat lists */
    @send CatDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(catNumItems);
    @send AddMCatDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(catNumItems);
    @send CSDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(catNumItems);  

    currentCat = GIGS_NONE;
    newCatSel = GIGS_NONE;
    /* disable the buttons */
    @send CatUse::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @send CatModify::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @send CatDelete::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @send CatNewSub::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);

    /* and send the focus back to the cat dbox */
    @send CatListGroup::MSG_META_GRAB_FOCUS_EXCL();

}

/***********************************************************************
 *
 * MESSAGE:	MSG_OPEN_NEW_SUBCATEGORY for GPCBnkrProcessClass
 *
 * DESCRIPTION:	Calls the dialog box when the trigger
 *                  item is selected
 *
 *              
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_OPEN_NEW_SUBCATEGORY
{
MemHandle		mh;
CatPickStruct	*pickElement;


    /* fill out the text line */
    MemLock (OptrToHandle(@SubCatText));
    @call NSCText::MSG_VIS_TEXT_REPLACE_ALL_PTR(LMemDeref(@SubCatText), 0);
    MemUnlock (OptrToHandle(@SubCatText));
    catListVMBHandle = VMFind(GPCBnkrFile, NullHandle, CATLIST);
    VMLock(GPCBnkrFile, catListVMBHandle ,&mh);
    pickElement = ChunkArrayElementToPtrHandles(
				mh,
				catListChunkArray,
				currentCat,
				0);
    if (trigger == @CatNewSub)
	  @call NSCText::MSG_VIS_TEXT_APPEND_PTR(pickElement->CPS_category, 0);
    else  @call NSCText::MSG_VIS_TEXT_APPEND_PTR(pickElement->CPS_subOf, 0);
    VMUnlock(mh);
    @call NSCText::MSG_VIS_TEXT_APPEND_PTR("\".", 2);

    if (trigger == @CatNewSub)  {
	  /* put in the right title and button */
	  MemLock (OptrToHandle(@NewSubCatMoniker));
	  @call NewSubCatDBox::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@NewSubCatMoniker),
			   VUM_DELAYED_VIA_APP_QUEUE);
	  @call NSCCancel::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@CancelMoniker),
			   VUM_DELAYED_VIA_APP_QUEUE);
	  MemUnlock (OptrToHandle(@NewSubCatMoniker));
	  @send NSCEnter::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	  @send ModSCEnter::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);

	  @send NSCName::MSG_VIS_TEXT_DELETE_ALL();
	  }
    else {
	  /* put in the right title and button */
	  MemLock (OptrToHandle(@ModSubCatMoniker));
	  @call NewSubCatDBox::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@ModSubCatMoniker),
			   VUM_DELAYED_VIA_APP_QUEUE);
	  @call NSCCancel::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@DontChangeMoniker),
			   VUM_DELAYED_VIA_APP_QUEUE);
	  MemUnlock (OptrToHandle(@ModSubCatMoniker));
	  @send NSCEnter::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	  @send ModSCEnter::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	  
	  /* get our list's block using its ID # */
	  catListVMBHandle = VMFind(GPCBnkrFile, NullHandle, CATLIST);
	  VMLock(GPCBnkrFile, catListVMBHandle ,&mh);
	  pickElement = ChunkArrayElementToPtrHandles(
				mh,
				catListChunkArray,
				currentCat,
				0);
	  @call NSCName::MSG_VIS_TEXT_REPLACE_ALL_PTR(pickElement->CPS_category, 0);
	  VMUnlock(mh);
	  }

    /* Open the dialog box */
    @call NewSubCatDBox::MSG_GEN_INTERACTION_INITIATE();

}

/***********************************************************************
 *
 * MESSAGE:	MSG_CAT_DLIST_MONIKER_QUERY for GPCBnkrProcessClass
 *
 * DESCRIPTION:	Queries for monikers for categories list and the
 *                  reports select categories list
 *
 * PARAMETERS:  void (optr list, word item)
 *
 *
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_CAT_DLIST_MONIKER_QUERY
{
MemHandle		mh;
CatPickStruct	*pickElement;
char			pickString[ENTRY_SIZE];
Boolean		isSel;
Boolean		needLine = FALSE;
word			type;
ChunkHandle	chunk;
MemHandle		mem;
GStateHandle	gstate;
Point		checkPoints[5] =  {{2,6},
						   {5,10},
						   {9,1},
						   {5,7},
						   {2,6}};


    pickString[0] = 0;
    /* get our list's block using its ID # */
    catListVMBHandle = VMFind(GPCBnkrFile, NullHandle, CATLIST);
    VMLock(GPCBnkrFile, catListVMBHandle ,&mh);
    pickElement = ChunkArrayElementToPtrHandles(
						mh,
						catListChunkArray,
						item,
						0);
    type = pickElement->CPS_type;
    isSel = pickElement->CPS_isSelected;
    MemLock (OptrToHandle(@IncTitle));
    if ((LocalCmpStrings(LMemDeref(@IncTitle),
					pickElement->CPS_category,
					strlen(LMemDeref(@IncTitle))))
	  && (LocalCmpStrings(LMemDeref(@ExpTitle),
					  pickElement->CPS_category,
					  strlen(LMemDeref(@ExpTitle))))) {
	  if (pickElement->CPS_isSub) strcpy(pickString, "      ");
	  else strcpy(pickString, "   ");
	  }
    strcat(pickString, pickElement->CPS_category);
    if (!LocalCmpStrings(LMemDeref(@ExpTitle),
					pickElement->CPS_category,
					strlen(LMemDeref(@ExpTitle))))
	  needLine = TRUE;
    MemUnlock (OptrToHandle(@IncTitle));
    VMUnlock(mh);

    if (list == @CatDList) {
		 mem = MemAllocLMem(LMEM_TYPE_GSTRING, 0);
		 gstate = GrCreateGString(mem, GST_CHUNK, (word*) &chunk);
		 /* set the color */
		 if ((item == newCatSel) && (newCatSel != GIGS_NONE))
			 GrSetAreaColor(gstate, CF_INDEX, C_BLUE, 0, 0);
		 else {
//@ifdef GPC_ONLY
//		    if (type == CTYPE_INC)
//			   GrSetAreaColor(gstate, CF_RGB, 197, 238, 205);
//		    else	 GrSetAreaColor(gstate, CF_RGB, 239, 232, 204);
//@else
		    if (type == CTYPE_INC)
			   GrSetAreaColor(gstate, CF_RGB, 170, 255, 255);
		    else	 GrSetAreaColor(gstate, CF_RGB, 255, 255, 85);
//@endif
		}	
		 GrFillRect(gstate, 0, 0, 304, 20);
		 if (needLine) {
              GrSetLineWidth(gstate, MakeWWFixed(1));
		    GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0);
		    GrDrawHLine(gstate, 0, 0, 304);  /* L, B, R */
		    }
		 GrDrawText(gstate, 1, 1, pickString, 0);
		 GrEndGString(gstate);
		 /* and tell the DList */
		 @call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_MONIKER(
							 item,
							 0,
							 20,				/* height */
							 304,				/* width */
							 0,
							 VMDT_GSTRING,
							 VMST_OPTR,
							 ConstructOptr(mem, chunk));

		 /* and 86 the gstate and mem */
		 GrDestroyGString(gstate, gstate, GSKT_KILL_DATA);
		 MemFree(mem);
		 } /* end of cat dlist if */
	 else {  /* it's the report cat select list */
		 mem = MemAllocLMem(LMEM_TYPE_GSTRING, 0);
		 gstate = GrCreateGString(mem, GST_CHUNK, (word*) &chunk);
		 /* fill in the selected field */
		 if (isSel) {
			 GrSetAreaColor(gstate, CF_INDEX, C_BLACK, 0, 0);
			 GrFillPolygon(gstate, ODD_EVEN, checkPoints, 5);
			 }
		 GrDrawText(gstate, 20, 1, pickString, 0);
		 GrEndGString(gstate);
		 /* and tell the DList */
		 @call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_MONIKER(
							 item,
							 0,
							 13,				/* height */
							 300,				/* width */
							 0,
							 VMDT_GSTRING,
							 VMST_OPTR,
							 ConstructOptr(mem, chunk));

		 /* and 86 the gstate and mem */
		 GrDestroyGString(gstate, gstate, GSKT_KILL_DATA);
		 MemFree(mem);
	    } /* end of report cat sel else */

}

/***********************************************************************
 *
 * MESSAGE:	MSG_CAT_DLIST_APPLY for GPCBnkrProcessClass
 *
 * DESCRIPTION:	Handles an apply of user selection in the category list.
 *
 * PARAMETERS:  void (word selection, numSelections, flags)
 *
 * 
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_CAT_DLIST_APPLY
{
MemHandle		mh;
CatPickStruct	*pickElement;
Boolean			isHeader = FALSE;
Boolean			isSub = FALSE;


	 /* get the selection info */
    catListVMBHandle = VMFind(GPCBnkrFile, NullHandle, CATLIST);
    VMLock(GPCBnkrFile, catListVMBHandle ,&mh);
    pickElement = ChunkArrayElementToPtrHandles(
						mh,
						catListChunkArray,
						selection,
						0);
    if (pickElement->CPS_isSub) isSub = TRUE;
    MemLock (OptrToHandle(@IncTitle));
    if ((!LocalCmpStrings(LMemDeref(@IncTitle),
					   pickElement->CPS_category,
					   strlen(LMemDeref(@IncTitle))))
		 || (!LocalCmpStrings(LMemDeref(@ExpTitle),
						  pickElement->CPS_category,
						  strlen(LMemDeref(@ExpTitle)))))
	  isHeader = TRUE;
    MemUnlock (OptrToHandle(@IncTitle));
    VMUnlock(mh);

    /* set the buttons */
    if (isHeader) {
	  @send CatNewSub::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	  @send CatModify::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	  @send CatDelete::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	  @send CatUse::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	  }
    else  {
	  if (isSub) @send CatNewSub::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	  else @send CatNewSub::MSG_GEN_SET_ENABLED(VUM_NOW);
	  /* only enable use button if there is a form on the screen */
	  if (formUp) @send CatUse::MSG_GEN_SET_ENABLED(VUM_NOW);
	  @send CatModify::MSG_GEN_SET_ENABLED(VUM_NOW);
	  @send CatDelete::MSG_GEN_SET_ENABLED(VUM_NOW);
       }

    /* redraw the last and current selection */
    newCatSel = selection;
    /* redraw its moniker to show selected */
    @send self::MSG_CAT_DLIST_MONIKER_QUERY(
						    @CatDList,
						    newCatSel);
    /* redraw the old moniker to show not selected */
    if (currentCat != GIGS_NONE)
       @send self::MSG_CAT_DLIST_MONIKER_QUERY(
						    @CatDList,
						    currentCat);
    /* update the current selection global */
    currentCat = selection;

}

/***********************************************************************
 *
 * FUNCTION:	AddNewPayee(void)
 *
 * CALLED BY:	MSG_NEW_PAYEE, MSG_MODIFY_PAYEE
 *
 * STRATEGY:    
 *		
 *
 ***********************************************************************/
 void AddNewPayee(void)
{
MemHandle		mh;
VMBlockHandle	vmbh;
PayPickStruct	*pickElement, *pickInsertElement;
VMMapStruct	*VMmapPtr;
char			pickString[ENTRY_SIZE], testString[ENTRY_SIZE];
char			amtString[DOLLAR_IN_SIZE];
char			catString[ENTRY_SIZE], memoString[ENTRY_SIZE];
word			length, lengthNew, lengthTest, i;
FloatNum		amount;
Boolean		isDupe = FALSE;
Boolean		inserted = FALSE;


    lengthNew = @call NPName::MSG_VIS_TEXT_GET_ALL_PTR(pickString);
    length = @call NPAmount::MSG_VIS_TEXT_GET_ALL_PTR(amtString);

    /* Exit if balance invalid */
    if (!AmountChecksOK(amtString, FALSE, FALSE))  {
	  /* send the focus back to the balance field */
	  @send NPAmount::MSG_META_GRAB_FOCUS_EXCL();
	  return;
	  }

    /* convert the amount to a value */
    FloatAsciiToFloat(FAF_STORE_NUMBER,
			length,
		     amtString,
			&amount);
    @call NPCat::MSG_VIS_TEXT_GET_ALL_PTR(catString);
    @call NPMemo::MSG_VIS_TEXT_GET_ALL_PTR(memoString);

    /* get our list's block using its ID # */
    payListVMBHandle = VMFind(GPCBnkrFile, NullHandle, PAYLIST);
    VMLock(GPCBnkrFile, payListVMBHandle ,&mh);
    for (i = 0; i < payNumItems; i++)  {
	  /* Get the ith element */
	  pickElement = ChunkArrayElementToPtrHandles(
		   mh,
		   payListChunkArray,
		   i,
		   0);
	  /* get the ith string & length */
	  strcpy(testString, pickElement->PPS_payee);
	  lengthTest = strlen(testString);
       /* get the longer */
	  if (lengthTest >= lengthNew)  length = lengthTest;
	  else  length = lengthNew;
	  /* is this payee before one in ith element? */
	  if (LocalCmpStrings(pickString, testString, length) < 0)  { /* yes */
		/* put the new payee in here */
		pickInsertElement = ChunkArrayInsertAtHandle(
				payListChunkArray,
				pickElement,
				0);
		strcpy(pickInsertElement->PPS_payee, pickString);
		pickInsertElement->PPS_amount = amount;
		strcpy(pickInsertElement->PPS_category, catString);
		strcpy(pickInsertElement->PPS_memo, memoString);
		/* get out of loop by... */
		inserted = TRUE;
		i = payNumItems;
		}  /* end of before? if */
	  /* OK - is it the same? */
	  if (LocalCmpStrings(pickString, testString, length) == 0)  { /* yes */
		/* just replace the amount and category and memo*/
		isDupe = TRUE;
		pickElement->PPS_amount = amount;
		strcpy(pickElement->PPS_category,catString);
		strcpy(pickElement->PPS_memo, memoString);
		/* get out of loop by... */
		inserted = TRUE;
		i = payNumItems;
		}  /* end of same? if */
	  }  /* end of for loop */
    /* check to see if it was inserted yet */
    if (!inserted)  {  /* just append it to the array */
	  pickElement = ChunkArrayAppendHandles(
		      mh,
			 payListChunkArray,
		      0);
	  strcpy(pickElement->PPS_payee, pickString);
       pickElement->PPS_amount = amount;
	  strcpy(pickElement->PPS_category, catString);
	  strcpy(pickElement->PPS_memo, memoString);
	  } /* end of append it if */

    /* unlock the array */
    VMDirty(mh);
    VMUnlock(mh);

    if (!isDupe)  {
	  payNumItems++;
	  /* put the new number of items into the map */
	  vmbh = VMGetMapBlock(GPCBnkrFile);
	  VMmapPtr = VMLock(GPCBnkrFile, vmbh, &mh);
       VMmapPtr->MS_payNumber = payNumItems;
	  VMDirty(mh);
       VMUnlock(mh);
	  }

}

/***********************************************************************
 *
 * FUNCTION:	DeletePayee(void)
 *
 * CALLED BY:	MSG_DELETE_PAYEE, MSG_MODIFY_PAYEE
 *
 * STRATEGY:
 *
 *
 ***********************************************************************/
 void DeletePayee(void)
{
MemHandle		mh;
PayPickStruct	*pickElement;
VMBlockHandle	vmbh;
VMMapStruct	*VMmapPtr;


    /* get our list's block using its ID # */
    payListVMBHandle = VMFind(GPCBnkrFile, NullHandle, PAYLIST);
    VMLock(GPCBnkrFile, payListVMBHandle ,&mh);
    /* Get the arrayed info */
    pickElement = ChunkArrayElementToPtrHandles(
		   mh,
		   payListChunkArray,
		   currentPayee,
		   0);
    /* delete this payee */
    ChunkArrayDeleteHandle(payListChunkArray, pickElement);
    VMDirty(mh);
    VMUnlock(mh);

    /* update the global */
    payNumItems--;

    /* put the new number of items into the map */
    vmbh = VMGetMapBlock(GPCBnkrFile);
    VMmapPtr = VMLock(GPCBnkrFile, vmbh, &mh);
    VMmapPtr->MS_payNumber = payNumItems;
    VMDirty(mh);
    VMUnlock(mh);

}

/***********************************************************************
 *
 * MESSAGE:	MSG_OPEN_SELECT_PAYEES for GPCBnkrProcessClass
 *
 * DESCRIPTION:	Calls the dialog box when the menu
 *              item is selected or when the pick button is clicked
 *     
 *              
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_OPEN_SELECT_PAYEES
{
word		length, i;
char		payString[ENTRY_SIZE];
MemHandle		mh;
PayPickStruct	*pickElement;
Boolean	dupe = FALSE;


    /* disable reply group (except new) until something is selected */
    @send PayUse::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @send PayModify::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @send PayDelete::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);

    /* set the selection to none */
    @send PayDList::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(FALSE);

    /* Open the dialog box */
    @call PayListGroup::MSG_GEN_INTERACTION_INITIATE();

    /* show add dbox if a payee has been entered */
    length = @call NEFPayText::MSG_VIS_TEXT_GET_ALL_PTR(payString);
    if (length)  {
	  payListVMBHandle = VMFind(GPCBnkrFile, NullHandle, PAYLIST);
	  VMLock(GPCBnkrFile, payListVMBHandle ,&mh);
	  for (i = 0; i < payNumItems; i++)  {
		pickElement = ChunkArrayElementToPtrHandles(
				    mh,
				    payListChunkArray,
				    i,
				    0);
		if (!strcmp(payString, pickElement->PPS_payee))  {
		   /* its already in the list */
		   dupe = TRUE;
		   i = payNumItems;
		   }
		}
	  VMUnlock(mh);
	  if (!dupe)  @send process::MSG_OPEN_NEW_PAYEE(@PayNew);
	  }

}

/***********************************************************************
 *
 * MESSAGE:	MSG_USE_PAYEE for GPCBnkrProcessClass
 *
 * DESCRIPTION:	 
 *              
 *     
 *              
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_USE_PAYEE
{
MemHandle		mh;
PayPickStruct	*pickElement;
char			amtString[MAX_TEXT_LEN];


    /* get our list's block using its ID # */
    payListVMBHandle = VMFind(GPCBnkrFile, NullHandle, PAYLIST);
    VMLock(GPCBnkrFile, payListVMBHandle ,&mh);
    /* Get the arrayed info */
    pickElement = ChunkArrayElementToPtrHandles(
		   mh,
		   payListChunkArray,
		   currentPayee,
		   0);
    @call NEFPayText::MSG_VIS_TEXT_REPLACE_ALL_PTR(pickElement->PPS_payee, 0);
    FloatFloatToAscii_StdFormat(amtString,
						 &pickElement->PPS_amount,
                               FFAF_FROM_ADDR,
                               14,
                               2);
    @call NEFDAmount::MSG_VIS_TEXT_REPLACE_ALL_PTR(amtString, 0);
    @call NEFCatText::MSG_VIS_TEXT_REPLACE_ALL_PTR(pickElement->PPS_category, 0);
    @call NEFMemoText::MSG_VIS_TEXT_REPLACE_ALL_PTR(pickElement->PPS_memo, 0);
    VMUnlock(mh);

    /* set the d list to no selections */
    @send PayDList::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(FALSE);
    @send PayUse::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    /* close dbox if ini set to */
    if (closeOnUse)  {
		 @send PayListGroup::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
	  	 @send NewEntryDBox::MSG_META_GRAB_FOCUS_EXCL(); 
		 @send NEFPayText::MSG_META_GRAB_FOCUS_EXCL();
		 }

}

/***********************************************************************
 *
 * MESSAGE:	MSG_OPEN_NEW_PAYEE for GPCBnkrProcessClass
 *
 * DESCRIPTION:	Calls the dialog box when the trigger
 *                  item is selected
 *     
 *              
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_OPEN_NEW_PAYEE
{
char		pickString[ENTRY_SIZE];
char		amtString[MAX_TEXT_LEN];
MemHandle		mh;
PayPickStruct	*pickElement;


    /* check whether we're a new or a mod dialog box */
    if (trigger == @PayNew)  {  /* New Payee/Payer */
	  /* put in the right title and button */
	  MemLock (OptrToHandle(@NewPayMoniker));
	  @call NewPayDBox::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@NewPayMoniker),
			   VUM_DELAYED_VIA_APP_QUEUE);
	  @call NPCancel::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@CancelMoniker),
			   VUM_DELAYED_VIA_APP_QUEUE);
	  MemUnlock (OptrToHandle(@NewPayMoniker));
	  @send NPEnter::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	  @send NPChange::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);

	  /* fill in the fields */
	  @call NEFPayText::MSG_VIS_TEXT_GET_ALL_PTR(pickString);
	  @call NPName::MSG_VIS_TEXT_REPLACE_ALL_PTR(pickString, 0);
	  @call NEFDAmount::MSG_VIS_TEXT_GET_ALL_PTR(amtString);
	  @call NPAmount::MSG_VIS_TEXT_REPLACE_ALL_PTR(amtString, 0);
	  @call NEFCatText::MSG_VIS_TEXT_GET_ALL_PTR(pickString);
	  @call NPCat::MSG_VIS_TEXT_REPLACE_ALL_PTR(pickString, 0);
	  @call NEFMemoText::MSG_VIS_TEXT_GET_ALL_PTR(pickString);
	  @call NPMemo::MSG_VIS_TEXT_REPLACE_ALL_PTR(pickString, 0);
	  }  /* End of New Payee/Payer */
    else  {  /* Modify Payee/Payer */
	  /* put in the right title and button */
	  MemLock (OptrToHandle(@ModPayMoniker));
	  @call NewPayDBox::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@ModPayMoniker),
			   VUM_DELAYED_VIA_APP_QUEUE);
	  @call NPCancel::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@DontChangeMoniker),
			   VUM_DELAYED_VIA_APP_QUEUE);
	  MemUnlock (OptrToHandle(@ModPayMoniker));
	  @send NPEnter::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	  @send NPChange::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);

	  /* get our list's block using its ID # */
	  payListVMBHandle = VMFind(GPCBnkrFile, NullHandle, PAYLIST);
	  VMLock(GPCBnkrFile, payListVMBHandle ,&mh);
	  /* Get the arrayed info */
	  pickElement = ChunkArrayElementToPtrHandles(
				mh,
				payListChunkArray,
				currentPayee,
				0);
	  @call NPName::MSG_VIS_TEXT_REPLACE_ALL_PTR(pickElement->PPS_payee, 0);
	  FloatFloatToAscii_StdFormat(amtString,
						 &pickElement->PPS_amount,
						 FFAF_FROM_ADDR,
						 14,
						 2);
	  @call NPAmount::MSG_VIS_TEXT_REPLACE_ALL_PTR(amtString, 0);
   	  @call NPCat::MSG_VIS_TEXT_REPLACE_ALL_PTR(pickElement->PPS_category, 0);
	  @call NPMemo::MSG_VIS_TEXT_REPLACE_ALL_PTR(pickElement->PPS_memo, 0);
  	  VMUnlock(mh);
	  } /* End of Modify Payee/Payer */

    /* Open the dialog box */
    @call NewPayDBox::MSG_GEN_INTERACTION_INITIATE();
    formUp++;

}

/***********************************************************************
 *
 * MESSAGE:	MSG_NEW_PAYEE for GPCBnkrProcessClass
 *
 * DESCRIPTION:	Creates a new payee.
 *
 * STRATEGY:    
 *              
 *              
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_NEW_PAYEE
{
char			catString[ENTRY_SIZE];


    @call NPCat::MSG_VIS_TEXT_GET_ALL_PTR(catString);

    /* check the cat */
    if (strlen(catString))  {
	  if (CheckIsNewCat(catString) == FALSE)  {
	    /* it was cancel */
	    return;
	    }
	  /* otherwise the user added the cat or ignored it as new */
	  } /* end of there is a cat if */

    AddNewPayee();

    /* Let the list know about the new payee */
    @send PayDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(payNumItems);


}

/***********************************************************************
 *
 * MESSAGE:	MSG_MODIFY_PAYEE for GPCBnkrProcessClass
 *
 * DESCRIPTION:	Modifies a payee and changes that payee amount
 *
 * STRATEGY:
 *
 *
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_MODIFY_PAYEE
{
MemHandle		mh;
PayPickStruct	*pickElement;
char			oldPayName[ENTRY_SIZE], newPayName[ENTRY_SIZE];
char			newCatName[ENTRY_SIZE];


    /* get the old & new payee info */
    @call NPName::MSG_VIS_TEXT_GET_ALL_PTR(newPayName);
    @call NPCat::MSG_VIS_TEXT_GET_ALL_PTR(newCatName);
    payListVMBHandle = VMFind(GPCBnkrFile, NullHandle, PAYLIST);
    VMLock(GPCBnkrFile, payListVMBHandle ,&mh);
    pickElement = ChunkArrayElementToPtrHandles(
		   mh,
		   payListChunkArray,
		   currentPayee,    
		   0);
    strcpy(oldPayName, pickElement->PPS_payee);
    VMUnlock(mh);

    /* put up do you wanna box */
    if (AckDBox(oldPayName, newPayName, @ModPayMsg) == ACK_NO) return;

    /* check the cat */
    if (strlen(newCatName))  {
	  if (CheckIsNewCat(newCatName) == FALSE)  {
	    /* it was cancel */
	    return;
	    }
	  /* otherwise the user added the cat or ignored it as new */
	  } /* end of there is a cat if */

    /* Let's do it!  delete the old */
    DeletePayee();

    /* add the new */
    AddNewPayee();

    /* Let the list know about the new payee */
    @send PayDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(payNumItems);

    /* disable the buttons */
    @send PayUse::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @send PayModify::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @send PayDelete::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);

    /* and send the focus back to the pay dbox */
    @send PayListGroup::MSG_META_GRAB_FOCUS_EXCL();

}

/***********************************************************************
 *
 * MESSAGE:	MSG_DELETE_PAYEE for GPCBnkrProcessClass
 *
 * DESCRIPTION:	Deletes a payee.
 *
 * STRATEGY:    
 *              
 *              
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_DELETE_PAYEE
{
MemHandle		mh;
PayPickStruct	*pickElement;
char			oldPayName[ENTRY_SIZE];


    /* get the old payee info */
    payListVMBHandle = VMFind(GPCBnkrFile, NullHandle, PAYLIST);
    VMLock(GPCBnkrFile, payListVMBHandle ,&mh);
    pickElement = ChunkArrayElementToPtrHandles(
		   mh,
		   payListChunkArray,
		   currentPayee,
		   0);
    strcpy(oldPayName, pickElement->PPS_payee);
    VMUnlock(mh);

    /* put up do you wanna box */
    if (AckDBox(oldPayName, 0, @DelPayMsg) == ACK_NO) return;

    /* OK delete it */
    DeletePayee();

    /* re-initialize the pay list */
    @send PayDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(payNumItems);

    /* disable the buttons */
    @send PayUse::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @send PayModify::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
    @send PayDelete::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);

    /* and send the focus back to the pay dbox */
    @send PayListGroup::MSG_META_GRAB_FOCUS_EXCL();
}

/***********************************************************************
 *
 * MESSAGE:	MSG_CLOSE_PAYEE() for GPCBnkrProcessClass
 *
 * DESCRIPTION:	decrements the formUp flag.
 *
 * PARAMETERS:
 *
 *
 ***********************************************************************/
@method NewPayGenInteractionClass, MSG_VIS_CLOSE
{

    formUp--;
    @callsuper();


}

/***********************************************************************
 *
 * MESSAGE:		MSG_PAY_DLIST_MONIKER_QUERY for GPCBnkrProcessClass
 *
 * DESCRIPTION:	Queries for monikers for payee list.
 *
 * PARAMETERS:  	void (optr list, word item)
 *
 *
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_PAY_DLIST_MONIKER_QUERY
{
MemHandle		mh;
PayPickStruct	*pickElement;
char			pickString[ENTRY_SIZE];


    /* get the moniker the list wants */
    payListVMBHandle = VMFind(GPCBnkrFile, NullHandle, PAYLIST);
    VMLock(GPCBnkrFile, payListVMBHandle ,&mh);
    pickElement = ChunkArrayElementToPtrHandles(
		   mh,
		   payListChunkArray,
		   item,
		   0);
    strcpy(pickString, pickElement->PPS_payee);
    VMUnlock(mh);

    @call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_TEXT(item, pickString);

}

/***********************************************************************
 *
 * MESSAGE:		MSG_PAY_DLIST_APPLY for GPCBnkrProcessClass
 *
 * DESCRIPTION:	Handles an apply of user selection in the payee list.
 *
 * PARAMETERS:  	void (word selection, numSelections, flags)
 *
 *
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_PAY_DLIST_APPLY
{

    currentPayee = selection;

    /* enable the buttons */
    /* only enable use button if there is a form on the screen */
    if (formUp) @send PayUse::MSG_GEN_SET_ENABLED(VUM_NOW);
    @send PayModify::MSG_GEN_SET_ENABLED(VUM_NOW);
    @send PayDelete::MSG_GEN_SET_ENABLED(VUM_NOW);

}

/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_CLOSE_WIN() for CatPayGenInteractionClass
 *
 * DESCRIPTION:	sends the focus back to the entry form.
 *
 * PARAMETERS:
 *
 *
 ***********************************************************************/
@method CatPayGenInteractionClass, MSG_VIS_CLOSE_WIN
{

    @send NewEntryDBox::MSG_META_GRAB_FOCUS_EXCL();
    if (oself == @CatListGroup) {
	  if (catSelOpenedBy == @NPCatButton)
		    @send NPCat::MSG_META_GRAB_FOCUS_EXCL();
	  else @send NEFCatText::MSG_META_GRAB_FOCUS_EXCL();
	  }
    else {
	  @send NEFPayText::MSG_META_GRAB_FOCUS_EXCL();
	  }

    @callsuper();
}

/***********************************************************************
 *
 * MESSAGE:		MSG_META_KBD_CHAR for GPCBnkrCatGenTextClass
 *
 * DESCRIPTION:	checks for length and : in the entry form and
 *                  new payee cat entry fields, since they can have
 *                  a combination of parent:subcat.  So those fields
 *                  are ENTRY_SIZE but cats and subs can only be
 *                  CAT_SIZE long
 *
 *
 * PARAMETERS:  	void (word character)
 *
 *
 *
 ***********************************************************************/
@extern method GPCBnkrCatGenTextClass, MSG_META_KBD_CHAR
{
 char		txtString[ENTRY_SIZE];
 word		length, i, colonPos, subLength;
 Boolean		isColon;


    /* check the length of the text */
    length = @call self::MSG_VIS_TEXT_GET_ALL_PTR(txtString);
    subLength = 0;
    if (length > (CAT_SIZE - 1))  {
	  /* see if there is a : in the string before CAT_SIZE */
	  isColon = FALSE;
	  for (i = 0; i < length; i++)  {
		if (txtString[i] == ':')  {
		   isColon = TRUE;
		   colonPos = i;
		   i = length;
		   }
		}
	  if (isColon)  subLength = length - colonPos - 1;
	  if (!isColon || (colonPos > CAT_SIZE) || (subLength > (CAT_SIZE - 1)))  {
		/* tell the user and don't accept the key stroke*/
		txtString[length - 1] = 0;
		@call self::MSG_VIS_TEXT_REPLACE_ALL_PTR(txtString, 0);
		NotifyDBox(0, @TooLongCatMsg);
	   	@send self::MSG_META_GRAB_FOCUS_EXCL();
		return;
		}
	  }

    @callsuper();



}

