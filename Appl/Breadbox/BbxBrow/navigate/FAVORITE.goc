/*
 *                          ==CONFIDENTIAL INFORMATION==
 *
 * COPYRIGHT 1994-99 BREADBOX COMPUTER COMPANY -- ALL RIGHTS RESERVED  --
 * THE FOLLOWING CONFIDENTIAL INFORMATION IS BEING DISCLOSED TO YOU UNDER
 * A NON-DISCLOSURE AGREEMENT AND MAY NOT BE DISCLOSED OR FORWARDED BY THE
 * RECIPIENT TO ANY OTHER PERSON OR ENTITY NOT COVERED BY THE SAME
 * NON-DISCLOSURE AGREEMENT COVERING THE RECIPIENT. USE OF THE FOLLOWING
 * CONFIDENTIAL INFORMATION IS RESTRICTED TO THE TERMS OF THE NON-DISCLOSURE
 * AGREEMENT.
 *
*/
/***********************************************************************
 *
 * PROJECT:       HTMLView
 * FILE:          FAVORITE.GOC
 * DESCRIPTION:   Module for handling the favorite database and UI.
 *
 * AUTHOR:        Lysle E. Shields III
 *
 * HISTORY:
 *   --- -------- -----------------------------------------------
 *   LES 01/13/97 Created
 *   LES 02/02/99 Converted to work with IBMS and extended to folders
 *   --- -------- -----------------------------------------------
 *
 ***********************************************************************/

/**************************************************************************
 *      Include files
 **************************************************************************/

@include <stdapp.goh>
@include <Ansi/string.h>
@include <initfile.h>
@include "options.goh"

@ifdef COMPILE_OPTION_FAVORITES

@include "favorite.goh"
@include <ibtree.goh>

#define FAVORITE_DEPTH_UNKNOWN  255

@ifdef YAGO_2_BUILD
#define FAVORITES_SP    0  /* Absolute */
#define FAVORITES_DIR   _TEXT("F:\\GEOWORKS\\PRIVDATA")
@else
#define FAVORITES_SP    SP_PRIVATE_DATA
#define FAVORITES_DIR   _TEXT(".")
@endif

#ifdef SKIPPER_PRO_BUILD
#define FAVORITES_NAME  _TEXT("Skipper Pro Favorites")
#else
#ifdef SKIPPER_VERSION
#define FAVORITES_NAME  _TEXT("Skipper Favorites")
#else
#ifdef YAGO_2_BUILD
#define FAVORITES_NAME  _TEXT("GlobeHopper 3.0 Favorites")
#else
#define FAVORITES_NAME  _TEXT("WEBFAVOR.000")
#endif
#endif
#endif

#define FAV_TEMP_LIST _TEXT("FAVTEMPL.000")

#define MAX_TOP_FAVORITES   10

static VMFileHandle G_favoritesFile = NullHandle ;
static VMBlockHandle G_favoritesIBMSRoot = NullHandle ;
static IBMSHandle G_favoritesIBMS = NullHandle ;
static IBDLLList G_favoritesTopTen = IBDLL_LIST_BAD ;
static VMBlockHandle G_favoritesListRoot = NullHandle ;
static IBMSHandle G_favoritesList = NullHandle ;
static IBTreeFolder G_favoritesTree = IBTREE_FOLDER_BAD ;
static VMFileHandle G_favIndexFile = NullHandle;
static VMBlockHandle G_favIndexArray = NullHandle ;

static word G_numFavoritesLocked = 0 ;
Boolean G_foldersInFolders = FALSE ;

#define FIELD_RESOLVE(p, fieldoffset, t)     (*((t *)(((byte *)(p))+(fieldoffset))))

#define f_LF(p, fieldoffset, t) FIELD_RESOLVE(p, fieldoffset, t)
#define GET_FIELD_LF(field)      (offsetof(T_lockedFavorite, field))

static byte LF_fields[] = {
    GET_FIELD_LF(p_title),
    GET_FIELD_LF(p_location),
    GET_FIELD_LF(p_notes)
} ;


typedef struct {
    VMBlockHandle FIM_favorites ;
    IBDLLList     FIM_topTen ;
    IBTreeFolder  FIM_tree ;
} T_favoriteIBMSMap ;

typedef struct {
    IBMSIndex FH_title ;
    IBMSIndex FH_location ;
    IBMSIndex FH_notes ;
} T_favoriteHeader ;
#define f_FH(p, fieldoffset, t)  FIELD_RESOLVE(p, fieldoffset, t)
#define GET_FIELD_FH(field)      (offsetof(T_favoriteHeader, field))

typedef struct {
    MemHandle FLI_self ;
    MemHandle FLI_memTitle ;
    MemHandle FLI_memLocation ;
    MemHandle FLI_memNotes ;
    IBMSIndex FLI_headerEntry ;
    T_lockedFavorite FLI_favorite ;
    Boolean FLI_isDirty ;
} T_favoriteLockedInternal ;
#define f_FLI(p, fieldoffset, t) FIELD_RESOLVE(p, fieldoffset, t)
#define GET_FIELD_FLI(field)      (offsetof(T_favoriteLockedInternal, field))

static byte FLI_fields[] = {
    GET_FIELD_FLI(FLI_memTitle),
    GET_FIELD_FLI(FLI_memLocation),
    GET_FIELD_FLI(FLI_memNotes)
} ;

typedef struct {
    IBTreeFolder FI_folder ;
    IBTreeEntry FI_entry ;
    byte FI_depth ;
} T_favoriteIndex ;

IBTreeEntry ILocateEntryByPos(
                dword posIndex,
                IBTreeFolder *p_folder,
                byte *p_depth) ;
dword IAppendIndexEntry(IBTreeFolder folder, IBTreeEntry entry, byte depth) ;
Boolean IDeleteFolder(dword pos) ;
Boolean IDeleteEntry(dword pos) ;
dword IInsertTreeEntries(dword pos, IBTreeFolder folder, byte depth) ;
void IInsertIndexEntry(
          dword pos,
          IBTreeFolder folder,
          IBTreeEntry entry,
          byte depth) ;
void IDeleteTreeEntries(dword pos, Boolean deleteSelf) ;

void IFavoriteDataResize(IBMSHandle memory, IBMSIndex *block, word newSize) ;
T_lockedFavorite *IFavoriteLockByEntry(IBTreeEntry entry, word depth) ;

#define FAVORITE_FLAG_IS_FOLDER   0x80
#define FAVORITE_FLAG_IS_OPEN  0x40
#define FAVORITE_FLAG_IS_TOP   0x20

#define IFavoriteDataUnlock(m, p)    \
            if (*p)  {               \
                IBMSUnlock(m, *p) ;  \
                *p = NULL ;          \
            }

/**************************************************************************
 * Routine:  FavoritesBuildUIList
 **************************************************************************
 *
 * Description:
 *     This complex command goes through all the children of the given
 *     parent and changes the moniker to match the entries in the
 *     favorites file.  If there are more favorites than children, the
 *     routine stops on the last child.  If there are more children than
 *     favorites, the latter children are turned off.  This routine assumes
 *     that the children are all regular gen objects (most like gen
 *     triggers) and that all the children are to be changed.  The most
 *     common technique is to create a sub-group in a menu of gentriggers.
 *
 * Inputs:
 *     optr parent                -- Parent GenInteraction object
 *
 **************************************************************************/
@extern object GPCFavoriteIconMoniker ;
@extern object GPCFavoriteGroupIconMoniker ;
@extern object GPCTopFavoriteIconMoniker ;

void FavoritesBuildUIList(optr parent)
{
    word numChildren ;
    optr child ;
    optr icon, iconPic ;
    word i ;
    word width, height ;
    dword numFavorites ;
    T_lockedFavorite *p_favorite = NULL ;
    GStateHandle gstate ;
    word numTops ;
    word max ;
    IBDLLItem item ;
    IBTreeEntry entry ;
    dword pos ;

//    EC_ERROR_IF(!G_favoritesFile, -1) ;
    numChildren = @call parent::MSG_GEN_COUNT_CHILDREN() ;
    numTops = FavoriteCountTopTen() ;
    numFavorites = FavoritesGetCount() ;

    /* If we have top favorites, we are going to show just those items */
    /* Determine the max number of items we can show */
    if (numTops)
        max = numTops ;
    else
        max = numFavorites ;

    for (pos=i=0; (i<numChildren);)  {
        child = @call parent::MSG_GEN_FIND_CHILD_AT_POSITION(i) ;
        if (pos >= max)  {
            /* If we are past the end of the favorites, make */
            /* the child disappear. */
            @call child::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
        } else {
            /* Change the moniker on the child to match the */
            /* name of the favorite */
            /* Lock in either a top entry or a regular entry.  Top */
            /* entries are shown when we have ANY top entries */
            if (numTops != 0)  {
                p_favorite = FavoriteLockTopEntry(i) ;
                item = IBDLLGetItem(G_favoritesIBMS, G_favoritesTopTen, i) ;
                entry = IBDLLItemGetData(G_favoritesIBMS, item) ;
                pos++ ;
            } else  {
                /* Skip folders */
                if (FavoriteIsFolder(pos))  {
                    pos++ ;
                    continue ;
                }
                p_favorite = FavoriteLock(pos) ;
                entry = ILocateEntryByPos(pos, NULL, NULL) ;
                pos++ ;
            }
            if (p_favorite)  {
                if (IBTreeEntryGetFolder(G_favoritesIBMS, entry))  {
                    icon = @GPCFavoriteGroupIconMoniker ;
                } else {
                    if (IBTreeEntryGetFlags(G_favoritesIBMS, entry) &
                                   FAVORITE_FLAG_IS_TOP)  {
                        icon = @GPCTopFavoriteIconMoniker ;
                    } else {
                        icon = @GPCFavoriteIconMoniker ;
                    }
                }

                /* Change the moniker on the favorite entry */
                iconPic = FavoriteCreateIcon(
                              p_favorite,
                              icon,
                              0,
                              &width,
                              &height,
                              &gstate) ;
                FavoriteUnlock(p_favorite) ;

                @call child::MSG_GEN_REPLACE_VIS_MONIKER(
                          VUM_DELAYED_VIA_UI_QUEUE,
                          height, width,
                          0, VMDT_GSTRING, VMST_OPTR,
                          iconPic) ;
                FavoriteDestroyIcon(gstate, iconPic) ;
                @call child::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
            } else {
                /* Didn't get a favorite.  Hide the entry. */
                @call child::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_UI_QUEUE) ;
            }
        }
        i++ ;
    }
}

/**************************************************************************
 * Routine:  FavoritesOpen
 **************************************************************************
 *
 * Description:
 *     Open the favorites file creating if necessary the file
 *     and/or huge array
 *
 * Outputs:
 *     Boolean                     -- FALSE = failed, else TRUE.
 *
 **************************************************************************/
Boolean FavoritesOpen(void)
{
    IBMSIndex map ;
    T_favoriteIBMSMap *p_map ;
    T_favoriteIBMSMap mapCopy ;

    /* Do not open twice */
    EC_ERROR_IF(G_favoritesFile, -1) ;

    /* Go to the favorite's location */
    FilePushDir() ;
    FileSetCurrentPath(FAVORITES_SP, FAVORITES_DIR);

    /* Open (or create) the favorites file */
    G_favoritesFile =
        VMOpen(FAVORITES_NAME, VMAF_FORCE_READ_WRITE, VMO_CREATE, 0) ;
    if (!G_favoritesFile)
    {
	/* If the file is corrupt, delete it and try again. */
	word error = ThreadGetError();
	if (error == VM_OPEN_INVALID_VM_FILE
	  || error == VM_FILE_FORMAT_MISMATCH)
	{
	    FileDelete(FAVORITES_NAME);
            G_favoritesFile =
                VMOpen(FAVORITES_NAME, VMAF_FORCE_READ_WRITE, VMO_CREATE, 0) ;
	}
    }
    if (G_favoritesFile)  {
        /* Make sure we only have a version that got saved */
        VMRevert(G_favoritesFile) ;

        /* Get the map block which points to the first array */
        G_favoritesIBMSRoot = VMGetMapBlock(G_favoritesFile) ;

        /* If not map block is set, create the array */
        if (!G_favoritesIBMSRoot)  {
            /* Create the array */
            G_favoritesIBMSRoot = IBMSCreate(G_favoritesFile);
            VMSetMapBlock(G_favoritesFile, G_favoritesIBMSRoot) ;
        }
        G_favoritesIBMS = IBMSOpen(G_favoritesFile, G_favoritesIBMSRoot) ;

        map = IBMSGetMap(G_favoritesIBMS) ;
        if (!map)  {
            /* No map yet, let's create it */
            map = IBMSAlloc(G_favoritesIBMS, sizeof(*p_map)) ;

            /* Create the major sections once */
            mapCopy.FIM_favorites = IBMSCreate(G_favoritesFile) ;
            mapCopy.FIM_topTen = IBDLLCreate(G_favoritesIBMS, 0) ;
            mapCopy.FIM_tree = IBTreeFolderCreate(G_favoritesIBMS) ;

            p_map = IBMSLock(G_favoritesIBMS, map) ;
            *p_map = mapCopy ;
            IBMSDirty(p_map) ;
            IBMSUnlock(G_favoritesIBMS, p_map) ;

            IBMSSetMap(G_favoritesIBMS, map) ;
            IBMSSave(G_favoritesIBMS) ;
        }

        /* Pull information out the map for faster reference */
        if (map)  {
            p_map = IBMSLock(G_favoritesIBMS, map) ;
            G_favoritesTopTen = p_map->FIM_topTen ;
            G_favoritesListRoot = p_map->FIM_favorites ;
            G_favoritesTree = p_map->FIM_tree ;
            IBMSUnlock(G_favoritesIBMS, p_map) ;
        }

        if (G_favoritesListRoot)  {
            G_favoritesList = IBMSOpen(G_favoritesFile, G_favoritesListRoot) ;
        }

        /* At this point, we should have a file with an IBMS in it */
        G_numFavoritesLocked = 0 ;

        /* Create a temporary vm file for the index */
        FileDelete(FAV_TEMP_LIST) ;
        G_favIndexFile =
        VMOpen(FAV_TEMP_LIST, VMAF_FORCE_READ_WRITE, VMO_CREATE_TRUNCATE, 0) ;
        if (G_favIndexFile)  {
            G_favIndexArray = HugeArrayCreate(G_favIndexFile, 0, 0) ;
        } else {
            /* !!! Abort !!! Couldn't create an index so we */
            /* shouldn't do anything */
            FavoritesClose() ;
        }
    }


    FilePopDir() ;

    G_foldersInFolders = FALSE ;
    InitFileReadBoolean("HTMLView", "foldersInFolders", &G_foldersInFolders) ;

    /* Setup the lookup table for the whole tree */
    if (G_favoritesTree)
        IInsertTreeEntries(0, G_favoritesTree, 0) ;

    return (map & G_favoritesFile & G_favoritesIBMS) ? TRUE:FALSE ;
}

/**************************************************************************
 * Routine:  FavoritesClose
 **************************************************************************
 *
 * Description:
 *     Close the favorites file
 *
 **************************************************************************/
void FavoritesClose(void)
{
    T_favoriteIBMSMap *p_map ;
    IBMSIndex map ;

    /* No double closings */
//    EC_ERROR_IF(!G_favoritesFile, -1) ;
    EC_ERROR_IF(G_numFavoritesLocked, -1) ;
    if (G_favoritesFile)  {
        map = IBMSGetMap(G_favoritesIBMS) ;
        p_map = IBMSLock(G_favoritesIBMS, map) ;
        p_map->FIM_topTen = G_favoritesTopTen ;
        p_map->FIM_favorites = G_favoritesListRoot ;
        p_map->FIM_tree = G_favoritesTree ;
        IBMSDirty(p_map) ;
        IBMSUnlock(G_favoritesIBMS, p_map) ;

        IBMSSave(G_favoritesIBMS) ;
        IBMSClose(G_favoritesIBMS) ;
        IBMSSave(G_favoritesList) ;
        IBMSClose(G_favoritesList) ;
        VMClose(G_favoritesFile, FALSE) ;
        if (G_favIndexFile)
            VMClose(G_favIndexFile, FALSE) ;

        G_favoritesFile = NullHandle ;
        G_favoritesIBMS = NullHandle ;
        G_favoritesTopTen = IBDLL_LIST_BAD ;
        G_favoritesList = NullHandle ;
        G_favoritesListRoot = NullHandle ;
        G_favoritesTree = IBTREE_FOLDER_BAD ;
        G_favIndexFile = NullHandle ;
        G_favIndexArray = NullHandle ;
    }
}

/**************************************************************************
 * Routine:  FavoriteLock
 **************************************************************************
 *
 * Description:
 *     Locks in a favorite entry based on the given index (0-based)
 *
 * Inputs:
 *     TCHAR **pp_location         -- Location of favorite (http://...)
 *                                   Pass NULL if not wanted.
 *
 * Outputs:
 *     T_lockedFavorite *         -- Favorite structure locked,
 *                                   NULL if index not found.
 *
 **************************************************************************/
T_lockedFavorite *FavoriteLock(dword index)
{
    IBTreeEntry entry ;
    byte depth ;
    T_lockedFavorite *p_favorite = NULL ;

    if (!G_favoritesFile)
        return p_favorite ;

    entry = ILocateEntryByPos(index, NULL, &depth) ;
    if (entry)  {
        p_favorite = IFavoriteLockByEntry(entry, depth) ;
    }

    return p_favorite ;
}

/**************************************************************************
 * Routine:  FavoriteLockTopEntry
 **************************************************************************
 *
 * Description:
 *     Locks in a favorite entry based on the position in the top ten
 *     list.
 *
 * Inputs:
 *     word index                 -- Index into the list of top entries.
 *
 * Outputs:
 *     T_lockedFavorite *         -- Favorite structure locked,
 *                                   NULL if index not found.
 *
 **************************************************************************/
T_lockedFavorite *FavoriteLockTopEntry(word index)
{
    IBDLLItem item ;
    T_lockedFavorite *p_favorite = NULL ;
    IBTreeEntry entry ;

    if (!G_favoritesFile)
        return p_favorite ;

    if (index < FavoriteCountTopTen())  {
        /* Get the entry at that location */
        item = IBDLLGetItem(
                   G_favoritesIBMS,
                   G_favoritesTopTen,
                   index) ;
        if (item)  {
            entry = IBDLLItemGetData(G_favoritesIBMS, item) ;
            if (entry)  {
                /* Lock the entry, but we don't know the depth */
                p_favorite = IFavoriteLockByEntry(
                                 entry,
                                 FAVORITE_DEPTH_UNKNOWN) ;
            }
        }
    }

    return p_favorite ;
}

/**************************************************************************
 * Routine:  FavoriteUnlock
 **************************************************************************
 *
 * Description:
 *     Get a favorite entry based on the given index (0-based)
 *
 * Inputs:
 *     TCHAR *p_favorite           -- Favorite location returned from
 *                                   FavoriteLock
 *
 **************************************************************************/
void FavoriteUnlock(T_lockedFavorite *p_favorite)
{
    T_favoriteLockedInternal *p_fav ;
    MemHandle mem ;
    TCHAR *p_data ;
    T_favoriteHeader *p_header = NULL ;
    T_favoriteHeader header ;

    if (!p_favorite)
        return ;

    /* Find the start of the internal structure */
    p_fav = (T_favoriteLockedInternal *)
                (((char *)p_favorite)-
                    (offsetof(T_favoriteLockedInternal, FLI_favorite))) ;

    /* We only do certain actions if things have been dirtied */
    if (p_fav->FLI_isDirty)  {
        p_header = IBMSLock(G_favoritesList, p_fav->FLI_headerEntry) ;
        header = *p_header ;
        IBMSUnlock(G_favoritesList, p_header) ;

        /* Get rid of the old data */
        if (header.FH_title)  {
            IBMSFree(G_favoritesList, header.FH_title) ;
            header.FH_title = IBMS_BAD ;
        }
        if (header.FH_location)  {
            IBMSFree(G_favoritesList, header.FH_location) ;
            header.FH_location = IBMS_BAD ;
        }
        if (header.FH_notes)  {
            IBMSFree(G_favoritesList, header.FH_notes) ;
            header.FH_notes = IBMS_BAD ;
        }

        /* Copy back the data */
        if (p_fav->FLI_memTitle)  {
            header.FH_title = IBMSAlloc(
                        G_favoritesList,
                        (1+strlen(p_favorite->p_title))*sizeof(TCHAR)) ;
            p_data = IBMSLock(G_favoritesList, header.FH_title) ;
            strcpy(p_data, p_favorite->p_title) ;
            IBMSDirty(p_data) ;
            IBMSUnlock(G_favoritesList, p_data);
        }

        if (p_fav->FLI_memLocation)  {
            header.FH_location = IBMSAlloc(
                        G_favoritesList,
                        (1+strlen(p_favorite->p_location))*sizeof(TCHAR)) ;
            p_data = IBMSLock(G_favoritesList, header.FH_location) ;
            strcpy(p_data, p_favorite->p_location) ;
            IBMSDirty(p_data) ;
            IBMSUnlock(G_favoritesList, p_data);
        }

        if (p_fav->FLI_memNotes)  {
            header.FH_notes = IBMSAlloc(
                        G_favoritesList,
                        (1+strlen(p_favorite->p_notes))*sizeof(TCHAR)) ;
            p_data = IBMSLock(G_favoritesList, header.FH_notes) ;
            strcpy(p_data, p_favorite->p_notes) ;
            IBMSDirty(p_data) ;
            IBMSUnlock(G_favoritesList, p_data);

            /* Make sure we have the latest saved. */
            IBMSSave(G_favoritesIBMS) ;
            VMSave(G_favoritesFile) ;
            VMSave(G_favIndexFile) ;
        }

        /* Record the changed header */
        p_header = IBMSLock(G_favoritesList, p_fav->FLI_headerEntry) ;
        *p_header = header ;
        IBMSDirty(p_header) ;
        IBMSUnlock(G_favoritesList, p_header) ;
    }

    /* Unlock and Free up the memory used */
    if (p_fav->FLI_memTitle)  {
        MemUnlock(p_fav->FLI_memTitle) ;
        MemFree(p_fav->FLI_memTitle) ;
        p_favorite->p_title = NULL ;
        p_fav->FLI_memTitle = NullHandle ;
    }

    if (p_fav->FLI_memLocation)  {
        MemUnlock(p_fav->FLI_memLocation) ;
        MemFree(p_fav->FLI_memLocation) ;
        p_favorite->p_location = NULL ;
        p_fav->FLI_memLocation = NullHandle ;
    }

    if (p_fav->FLI_memNotes)  {
        MemUnlock(p_fav->FLI_memNotes) ;
        MemFree(p_fav->FLI_memNotes) ;
        p_favorite->p_notes = NULL ;
        p_fav->FLI_memNotes = NullHandle ;
    }

    /* Get rid of this block */
    mem = p_fav->FLI_self ;
    MemUnlock(mem) ;
    MemFree(mem) ;

    G_numFavoritesLocked-- ;
}

/**************************************************************************
 * Routine:  FavoritesGetCount
 **************************************************************************
 *
 * Description:
 *     Determine how many favorites are in the array.
 *
 * Outputs:
 *     dword                      -- Number of favorites found.
 *
 **************************************************************************/
dword FavoritesGetCount(void)
{
    dword count = 0 ;

//    EC_ERROR_IF(!G_favIndexFile, -1) ;
    if (G_favIndexFile)
        count = HugeArrayGetCount(G_favIndexFile, G_favIndexArray) ;

    return count ;
}

/**************************************************************************
 * Routine:  FavoriteAppend
 **************************************************************************
 *
 * Description:
 *     Create a new blank favorite at the end of the favorite array
 *
 * Inputs:
 *     TCHAR *p_title              -- Title for favorite
 *     TCHAR *p_location           -- Location for favorite
 *
 * Outputs:
 *     dword                      -- Index of new favorite,
 *                                   or FAVORITE_BAD
 *
 **************************************************************************/
dword FavoriteAppend(void)
{
    dword pos = FAVORITE_BAD ;
    IBMSIndex newEntry ;
    IBTreeEntry entry ;
    T_favoriteHeader *p_header ;

    /* Abort if we don't have a file */
    //EC_ERROR_IF(!G_favoritesFile, -1) ;
    if (!G_favoritesFile)
        return FAVORITE_BAD ;

    /* Create the blank new entry */
    newEntry = IBMSAlloc(G_favoritesList, sizeof(T_favoriteHeader)) ;
    if (newEntry)  {
        /* The new entry has nothing in it */
        p_header = IBMSLock(G_favoritesList, newEntry) ;
        p_header->FH_title = IBMS_BAD ;
        p_header->FH_location = IBMS_BAD ;
        p_header->FH_notes = IBMS_BAD ;
        IBMSDirty(p_header) ;
        IBMSUnlock(G_favoritesList, p_header) ;

        /* Add the entry to the end of the root folder of the tree */
        entry = IBTreeFolderInsertData(
                    G_favoritesIBMS,
                    G_favoritesTree,
                    IBTREE_APPEND,
                    newEntry,
                    0) ;

        /* Add the entry to the index list */
        if (entry)  {
            pos = IAppendIndexEntry(G_favoritesTree, entry, 0) ;
            IBMSSave(G_favoritesIBMS) ;
            VMSave(G_favoritesFile) ;
            VMSave(G_favIndexFile) ;
        }
    }

    return pos ;
}

/**************************************************************************
 * Routine:  FavoriteDelete
 **************************************************************************
 *
 * Description:
 *     Deletes an old favorite or folder of favorites
 *
 * Inputs:
 *     dword pos                  -- Index of favorite
 *
 **************************************************************************/
Boolean FavoriteDelete(dword pos)
{
    Boolean deleted = FALSE;

//    EC_ERROR_IF(!G_favoritesFile, -1) ;
    if (G_favoritesFile)  {
        if (FavoriteIsFolder(pos))  {
            deleted = IDeleteFolder(pos) ;
        } else {
            deleted = IDeleteEntry(pos) ;
        }
    }
    return deleted;
}

/**************************************************************************
 * Routine:  FavoriteDirty
 **************************************************************************
 *
 * Description:
 *     Dirty a previously locked favorite.
 *
 * Inputs:
 *     TCHAR *p_favorite           -- Favorite location returned from
 *                                   FavoriteLock
 *
 **************************************************************************/
void FavoriteDirty(T_lockedFavorite *p_favorite)
{
    T_favoriteLockedInternal *p_fav ;

    if (!p_favorite)
        return ;

    /* Find the start of the internal structure */
    p_fav = (T_favoriteLockedInternal *)
                (((byte *)p_favorite)-
                    (offsetof(T_favoriteLockedInternal, FLI_favorite))) ;

    /* Just mark it as dirty until it is unlocked */
    p_fav->FLI_isDirty = TRUE ;
}

/**************************************************************************
 * Routine:  FavoriteResizeLockedField
 **************************************************************************
 *
 * Description:
 *     Reallocs the size of a locked field and fixes up the pointer.
 *     NOTE:  Old data is lost
 *
 * Inputs:
 *     T_lockedFavorite *p_favorite -- Favorite location returned from
 *                                     FavoriteLock
 *     FavoriteLockedField field  -- Which field to resize
 *     word newSize               -- number of bytes big now.  Zero to
 *                                   clear.
 *
 **************************************************************************/
void FavoriteResizeLockedField(
         T_lockedFavorite *p_favorite,
         FavoriteLockedField field,
         word newSize)
{
    T_favoriteLockedInternal *p_fav ;
    word FLI_offset, LF_offset ;

    EC_ERROR_IF(field >= FAVORITE_LOCKED_FIELD_UNKNOWN, -1) ;

    /* Find the start of the internal structure */
    p_fav = (T_favoriteLockedInternal *)
                (((byte *)p_favorite)-
                    (offsetof(T_favoriteLockedInternal, FLI_favorite))) ;

    FLI_offset = FLI_fields[field] ;
    LF_offset = LF_fields[field] ;

    if (f_FLI(p_fav, FLI_offset, MemHandle))  {
        MemUnlock(f_FLI(p_fav, FLI_offset, MemHandle)) ;
        f_FLI(p_fav, FLI_offset, MemHandle) =
            MemReAlloc(f_FLI(p_fav, FLI_offset, MemHandle), newSize, 0);
    } else {
        if (newSize)
            f_FLI(p_fav, FLI_offset, MemHandle) =
                MemAlloc(newSize, HF_DYNAMIC, HAF_NO_ERR) ;
    }
    if (newSize)
        f_LF(p_favorite, LF_offset, byte *) =
            MemLock(f_FLI(p_fav, FLI_offset, MemHandle)) ;

    FavoriteDirty(p_favorite) ;
}

/**************************************************************************
 * Routine:  FavoriteAppendFolder
 **************************************************************************
 *
 * Description:
 *     Creates a new folder at the end of the favorites list
 *
 * Inputs:
 *     TCHAR *p_name               -- Name of folder to use
 *
 * Outputs:
 *     dword                      -- Position in list created
 *
 **************************************************************************/
dword FavoriteAppendFolder(TCHAR *p_name)
{
    IBTreeFolder newFolder ;
    word len ;
    IBMSIndex text = IBMS_BAD ;
    TCHAR *p_text ;
    dword pos = FAVORITE_BAD ;
    IBMSIndex newEntry ;
    IBTreeEntry newItem ;
    T_favoriteHeader *p_header ;

    /* Can't work with a bad favorites file */
    EC_ERROR_IF(!G_favoritesFile, -1) ;
    if (!G_favoritesFile)
        return pos ;

    len = (1+strlen(p_name))*sizeof(TCHAR) ;

    /* Create the title string */
    if (len > 1*sizeof(TCHAR))  {
        text = IBMSAlloc(G_favoritesList, len) ;
        if (text)  {
            p_text = IBMSLock(G_favoritesList, text) ;
            memcpy(p_text, p_name, len) ;
            IBMSDirty(p_text) ;
            IBMSUnlock(G_favoritesList, p_text) ;
        }
    }

    /* Create the blank new entry */
    newEntry = IBMSAlloc(G_favoritesList, sizeof(T_favoriteHeader)) ;
    if (newEntry)  {
        /* The new entry has nothing in it except the title */
        p_header = IBMSLock(G_favoritesList, newEntry) ;
        p_header->FH_title = text ;
        p_header->FH_location = IBMS_BAD ;
        p_header->FH_notes = IBMS_BAD ;
        IBMSDirty(p_header) ;
        IBMSUnlock(G_favoritesList, p_header) ;

        /* Add the folder to the end of the root folder of the tree */
        newFolder = IBTreeFolderCreate(G_favoritesIBMS) ;
/*        IBTreeEntrySetData(G_favoritesIBMS, newFolder, newEntry) ; */
        newItem = IBTreeFolderInsertFolder(
                        G_favoritesIBMS,
                        G_favoritesTree,
                        IBTREE_APPEND,
                        newFolder,
                        newEntry,
                        0) ;
        IBTreeEntrySetFlags(G_favoritesIBMS, newItem, FAVORITE_FLAG_IS_OPEN) ;

        /* Add the entry to the index list */
        if (newItem)
            pos = IAppendIndexEntry(G_favoritesTree, newItem, 0) ;

        /* Make sure everything is saved. */
        IBMSSave(G_favoritesIBMS) ;
        VMSave(G_favoritesFile) ;
        VMSave(G_favIndexFile) ;
    }

    return pos ;
}

/**************************************************************************
 * Routine:  FavoriteFolderOpen
 **************************************************************************
 *
 * Description:
 *     Open a folder that is closed at the given position.
 *
 * Inputs:
 *     dword pos                  -- Position of folder
 *
 **************************************************************************/
void FavoriteFolderOpen(dword pos)
{
    IBTreeEntry folderEntry ;
    IBTreeFolder folder ;
    IBTreeUserFlags flags ;
    byte depth ;

    if (!G_favoritesFile)
        return ;

    folderEntry = ILocateEntryByPos(pos, &folder, &depth) ;

    /* Make sure this is really a folder */
    flags = IBTreeEntryGetFlags(G_favoritesIBMS, folderEntry) ;
    if ((flags & FAVORITE_FLAG_IS_FOLDER) &&
        (!(flags & FAVORITE_FLAG_IS_OPEN)))  {
        IBTreeEntrySetFlags(
            G_favoritesIBMS,
            folderEntry,
            flags | FAVORITE_FLAG_IS_OPEN) ;

        /* Add the tree entries into the list */
        IInsertTreeEntries(pos, folderEntry, depth+1) ;
    }
}

/**************************************************************************
 * Routine:  FavoriteFolderClose
 **************************************************************************
 *
 * Description:
 *     Close a folder that was opened at the given position.
 *
 * Inputs:
 *     dword pos                  -- Position of folder
 *
 **************************************************************************/
void FavoriteFolderClose(dword pos)
{
    IBTreeEntry folderEntry ;
    IBTreeFolder folder ;
    IBTreeUserFlags flags ;

    if (!G_favoritesFile)
        return ;

    folderEntry = ILocateEntryByPos(pos, &folder, NULL) ;

    /* Make sure this is really a folder */
    flags = IBTreeEntryGetFlags(G_favoritesIBMS, folderEntry) ;
    if ((flags & FAVORITE_FLAG_IS_FOLDER) &&
        (flags & FAVORITE_FLAG_IS_OPEN))  {
        IBTreeEntrySetFlags(
            G_favoritesIBMS,
            folderEntry,
            flags & (~FAVORITE_FLAG_IS_OPEN)) ;

        /* Add the tree entries into the list */
        IDeleteTreeEntries(pos, FALSE) ;
    }
}

/**************************************************************************
 * Routine:  FavoriteCountTopTen
 **************************************************************************
 *
 * Description:
 *     Count the nubmer of items in the favorites list.
 *
 * Outputs:
 *     word                       -- Number of items
 *
 **************************************************************************/
word FavoriteCountTopTen(void)
{
    /* No file?  No data */
    if (!G_favIndexFile)
        return 0 ;

    return (word)IBDLLGetCount(G_favoritesIBMS, G_favoritesTopTen) ;
}

/**************************************************************************
 * Routine:  FavoriteAddToTopTen
 **************************************************************************
 *
 * Description:
 *     Append an item to the end of the top ten list if there is room.
 *
 * Inputs:
 *     dword pos                  -- Position in favorites to add
 *
 **************************************************************************/
void FavoriteAddToTopTen(dword pos)
{
    IBTreeEntry entry ;
    IBTreeFolder folder ;
    IBTreeUserFlags flags ;

    if (!G_favoritesFile)
        return ;

    /* Only add if we are below the max */
    if (FavoriteCountTopTen() < MAX_TOP_FAVORITES)  {
        /* Get the entry at that location */
        entry = ILocateEntryByPos(pos, NULL, NULL) ;
        if (entry)  {
            /* See if this entry has a folder.  Only non-foldered entries can */
            /* be on the favorites list. */
            folder = IBTreeEntryGetFolder(G_favoritesIBMS, entry) ;
            if (!folder)  {
                /* Ok, we are legal. */
                /* Add the entry to the end of the list */
                IBDLLInsert(
                    G_favoritesIBMS,
                    G_favoritesTopTen,
                    (IBDLLData)entry,
                    0,
                    IBDLL_ITEM_BAD) ;

                /* Now mark the entry as being on the top favorites */
                flags = IBTreeEntryGetFlags(G_favoritesIBMS, entry) ;
                IBTreeEntrySetFlags(
                    G_favoritesIBMS,
                    entry,
                    flags | FAVORITE_FLAG_IS_TOP) ;
            }
        }
    }
}

/**************************************************************************
 * Routine:  FavoriteRemoveFromTopTen
 **************************************************************************
 *
 * Description:
 *     Remove the item from the top.
 *
 * Inputs:
 *     dword pos                  -- Position in favorites to remove
 *
 **************************************************************************/
void FavoriteRemoveFromTopTen(dword pos)
{
    IBTreeEntry entry ;
    IBDLLData data ;
    IBDLLItem item ;
    IBTreeUserFlags flags ;

    if (!G_favoritesFile)
        return ;

    /* Remove the entry by its position */
    /* Get the entry at that location */
    entry = ILocateEntryByPos(pos, NULL, NULL) ;
    if (entry)  {
        item = IBDLLGetItem(
                   G_favoritesIBMS,
                   G_favoritesTopTen,
                   IBDLL_LOCATION_FIRST) ;
        while (item)  {
            data = IBDLLItemGetData(G_favoritesIBMS, item) ;
            if (data == entry)  {
                /* Found the item in the list */
                /* Now mark the entry as NOT being on the top favorites */
                flags = IBTreeEntryGetFlags(G_favoritesIBMS, entry) ;
                IBTreeEntrySetFlags(
                    G_favoritesIBMS,
                    entry,
                    flags & (~FAVORITE_FLAG_IS_TOP)) ;

                /* Delete the item from the list and stop looping */
                IBDLLItemDelete(G_favoritesIBMS, G_favoritesTopTen, item) ;
                item = IBDLL_ITEM_BAD ;
            } else {
                item = IBDLLItemGetNext(G_favoritesIBMS, item) ;
            }
        }
    }
}

/**************************************************************************
 * Routine:  FavoriteIsFolder
 **************************************************************************
 *
 * Description:
 *     Determine if an item is a folder.
 *
 * Inputs:
 *     dword pos                  -- Position to check as a folder
 *
 **************************************************************************/
Boolean FavoriteIsFolder(dword pos)
{
    IBTreeEntry entry ;
    Boolean isFolder = FALSE ;

    if (!G_favoritesFile)
        return FALSE ;

    /* Get the entry at that location */
    entry = ILocateEntryByPos(pos, NULL, NULL) ;
    if (entry)  {
        /* Does it have a folder node attached to it? */
        if (IBTreeEntryGetFolder(G_favoritesIBMS, entry))
           isFolder = TRUE ;
    }

    return isFolder ;
}

/**************************************************************************
 * Routine:  FavoriteFindNextDown
 **************************************************************************
 *
 * Description:
 *     Find the next logical item below the given position.  Used by
 *     FavoritePushDown.
 *
 * Inputs:
 *     dword pos                  -- Position to check below
 *     byte *p_depth              -- Returned depth of passed in pos.
 *
 * Outputs:
 *     dword                      -- Position of found item, else
 *                                   FAVORITE_BAD
 *
 **************************************************************************/
dword FavoriteFindNextDown(dword pos, byte *p_depth)
{
    dword newPos ;
    byte depth ;
    byte newDepth ;
    dword count ;

    if (!G_favoritesFile)
        return FAVORITE_BAD ;

    /* Get the depth at that location */
    ILocateEntryByPos(pos, NULL, &depth) ;
    if (p_depth)
        *p_depth = depth ;
    newPos = pos+1 ;
    count = FavoritesGetCount() ;
    while (1)  {
        /* If we have reached an end without our goal in site, return 0 */
        if (newPos >= count)  {
            newPos = FAVORITE_BAD ;
            break ;
        }

        /* What is the depth at this new position ? */
        ILocateEntryByPos(newPos, NULL, &newDepth) ;

        /* Stop if we have found a depth equal or more to left than ours */
        if (newDepth <= depth)
            break ;

        /* Next position */
        newPos++ ;
    }

    return newPos ;
}

/**************************************************************************
 * Routine:  FavoriteIsTopTen
 **************************************************************************
 *
 * Description:
 *     Determine if the item is on the top ten list
 *
 * Inputs:
 *     dword pos                  -- Position to check as a folder
 *
 **************************************************************************/
Boolean FavoriteIsTopTen(dword pos)
{
    IBTreeEntry entry ;
    Boolean isTopTen = FALSE ;

    if (!G_favoritesFile)
        return FALSE ;

    /* Get the entry at that location */
    entry = ILocateEntryByPos(pos, NULL, NULL) ;
    if (entry)  {
        /* Is it declared to be a top? */
        if (IBTreeEntryGetFlags(G_favoritesIBMS, entry) &
                FAVORITE_FLAG_IS_TOP)
           isTopTen = TRUE ;
    }

    return isTopTen ;
}

dword FavoritePushUp(dword pos)
{
    IBTreeEntry selfEntry ;
    IBTreeEntry aboveEntry ;
    byte aboveDepth ;
    dword abovePos ;
    IBTreeFolder aboveFolder ;
    IBTreeFolder selfFolder ;
    IBTreeFolder subFolder ;
    IBTreeFolder aboveSubFolder ;
    byte depth ;
    Boolean isFolder ;

    if (!G_favoritesFile)
        return FAVORITE_BAD ;

    /* Let's find the slot above that this can go in */
    /* Only do this if not the top slot */
    if (pos)  {
        /* Get information about everything before we lose our indexing */
        abovePos = pos-1 ;
        isFolder = FavoriteIsFolder(pos) ;
        do {
            aboveEntry = ILocateEntryByPos(abovePos, &aboveFolder, &aboveDepth) ;
            aboveSubFolder = IBTreeEntryGetFolder(G_favoritesIBMS, aboveEntry) ;
            if ((G_foldersInFolders) || (!isFolder))
                break ;
            if (aboveDepth == 0)
                break ;
            if (abovePos == 0)
                return FAVORITE_BAD ;
            abovePos-- ;
        } while (1) ;
        selfEntry = ILocateEntryByPos(pos, &selfFolder, &depth) ;
        if ((aboveSubFolder) && (aboveSubFolder != selfFolder) && ((G_foldersInFolders)||(!isFolder)))  {
            /* The folder above me is empty (because it is not the folder I'm
               in).  Put me IN the folder */
            aboveFolder = aboveSubFolder ;
            aboveDepth++ ;
            aboveEntry = IBTREE_APPEND ;
            abovePos++ ;
        } else if (aboveDepth > depth)  {
            aboveEntry = IBTREE_APPEND ;
            abovePos++ ;
        }

        /* Delete this entry and its children (if any) from the index */
        IDeleteTreeEntries(pos, TRUE) ;

        /* Move the whole entry (and get a new entry identifier) */
        selfEntry = IBTreeEntryMoveTo(
                        G_favoritesIBMS,
                        selfFolder,
                        selfEntry,
                        aboveFolder,
                        aboveEntry) ;

        /* Fix up the index by inserting the new items */
        subFolder = IBTreeEntryGetFolder(G_favoritesIBMS, selfEntry) ;
        if (subFolder)
            IInsertTreeEntries(abovePos, subFolder, aboveDepth+1) ;
        IInsertIndexEntry(abovePos, aboveFolder, selfEntry, aboveDepth) ;
    }

    return abovePos ;
}

dword FavoritePushDown(dword pos)
{
    dword nextDown ;
    dword oneMorePast ;
    IBTreeEntry entry ;
    IBTreeFolder folder ;
    IBTreeEntry beforeThisEntry ;
    IBTreeFolder inThisFolder = IBTREE_FOLDER_BAD ;
    IBTreeFolder oneMorePastFolder ;
    IBTreeFolder subFolder ;
    IBTreeEntry nextEntry ;
    byte newDepth ;
    byte newMoreDepth ;
    byte depth ;
    Boolean isFolder ;

    if (!G_favoritesFile)
        return FAVORITE_BAD ;

    /* Get info about the current location */
    entry = ILocateEntryByPos(pos, &folder, NULL) ;
    isFolder = FavoriteIsFolder(pos) ;

    nextDown = FavoriteFindNextDown(pos, &depth) ;
    if (nextDown != FAVORITE_BAD)  {
        /* What is past the one below us? */
        oneMorePast = nextDown+1 ;

        /* Have I found an item or a folder? */
        if (FavoriteIsFolder(nextDown))  {
            nextEntry = ILocateEntryByPos(nextDown, NULL, &newDepth) ;

            /* Is the folder on the same level, deeper, or to the left? */
            if (newDepth >= depth)  {
                if ((isFolder) && (!G_foldersInFolders))  {
                    /* Can't put a folder in a folder, let's try the next */
                    /* position down */
                    oneMorePast = FavoriteFindNextDown(nextDown, &newMoreDepth) ;
                    if ((newMoreDepth == newDepth) &&
                            (oneMorePast != FAVORITE_BAD))  {
                        /* Found something */
                        beforeThisEntry = ILocateEntryByPos(
                                              oneMorePast,
                                              &inThisFolder,
                                              &newDepth) ;
                        nextDown = pos+(oneMorePast-nextDown) ;
                    } else {
                        /* Need to append */
                        inThisFolder = folder ;
                        beforeThisEntry = IBTREE_APPEND ;
                        nextDown = FavoritesGetCount() - (nextDown - pos) ;
                    }
                } else {
                    /* Deep or same level */
                    /* Put item at beginning of folder */
                    inThisFolder = IBTreeEntryGetFolder(
                                       G_favoritesIBMS,
                                       nextEntry) ;
                    beforeThisEntry = IBTreeFolderGetEntry(
                                          G_favoritesIBMS,
                                          inThisFolder,
                                          IBTREE_LOCATION_FIRST) ;
                    newDepth++ ;
                    nextDown = pos+1 ;
                }
            } else {
                /* Otherwise, Just go up a level */
                inThisFolder = IBTreeFolderGetParent(
                                   G_favoritesIBMS,
                                   folder,
                                   &nextEntry) ;
                beforeThisEntry = IBTREE_APPEND ;
                newDepth = depth-1 ;
                nextDown = pos ;
            }
        } else {
            /* If an entry, we need to see if there is one past it */
            ILocateEntryByPos(nextDown, &inThisFolder, &newDepth) ;
            if (newDepth >= depth)  {
                beforeThisEntry = ILocateEntryByPos(
                                      oneMorePast,
                                      &oneMorePastFolder,
                                      NULL) ;
                /* If the item past is not in the same folder, just append */
                if (oneMorePastFolder != inThisFolder)
                    beforeThisEntry = IBTREE_APPEND ;

                nextDown = pos+1 ;
            } else {
                /* Otherwise, Just go up a level */
                inThisFolder = IBTreeFolderGetParent(
                                   G_favoritesIBMS,
                                   folder,
                                   &nextEntry) ;
                beforeThisEntry = IBTREE_APPEND ;
                newDepth = depth-1 ;
                nextDown = pos ;
            }
        }

    } else {
        /* We are at the end of the list */
        /* Are we levels deep? */
        if (depth)  {
            /* Yes, we need to go up one level and append at the end */
            inThisFolder = IBTreeFolderGetParent(
                               G_favoritesIBMS,
                               folder,
                               &nextEntry) ;
            beforeThisEntry = IBTREE_APPEND ;
            newDepth = depth-1 ;
            nextDown = pos ;
        }
    }

    /* Only put in a folder if we have one */
    if (inThisFolder)  {
        /* Delete this entry and its children (if any) from the index */
        IDeleteTreeEntries(pos, TRUE) ;

        /* Now that we know where we need to go to, move there */
        IBTreeEntryMoveTo(
            G_favoritesIBMS,
            folder,
            entry,
            inThisFolder,
            beforeThisEntry) ;

        /* Fix up the index by inserting the new items */
        subFolder = IBTreeEntryGetFolder(G_favoritesIBMS, entry) ;
        if (subFolder)
            IInsertTreeEntries(nextDown, subFolder, newDepth+1) ;
        IInsertIndexEntry(nextDown, inThisFolder, entry, newDepth) ;
    }

    return nextDown ;
}

/**************************************************************************
 * Routine:  ILocateEntryByPos                             * INTERNAL *
 **************************************************************************
 *
 * Description:
 *     Determine what folder or entry is at in the list.
 *
 * Inputs:
 *     dword posIndex             -- Position to look up
 *     IBTreeFolder *p_folder     -- Returned folder position
 *                                   Pass NULL if you don't want the data.
 *     byte *p_depth              -- Optional depth return value, pass
 *                                   NULL for none.
 *
 * Outputs:
 *     IBTreeEntry                -- Found entry, or IBTREE_ENTRY_BAD
 *
 **************************************************************************/
IBTreeEntry ILocateEntryByPos(
                dword posIndex,
                IBTreeFolder *p_folder,
                byte *p_depth)
{
    T_favoriteIndex *p_index = NULL ;
    word size ;
    IBTreeEntry entry = IBTREE_ENTRY_BAD ;

    if (posIndex < HugeArrayGetCount(G_favIndexFile, G_favIndexArray))  {
        HugeArrayLock(G_favIndexFile, G_favIndexArray, posIndex, (void**)&p_index, &size) ;
        if (p_index)  {
            entry = p_index->FI_entry ;
            if (p_folder)
                *p_folder = p_index->FI_folder ;
            if (p_depth)
                *p_depth = p_index->FI_depth ;
            HugeArrayUnlock(p_index) ;
        } else {
            if (p_folder)
                *p_folder = IBTREE_FOLDER_BAD ;
        }
    } else {
        if (p_folder)
            *p_folder = IBTREE_FOLDER_BAD ;
    }

    return entry ;
}

/**************************************************************************
 * Routine:  IAppendIndexEntry                             * INTERNAL *
 **************************************************************************
 *
 * Description:
 *     Create a new entry in the index table and set the folder and entry.
 *
 * Inputs:
 *     IBTreeFolder folder        -- Folder to append
 *     IBTreeEntry entry          -- Entry in this folder
 *     byte depth                 -- Depth of entry
 *
 * Outputs:
 *     dword                      -- Index of entry
 *
 **************************************************************************/
dword IAppendIndexEntry(
          IBTreeFolder folder,
          IBTreeEntry entry,
          byte depth)
{
    dword pos = 0 ;
    T_favoriteIndex *p_index ;
    word size ;

    EC_ERROR_IF(!G_favIndexFile, -1) ;
    if (G_favIndexFile)  {
        /* Add an element to the end of the huge array */
        HugeArrayAppend(
            G_favIndexFile,
            G_favIndexArray,
            sizeof(T_favoriteIndex),
            NULL) ;
        pos = FavoritesGetCount() - 1 ;
        HugeArrayLock(
            G_favIndexFile,
            G_favIndexArray,
            pos,
            (void**)&p_index,
            &size) ;

        p_index->FI_entry = entry ;
        p_index->FI_folder = folder ;
        p_index->FI_depth = depth ;

        /* Dirty and unlock */
        HugeArrayDirty(p_index) ;
        HugeArrayUnlock(p_index) ;
    }

    return pos ;
}

/**************************************************************************
 * Routine:  IDeleteFolder                                 * INTERNAL *
 **************************************************************************
 *
 * Description:
 *     Deletes all the items in a folder at the given position.  Deletes
 *     folder too.
 *
 * Inputs:
 *     dword pos                  -- Position of folder
 *
 **************************************************************************/
Boolean IDeleteFolder(dword pos)
{
    byte folderDepth ;
    byte currentDepth ;

    /* Delete all the entries that position in the same folder */
    /* Get the first entry and folder */
    ILocateEntryByPos(pos, NULL, &folderDepth) ;

    /* Delete the entries one by one */
    ILocateEntryByPos(pos+1, NULL, &currentDepth) ;
    while (currentDepth > folderDepth)  {
        if (!FavoriteDelete(pos+1)) break;
        ILocateEntryByPos(pos+1, NULL, &currentDepth) ;
    }

    /* Finally, delete this folder entry */
    return IDeleteEntry(pos) ;
}

/**************************************************************************
 * Routine:  IDeleteEntry                                  * INTERNAL *
 **************************************************************************
 *
 * Description:
 *     Delete a single item in the list
 *
 * Inputs:
 *     dword pos                  -- Position of folder
 *
 **************************************************************************/
Boolean IDeleteEntry(dword pos)
{
    IBTreeEntry entry ;
    IBTreeFolder folder ;
    T_favoriteHeader *p_header ;
    T_favoriteHeader header;
    dword index ;
    Boolean deleted = FALSE;

    entry = ILocateEntryByPos(pos, &folder, NULL) ;
    if (entry)   {
        /* If the entry is on the top favorites, remove it first */
        if (FavoriteIsTopTen(pos))
            FavoriteRemoveFromTopTen(pos) ;

        /* Find the entry's link to the record */
        index = IBTreeEntryGetData(G_favoritesIBMS, entry) ;

        /* Delete the data in the record */
        p_header = IBMSLock(G_favoritesList, index) ;
        if (p_header)  {
            header = *p_header ;
            IBMSUnlock(G_favoritesList, p_header) ;

            if (header.FH_title)
                IBMSFree(G_favoritesList, header.FH_title) ;
            if (header.FH_location)
                IBMSFree(G_favoritesList, header.FH_location) ;
            if (header.FH_notes)
                IBMSFree(G_favoritesList, header.FH_notes) ;
        }

        /* Delete the record */
        IBMSFree(G_favoritesList, index) ;

        /* Delete the entry with the reference to the record */
        /* in the folder */
        IBTreeEntryDelete(G_favoritesIBMS, folder, entry) ;
        HugeArrayDelete(G_favIndexFile, G_favIndexArray, 1, pos) ;
	deleted = TRUE;
    }
    return deleted;
}

/**************************************************************************
 * Routine:  IInsertIndexEntry                             * INTERNAL *
 **************************************************************************
 *
 * Description:
 *     Create a new entry in the index table and set the folder and entry.
 *
 * Inputs:
 *     dword pos                  -- Position to insert at
 *     IBTreeFolder folder        -- Folder to append
 *     IBTreeEntry entry          -- Entry in this folder
 *     byte depth                 -- Depth of entry
 *
 * Outputs:
 *     dword                      -- Index of entry
 *
 **************************************************************************/
void IInsertIndexEntry(
          dword pos,
          IBTreeFolder folder,
          IBTreeEntry entry,
          byte depth)
{
    T_favoriteIndex *p_index ;
    word size ;

    EC_ERROR_IF(!G_favIndexFile, -1) ;
    if (G_favIndexFile)  {
        /* Add an element to the end of the huge array */
        HugeArrayInsert(
            G_favIndexFile,
            G_favIndexArray,
            sizeof(T_favoriteIndex),
            pos,
            NULL) ;

        HugeArrayLock(
            G_favIndexFile,
            G_favIndexArray,
            pos,
            (void**)&p_index,
            &size) ;

        p_index->FI_entry = entry ;
        p_index->FI_folder = folder ;
        p_index->FI_depth = depth ;

        /* Dirty and unlock */
        HugeArrayDirty(p_index) ;
        HugeArrayUnlock(p_index) ;
    }
}

/**************************************************************************
 * Routine:  IInsertTreeEntries                            * INTERNAL *
 **************************************************************************
 *
 * Description:
 *     Insert a whole group of entries in the lookup table based on the
 *     given file.  Calls recursively on itself.
 *
 * Inputs:
 *     dword pos                  -- Position to insert at
 *     IBTreeFolder folder        -- Folder to append
 *     IBTreeEntry entry          -- Entry in this folder
 *     byte depth                 -- Depth of entry
 *
 * Outputs:
 *     dword                      -- Index of entry past all added
 *
 **************************************************************************/
dword IInsertTreeEntries(dword pos, IBTreeFolder folder, byte depth)
{
    IBTreeEntry entry ;
    IBTreeFolder subFolder ;
    IBTreeUserFlags flags ;

    entry = IBTreeFolderGetEntry(
                G_favoritesIBMS,
                folder,
                IBTREE_LOCATION_FIRST) ;
    while (entry)  {
        /* Add this entry */
        IInsertIndexEntry(pos++, folder, entry, depth) ;
        subFolder = IBTreeEntryGetFolder(G_favoritesIBMS, entry) ;
        flags = IBTreeEntryGetFlags(G_favoritesIBMS, entry) ;

        /* Add all children folders (if open) */
        if ((subFolder) && (flags & FAVORITE_FLAG_IS_OPEN))
            pos = IInsertTreeEntries(pos, subFolder, depth+1) ;

        entry = IBTreeEntryGetNext(G_favoritesIBMS, entry) ;
    }

    return pos ;
}

/**************************************************************************
 * Routine:  IDeleteTreeEntries                            * INTERNAL *
 **************************************************************************
 *
 * Description:
 *     Delete a whole group of entries and all the subfolders.
 *     Calls recursively on itself.
 *
 * Inputs:
 *     dword pos                  -- Position to start deleting
 *     IBTreeFolder folder        -- Folder to delete from list
 *
 **************************************************************************/
void IDeleteTreeEntries(dword pos, Boolean deleteSelf)
{
    IBTreeEntry entry ;
    IBTreeFolder subFolder ;
    IBTreeFolder folder ;
    byte depth ;
    byte subDepth ;
    IBTreeFolder subSubFolder ;
    dword origPos = pos ;

    entry = ILocateEntryByPos(pos++, &folder, &depth) ;

    if (entry)  {
        /* Determine children's depth */
        depth++ ;

        /* We now have info about the folder holding the following items */
        /* Let's delete those items */
        entry = ILocateEntryByPos(pos, &subFolder, &subDepth) ;
        while (entry)  {
            if (subDepth < depth)
                break ;

            /* If this entry has a folder, then delete all its sub-entries */
            /* first. */
            subSubFolder = IBTreeEntryGetFolder(G_favoritesIBMS, entry) ;
            if (subSubFolder)
                IDeleteTreeEntries(pos, FALSE) ;

            /* Ok, let's delete this entry */
            HugeArrayDelete(G_favIndexFile, G_favIndexArray, 1, pos) ;

            entry = ILocateEntryByPos(pos, &subFolder, &subDepth) ;
        }

        if (deleteSelf)
            HugeArrayDelete(G_favIndexFile, G_favIndexArray, 1, origPos) ;
    }
}

/**************************************************************************
 * Routine:  IFavoriteDataResize                           * INTERNAL *
 **************************************************************************
 *
 * Description:
 *     Resizes a IBMS block of data.
 *
 * Inputs:
 *     dword pos                  -- Position to start deleting
 *     IBTreeFolder folder        -- Folder to delete from list
 *
 **************************************************************************/
void IFavoriteDataResize(IBMSHandle memory, IBMSIndex *block, word newSize)
{
    IBMSIndex localBlock ;

    localBlock = *block ;
    if (localBlock)  {
        IBMSFree(memory, *block) ;
        localBlock = IBMS_BAD ;
    }
    if (newSize)
        if (*block)
            IBMSResize(memory, localBlock, newSize) ;
        else
            localBlock = IBMSAlloc(memory, newSize) ;

    *block = localBlock ;
}

/**************************************************************************
 * Routine:  FavoriteCreateIcon
 **************************************************************************
 *
 * Description:
 *     Takes a locked favorite and icon and creates a LMEM gstring
 *     returning the width and height.  Be sure to use FavoriteDestroyIcon.
 *
 * Inputs:
 *     T_lockedFavorite *p_favorite -- Favorite title to use
 *     optr icon                  -- Icon to display next to text
 *     word insetX                -- Amount to shift right
 *     word *width                -- Returned width of icon
 *     word *height               -- Returned height of icon
 *     GStateHandle *p_gstate     -- Returned created gstate
 *
 * Outputs:
 *     optr                       -- Created gstring icon, or NullHandle.
 *
 **************************************************************************/
optr FavoriteCreateIcon(
                 T_lockedFavorite *p_favorite,
                 optr icon,
                 word insetX,
                 word *width,
                 word *height,
                 GStateHandle *p_gstate)
{
    MemHandle mem = NullHandle ;
    ChunkHandle chunk = NullHandle ;
    word height1=0, height2=0, maxHeight ;
    word offset1, offset2 ;
    WWFixedAsDWord pointSize ;
    word xStart ;
    word bitmapWidth ;
    Bitmap *p_bitmap ;
    GStateHandle gstate ;
    TCHAR favoriteName[60] ;
    word i, maxLen;

    if (!p_favorite)
        return NULL ;

    /* Copy and truncate the string */
    /* (with fancy ... extension) */
    gstate = GrCreateState(0);
    maxLen = strlen(p_favorite->p_title);
    if (maxLen > sizeof(favoriteName)-4) {
	maxLen = sizeof(favoriteName)-4;
    }
    for (i = maxLen; i; i--) {
	/* 400 should be greater than or equal to 400 in favorui.goh's
	   FavoritesOrganizeRegion */
	if (GrTextWidth(gstate, p_favorite->p_title, i) < 400)
	    break;
    }
    strncpy(favoriteName, p_favorite->p_title, i) ;
    if (i < strlen(p_favorite->p_title)) {
	strcpy(favoriteName+i, _TEXT("...")) ;
    } else {
	favoriteName[i] = C_NULL;
    }
    GrDestroyState(gstate);

    mem = MemAllocLMem(LMEM_TYPE_GENERAL, 0) ;
    if (mem)  {
        gstate = GrCreateGString(mem, GST_CHUNK, (word*)&chunk) ;
        if (gstate)  {
            /* Get information about the bitmap */
            MemLock(OptrToHandle(icon)) ;
            p_bitmap = LMemDeref(icon) ;

            /* Calculate how to center the text and moniker */
            if (!height1)  {
                bitmapWidth = p_bitmap->B_width ;
                height2 = p_bitmap->B_height ;
                GrGetFont(gstate, &pointSize) ;
                height1 = IntegerOf(pointSize) ;
                maxHeight = (height1 > height2)?height1:height2 ;
                offset1 = ((maxHeight-height1)>>2) ;
                offset2 = ((maxHeight-height2)>>1) ;
            }

            /* Draw the bitmap on the moniker */
            GrDrawBitmap(gstate, insetX, offset2, p_bitmap, NULL) ;
            MemUnlock(OptrToHandle(icon)) ;

            /* Now draw the text (and track the width) */
            xStart = DWORD_X(GrGetCurPos(gstate)) ;
            GrDrawText(gstate, bitmapWidth+insetX+2, offset1, favoriteName, 0) ;
            GrEndGString(gstate) ;

            /* Set up the return values */
            *width = 2+DWORD_X(GrGetCurPos(gstate)) - xStart ;
            *height = maxHeight ;
            *p_gstate = gstate ;
        } else {
            MemFree(mem) ;
            mem = NullHandle ;
        }
    }

    return ConstructOptr(mem, chunk) ;
}

/**************************************************************************
 * Routine:  FavoriteDestroyIcon
 **************************************************************************
 *
 * Description:
 *     Destroys an icon created with FavoriteCreateIcon.  You MUST do
 *     this per creation.
 *
 * Inputs:
 *     GStateHandle gstate        -- GState of icon
 *     optr icon                  -- Direct memory of icon
 *
 **************************************************************************/
void FavoriteDestroyIcon(GStateHandle gstate, optr icon)
{
    GrDestroyGString(gstate, 0, GSKT_KILL_DATA) ;
    MemFree(OptrToHandle(icon)) ;
}

/**************************************************************************
 * Routine:  IFavoriteLockByEntry                          * INTERNAL *
 **************************************************************************
 *
 * Description:
 *     Locks an entry based on the tree node entry given and records
 *     the given depth.
 *
 * Inputs:
 *     IBTreeEntry entryId        -- Entry in tree to lock
 *     word depth                 -- Depth of entry
 *
 * Outputs:
 *     T_lockedFavorite *         -- Favorite structure locked,
 *                                   NULL if index not found.
 *
 **************************************************************************/
T_lockedFavorite *IFavoriteLockByEntry(IBTreeEntry entry, word depth)
{
    T_favoriteHeader *p_header = NULL ;
    T_lockedFavorite *p_favorite = NULL ;
    MemHandle mem ;
    T_favoriteLockedInternal *p_fav = NULL ;
    dword entryId ;
    TCHAR *p_text ;

    entryId = IBTreeEntryGetData(G_favoritesIBMS, entry) ;
    if (entryId)  {
        p_header = IBMSLock(G_favoritesList, entryId) ;
        if (p_header)  {
            mem = MemAlloc(
                      sizeof(T_favoriteLockedInternal),
                      HF_DYNAMIC|HF_SHARABLE,
                      HAF_ZERO_INIT) ;
            if (mem)  {
                /* Create a temporary block to hold all our data */
                p_fav = MemLock(mem) ;
                p_fav->FLI_self = mem ;
                p_fav->FLI_favorite.p_title = NULL ;
                p_fav->FLI_favorite.p_location = NULL ;
                p_fav->FLI_favorite.p_notes = NULL ;
                p_fav->FLI_favorite.depth = depth ;
                p_fav->FLI_headerEntry = entryId ;
                p_fav->FLI_isDirty = FALSE ;

                if (p_header->FH_title)  {
                    p_text = IBMSLock(G_favoritesList, p_header->FH_title) ;
                    p_fav->FLI_memTitle = MemAlloc((1+strlen(p_text))*sizeof(TCHAR), HF_DYNAMIC, HAF_NO_ERR) ;
                    p_fav->FLI_favorite.p_title = MemLock(p_fav->FLI_memTitle) ;
                    strcpy(p_fav->FLI_favorite.p_title, p_text) ;
                    IBMSUnlock(G_favoritesList, p_text) ;
                }
                if (p_header->FH_location)  {
                    p_text = IBMSLock(G_favoritesList, p_header->FH_location) ;
                    p_fav->FLI_memLocation = MemAlloc((1+strlen(p_text))*sizeof(TCHAR), HF_DYNAMIC, HAF_NO_ERR) ;
                    p_fav->FLI_favorite.p_location = MemLock(p_fav->FLI_memLocation) ;
                    strcpy(p_fav->FLI_favorite.p_location, p_text) ;
                    IBMSUnlock(G_favoritesList, p_text) ;
                }
                if (p_header->FH_notes)  {
                    p_text = IBMSLock(G_favoritesList, p_header->FH_notes) ;
                    p_fav->FLI_memNotes = MemAlloc((1+strlen(p_text))*sizeof(TCHAR), HF_DYNAMIC, HAF_NO_ERR) ;
                    p_fav->FLI_favorite.p_notes = MemLock(p_fav->FLI_memNotes) ;
                    strcpy(p_fav->FLI_favorite.p_notes, p_text) ;
                    IBMSUnlock(G_favoritesList, p_text) ;
                }
                G_numFavoritesLocked++ ;
                p_favorite = &p_fav->FLI_favorite ;
            }
            IBMSUnlock(G_favoritesList, p_header) ;
        }
    }

    return p_favorite ;
}

/**************************************************************************
 * Routine:  FavoritesUpdate
 **************************************************************************
 *
 * Description:
 *    Actually saves out any data that may have changed.
 *
 **************************************************************************/
void FavoritesUpdate()
{
    IBMSSave(G_favoritesIBMS) ;
    VMSave(G_favoritesFile) ;
}

@endif
