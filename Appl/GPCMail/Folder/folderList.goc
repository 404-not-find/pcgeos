/***********************************************************************
 *
 *	Copyright (c) New Deal 1998 -- All Rights Reserved
 *
 * PROJECT:	  Mail
 * MODULE:	  Mail
 * FILE:	  folderList.goc
 *
 * AUTHOR:  	  Gene Anderson: 12/2/98
 *
 * REVISION HISTORY:
 *	Date	  Name	    Description
 *	----	  ----	    -----------
 *	12/2/98    gene	    Initial version
 *
 * DESCRIPTION:
 *	FolderListClass for the Mail application
 *
 * 	$Id$
 *
 ***********************************************************************/

@include "mail.goh"
@include "class.goh"
@include "global.goh"
@include <sem.h>

@classdecl FolderListClass;

#ifdef __BORLANDC__
#pragma codeseg InitCode
#endif



/**************************************************************
 *      
 * FUNCTION:        MSG_META_FUP_KBD_CHAR
 * PASS:            character - character
 *                  flags - CharFlags + ShiftState
 *                  state - scan code
 * RETURN:          none
 * DESCRIPTION:
 *         Handle an <ENTER> press by sending it to the message list
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/2/99     Initial Revision
 ***************************************************************/

@method FolderListClass, MSG_META_FUP_KBD_CHAR
{
    /*
     * if we get a press of the Enter key...
     */
    if ((!(flags & CF_RELEASE)) && (character == ((CS_CONTROL<<8)|VC_ENTER))) {
	@send, forceQueue TheMessageList::MSG_MAIL_LIST_OPEN_MESSAGE();
	return(TRUE);
    }
    @callsuper();
}


/**************************************************************
 *      
 * FUNCTION:        MSG_FOLDER_LIST_FREE
 * PASS:            none
 * RETURN:          none
 * DESCRIPTION:
 *         we're shutting down
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      10/26/99    Initial Revision
 ***************************************************************/

@method FolderListClass, MSG_FOLDER_LIST_FREE
{
    if (pself->FLI_folderArray) {
	LMemFree(pself->FLI_folderArray);
	pself->FLI_folderArray = 0;
    }
}

#ifdef __BORLANDC__
#pragma codeseg FolderCode
#endif

@ifdef CUI_SUPPORT

#define FOLDER_LIST_NUDGE 6


/**************************************************************
 *      
 * FUNCTION:        FolderSetCUIMoniker
 * PASS:            list:   list optr to set moniker in
 *                  item:   item # to set
 *                  bmap:   bitmap to use
 *                  folderName:   name of folder
 *                  numMsgs:   # of messages (-1 to not display)
 * RETURN:          none 
 * DESCRIPTION:
 *         Make and set a gstring moniker for a CUI folder name
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      9/28/98     Initial Revision
 ***************************************************************/

void
FolderSetCUIMoniker(optr list,
		 word item,
		 optr bmap,
		 char *folderName)
{
	GStateHandle gs;
	Bitmap *bp;
	word   gschunk;
	sword   width, height, twidth;

	/*
	 * Create a GString to use
	 */
	gs = GrCreateGString(OptrToHandle(list), GST_CHUNK, &gschunk);
	/*
	 * Initialize the GString/GState to UI font & pointsize
	 */
	SetUIFontPointsize(list, gs);

	/*
	 * Draw the bitmap centered
	 */
	height = GetUIFontHeight(gs)+5;
	/* getting the width from MSG_VIS_GET_SIZE create a feedback loop
	 * causing the monikers to get gradually bigger.  Subtracting 
	 * FOLDER_LIST_NUDGE is a hack to keep them from growing
	 */
	width =(@call list::MSG_VIS_GET_SIZE()) - FOLDER_LIST_NUDGE;

	(void *) MemLock(OptrToHandle(bmap));
	bp = LMemDeref(bmap);
	GrDrawBitmap(gs, (width-CUI_FOLDER_ICON_WIDTH)/2, FOLDER_NAME_OFFSET_Y, bp, NULL);
	MemUnlock(OptrToHandle(bmap));

	/*
	 * Draw the folder name centered
	 */
	twidth = GrTextWidth(gs, folderName, 0);
	GrDrawText(gs,
		   (width-twidth)/2,
		   CUI_FOLDER_ICON_HEIGHT+FOLDER_NAME_OFFSET_Y,
		   folderName, 0);
	/*
	 * Finish up the gstring
	 */
	GrEndGString(gs);

	/*
	 * Finally, set the moniker
	 */
	@call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_MONIKER(
              item,              /* Item number -- Folder number */
              0,                 /* Item not disabled */
              CUI_FOLDER_ICON_HEIGHT+height,      /* height */
              width,                 /* width, 0 = auto detect */
              0,                 /* size, 0 = auto detect */
              VMDT_GSTRING,
              VMST_OPTR,
              ConstructOptr(OptrToHandle(list), gschunk)
	      );

	GrDestroyGString(gs, 0, GSKT_KILL_DATA);
}

@endif


/**************************************************************
 *      
 * FUNCTION:        FolderSetMoniker
 * PASS:            list:   list optr to set moniker in
 *                  item:   item # to set
 *                  bmap:   bitmap to use
 *                  folderName:   name of folder
 *                  numMsgs:   # of messages (-1 to not display)
 * RETURN:          none 
 * DESCRIPTION:
 *         Make and set a gstring moniker for a folder name
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      9/28/98     Initial Revision
 ***************************************************************/

void
FolderSetMoniker(optr list,
		 word item,
		 optr bmap,
		 char *folderName,
		 sword numMsgs)
{
	GStateHandle gs;
	Bitmap *bp;
	word   gschunk;
	sword   cwidth, width, yOff, sw;
        TCHAR buf[MAX_FOLDER_NAME_LENGTH+1];

	/*
	 * Create a GString to use
	 */
	gs = GrCreateGString(OptrToHandle(list), GST_CHUNK, &gschunk);
	/*
	 * Initialize the GString/GState to UI font & pointsize
	 */
	SetUIFontPointsize(list, gs);

	/*
	 * Draw the bitmap
	 */
	yOff = (GetUIFontHeight(gs) + 5 - FOLDER_ICON_HEIGHT)/2;
	(void *) MemLock(OptrToHandle(bmap));
	bp = LMemDeref(bmap);
	GrDrawBitmap(gs, FOLDER_ICON_OFFSET_X, yOff, bp, NULL);
	MemUnlock(OptrToHandle(bmap));

	/*
	 * Draw the folder name in the space allowed
	 */
	width = @call list::MSG_VIS_GET_SIZE();
	if (numMsgs != -1) {
	    cwidth = GrFontMetrics(gs, GFMI_AVERAGE_WIDTH_ROUNDED);
	} else {
	    cwidth = 0;
	}
	strcpy(buf, folderName);
	FitStringInField(gs, buf, width - cwidth*3 - (FOLDER_ICON_OFFSET_X + FOLDER_ICON_WIDTH + GAP_BETWEEN_ICON_AND_NAME + 2));
	GrDrawText(gs,
		   FOLDER_ICON_OFFSET_X + FOLDER_ICON_WIDTH + GAP_BETWEEN_ICON_AND_NAME,
		   FOLDER_NAME_OFFSET_Y,
		   buf, 0);

	/*
	 * Draw the number of messages
	 */
@ifdef SHOW_NUM_MESSAGES_IN_FOLDERS
	sprintf(buf, "%d", numMsgs);
        sw = GrTextWidth(gs, buf, 0);
	GrDrawText(gs,
		   width-cwidth-sw,
		   FOLDER_NAME_OFFSET_Y,
		   buf, 0);
@else
        if (numMsgs != -1) {
	    sprintf(buf, " (%d)", numMsgs);
	    GrDrawTextAtCP(gs, buf, 0);
	}
@endif

	/*
	 * Finish up the gstring
	 */
	GrEndGString(gs);

	/*
	 * Finally, set the moniker
	 */
	@call list::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_MONIKER(
              item,              /* Item number -- Folder number */
              0,                 /* Item not disabled */
              0,                 /* height, 0 = auto detect */
              0 ,                /* width, 0 = auto detect */
              0,                 /* size, 0 = auto detect */
              VMDT_GSTRING,
              VMST_OPTR,
              ConstructOptr(OptrToHandle(list), gschunk)
	      );

	GrDestroyGString(gs, 0, GSKT_KILL_DATA);

}


/**************************************************************
 *      
 * FUNCTION:        MSG_FOLDER_LIST_GET_NUM_MESSAGES
 * PASS:            folderNum - folder #
 * RETURN:          none
 * DESCRIPTION:
 *         Count the number of messages in the specified folder
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      9/28/98     Initial Revision
 ***************************************************************/

@method FolderListClass, MSG_FOLDER_LIST_GET_NUM_MESSAGES
{
	FileEnumParams params;
	word bufHan;
	char *buf;
	word numNoFit;

	FilePushDir();
	bufHan = @call oself::MSG_FOLDER_LIST_GET_FOLDER_NAME(folderNum);
	buf = MemLock(bufHan);
	GotoMailDirectory(buf);
	MemFree(bufHan);

	params.FEP_searchFlags = FESF_NON_GEOS;
	params.FEP_returnAttrs = (void *) FESRT_COUNT_ONLY;
	params.FEP_returnSize = 0;
	params.FEP_matchAttrs = 0;
	params.FEP_bufSize = FE_BUFSIZE_UNLIMITED;
	params.FEP_skipCount = 0;
	(void) FileEnum(&params, &bufHan, &numNoFit);
	FilePopDir();

	return(numNoFit);
}


/**************************************************************
 *          
 * FUNCTION:        MSG_FOLDER_LIST_GET_NUM_FOLDERS
 * DESCRIPTION:     return # of folders
 *
 * PASS:            none
 * RETURN:          # of folders
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/2/98     Initial Revision
 *         gene      7/2/99      Rewrote for folder name array
 ***************************************************************/
@method FolderListClass, MSG_FOLDER_LIST_GET_NUM_FOLDERS
{
    word numDirs;

@ifdef CUI_SUPPORT
    if (@call MailAppObj::MSG_MAIL_APP_GET_USER_LEVEL() > UIIL_BEGINNING) {
@endif
        numDirs = ChunkArrayGetCountHandles(OptrToHandle(oself), pself->FLI_folderArray);
@ifdef CUI_SUPPORT
    } else {
	numDirs = 5; /* drafts + inbox + outbox + sent + trash */
    }
@endif

    return(numDirs);
}


/**************************************************************
 *          
 * FUNCTION:        MSG_FOLDER_LIST_GET_FOLDER_NUM
 * DESCRIPTION:     return folder #
 *
 * PASS:            folder name
 * RETURN:          folder num, -1 if could not find folder
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         ian       5/17/99     Initial Revision
 *         gene      7/2/99      Rewrote for folder name array
 ***************************************************************/
@method FolderListClass, MSG_FOLDER_LIST_GET_FOLDER_NUM
{
    word i, numDirs, eSize;
    FolderListStruct *fls;
    optr arr;

    FilePushDir();
    GotoMailDirectory(NULL);
    arr = pself->FLI_folderArray;
    numDirs = @call oself::MSG_FOLDER_LIST_GET_NUM_FOLDERS();
    for (i = 0; i < numDirs; i++) {
	fls = ChunkArrayElementToPtr(arr, i, &eSize);
	if (!strcmp(folderName,fls->FLS_name)) {
	    break;
	}
    }
	
    if (i == numDirs) {
	i = -1;
    }
    FilePopDir();
    return(i);
}


/**************************************************************
 *          
 * FUNCTION:        MSG_FOLDER_LIST_GET_FOLDER_NAME
 * DESCRIPTION:     return name of folder
 *
 * PASS:            folderNum - # of folder in list
 * RETURN:          handle of buffer with folder name
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/2/98     Initial Revision
 *         gene      7/2/99      Rewrote for folder name array
 ***************************************************************/
@method FolderListClass, MSG_FOLDER_LIST_GET_FOLDER_NAME
{
    MemHandle mh;
    FolderListStruct *fls;
    word eSize;
    TCHAR *p;

    mh = MemAlloc(sizeof(FileLongName), HF_DYNAMIC, HAF_STANDARD|HAF_NO_ERR);
    p = MemLock(mh);
    fls = ChunkArrayElementToPtr(pself->FLI_folderArray, folderNum, &eSize);
    strcpy(p, fls->FLS_name);
    MemUnlock(mh);
    return(mh);
}


/**************************************************************
 *          
 * FUNCTION:        MSG_FOLDER_LIST_QUERY_MONIKER
 * DESCRIPTION:     handle a dynamic list query for a moniker
 *
 * PASS:            list - optr of list
 *                  item - item #
 * RETURN:          none
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/2/98     Initial Revision
 ***************************************************************/

@ifdef CUSTOM_FOLDER_ICONS

optr folderMonikers[] = {
    @draftsFolderMoniker,
    @inboxFolderMoniker,
    @outboxFolderMoniker,
    @sentFolderMoniker,
    @trashFolderMoniker
};

@endif

@ifdef CUI_SUPPORT

optr cuiMonikers[] = {
    @CUIDraftsFolderMoniker,
    @CUIInboxFolderMoniker,
    @CUIOutboxFolderMoniker,
    @CUISentFolderMoniker,
    @CUITrashFolderMoniker
};

@endif

@method FolderListClass, MSG_FOLDER_LIST_QUERY_MONIKER
{
	MemHandle bufHan;
	char *buf;
	word numMsgs;
	optr bmap;

	bufHan = @call oself::MSG_FOLDER_LIST_GET_FOLDER_NAME(item);
	buf = MemLock(bufHan);
	/*
	 * Count the number of messages in the folder
	 */
	numMsgs = @call oself::MSG_FOLDER_LIST_GET_NUM_MESSAGES(item);

        /*
	 * Make a moniker and set it in the list
	 */
@ifdef CUSTOM_FOLDER_ICONS
        if (item <= MFID_TRASH) {
	    bmap = folderMonikers[item];
	} else {
	    bmap = @genericFolderMoniker;
	}
@else
        bmap = @folderCloseBitmap;
@endif

@ifdef CUI_SUPPORT
        if (@call MailAppObj::MSG_MAIL_APP_GET_USER_LEVEL() <= UIIL_BEGINNING) {
	    if (item > MFID_TRASH) {
		item = MFID_TRASH;
	    }
	    bmap = cuiMonikers[item];
	    FolderSetCUIMoniker(list, item, bmap, buf);
	    goto doneFree;
        }
@endif
@ifdef SHOW_NUM_MESSAGES_IN_FOLDERS
        FolderSetMoniker(list, item, bmap, buf, numMsgs);
@else
	if (item == MFID_DRAFTS) {
	    FolderSetMoniker(list, item, bmap, buf, numMsgs);
	} else {
	    FolderSetMoniker(list, item, bmap, buf, -1);
	}
@endif

doneFree:
	MemFree(bufHan);
}


/**************************************************************
 *          
 * FUNCTION:        MSG_FOLDER_LIST_FOLDER_SELECTED
 * DESCRIPTION:     handle a list selection
 *
 * PASS:            selection - item #
 *                  numSelections - # of selections
 *                  stateFlags - GenItemGroupStateFlags
 * RETURN:          none
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/4/98     Initial Revision
 ***************************************************************/

#define FOLDER_NAME_MAX_LEN_FOR_MONIKER 24

@method FolderListClass, MSG_FOLDER_LIST_FOLDER_SELECTED
{
@ifndef SORT_BY_COLUMNS
        word numMessages;
        TCHAR buf[MAX_FOLDER_CONTENTS_STRING+4];
	word bufHan;
	TCHAR *folderName;
@endif
        word userLevel;
	word fnum = selection;

	userLevel = @call MailAppObj::MSG_MAIL_APP_GET_USER_LEVEL();
@ifndef SORT_BY_COLUMNS
	/*
	 * Get the number of messages and the folder name
	 */
	numMessages = @call oself::MSG_FOLDER_LIST_GET_NUM_MESSAGES(selection);
	bufHan = @call oself::MSG_FOLDER_LIST_GET_FOLDER_NAME(selection);
	folderName = MemLock(bufHan);
	GotoMailDirectory(folderName);

	/*
	 * hack the name so it doesn't get too wide
	 */
	if (strlen(folderName) > FOLDER_NAME_MAX_LEN_FOR_MONIKER) {
	    folderName[FOLDER_NAME_MAX_LEN_FOR_MONIKER] = C_ELLIPSIS;
	    folderName[FOLDER_NAME_MAX_LEN_FOR_MONIKER+1] = 0;
	}
	/*
	 * Construct the moniker string based on the number of messages
	 */
	LockStrings();
	switch (numMessages) {
	    case 0:  sprintf(buf, LMemDeref(@noMessagesCtStr), folderName);
		break;
	    case 1:  sprintf(buf, LMemDeref(@oneMessageCtStr), folderName);
		break;
	    default: sprintf(buf, LMemDeref(@nMessagesCtStr), folderName, numMessages);
		break;
	}
	UnlockStrings();

	/*
	 * set the moniker
	 */
	@call MessageListGlyph::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(buf, VUM_DLYD);

	/*
	 * clean up
	 */
	MemFree(bufHan);
@endif

	/*
	 * Enable/disable based on standard folders
	 */
	if (numSelections == 0 || selection < NUM_BUILT_IN_FOLDERS) {
	    @call DeleteFolderTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DLYD);
	    @call RenameFolderDialog::MSG_GEN_SET_NOT_ENABLED(VUM_DLYD);
	} else {
	    @call DeleteFolderTrigger::MSG_GEN_SET_ENABLED(VUM_DLYD);
	    @call RenameFolderDialog::MSG_GEN_SET_ENABLED(VUM_DLYD);
	}
	/*
	 * change Throw Away to Recover for Trash
	 */
        if (userLevel > UIIL_INTRODUCTORY) {
	    if (selection == MFID_TRASH) {
		@call ThrowAwayTool::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
		@call ThrowAwayTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
		@call ReadThrowAwayTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
		@call ReadThrowAwayTool::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
		@call RecoverTool::MSG_GEN_SET_USABLE(VUM_DLYD);
		@call RecoverTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
		@call ReadRecoverTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
		@call ReadRecoverTool::MSG_GEN_SET_USABLE(VUM_DLYD);
	    } else {
		@call ThrowAwayTool::MSG_GEN_SET_USABLE(VUM_DLYD);
		@call ThrowAwayTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
		@call ReadThrowAwayTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
		@call ReadThrowAwayTool::MSG_GEN_SET_USABLE(VUM_DLYD);
		@call RecoverTool::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
		@call RecoverTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
		@call ReadRecoverTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
		@call ReadRecoverTool::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
	    }
	/*
	 * change Read to Edit for Drafts and Outbox and disable
	 * 'Show All' and 'Show Unread Only'
	 */
	    if (selection == MFID_DRAFTS || selection == MFID_OUTBOX) {
		@call ReadMessageTool::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
		@call ReadMessageTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
		@call EditMessageTool::MSG_GEN_SET_USABLE(VUM_DLYD);
		@call EditMessageTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
	    } else {
		@call ReadMessageTool::MSG_GEN_SET_USABLE(VUM_DLYD);
		@call ReadMessageTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
		@call EditMessageTool::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
		@call EditMessageTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
	    }
	}

@ifdef SORT_BY_COLUMNS
        /*
	 * change Sender to Recipient for Sent and Outbox
	 */
        if (selection == MFID_OUTBOX || selection == MFID_SENT || selection == MFID_DRAFTS) {
	    @call SortBySenderButton::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(@recipientMkr, VUM_DLYD);
	} else {
	    @call SortBySenderButton::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(@senderMkr, VUM_DLYD);
	}
@endif

	/*
	 * rebuild the message list
	 */
	@send TheMessageList::MSG_MAIL_LIST_SET_FOLDER(fnum);
	/*
	 * set the focus
	 */
@ifdef GIVE_MESSAGE_LIST_FOCUS_ON_OPEN
	if (numMessages) {
	    @call TheMessageList::MSG_META_GRAB_FOCUS_EXCL();
	} else {
	    @call oself::MSG_META_GRAB_FOCUS_EXCL();
	}
@endif
	@send TheMessageList::MSG_GEN_ITEM_GROUP_SEND_STATUS_MSG(FALSE);
}


/**************************************************************
 *      
 * FUNCTION:        EnableDisableEmptyTrash
 * DESCRIPTION:     enable/disable "Empty Trash" depending on # messages
 * PASS:            none
 * RETURN:          none
 *         
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/7/98     Initial Revision
 ***************************************************************/

void
EnableDisableEmptyTrash()
{
        word numMsgs;
        numMsgs = @call TheFolderList::MSG_FOLDER_LIST_GET_NUM_MESSAGES(MFID_TRASH);
	if (numMsgs) {
	    @call EmptyTrashTrigger::MSG_GEN_SET_ENABLED(VUM_DLYD);
	} else {
	    @call EmptyTrashTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DLYD);
	}
}



/**************************************************************
 *      
 * FUNCTION:        CleanFolder, CleanFile
 * DESCRIPTION:     Remove bad files from folder
 * PASS:            none
 * RETURN:          none
 *         
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         ian       5/25/99      Initial Revision
 ***************************************************************/
void CleanFile(TCHAR *fileName)
{
    FileHandle fHan;
    dword size;

    fHan = FileOpen(fileName, FILE_ACCESS_R|FILE_DENY_NONE);
    if (fHan) {
	size = FileSize(fHan);
	FileClose(fHan,NULL);
	if (size == 0) {
	    FileDelete(fileName);
	}
    }

}
char wildStr2[] = "*";
void CleanFolder(TCHAR *folderName)
{
    MemHandle mh;
    int i, count;
    FileEnumParams params;
    FileLongName *fnp;

    LockStrings();
    FileSetCurrentPath(0,folderName);
    FileDelete(LMemDeref(@msglistName));
    UnlockStrings();
    
    params.FEP_searchFlags = FESF_GEOS_NON_EXECS|FESF_CALLBACK;
    params.FEP_returnAttrs = (void *) FESRT_NAME;
    params.FEP_returnSize = sizeof(FileLongName);
    params.FEP_matchAttrs = 0;
    params.FEP_bufSize = MAX_FOLDER_ENUM;
    params.FEP_callback = (void *) FESC_WILDCARD;
    params.FEP_cbData1 = (dword) wildStr2;
    params.FEP_skipCount = 0;    

    while (1) {
	count = FileEnum(&params, &mh, NULL);
	if (mh) {
	    fnp = MemLock(mh);
	    for (i=0;i<count;++i) {
		CleanFile(fnp[i]);
	    }
	    MemFree(mh);
	}
	if (count < MAX_FOLDER_ENUM) {
	    break;
	} else {
	    params.FEP_skipCount += MAX_FOLDER_ENUM;
	}
    }
}



/**************************************************************
 *
 * FUNCTION:        MSG_FOLDER_LIST_CLEAN_FOLDERS
 * DESCRIPTION:     
 *
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         ian       5/25/99     Initial Revision
 *         gene      7/2/99      Rewrote for folder name array
 ***************************************************************/
@method FolderListClass, MSG_FOLDER_LIST_CLEAN_FOLDERS
{
    word i,j, numAccts,numFolders;
    MemHandle mhAccts, mhFolders;
    FileLongName *accts, *folders;
    FileEnumParams params;
    word skipCount1 =0 , skipCount2=0;
    TCHAR *mdName;

    FilePushDir();
    mdName = MailLockStdString(MSS_MAIL_DIR);
    FileSetCurrentPath(SP_PRIVATE_DATA, mdName);
    params.FEP_searchFlags = FESF_DIRS|FESF_CALLBACK;
    params.FEP_returnAttrs = (void *) FESRT_NAME;
    params.FEP_returnSize = sizeof(FileLongName);
    params.FEP_matchAttrs = 0;
    params.FEP_bufSize = MAX_FOLDER_ENUM;
    params.FEP_callback = (void *) FESC_WILDCARD;
    params.FEP_cbData1 = (dword) wildStr2;

    numAccts=0;
    while (1) {
	params.FEP_skipCount = skipCount1;    
	numAccts = FileEnum(&params, &mhAccts, NULL);
	if (mhAccts) {
	    accts = MemLock(mhAccts);
	    for (i=0;i<numAccts;++i) {
		numFolders=0;
		FilePushDir();
		FileSetCurrentPath(0,accts[i]);
		while (1) {
		    params.FEP_skipCount = skipCount2;    
		    numFolders = FileEnum(&params, &mhFolders, NULL);
		    if (mhFolders) {
			folders = MemLock(mhFolders);
			for (j=0;j<numFolders;++j) {
			    FilePushDir();
			    CleanFolder(folders[j]);
			    FilePopDir();
			}
			MemFree(mhFolders);
		    }
		    if (numFolders < MAX_FOLDER_ENUM) {
			break;
		    } else {
			skipCount2 += MAX_FOLDER_ENUM;
		    }
		}
		FilePopDir();
	    }
	    MemFree(mhAccts);
	}
	if (numAccts < MAX_FOLDER_ENUM) {
	    break;
	} else {
	    skipCount1 += MAX_FOLDER_ENUM;
	}
    }
    MailUnlockStdString(MSS_MAIL_DIR);
    FilePopDir();
}



/**************************************************************
 *
 * FUNCTION:        MSG_FOLDER_LIST_INIT_MSGLIST
 * DESCRIPTION:     
 *
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         ian       5/25/99     Initial Revision
 ***************************************************************/
@method FolderListClass, MSG_FOLDER_LIST_INIT_MSGLIST
{
    VMFileHandle vmf;
    VMBlockHandle vmbh;
    optr indexArray;
    word numDirs;
    int folderNum;
    Boolean inuse;

    FilePushDir();
    GotoMailDirectory(NULL);
    numDirs = @call oself::MSG_FOLDER_LIST_GET_NUM_FOLDERS();
    for (folderNum=0;folderNum < numDirs; ++folderNum) {
	FilePushDir();
	inuse = GetMessageArrays(folderNum,&vmf,&vmbh,&indexArray);
	FilePopDir();
	ThreadReleaseThreadLock(TheMessageListLock);
	UnlockIndexArray(OptrToHandle(indexArray));
	if (!inuse) {
	    VMClose(vmf, NULL);
	}
    }
	
    FilePopDir();

}



/**************************************************************
 *
 * FUNCTION:        CompareFoldersCB
 * DESCRIPTION:     Callback to sort the folder list
 *
 * PASS:            el1 - ptr to element #1
 *                  el2 - ptr to element #2
 * RETURN:          el1 < el2, el1 == el2, el1 > el2
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene       7/2/99     Initial Revision
 ***************************************************************/

sword
_pascal CompareFoldersCB (void *el1, void *el2, word fooType)
{
    FolderListStruct *f1, *f2;
    f1 = el1;
    f2 = el2;

    /*
     * if the IDs are equal, i.e., user folders, then compare the names
     */
    if (f1->FLS_ID == f2->FLS_ID) {
	return(LocalCmpStrings(f1->FLS_name, f2->FLS_name, 0));
    }
    /*
     * if different IDs, i.e., standard folders, then compare the IDs
     */
    return(f1->FLS_ID - f2->FLS_ID);
}


/**************************************************************
 *
 * FUNCTION:        GetFolderIndex
 * DESCRIPTION:     Get the index of a folder name
 *
 * PASS:            fname - ptr to folder name
 * RETURN:          index - MailFolderID of folder
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene       7/2/99     Initial Revision
 ***************************************************************/

MailStdString stdDirs[] = {
    MSS_DRAFTS_FOLDER,
    MSS_INBOX_FOLDER,
    MSS_OUTBOX_FOLDER,
    MSS_SENT_FOLDER,
    MSS_TRASH_FOLDER
};

word
GetFolderIndex(TCHAR *fname)
{
    word i, retVal;
    TCHAR *stdFldrName;

    /*
     * if not a standard folder, just return default index
     */
    retVal = MFID_FIRST_USER_FOLDER;
    for (i = 0; i < NUM_BUILT_IN_FOLDERS; i++) {
	/*
	 * if a standard folder, return the index
	 */
	stdFldrName = MailLockStdString(stdDirs[i]);
	if (!strcmp(fname, stdFldrName)) {
	    retVal = i;
	    i = NUM_BUILT_IN_FOLDERS; /* done */
	}
	MailUnlockStdString(stdDirs[i]);
    }
    return(retVal);
}


/**************************************************************
 *
 * FUNCTION:        MSG_FOLDER_LIST_INIT_NAME_ARRAY
 * DESCRIPTION:     Build the array of names
 *
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene       7/2/99     Initial Revision
 ***************************************************************/

MemHandle
GetDirNames(word *numDirs)
{
    FileEnumParams params;

    /*
     * get all the folder names
     */
    params.FEP_searchFlags = FESF_DIRS;
    params.FEP_skipCount = 0;
    return(FolderGetCommon(params, numDirs));
}

@method FolderListClass, MSG_FOLDER_LIST_INIT_NAME_ARRAY
{
    word numDirs, i;
    optr arr;
    ChunkHandle chl;
    MemHandle bufHan;
    FileLongName *bufP;
    FolderListStruct *fls;

    /*
     * go to the top level directory
     */
    FilePushDir();
    GotoMailDirectory(NULL);
    arr = pself->FLI_folderArray;
    /*
     * make sure there's a chunk array
     */
    if (arr) {
	ChunkArrayZero(arr);
    } else {
	chl = ChunkArrayCreate(OptrToHandle(oself), sizeof(FolderListStruct), 0, 0);
	arr = ConstructOptr(OptrToHandle(oself), chl);
	ObjDerefGen(oself);
	pself->FLI_folderArray = arr;
    }

    bufHan = GetDirNames(&numDirs);
    /*
     * go through the folder names and build an array
     */
    bufP = MemLock(bufHan);
    for (i = 0; i < numDirs; i++) {
	fls = ChunkArrayAppend(arr, sizeof(FolderListStruct));
	strcpy(fls->FLS_name, bufP[i]);
	fls->FLS_ID = GetFolderIndex(bufP[i]);
    }
    MemFree(bufHan);

    /*
     * sort the array
     */
    ChunkArraySort(arr, 0, CompareFoldersCB);

    FilePopDir();

}

#ifdef __BORLANDC__
#pragma codeseg RareCode
#endif



/**************************************************************
 *
 * FUNCTION:        MSG_FOLDER_LIST_CREATE_NEW_FOLDER
 * DESCRIPTION:     create a new folder from the New Folder dialog
 *
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/4/98     Initial Revision
 ***************************************************************/
@method FolderListClass, MSG_FOLDER_LIST_CREATE_NEW_FOLDER
{
        char folderName[MAX_FOLDER_NAME_LENGTH+1];
	word err;
	optr errMsg;
	VMFileHandle vmf;

	/*
	 * Get the folder name from the user
	 */
	@call NewFolderNameEntry::MSG_VIS_TEXT_GET_ALL_PTR(folderName);

	GotoMailDirectory(NULL);
	err = FileCreateDir(folderName);

	if (!err) {
	    /*
	     * no error: dismiss the dialog and rebuild the folder list
	     */
	    vmf = CreateMessageListFile(folderName);
	    VMClose(vmf, FALSE);
	    @call NewFolderDialog::MSG_GEN_INTERACTION_ACTIVATE_COMMAND(IC_DISMISS);
	    @call NewFolderNameEntry::MSG_VIS_TEXT_DELETE_ALL();
	    @call NewFolderCreateTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DLYD);
	    RebuildFolderList(MFID_LEAVE_SELECTION, FALSE);
        } else {
	    /*
	     * error: report it and leave the dialog up
	     */
	    switch (err) {
	      case ERROR_FILE_EXISTS:
		errMsg = @folderExistsErr;
		break;
	      default:
		errMsg = @folderNoCreateErr;
	    }
	    ReportError(errMsg, folderName);
	}
}


/**************************************************************
 *
 * FUNCTION:        MSG_FOLDER_LIST_DELETE_CURRENT_FOLDER
 * DESCRIPTION:     delete the currently selected folder
 *
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/4/98     Initial Revision
 ***************************************************************/
@method FolderListClass, MSG_FOLDER_LIST_DELETE_CURRENT_FOLDER
{
	word folderNum;
	word numMsgs;
	MemHandle bufHan;
	char *folderName;
	word errResp;

	/*
	 * Get the current folder, number of messages in it, and its name
	 */
	folderNum = @call oself::MSG_GEN_ITEM_GROUP_GET_SELECTION();
	numMsgs = @call oself::MSG_FOLDER_LIST_GET_NUM_MESSAGES(folderNum);
	bufHan = @call oself::MSG_FOLDER_LIST_GET_FOLDER_NAME(folderNum);
	folderName = MemLock(bufHan);

	/*
	 * Warn the user depending on whether there are messages in the folder
	 */
	if (numMsgs) {
	    errResp = DoYesNo(@folderDeleteNonEmpty, folderName);
	} else {
	    errResp = DoYesNo(@folderDeleteEmpty, folderName);
	}

	/*
	 * Delete the folder
	 */
	if (errResp == IC_YES) {
	    @call MailAppObj::MSG_GEN_APPLICATION_MARK_BUSY();
	    /*
	     * If the folder is not empty, empty it first
	     */
	    if (numMsgs) {
	        FolderDeleteMessages(folderName);
	    }
	    /*
	     * close and delete the folder cache file so we can
	     * delete the folder
	     */
	    @call TheMessageList::MSG_MAIL_LIST_CLOSE_MESSAGE_ARRAY();
	    DeleteMessageListArray(folderName);
	    /*
	     * Delete the folder
	     */
	    GotoMailDirectory(NULL);
	    errResp = FileDeleteDir(folderName);
	    @call MailAppObj::MSG_GEN_APPLICATION_MARK_NOT_BUSY();

	    if (errResp) {
	        /*
		 * Report the error
		 */
	        ReportError(@folderDeleteErr, folderName);
	    } else {
	        /*
		 * Update the folder list and reset the selection
		 */
	        RebuildFolderList(MFID_DEFAULT, FALSE);
	    }
	}
	MemFree(bufHan);
}


/**************************************************************
 *
 * FUNCTION:        MSG_FOLDER_LIST_RENAME_CURRENT_FOLDER
 * DESCRIPTION:     empty the trash
 *
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/7/98     Initial Revision
 ***************************************************************/
@method FolderListClass, MSG_FOLDER_LIST_RENAME_CURRENT_FOLDER
{
        word folderNum = @call oself::MSG_GEN_ITEM_GROUP_GET_SELECTION();
	MemHandle oldFldrHan, newFldrHan;
	char *oldFldrName, *newFldrName;
	word err;

	/*
	 * close the folder cache file so we can rename the folder
	 */
	@call TheMessageList::MSG_MAIL_LIST_CLOSE_MESSAGE_ARRAY();
	/*
	 * get the old name and the new name
	 */
	oldFldrHan = @call oself::MSG_FOLDER_LIST_GET_FOLDER_NAME(folderNum);
	newFldrHan = @call RenameFolderNewEntry::MSG_VIS_TEXT_GET_ALL_BLOCK(0);

	oldFldrName = MemLock(oldFldrHan);
	newFldrName = MemLock(newFldrHan);

	/*
	 * rename the folder
	 */
	GotoMailDirectory(NULL);
	err = FileRename(oldFldrName, newFldrName);

	/*
	 * report any error and clean up
	 */
	if (err) {
	        switch (err) {
		    case ERROR_FILE_EXISTS:
		        ReportError(@folderRenameExistsErr, newFldrName);
			break;
		    default:
		        ReportError(@folderNoRenameErr, oldFldrName);
		}
	} else {
	        @call RenameFolderDialog::MSG_GEN_INTERACTION_ACTIVATE_COMMAND(IC_DISMISS);
	        RebuildFolderList(MFID_LEAVE_SELECTION, FALSE);
	}
	MemFree(oldFldrHan);
	MemFree(newFldrHan);
}



/**************************************************************
 *      
 * FUNCTION:        EmptyTrash
 * DESCRIPTION:     empty the trash
 * PASS:            none
 * RETURN:          none
 *         
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      1/5/99      Initial Revision
 ***************************************************************/
void
EmptyTrash(void)
{
    TCHAR *tName;

    GotoMailDirectory(NULL);
    tName = MailLockStdString(MSS_TRASH_FOLDER);
    FolderDeleteMessages(tName);
    MailUnlockStdString(MSS_TRASH_FOLDER);
}


/**************************************************************
 *
 * FUNCTION:        MSG_FOLDER_LIST_EMPTY_TRASH
 * DESCRIPTION:     empty the trash
 *
 * PASS:            none
 * RETURN:          none
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      12/7/98     Initial Revision
 ***************************************************************/
@method FolderListClass, MSG_FOLDER_LIST_EMPTY_TRASH
{
    word resp = DoYesNo(@emptyTrashStr, NULL);

    if (resp == IC_YES) {
        /*
	 * delete the messages in the Trash folder
	 */
        EmptyTrash();
	/*
	 * rebuild the folder list (in case we're displaying
	 * trash or the list has the # of messages
	 */
	RebuildFolderList(MFID_LEAVE_SELECTION, FALSE);
	/*
	 * Disable "Empty Trash"
	 */
	EnableDisableEmptyTrash();
    }
}

@ifdef CUI_SUPPORT_2

#ifdef __BORLANDC__
#pragma codeseg CUICode
#endif


/**************************************************************
 *      
 * FUNCTION:        MSG_FOLDER_LIST_CUI_WRITE_EMAIL
 * PASS:            none
 * RETURN:          none
 * DESCRIPTION:
 *         CUI: write a new message or edit a draft
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      5/1/00      Initial Revision
 ***************************************************************/

@method FolderListClass, MSG_FOLDER_LIST_CUI_WRITE_EMAIL
{
    /*
     * if any drafts, bring up Write Email window, else New Message
     */
    if (@call oself::MSG_FOLDER_LIST_GET_NUM_MESSAGES(MFID_DRAFTS)) {
	@call CUIWriteStuff::MSG_GEN_SET_USABLE(VUM_DLYD);
	@call FolderMessageArea::MSG_GEN_SET_USABLE(VUM_DLYD);
	@call CUIBackButton::MSG_GEN_SET_USABLE(VUM_DLYD);

	@call CUINewMessageTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
	@call CUIOpenUnfinishedTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
	@call CUIDiscardUnfinishedTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);

	@call CUIMain::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
	@call CUIReadTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
	@call CUISendTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
	@call CUIViewTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
@ifdef CUI_SENT_FOLDER
	@call CUIViewSentTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
@endif
	@call CUICheckTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
	@call CUIWriteTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);

	@call TheFolderList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(MFID_DRAFTS, 0);
	@call TheFolderList::MSG_GEN_ITEM_GROUP_SEND_STATUS_MSG(0);
	@call TheMessageList::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(0);
	@call TheMessageList::MSG_GEN_ITEM_GROUP_SEND_STATUS_MSG(0);
    } else {
	@send ComposeMailWin::MSG_MAIL_COMPOSER_NEW_MESSAGE();
    }
}


/**************************************************************
 *      
 * FUNCTION:        MSG_FOLDER_LIST_CUI_READ_EMAIL
 * PASS:            none
 * RETURN:          none
 * DESCRIPTION:
 *         CUI: get new mail or read existing mails
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      5/2/00      Initial Revision
 ***************************************************************/

@method FolderListClass, MSG_FOLDER_LIST_CUI_READ_EMAIL
{
    @call CUIReadStuff::MSG_GEN_SET_USABLE(VUM_DLYD);
@ifdef CUI_SENT_FOLDER
    @call CUICheckTool::MSG_GEN_SET_USABLE(VUM_DLYD);
@endif
    @call FolderMessageArea::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call CUIBackButton::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call CUIOpenTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call CUIDiscardTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call SearchMenu::MSG_GEN_SET_USABLE(VUM_DLYD);

    @call CUIMain::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIReadTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUISendTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIViewTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
@ifdef CUI_SENT_FOLDER
    @call CUIViewSentTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
@endif
    @call CUIWriteTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIWriteBugTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);

    @call TheFolderList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(MFID_INBOX,0);
    @call TheFolderList::MSG_GEN_ITEM_GROUP_SEND_STATUS_MSG(0);
}


/**************************************************************
 *      
 * FUNCTION:        MSG_FOLDER_LIST_CUI_VIEW_OUTBOX
 * PASS:            none
 * RETURN:          none
 * DESCRIPTION:
 *         CUI: view queued messages
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      5/3/00      Initial Revision
 ***************************************************************/

@method FolderListClass, MSG_FOLDER_LIST_CUI_VIEW_OUTBOX
{
    @call CUIViewStuff::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call FolderMessageArea::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call CUIBackButton::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call CUIEditTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call CUISendThisTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call CUISendAllTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call SearchMenu::MSG_GEN_SET_USABLE(VUM_DLYD);

    @call CUIMain::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIReadTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUISendTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIViewTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
@ifdef CUI_SENT_FOLDER
    @call CUIViewSentTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
@endif
    @call CUIWriteTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIWriteBugTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUICheckTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);

    @call TheFolderList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(MFID_OUTBOX,0);
    @call TheFolderList::MSG_GEN_ITEM_GROUP_SEND_STATUS_MSG(0);
}


/**************************************************************
 *      
 * FUNCTION:        MSG_FOLDER_LIST_CUI_VIEW_SENT
 * PASS:            none
 * RETURN:          none
 * DESCRIPTION:
 *         CUI: view sent messages
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         brianc    7/10/00     Initial Revision
 ***************************************************************/

@ifdef CUI_SENT_FOLDER
@method FolderListClass, MSG_FOLDER_LIST_CUI_VIEW_SENT
{
    @call CUIReadStuff::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call CUICheckTool::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call FolderMessageArea::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call CUIBackButton::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call CUIOpenTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call CUIDiscardTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call SearchMenu::MSG_GEN_SET_USABLE(VUM_DLYD);

    @call CUIMain::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIReadTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUISendTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIViewTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIViewSentTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIWriteTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIWriteBugTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUICheckTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);

    @call TheFolderList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(MFID_SENT,0);
    @call TheFolderList::MSG_GEN_ITEM_GROUP_SEND_STATUS_MSG(0);
}
@endif


/**************************************************************
 *      
 * FUNCTION:        MSG_FOLDER_LIST_CUI_BACK
 * PASS:            none
 * RETURN:          none
 * DESCRIPTION:
 *         CUI: go back to the main screen
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      5/2/00      Initial Revision
 ***************************************************************/

@method FolderListClass, MSG_FOLDER_LIST_CUI_BACK
{
    @call CUIWriteStuff::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIReadStuff::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIViewStuff::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);

    @call FolderMessageArea::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIBackButton::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUINewMessageTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIOpenUnfinishedTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIDiscardUnfinishedTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIOpenTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIDiscardTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUIEditTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUISendThisTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);
    @call CUISendAllTrigger::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);

    @call CUIMain::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call CUIReadTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call CUISendTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call CUIViewTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
@ifdef CUI_SENT_FOLDER
    @call CUIViewSentTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
@endif
    @call CUICheckTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call CUIWriteTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call CUIWriteBugTrigger::MSG_GEN_SET_USABLE(VUM_DLYD);
    @call SearchMenu::MSG_GEN_SET_NOT_USABLE(VUM_DLYD);

    /*
     * make sure the totals are up to date
     */
    UpdateCUIMonikers();
}



/**************************************************************
 *      
 * FUNCTION:        MSG_FOLDER_LIST_GET_NUM_UNREAD_MESSAGES
 * PASS:            folderNum - folder #
 * RETURN:          none
 * DESCRIPTION:
 *         Count the number of unread messages in the specified folder
 *
 * REVISION HISTORY:
 *         Name      Date        Description
 *         ----      ----        -----------
 *         gene      5/07/00     Initial Revision
 ***************************************************************/

typedef struct {
    word              UMS_count;
} UMStruct;

Boolean _pascal CountUnreadCB(void* element, void *data)
{
    UMStruct *ums = data;
    MessageIndexStruct *ie = element;

    if (!(ie->MIS_flags & MF_READ)) {
	ums->UMS_count++;
    }
    return(FALSE);
}


@method FolderListClass, MSG_FOLDER_LIST_GET_NUM_UNREAD_MESSAGES
{
    VMBlockHandle vmbh;
    VMFileHandle vmf;
    optr indexArray;
    Boolean inUse;
    word bufHan;
    UMStruct ums;
    TCHAR *buf;

    FilePushDir();
    bufHan = @call oself::MSG_FOLDER_LIST_GET_FOLDER_NAME(folderNum);
    buf = MemLock(bufHan);
    GotoMailDirectory(buf);
    MemFree(bufHan);


    /*
     * get the message list and index arrays
     */
    inUse = GetMessageArrays(folderNum, &vmf, &vmbh, &indexArray);

    /*
     * count the number of unread messages
     */
    ums.UMS_count = 0;
    ChunkArrayEnum(indexArray,&ums,CountUnreadCB);

    /*
     * Close the VMFile only if it was not in use
     */
    UnlockIndexArray(OptrToHandle(indexArray));
    if (!inUse) {
	VMClose(vmf,NULL);
    }
    ThreadReleaseThreadLock(TheMessageListLock);
    FilePopDir();

    return(ums.UMS_count);
}

@endif
