/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) GeoWorks 1992 -- All Rights Reserved

PROJECT:	GeoDex
MODULE:		Main
FILE:		mainGeoDex.asm
MAKE:		geodex.geo

AUTHOR:		Ted H. Kim, August 30, 1989

ROUTINES:
	Name			Description
	----			-----------
	RolodexHandleCR		Called when CR is hit in index field
	ModifyIndex		Display first name first and then the last name
	RolodexPrevious		Read in and display previous record
	RolodexNext		Read in and display next record
	RolodexNew		Bring in a blank record for creation
	RolodexNotes		Bring up the Notes Field edit dialog box
	SaveCurRecord		Save currently displayed record
	UpdateQuickDialMenu	Disable or enable the quick dial trigger
	HandleWarningBox	Puts up a warning box for blank index field
	UpdateLetterButton	Updates the letter button
	CompareRecord		Checks to see if a record is modified
	RolodexEnableDisableCalendarButton
				Enable or disable Calendar button
	RespondCalendarRequest	Responds to calendar's request for searching
	RolodexRequestSearch	Sends calendar with a text string to search for
	CallCalendar		Call calendar with given method

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ted	8/30/89		Initial revision
	ted	3/92		Compete revamping for V2.0
	witt	1/94		DBCS conversion

DESCRIPTION:
	This file contains message handlers for all (but phone) icons
	on GeoDex.

	$Id: mainGeoDex.asm,v 1.1 97/04/04 15:50:11 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
/*-----------------------------------------------------------------------------
;			Class definition
;------------------------------------------------------------------------------

idata	segment
	RolDocumentControlClass
idata	ends */

@include "cdex.goh"

@classdecl	NotesDialogClass;

UndoStatus g_undoAction = 0;
word g_warnReply = 0;

/* CommonCode	segment	resource */

@extern object NotesBox;
@extern object MyLetters;

@extern chunk Set1Char1;
@extern chunk Set1Char2;
@extern chunk Set1Char3;
@extern chunk Set1Char4;
@extern chunk Set1Char5;
@extern chunk Set1Char6;
@extern chunk Set1Char7;
@extern chunk Set1Char8;
@extern chunk Set1Char9;
@extern chunk Set1Char10;
@extern chunk Set1Char11;
@extern chunk Set1Char12;
@extern chunk Set1Char13;
@extern chunk Set1Char14;
@extern chunk Set1Char15;
@extern chunk Set1Char16;
@extern chunk Set1Char17;
@extern chunk Set1Char18;
@extern chunk Set1Char19;
@extern chunk Set1Char20;
@extern chunk Set1Char21;
@extern chunk Set1Char22;
@extern chunk Set1Char23;
@extern chunk Set1Char24;
@extern chunk Set1Char25;
@extern chunk Set1Char26;
@extern chunk Set1Char27;
@extern chunk Set1Char28;
@extern chunk Set1Char29;

@extern object LastNameField;
@extern object AddrField;
@extern object NoteText;
@extern object PhoneNoTypeField;
@extern object PhoneNoField;
@extern object EditCopyRecord;
@extern object EditUndo;

void HandleWarningBox(void);
void ModifyIndex(char *sourceStr, char *destStr);

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RolodexHandleCR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Called when CR is hit in index field.

CALLED BY:	UI (= MSG_ROLODEX_CR )

PASS:		nothing

RETURN:		nothing

PSEUDO CODE/STRATEGY:
		(* Don't modify address box if something there already. *)
		If Address field has text, cleanup and return.

		If Index field has NO text, cleanup and return.
		Call ModifyIndex to put first name first.
		Give focus and target to address field.

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Ted	12/8/89		Initial version
	jfh	1/2/05	Port to GOC

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
@extern method	RolodexProcessClass, MSG_ROLODEX_CR
{
 MemHandle	smh, dmh;
 word			len;
 char			*sourceStr, *destStr;


	/* bail if addr field is not empty */
	if (@call AddrField::MSG_VIS_TEXT_GET_TEXT_SIZE()) return;

	/* get num chars in index field */
	len = (word)@call LastNameField::MSG_VIS_TEXT_GET_TEXT_SIZE();
	/* bail if none */
	if (!len) return;

	/* read the last name into a mem bolck */
	smh = @call LastNameField::MSG_VIS_TEXT_GET_ALL_BLOCK(0);
	sourceStr = MemLock(smh);

	/* allocate a block for our revised string */
	dmh = MemAlloc(len + 1, HF_SWAPABLE, HAF_STANDARD_NO_ERR_LOCK);
	destStr = MemDeref(dmh);

	/* modify text string from index field */
	ModifyIndex(sourceStr, destStr);
	MemFree(smh);

	/* show the modified string in the addr field */
	@call AddrField::MSG_VIS_TEXT_REPLACE_ALL_PTR(destStr, 0);
	MemFree(dmh);

	/* give focus to the address field */
	@send AddrField::MSG_META_GRAB_FOCUS_EXCL();

	/* now give target to the address field also */
	@send AddrField::MSG_META_GRAB_TARGET_EXCL();

	/* mark address field user modified */
	@send AddrField::MSG_VIS_TEXT_SET_USER_MODIFIED();

}

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		ModifyIndex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Display first name first and then the last name.

CALLED BY:	RolodexHandleCR

PASS:		ds:si - ptr to source string
		es:di - ptr to destination
	GOC:  (char *sourceStr, char *destStr)

RETURN:		es:di - ptr to end of string (not NULL terminated)
	GOC: nuthin!  AND string IS null termed

PSEUDO CODE/STRATEGY:
	Skip all leading spaces if there are any
	Skip til a comma is found
	Skip any spaces after the comma
	Copy the first name into destination buffer
	Copy the last name into destination buffer

KNOWN BUGS/SIDE EFFECTS/IDEAS:
	If someone types "Smith, John" in index field
	and hits carriage return, it will say "John Smith"
	in address field.

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Ted	3/22/90		Initial version
	jfh	1/2/05	Port to GOC

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
void ModifyIndex(char *sourceStr, char *destStr)
{
 char		*commaPtr, *firstPtr;


	/* first, ignore all leading space characters */
	while (sourceStr[0] == ' ') {
		sourceStr++;
		}
	/* now skip until comma */
	commaPtr = strchr(sourceStr, ',');
	if (commaPtr)  {
		/* ignore all space characters after comma */
		commaPtr[0] = 0;
		firstPtr = commaPtr + 1;
		while (firstPtr[0] == ' ') {
			firstPtr++;
			}
		/* copy the text after comma into memory block first */
		strcpy(destStr, firstPtr);
		strcat(destStr, " ");
		/* now copy the text before comma into momory block */
		strcat(destStr, sourceStr);
		}
	else {
		/* there is no comma b/w first and last name, so don't invert */
		strcpy(destStr, sourceStr);
		}

	return;

}

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RolodexPrevious
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Saves the current record in database file and displays
		the previous record on screen.

CALLED BY:	Kernel

PASS:		ds - segment of core block

RETURN:		nothing

PSEUDO CODE/STRATEGY:
	Saves the current record
	Gets the previous record
	Displays the new record

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ted	9/7/89		Initial version
	jfh	12/15/04	Port to GOC

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
@extern method	RolodexProcessClass, MSG_ROLODEX_PREVIOUS
{
 DBItem		prevRec;


	/* save current record if necessary, exit if error */
	if (SaveCurRecord()) return;

	/* is database empty? */
	if (g_gmb.GMB_numMainTab)  {
		/* there are records... */
		/* was warning box up? */
		if (g_recStatus & RSF_WARNING) {
			/* if warning box was up, clear warning flag */
			g_recStatus = g_recStatus & ~RSF_WARNING;
			}
		else {
			/* get handle of previous record */
			prevRec = FindPrevious();
			/* force redraw by setting different - XXX do we need this? */
			g_curRecord = 0;
			/* display this record on the screen */
			DisplayCurRecord(prevRec);
			/* clear search flag */
			g_searchFlag = g_searchFlag & ~SOF_NEW;
			/* update the name list */
			UpdateNameList();
			/* fix up some menu stuff */
			@send EditCopyRecord::MSG_GEN_SET_ENABLED(VUM_NOW);
			g_recStatus = 0;
			}
		}
	else { /*empty database */
		/* fix up some menu stuff */
		@send EditCopyRecord::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
		g_recStatus = RSF_EMPTY | RSF_NEW;
		}

	/* no undoable action exists */
	g_undoAction = UNDO_NOTHING;
	@send EditUndo::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);

}

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RolodexNext
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Saves the current record in database file and displays
		the next record on screen.

CALLED BY:	Kernel

PASS:		ds - segment of core block

RETURN:		nothing

PSEUDO CODE/STRATEGY:
	Saves the current record
	Gets the next record
	Displays the new record

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ted	9/7/89		Initial version
	jfh	12/15/04	Port to GOC

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
@extern method	RolodexProcessClass, MSG_ROLODEX_NEXT
{
 DBItem		nextRec;


	/* save current record if necessary, exit if error */
	if (SaveCurRecord()) return;

	/* is database empty? */
	if (g_gmb.GMB_numMainTab)  {
		/* database has records */
		if (g_recStatus & RSF_WARNING) {
			/*was warning box up?  If so, clear warning flag */
			g_recStatus = g_recStatus & ~RSF_WARNING;
			}
		else {
			/* get handle of next record */
			nextRec = FindNext();
			/* display this record on the screen */
			DisplayCurRecord(nextRec);
			/* clear search flag */
			g_searchFlag = g_searchFlag & ~SOF_NEW;
			/* update the name list */
			UpdateNameList();
			/* fix up some menu stuff */
			@send EditCopyRecord::MSG_GEN_SET_ENABLED(VUM_NOW);
			g_recStatus = 0;
			}
		}
	else  { /* empty database */
		/* fix up some menu stuff */
		@send EditCopyRecord::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
		g_recStatus = RSF_EMPTY | RSF_NEW;
		}

	/* no undoable action exists */
	g_undoAction = UNDO_NOTHING;
	@send EditUndo::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);

}

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RolodexNew
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Saves the current record if changed and clears the screen
		for a new record.

CALLED BY:	Kernel

PASS:		ds - segment of core block

RETURN:		nothing

PSEUDO CODE/STRATEGY:
	Save currently displayed record
	Clear all the text edit fields
	Re-initialize some variables

KNOWN BUGS/SIDE EFFECTS/IDEAS:
	There are two ways to initialize a record.  This routine is one
	of those paths.  ClearRecord calls InitRecord.  'gmb.GMB_curPhoneIndex'
	is changed here, for the case when the record is already blank.

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ted	9/7/89		Initial version
	jfh	12/31/04 Port to GOC

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
@extern method	RolodexProcessClass, MSG_ROLODEX_NEW
{

	/* save current record if necessary, exit if error */
	if (SaveCurRecord()) return;

	/* was warning box up? */
	if (g_recStatus & RSF_WARNING)  {
		if (g_warnReply != IC_NULL && g_warnReply != IC_NO) {
			/* is this a new record? if not, exit */
			if (!g_curRecord) {
				/* set undo flag */
				g_undoAction = UNDO_NEW;
				}
			goto quit;
			}
		}
	else {
		/* clear the record */
		ClearRecord();
		}

	@send LastNameField::MSG_META_GRAB_FOCUS_EXCL();
	g_recStatus = RSF_NEW | RSF_EMPTY;
	g_gmb.GMB_curPhoneIndex = 1;
	g_curRecord = 0;
	@send EditCopyRecord::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	g_undoAction = UNDO_NEW;
	/* card view only? */
	if (g_displayStatus != CARD_VIEW) {
		/* deselect the list entry */
		SetNewExclusive();
		}

quit:
	/* clear search flag */
	g_searchFlag = g_searchFlag & ~SOF_NEW;
	/* no undoable action exists */
	g_undoAction = UNDO_NOTHING;
	@send EditUndo::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);

}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RolodexNotes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Brings up the Notes dialog box.

CALLED BY:	UI (=MSG_ROLODEX_NOTES)

PASS:		nothing

RETURN:		nothing


REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ted	3/92		Initial version
	jfh	12/10/04	Port to GOC

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
@extern method	RolodexProcessClass, MSG_ROLODEX_NOTES
{

	/* make the window usable */
	@send NotesBox::MSG_GEN_SET_USABLE(VUM_NOW);
	/* display the window */
	@send NotesBox::MSG_GEN_INTERACTION_INITIATE();

}

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RolodexSaveAfterNoteEdit
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Receive this message when the close trigger on the
		notes dialog is pressed.  After the notes field has
		been edited, this routine will save the record to
		the database and then dismiss the dialog.

CALLED BY:	MSG_ROLODEX_SAVE_AFTER_NOTE_EDIT
PASS:		nothing
RETURN:		nothing

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	grisco	5/ 2/95   	Initial version
	jfh	12/31/04	Port to GOC

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
@method NotesDialogClass, MSG_ROLODEX_SAVE_AFTER_NOTE_EDIT
{

	SaveCurRecord();

	@send oself::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);

}

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		SaveCurRecord
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Saves out the current record if changed or just created.

CALLED BY:	UTILITY

PASS:		ds - segment addr of core block
		curRecord - current record handle

RETURN:		carry set if error returned in MemAlloc
				ax has the InteractionCommand if a warning box was shown
	GOC:	Boolean - TRUE if error

PSEUDO CODE/STRATEGY:
	If current record modified	{
		If this record has been created but not inserted {
			Update the record
			If index field modified	{
				Delete the old entry
			}
			And re-insert the new one
			exit
		}
		Else {
			Create a new record 
			Insert this record
			exit
		}
	}
	Else	exit
			
REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ted	9/4/89		Initial version
	jfh	12/31/04	Port to GOC - I had to relent and use goto in this one...
						waaay too much spaghetti.  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
Boolean SaveCurRecord(void)
{
 Boolean			isMod;
 TableEntry		*entry;


	/* was there any record to be deleted? */
	if (g_undoItem)  {
		NewDBFree(g_undoItem);
		g_undoItem = 0;
		}

	/* read in changed fields */
	GetRecord(NUM_TEXT_EDIT_FIELDS + 1, 0);

	/* was this record already inserted? if so, skip */
	if (!g_curRecord)  {
		/* was it an empty record? if it was, exit */
		if (g_recStatus & RSF_EMPTY) {
			return(FALSE);
			}
		}

	/* setFlag - warning box was not on */
	g_recStatus = g_recStatus & ~RSF_WARNING;

	/* index field empty? if so, put up a warning box */
	if (g_recStatus & RSF_SORT_EMPTY)
		goto warningBox;

	/* is this record modified? */
	isMod = CompareRecord(NUM_TEXT_EDIT_FIELDS + 1, 0);

	/* if not, check to see if created */
	if (!isMod)
		goto notModified;

	/* new record? if so, skip to handle it */
	if (!g_curRecord)
		goto newRecord;

	/* update everything & add the changes to database
		bail out if error */
	if (UpdateRecord(FALSE))
		return(TRUE);

	/* new record? if so, skip to insert */
	if (g_recStatus & RSF_NEW)
		goto insert;

	/* is index field modified? if not, exit */
	if (!(g_dirtyFields & DFF_INDEX))
		goto updateQuick;

deleteRec:
	/* delete all phone entries */
	g_phoneFlag |= PF_SAVE_RECORD;
	/* delete the record from main table */
	DeleteFromMainTable();
	/* insert it back into quick table */
   goto insert;

newRecord:
	/* update everything & create a new record and initialize
		bail out if error */
	if (InitRecord(FALSE))
		return(TRUE);

insert:
	/* insert it into database */
   InsertRecord();

insert2:
	/* clear save record flag */
	g_phoneFlag = g_phoneFlag & ~PF_SAVE_RECORD;

	/* exit - no error */
	return(FALSE);



warningBox:
	/* delete all the memory blocks */
	FreeMemChunks(NUM_TEXT_EDIT_FIELDS + 1, 0);
	/* called by FileSave? if so, exit w/ no error */
	if (g_recStatus & RSF_FILE_SAVE)
		return(FALSE);
	/* put up a warning box */
	HandleWarningBox();
	/* if index field empty, set focus to index field */
	if (g_recStatus & RSF_SORT_EMPTY)
		@send LastNameField::MSG_META_GRAB_FOCUS_EXCL();
	/* bail out */
	return(FALSE);

notModified:
	/* new record? if so, insert it */
	if (g_recStatus & RSF_NEW)
		goto insert;

	/* record modified through udno? if so, delete and re-insert it */
	if (g_undoAction >= UNDO_CHANGE)
		goto deleteRec;

	/* delete all the memory blocks */
	FreeMemChunks(NUM_TEXT_EDIT_FIELDS + 1, 0);
	return(FALSE);

updateQuick:
	/* update the main table */
	entry = DBLock(g_fileHandle, g_groupHandle, g_gmb.GMB_mainTable);
	DBDirty(entry);
	entry += g_curOffset / sizeof(TableEntry);
	entry->TE_item = g_curRecord;
	DBUnlock(entry);

	/* delete all phone entries */
	g_phoneFlag |= PF_SAVE_RECORD;
	goto insert2;


}

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		HandleWarningBox
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Puts up the warning box when index field is empty.

CALLED BY:	SaveCurRecord

PASS:		recStatus - various record flags

RETURN:		ax - OK or CANCEL depending on which option is chosen
		carry set if error found (but the only caller doesn't care about
											the returned carry flag - jfh)
	GOC:	g_warnReply set by DisplayErrorBox

PSEUDO CODE/STRATEGY:
	If not called by 'RolodexDelete'
		Put up the warning box
		If CANCEL
			Clear the reocrd
		Delele all the memory chunks
	Else exit

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Ted	12/6/89		Initial version
	jfh	12/21/04	Port to GOC

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
void HandleWarningBox(void)
{


	/* assume YES */
	g_warnReply = IC_YES;

	/* is this called by delete? if so, don't put up warning */
	if (!(g_recStatus & RSF_DELETE)) {
		/* are we in browse mode? */
		if (g_displayStatus == BROWSE_VIEW)  {
			/* XXX jfh - I don't think we could ever get here.  How can you
				have an empty last name field and be in the browse view?
				But I'll leave this in just in case */
			/* put up a warning box */
			DisplayErrorBox(ERROR_IN_BROWSE_MODE);
			}
		else {
			/* put up a warning box */
			DisplayErrorBox(ERROR_INDEX_FIELD);
			g_recStatus |= RSF_WARNING;
			}
		}

	/*  is DB terminated by the system?  if so, exit */
	if (g_warnReply == IC_NULL) return;

	/* is YES button pressed? */
	if (g_warnReply == IC_YES) {
		g_undoAction = UNDO_NOTHING;
		@send EditUndo::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
		return;
		}

	/* delete the record must have been the user's choice */
	if (g_curRecord)  {
		NewDBFree(g_curRecord);
		if (!(g_recStatus & RSF_NEW))  {
			DeleteFromMainTable();
			}
		g_curRecord = 0;
		g_undoAction = UNDO_NOTHING;
		@send EditUndo::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
		}
	ClearRecord();
	g_recStatus = RSF_NEW | RSF_EMPTY | RSF_WARNING;
	@send EditCopyRecord::MSG_GEN_SET_ENABLED(VUM_NOW);

}

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		UpdateLetterButton
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Updates the letter button so it reflects the currently
		displayed record.

CALLED BY:	DisplayCurRecLow

PASS:		sortBuffer - index field text string of current record

RETURN:		curLetter - updated

DESTROYED:	ax, bx, cx, dx, si, di, bp

KNOWN BUGS/SIDE EFFECTS/IDEAS:
	none

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Ted	9/21/89		Initial version
	witt	1/22/94 	DBCS-ized
	jfh	12/10/04	Port to GOC - skipped a bunch of ESP code since we're using
						only single letter tabs.  No need to copy a 4 letter string
                  into g_curLetter.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
void UpdateLetterButton(void)
{
 word		letterID;

	/* first check to see if 'sortBuffer' is empty */
	if (!g_sortBuffer[0]) return;

	/* copy the first char into 'curLetter' after getting the lexical value */
	g_curLetter[0] = GetLexicalValue(g_sortBuffer[0]);
	g_curLetter[1] = 0; // null term

	/* called by FindLetter? */
	if (g_recStatus & RSF_FIND_LETTER) return;

	/* first clear the old letter tab that has been inverted */
	@call MyLetters::MSG_LETTERS_CLEAR();

	/* now invert the new letter tab */
	/* find out which letter to invert */
	letterID = SearchCharSet();
	/* 3rd arg of 0 says we aren't passing an existing gstring */
	@call MyLetters::MSG_LETTERS_INVERT(g_gmb.GMB_numMainTab, letterID, 0);

}

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		SearchCharSet
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Search for a given character in a given character set. 

CALLED BY:	SearchCharSetTable & GetTabLetterStrOfCurRec

PASS:		ds:[curCharSet] - current character set
		es:di - pointer to table of lptrs for character strings
		ds:curLetter - letter tab string to search for
	GOC: nada

RETURN:		zero flag set if the letter is not found
		zero flag cleared if the letter is found
		cl - index to character set for the character found
			(cl = 0 if not found, use ds:starTabID)
		ds:starTabID - index where wildcard "*" is located.
		ds:curLetter - updated
		ds:curLetterLen
	GOC: word letterID

DESTROYED:	ax, dx, si

KNOWN BUGS/SIDE EFFECTS/IDEAS:
		es:di is usually passed as LetterTabCharSetTable.
		Does _not_ assume letter tabs are in order - A Good Thing.

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	ted	7/92		Initial version
	witt	2/94		DBCS-ized, clean up for LocalXxx funcs
	jfh	12/10/04	Port to GOC - we're locking the block in the routine
						instead of in the two callers and we're checking only
						the 1st letter fro a match

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
word SearchCharSet(void)
{
 optr	letter[MAX_NUM_OF_LETTER_TABS] = {@Set1Char1, @Set1Char2, @Set1Char3,
				@Set1Char4, @Set1Char5, @Set1Char6, @Set1Char7, @Set1Char8,
				@Set1Char9, @Set1Char10, @Set1Char11, @Set1Char12, @Set1Char13,
				@Set1Char14, @Set1Char15, @Set1Char16, @Set1Char17, @Set1Char18,
				@Set1Char19, @Set1Char20, @Set1Char21, @Set1Char22, @Set1Char23,
				@Set1Char24, @Set1Char25, @Set1Char26, @Set1Char27, @Set1Char28,
				@Set1Char29};
 word			letterID, i;


	MemLock (OptrToHandle(letter[0]));

	/* now loop within the character set until we find a match */
	for (i = 0; i < MAX_NUM_OF_LETTER_TABS; i++)  {
		if (!LocalCmpStringsNoCase(LMemDeref(letter[i]), g_curLetter, 1)) {
			/* we found our tab */
			letterID = i;
			break;
			}
		else if (!strncmp(LMemDeref(letter[i]), "*", 1)) {
			/* we got to the * so the g_curLetter must not be A - Z */
			letterID = i;
         break;
			}
		}

	MemUnlock(OptrToHandle(letter[0]));
   return(letterID);

}

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		CompareRecord
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Checks to see if any of the text edit fields
		have been changed.

CALLED BY:	SaveCurRecord & CLOSE_APP

PASS:		bx - number of text edit fields to check
		bp - offset into FieldTable (TEFO_xxx)

RETURN:		zero flag set if any of the text fields is modified
		zero flag cleared otherwise
		dirtyFields - tells which text edit field is modified
	GOC: True if any fields are modified

FieldTable	label		word
	word	offset	Interface: LastNameField
	word	offset	Interface: AddrField
	word	offset	WindowResource: NoteText
	word	offset	Interface: PhoneNoTypeField
	word	offset	Interface: PhoneNoField

PSEUDO CODE/STRATEGY:
	For each text edit field
		call MSG_VIS_TEXT_GET_USER_MODIFIED 
		if modified
			set a flag for this edit field
			update 'dirtyFields'
	Check the next text edit field

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Ted	10/31/89	Initial version
	Ted	11/9/89		Returns 'dirtyFields'
	jfh	12/13/04	Port to GOC

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
Boolean CompareRecord(word number, word offset)
{
 Boolean		isMod = FALSE;
 Boolean 	fieldMod;
 optr		field[5] = {@LastNameField, @AddrField, @NoteText,
							@PhoneNoTypeField, @PhoneNoField};
 word		i;


	/* clear the flag */
	g_dirtyFields = 0;

	for (i = offset; i < 5; i++) {
		/* check the field's modified status */
		fieldMod = @call field[i]::MSG_VIS_TEXT_GET_USER_MODIFIED_STATE();
		if (fieldMod)  {
			/* set the dirty flag */
			g_dirtyFields |= (1 << (5 - i));
         /* and the return */
			isMod = TRUE;
         }
		number--;
		if (!number) break;
		}

	return(isMod);

}

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RolodexEnableDisableCalendarButton
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	En{Dis}ables calendar button.

CALLED BY:	(GLOBAL) MSG_META_NOTIFY_WITH_DATA_BLOCK	

PASS:		cx:dx - NotificationType 
		bp - handle of data block 

RETURN:		nothing

DESTROYED:	nothing	

SIDE EFFECTS:	none

PSEUDO CODE/STRATEGY:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	THK	10/92		Initial revision

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
RolodexEnableDisableCalendarButton	method	RolodexClass, 
				MSG_META_NOTIFY_WITH_DATA_BLOCK 	

	; check to make sure it is the right notification type

	cmp	cx, MANUFACTURER_ID_GEOWORKS
	jne	quit
	cmp	dx, GWNT_SELECT_STATE_CHANGE
	jne	quit

	; up the reference count and lock the data block

	push	ax, cx, dx, bp, ds, si, es
	mov	bx, bp
	tst	bx
	je	exit		; don't do anything if no block handle	
	push	bx
	call	MemLock
	mov	es, ax		; es - NotifySelectStateChange

	; check to see if any text has been selected 

	mov	ax, MSG_GEN_SET_NOT_ENABLED 	; disable the trigger
	cmp	es:[NSSC_clipboardableSelection], FALSE
	je	common
	mov	ax, MSG_GEN_SET_ENABLED		; enable the trigger
common:
	; enable or disable the calendar button

	GetResourceHandleNS	CalendarTrigger, bx
	mov	si, offset CalendarTrigger	; OD => BX:SI
	mov	di, mask MF_FIXUP_DS
	mov	dl, VUM_NOW			; do it now
	call	ObjMessage

	; unlock the data block and decrement the reference count

	pop	bx
	call	MemUnlock
exit:
	; call super class

	pop	ax, cx, dx, bp, ds, si, es
quit:
	mov	di, offset RolodexClass
	call	ObjCallSuperNoLock
	ret
RolodexEnableDisableCalendarButton	endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RespondCalendarRequest
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Responds to calendar's request for searching.	

CALLED BY:	Calendar

PASS:		cx - length of string to search for
		dx - handle of data block that contains the string

RETURN:		Address Book will grab the focus

DESTROYED:	ax, bx, cx, dx, es, si, di, bp

PSEUDO CODE/STRATEGY:
	Search the database for possible match
	Grab the focus
	If a match found 
		display the 1st record with the match
		if both view up 
			change moniker from "Lookup" to "Find Next"
			copy text string to filter field
			enable "Clear Search" button
		endif
	Endif
			
KNOWN BUGS/SIDE EFFECTS/IDEAS:
	none

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Ted	3/22/90		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
RespondCalendarRequest	method	GeoDexClass, MSG_ROLODEX_REQUEST_SEARCH

	push	dx, cx

	; check to see if we are in INTRODUCTORY level

	GetResourceHandleNS	RolodexApp, bx
	mov	si, offset RolodexApp
	mov	ax, MSG_GEN_APPLICATION_GET_APP_FEATURES
	mov	di, mask MF_FIXUP_DS or mask MF_CALL
	call	ObjMessage

	; if INTRODUCTORY level, there is no search feature

ifndef GPC  ; allow to all levels to avoid problems where Address Book and
	; Calendar are at different levels
	cmp	dx, UIIL_INTRODUCTORY
	LONG	je	error		; just exit
endif

	;
	; Bring ourselves to the fore in a way that ensures nice transfer
	; of target & focus, and de-iconifies our primary, too.
	; 
	mov	ax, MSG_META_NOTIFY_TASK_SELECTED
	call	UserCallApplication
	
	mov	ax, MSG_GEN_BRING_TO_TOP
	call	UserCallApplication

	cmp	ds:[displayStatus], DISABLED_VIEW	; is data file open?
	je	error3			; if not, put up an error box 

	call	SaveCurRecord		; update the record if necessary
	jc	error			; exit if error

	call	DisableUndo		; no undoable action exists

	tst	ds:[gmb.GMB_numMainTab]		; is data file empty?
	je	error2			; if so, skip

	test	ds:[recStatus], mask RSF_WARNING ; was warning box up?
	jne	error			; if so, exit

	ornf	ds:[searchFlag], mask SOF_NEW or \
			mask SOF_CAL_SEARCH	; clear the filter table flag
	pop	bx, cx

	; create the classed event

	call	MemLock				; lock the data block
	push	bx
	mov	dx, ax				; dx:bp - ptr to string
	clr	bp			
	clr	cx				; cx - null terminated
	mov	ax, MSG_VIS_TEXT_REPLACE_ALL_PTR
	mov	di, mask MF_RECORD
	call	ObjMessage			; event handle => DI

	; bring up the search dialog box

	push	di
	GetResourceHandleNS	RolodexSearchControl, bx
	mov	si, offset RolodexSearchControl	; bx:si - OD of SearchControl
	mov	ax, MSG_GEN_INTERACTION_INITIATE
	mov	di, mask MF_FIXUP_DS
	call	ObjMessage			; send it!!

	; send the event handle to the search controller

	pop	bp				; bp - event handle
	mov	ax, MSG_SRC_SEND_EVENT_TO_SEARCH_TEXT
	clr	di 
	call	ObjMessage			; send it!!

	; initiate forward search

	mov	ax, MSG_SRC_FIND_NEXT
	mov	di, mask MF_CALL
	call	ObjMessage			; send it!!

	andnf	ds:[searchFlag], not mask SOF_CAL_SEARCH 
	pop	bx
	call	MemUnlock			; unlock data block
exit:
	ret
error:
	add	sp, 4				; adjust stack pointer (cx,dx)
	jmp	short	exit
error2:
	mov	bp, ERROR_NO_RECORD		; bp - error message constant
	call	DisplayErrorBox			; put up an error dialog box
	jmp	short	error
error3:
	mov	bp, ERROR_NO_DATA_FILE		; bp - error msg number
	call	DisplayErrorBox			; put up an error dialog box 
	jmp	short	error
RespondCalendarRequest	endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RolodexRequestSearch
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Sends calendar with a text string to search for.

CALLED BY:	UI (= MSG_ROLODEX_CALL_CALENDAR ) 

PASS:		nothing

RETURN:		nothing

DESTROYED:	ax, bx, cx, dx, si, di, bp, es

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Ted	3/22/90		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
RolodexRequestSearch	method	GeoDexClass, MSG_ROLODEX_CALL_CALENDAR

	; get the OD of text object with the target

	GetResourceHandleNS	RolodexPrimary, bx
	mov	si, offset RolodexPrimary	; bx:si - OD of GenPrimary
	mov	ax, MSG_META_GET_TARGET_AT_TARGET_LEVEL
	clr	cx				; leaf
	mov	di, mask MF_CALL or mask MF_FIXUP_DS
	call	ObjMessage			; returns OD in bx:si

	; get the selected text in a memory block

	mov	si, dx			; OD chunk => SI
	mov	bx, cx			; handle of OD => BX
	mov	ax, MSG_VIS_TEXT_GET_SELECTION_BLOCK
	clr	dx			; cx - return text in a global block
	mov	di, mask MF_CALL or mask MF_FIXUP_DS	
	call	ObjMessage		; cx - handle of text block

	; send a search message to GeoPlanner

	mov	dx, cx			; dx - handle of text block
	mov	cx, ax			; cx - text string length 
	mov	ax, MSG_CALENDAR_REQUEST_SEARCH
	call	CallCalendar		; call calendar with string to search 
	jnc	exit			; exit if success!!

	; if GeoPlanner is not found, put up an error message and exit

	mov	bp, ERROR_NO_CALENDAR	; bp - error message constant
	call	DisplayErrorBox		
exit:
	ret
RolodexRequestSearch	endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RolodexSendEmail
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Send email.

CALLED BY:	UI (= MSG_ROLODEX_CALL_EMAIL ) 

PASS:		nothing

RETURN:		nothing

DESTROYED:	ax, bx, cx, dx, si, di, bp, es

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	brianc	4/20/00		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

ifdef GPC
emailToken	GeodeToken <<'mail'>, MANUFACTURER_ID_GEOWORKS>

RolodexSendEmail	method	GeoDexClass, MSG_ROLODEX_CALL_EMAIL
	;
	; make sure we have email field
	;
	GetResourceHandleNS	StaticPhoneSixName, bx
	mov	si, offset StaticPhoneSixName
	mov	ax, MSG_VIS_TEXT_GET_ALL_BLOCK
	clr	dx
	mov	di, mask MF_CALL or mask MF_FIXUP_DS	
	call	ObjMessage		; cx - handle of text block, ax = len
	LONG jcxz	done
	push	cx
	mov	bx, cx
	tst	ax
	LONG jz	doneFree
	push	ds
	call	MemLock
	mov	ds, ax
	clr	si
	GetResourceHandleNS	PhoneEmailDisplayString, bx
	call	MemLock
	mov	es, ax	
	mov	di, offset PhoneEmailDisplayString
	mov	di, es:[di]		; es:di == text in PhoneEmailDisplayString
	clr	cx
	call	LocalCmpStrings		; compare and make sure both strings are "email:"
	pop	ds
	pop	cx			; cx <- handle of StaticPhoneSixName text block
	pushf				; save LocalCmpStrings result
	GetResourceHandleNS	PhoneEmailDisplayString, bx
	call	MemUnlock
	mov	bx, cx	
	call	MemFree
	popf
	jne	done
	;
	; allocate IApp block
	;
	mov	ax, size InternetAppBlock + PHONE_NO_LENGTH+1	; include null
	mov	cx, ALLOC_DYNAMIC or (HAF_STANDARD_LOCK shl 8)
	mov	bx, handle ui
	call	MemAllocSetOwner	; bx = handle, ax = segment
	jc	done
	;
	; get email addr
	;
	push	bx
	mov	es, ax
	mov	es:[IAB_type], IADT_MAIL_TO
	mov	dx, ax			; dx:bp = URL buffer in IAB
	mov	bp, size InternetAppBlock
	GetResourceHandleNS	StaticPhoneSixNumber, bx
	mov	si, offset StaticPhoneSixNumber
	mov	ax, MSG_VIS_TEXT_GET_ALL_PTR
	mov	di, mask MF_CALL or mask MF_FIXUP_DS	
	call	ObjMessage		; cx = length
	pop	bx			; bx = IAB
	call	MemUnlock		; unlock IAB
	jcxz	doneFree
	;
	; call email app
	;
	mov	dx, MSG_GEN_PROCESS_OPEN_APPLICATION
	call	IACPCreateDefaultLaunchBlock	; dx = ALB
	jc	doneFree
	xchg	bx, dx			; bx = ALB, dx = IAB
	call	MemLock
	mov	es, ax
	mov	es:[ALB_extraData], dx	; store IAB in ALB
	call	MemUnlock
	segmov	es, cs, di
	mov	di, offset emailToken
	clr	ax
	call	IACPConnect		; bp = IACPConnection
	jc	error
	clr	cx
	call	IACPShutdown
done:
	ret

doneFree:
	call	MemFree
	jmp	short done

error:
	mov	bp, ERROR_NO_EMAIL
	call	DisplayErrorBox
	jmp	short done

RolodexSendEmail	endm
endif

RolodexTextEmptyChange	method	GeoDexClass, MSG_META_TEXT_EMPTY_STATUS_CHANGED
ifdef GPC
	GetResourceHandleNS	StaticPhoneSixNumber, ax
	cmp	cx, ax
	jne	done
	cmp	dx, offset StaticPhoneSixNumber
	jne	done
	;
	; enable or disable Email button based on email address
	;
	mov	ax, MSG_GEN_SET_ENABLED
	tst	bp
	jnz	gotState		; becoming non-empty
	mov	ax, MSG_GEN_SET_NOT_ENABLED	; else, becoming empty
gotState:
	GetResourceHandleNS	EmailTrigger, bx
	mov	si, offset EmailTrigger
	mov	dl, VUM_NOW
	mov	di, mask MF_CALL or mask MF_FIXUP_DS
	call	ObjMessage
done:
endif
	ret
RolodexTextEmptyChange	endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RolodexUpdateEntry
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Update (add/edit) entry.

CALLED BY:	EXTERNAL

PASS:		cx - handle of data block

RETURN:		Address Book will grab the focus

DESTROYED:	ax, bx, cx, dx, es, si, di, bp

PSEUDO CODE/STRATEGY:
			
KNOWN BUGS/SIDE EFFECTS/IDEAS:
	none

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	brianc	2/25/99		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

ifndef GPC
RolodexUpdateEntry	method	GeoDexClass, MSG_ROLODEX_UPDATE_ENTRY

	push	cx			; save data block

	;
	; Bring ourselves to the fore in a way that ensures nice transfer
	; of target & focus, and de-iconifies our primary, too.
	; 
	mov	ax, MSG_META_NOTIFY_TASK_SELECTED
	call	UserCallApplication
	
	mov	ax, MSG_GEN_BRING_TO_TOP
	call	UserCallApplication

	cmp	ds:[displayStatus], DISABLED_VIEW	; is data file open?
	LONG je	error3			; if not, put up an error box 

	call	SaveCurRecord		; update the record if necessary
	LONG jc	error			; exit if error

	call	DisableUndo		; no undoable action exists

	test	ds:[recStatus], mask RSF_WARNING ; was warning box up?
	LONG jne	error			; if so, exit

	;
	; initiate new entry dialog box
	;
	call	GeodeGetProcessHandle
	mov	ax, MSG_ROLODEX_NEW
	mov	di, mask MF_FIXUP_DS
	call	ObjMessage

	;
	; enter fields
	;
	pop	bx
	call	MemLock
	push	bx
	GetResourceHandleNS	AddrBox, bx
	mov	es, ax


	clr	di
addrFieldLoop:
	mov	ax, es:[di].RUEF_type
	cmp	ax, RUEFT_LAST_FIELD
	LONG je	doneFields

	mov	dx, es
	push	es, di
	lea	bp, es:[di].RUEF_data

	cmp	ax, RUEFT_LASTNAME
	LONG jz	isLastName
	cmp	ax, RUEFT_ADDRESS
	LONG jz	isAddress
	cmp	ax, RUEFT_EMAIL
	LONG jz	nextField	; don't do this rogue Email
	cmp	ax, RUEFT_EMAIL_KEY
	LONG ja	nextField	; don't know what this is!

	;
	; Must be a phone field of some sort
	;
	mov	si, offset PhoneNoField
	sub	ax, RUEFT_HOME_PHONE-1 ;; Convert to a PhoneTypeIndex

	;
	; We need to display the right record item
	;
	push	bx, cx, dx, es, si, di, bp
	push	ax
	; Force it to be modified
	or	ds:[phoneFieldDirty], mask GTSF_MODIFIED
	call	SaveCurPhone

	; Display the phone field we are about to modify
	pop	cx
	push	cx
	call	RolodexPhoneTo

if 0
	call	DBLockNO
	mov	di, es:[di]		; open up this record
	mov	bp, ds:[curRecord]	; bp - current record handle
	pop	cx
	push	cx
	call	DisplayPhoneNoField	; display phone field text string
	call	DBUnlock
endif

	pop	ax
	pop	bx, cx, dx, es, si, di, bp

	;
	; Now change that record item (just a text item)
	;
	or	ds:[phoneFieldDirty], mask GTSF_MODIFIED
;;	call	SaveCurPhone
	jmp	storeData

isLastName:
	mov	si, offset LastNameField
	jmp	storeData
isAddress:
	mov	si, offset AddrField
	jmp	storeData
storeData:
	;
	; try to put name in Last, First format (fields are clear,
	; so we can append)
	;
	mov	es, dx
	mov	di, bp
	mov	ax, C_NULL
	mov	cx, -1
	LocalFindChar
	LocalPrevChar	esdi		; point at last char
	mov	ax, C_SPACE
	neg	cx
	dec	cx			; # of characters in string
	std				; find last space (search backwards)
	LocalFindChar
	cld
	jne	notLastName		; no space found
	LocalNextChar	esdi		; point at last space
	mov	ax, C_NULL
	LocalPutChar	esdi, ax	; null-term first name, skip it
	push	dx, bp			; save first name
	movdw	dxbp, esdi		; point to last name
	mov	ax, MSG_VIS_TEXT_APPEND_PTR
	clr	cx
	mov	di, mask MF_CALL or mask MF_FIXUP_DS
	call	ObjMessage
	mov	dx, SEGMENT_CS		; add separator
	mov	bp, offset commaSpace
	mov	ax, MSG_VIS_TEXT_APPEND_PTR
	clr	cx
	mov	di, mask MF_CALL or mask MF_FIXUP_DS
	call	ObjMessage
	pop	dx, bp			; dx:bp = beginning of name
notLastName:
	mov	ax, MSG_VIS_TEXT_APPEND_PTR
	clr	cx
	mov	di, mask MF_CALL or mask MF_FIXUP_DS
	call	ObjMessage

	; mark text modified
	mov	ax, MSG_GEN_TEXT_SET_MODIFIED_STATE
	mov	cx, 1
	mov	di, mask MF_CALL or mask MF_FIXUP_DS
	call	ObjMessage


nextField:
	pop	es, di
	add	di, es:[di].RUEF_size
	add	di, size RolodexUpdateEntryField
	jmp	addrFieldLoop

doneFields:
	pop	bx				; free data block
	call	MemFree

exit:
	ret
error:
	pop	bx				; free data block
	call	MemFree
	jmp	short	exit
error3:
	mov	bp, ERROR_NO_DATA_FILE		; bp - error msg number
	call	DisplayErrorBox			; put up an error dialog box 
	jmp	short	error
RolodexUpdateEntry	endm

commaSpace	TCHAR	", ",0

endif

ifdef GPC ;;

RolodexUpdateEntry	method	GeoDexClass, MSG_ROLODEX_UPDATE_ENTRY

	push	cx			; save data block

	;
	; Bring ourselves to the fore in a way that ensures nice transfer
	; of target & focus, and de-iconifies our primary, too.
	; 
	mov	ax, MSG_META_NOTIFY_TASK_SELECTED
	call	UserCallApplication
	
	mov	ax, MSG_GEN_BRING_TO_TOP
	call	UserCallApplication

	cmp	ds:[displayStatus], DISABLED_VIEW	; is data file open?
	LONG je	error3			; if not, put up an error box 

	call	SaveCurRecord		; update the record if necessary
	LONG jc	error			; exit if error

	call	DisableUndo		; no undoable action exists

	test	ds:[recStatus], mask RSF_WARNING ; was warning box up?
	LONG jne	error			; if so, exit
	;
	; initiate new entry dialog box
	;
	call	GeodeGetProcessHandle
	mov	ax, MSG_ROLODEX_NEW_INITIATE
	mov	di, mask MF_FIXUP_DS
	call	ObjMessage
	;
	; enter fields into new entry dialog
	;
	pop	bx
	call	MemLock
	push	bx
	GetResourceHandleNS	NewRecordDialog, bx
	mov	es, ax
	clr	di
addrFieldLoop:
	mov	ax, es:[di].RUEF_type
	cmp	ax, RUEFT_LAST_FIELD
	LONG je	doneFields
	cmp	ax, RUEFT_EMAIL_KEY
	jne	notEmailKey
	mov	ds:[updateEntry], BB_TRUE
notEmailKey:
	mov	dx, es
	lea	bp, es:[di].RUEF_data
	push	es, di
	mov	cx, length updateEntryFieldTable
	segmov	es, cs, di
	mov	di, offset updateEntryFieldTable
	repne	scasw
	jne	nextField
	sub	di, offset updateEntryFieldTable
	mov	si, cs:[updateEntryTextObjTable][di-size(word)]
	cmp	si, offset NewLastNameField
	jne	notLastName
	;
	; try to put name in Last, First format (fields are clear,
	; so we can append)
	;
	mov	es, dx
	mov	di, bp
	mov	ax, C_NULL
	mov	cx, -1
	LocalFindChar
	LocalPrevChar	esdi		; point at last char
	mov	ax, C_SPACE
	neg	cx
	dec	cx			; # of characters in string
	std				; find last space (search backwards)
	LocalFindChar
	cld
	jne	notLastName		; no space found
	LocalNextChar	esdi		; point at last space
	mov	ax, C_NULL
	LocalPutChar	esdi, ax	; null-term first name, skip it
	push	dx, bp			; save first name
	movdw	dxbp, esdi		; point to last name
	mov	ax, MSG_VIS_TEXT_APPEND_PTR
	clr	cx
	mov	di, mask MF_CALL or mask MF_FIXUP_DS
	call	ObjMessage
	mov	dx, SEGMENT_CS		; add separator
	mov	bp, offset commaSpace
	mov	ax, MSG_VIS_TEXT_APPEND_PTR
	clr	cx
	mov	di, mask MF_CALL or mask MF_FIXUP_DS
	call	ObjMessage
	pop	dx, bp			; dx:bp = beginning of name
notLastName:
	mov	ax, MSG_VIS_TEXT_APPEND_PTR
	clr	cx
	mov	di, mask MF_CALL or mask MF_FIXUP_DS
	call	ObjMessage
nextField:
	pop	es, di
	add	di, es:[di].RUEF_size
	add	di, size RolodexUpdateEntryField
	jmp	addrFieldLoop

doneFields:
	pop	bx				; free data block
	call	MemFree
	;
	; enable Create button
	;
	GetResourceHandleNS	NewCreate, bx
	mov	si, offset NewCreate
	mov	ax, MSG_GEN_SET_ENABLED
	mov	dl, VUM_NOW
	mov	di, mask MF_FIXUP_DS
	call	ObjMessage
exit:
	ret
error:
	pop	bx				; free data block
	call	MemFree
	jmp	short	exit
error3:
	mov	bp, ERROR_NO_DATA_FILE		; bp - error msg number
	call	DisplayErrorBox			; put up an error dialog box
	jmp	short	error
RolodexUpdateEntry	endm

commaSpace	TCHAR	", ",0

updateEntryFieldTable	word \
	RUEFT_LASTNAME,
	RUEFT_ADDRESS,
	RUEFT_EMAIL,
	RUEFT_EMAIL_KEY,
	RUEFT_HOME_PHONE,
	RUEFT_WORK_PHONE,
	RUEFT_MOBILE_PHONE,
	RUEFT_FAX_PHONE,
	RUEFT_PAGER_PHONE

updateEntryTextObjTable	lptr \
	offset	NewDialogResource:NewLastNameField,
	offset	NewDialogResource:NewAddrField,
	offset	NewDialogResource:NewStaticPhoneSixNumber,
	offset	NewDialogResource:NewStaticPhoneSixNumber,
	offset	NewDialogResource:NewStaticPhoneOneNumber,
	offset	NewDialogResource:NewStaticPhoneTwoNumber,
	offset	NewDialogResource:NewStaticPhoneThreeNumber,
	offset	NewDialogResource:NewStaticPhoneFourNumber,
	offset	NewDialogResource:NewStaticPhoneFiveNumber

endif  ; GPC ;;


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		CallCalendar
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Call calendar with the given method

CALLED BY:	(INTERNAL)

PASS: 		AX	= Message to send
		CX	= Text length
		DX	= Text block handle

RETURN:		carry set if calendar is found
		carry clear if there is no calendar app

DESTROYED:	BX, DI

PSEUDO CODE/STRATEGY:

KNOWN BUGS/SIDE EFFECTS/IDEAS:
		none

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Don	2/25/90		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

calendarToken	GeodeToken	CALENDAR_TOKEN	; token for calendar lookups

CallCalendar	proc	near
	uses	es
	.enter

	push	ax, cx, dx		; save message & text params

	;
	; Create a launch block so IACP can launch the app if it's not
	; around yet.
	; 
	mov	dx, MSG_GEN_PROCESS_OPEN_APPLICATION
	call	IACPCreateDefaultLaunchBlock
	;
	; Set ALF_DESK_ACCESSORY to match our own.
	; 
	mov	bx, dx
	mov	ax, MSG_GEN_APPLICATION_GET_LAUNCH_FLAGS
	call	UserCallApplication
	andnf	ax, mask ALF_DESK_ACCESSORY
	mov_tr	dx, ax
	call	MemLock
	mov	es, ax
	ornf	es:[ALB_launchFlags], dl
	call	MemUnlock
	;
	; Connect to all GeoPlanner apps currently functional
	; 
	segmov	es, cs
	mov	di, offset calendarToken
	mov	ax, IACPSM_USER_INTERACTIBLE shl offset IACPCF_SERVER_MODE
				; connect to all servers, use app obj as client
				;  od.
	call	IACPConnect
	jc	error
	;
	; Initialize reference count for block to be the number of servers
	; to which we're connected so we can free the block when they're all
	; done.
	; 
	pop	bx			; bx <- text block
	mov	ax, cx			; # of connections => AX
	call	MemInitRefCount
	pop	ax, cx			; ax <- msg, cx <- text length
	mov	dx, bx
	;
	; Record message to send to them
	; 
	clr	bx, si			; any class acceptable
	mov	di, mask MF_RECORD
	call	ObjMessage
	
	push	di			; save handle
	;
	; Record completion message for nuking text block
	; 
	call	GeodeGetProcessHandle
	mov	ax, MSG_META_DEC_BLOCK_REF_COUNT
	clr	cx			; no block in cx (block is in dx)
	mov	di, mask MF_RECORD
	call	ObjMessage

	mov	cx, di			; cx <- completion msg
	pop	bx			; bx <- msg to send
	mov	dx, TO_PROCESS		; dx <- TravelOption
	mov	ax, IACPS_CLIENT	; ax <- side doing the send
	call	IACPSendMessage

	; That's it, we're done.  Shut down the connection we opened up, so
	; that GeoPlanner is allowed to exit.  -- Doug 2/93
	;
	clr	cx, dx			; shutting down the client
	call	IACPShutdown

	clc	
done:
	.leave
	ret

	; There was an error, so delete the text and return carry set
error:
	pop	bx
	call	MemFree
	add	sp, 4			; drop ax,cx
	stc
	jmp	done
CallCalendar	endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		GeoDexDispatchEvent
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	To handle a synchronization problem with geoplanner,
		we need to make sure that the completion message going
		back to geoplanner gets put on our queue.
		(When there is a password on the document, the completion 
		message was going through, while the IACP message was being
		held up)

CALLED BY:	MSG_META_DISPATCH_EVENT
PASS:		*ds:si	= GeoDexClass object
		ds:di	= GeoDexClass instance data
		ds:bx	= GeoDexClass object (same as *ds:si)
		es 	= segment of GeoDexClass
		ax	= message #
		cx	= handle of event
		dx 	= MessageFlags to pass to ObjDispatchMessage

RETURN:		If MF_CALL specified:
			carry, ax, cx, dx, bp - return values
		Otherwise:
			ax, cx, dx, bp - destroyed
		(event freed)
DESTROYED:	
SIDE EFFECTS:	

PSEUDO CODE/STRATEGY:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	RB	7/29/93		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
GeoDexDispatchEvent	method dynamic GeoDexClass, 
					MSG_META_DISPATCH_EVENT

	;
	; Should we hold up this message on the queue?	

	mov	bx, cx				; event handle
	call	ObjGetMessageInfo
	mov	cx, bx				; cx = event handle
	cmp	ax, MSG_META_DEC_BLOCK_REF_COUNT
	je	sendAgain

	;
	; Send to super
	; resend the event we were in the middle of delivering
	;

callSuper::
	mov	ax, MSG_META_DISPATCH_EVENT
	mov	di, offset GeoDexClass
	GOTO	ObjCallSuperNoLock

sendAgain:
	mov	ax, MSG_ROLODEX_DISPATCH_EVENT
	call	GeodeGetProcessHandle
	mov	di, mask MF_FORCE_QUEUE
	GOTO	ObjMessage

GeoDexDispatchEvent	endm


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		RolodexDispatchEvent
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Routine to use for synchronization purposes.
		We need to make sure that the completion routine
		sent from IACP happens after the initial routine is called.
		Therfore we use the routine to stick the message back

		in the queue.

CALLED BY:	MSG_GEODEX_DISPATCH_EVENT
PASS:		*ds:si	= GeoDexClass object
		ds:di	= GeoDexClass instance data
		ds:bx	= GeoDexClass object (same as *ds:si)
		es 	= segment of GeoDexClass
		ax	= message #
		cx	= handle of event
		dx 	= MessageFlags to pass to ObjDispatchMessage

RETURN:		If MF_CALL specified:
			carry, ax, cx, dx, bp - return values
		Otherwise:
			ax, cx, dx, bp - destroyed
		(event freed)
DESTROYED:	
SIDE EFFECTS:	

PSEUDO CODE/STRATEGY:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	RB	7/29/93		Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
RolodexDispatchEvent	method dynamic GeoDexClass, 
					MSG_ROLODEX_DISPATCH_EVENT

		mov	ax, MSG_META_DISPATCH_EVENT
		mov	di, offset GeoDexClass
		GOTO	ObjCallSuperNoLock

RolodexDispatchEvent	endm



ifdef EXPORT
RolDocumentControlScanFeatureHints	method	dynamic
RolDocumentControlClass, MSG_GEN_CONTROL_SCAN_FEATURE_HINTS
	;
	; let superclass build out default features
	;
		mov	di, offset RolDocumentControlClass
		call	ObjCallSuperNoLock
	;
	; add EXPORT for all AUI levels
	;
		call	UserGetDefaultUILevel
		cmp	ax, UIIL_INTRODUCTORY
		je	done
		mov	es, dx
		mov	di, bp
		ornf	es:[di].GCSI_userAdded, mask GDCF_EXPORT
		ornf	es:[di].GCSI_appRequired, mask GDCF_EXPORT
		andnf	es:[di].GCSI_userRemoved, not mask GDCF_EXPORT
		andnf	es:[di].GCSI_appProhibited, not mask GDCF_EXPORT
done:
		ret
RolDocumentControlScanFeatureHints	endm
endif

CommonCode ends */

